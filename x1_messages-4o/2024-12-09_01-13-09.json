[
    {
        "role": "user",
        "content": "How can I implement a Median-heap with the following functions - 'insert(int)', 'median()', and 'delmedian()' using an array to store the heap elements? The children of array index k should be stored in array indices 2*k and 2*k + 1, with the array starting to populate elements from index 1. I have already created two integers to keep track of the number of integers inserted so far that are greater or less than the current median (gcm and lcm respectively). However, I'm having difficulty coming up with an algorithm for sinking and swimming elements."
    },
    {
        "role": "assistant",
        "content": "Implementing a Median-heap involves managing two heaps: a max-heap to store the lower half of the data, and a min-heap for the upper half. This allows efficient retrieval of the median, which will be the root of one or both heaps, depending on the total number of elements.\n\nHere's a step-by-step guide to implement it using arrays:\n\n### Data Structures\n1. **Max-Heap (left-heap)**: Stores the lower half of the numbers. The largest number in this heap is at the root.\n2. **Min-Heap (right-heap)**: Stores the upper half of the numbers. The smallest number in this heap is at the root.\n\n### Operations\n- **Insert(int)**: Insert the number into the appropriate heap.\n- **Median()**: Retrieve the median from the heaps.\n- **Delmedian()**: Remove the median and adjust the heaps.\n\n### Algorithms\n\n#### Initialization\n- Use two arrays to represent the max-heap and min-heap.\n- Maintain counters for the size of each heap.\n\n#### Insert(int num)\n1. If `max-heap` is empty or `num` is less than or equal to the root of `max-heap`, insert `num` into `max-heap`.\n2. Otherwise, insert `num` into `min-heap`.\n3. **Balance Heaps**: Ensure that the difference in size between the heaps is at most 1:\n   - If `max-heap` has more than one extra element compared to `min-heap`, move the root of `max-heap` to `min-heap`.\n   - If `min-heap` has more elements, move the root of `min-heap` to `max-heap`.\n\n#### Median()\n- If `max-heap` has more elements, the median is its root.\n- If `min-heap` has more elements, the median is its root.\n- If both heaps are the same size, the median is the average of the roots of both heaps.\n\n#### Delmedian()\n1. Determine which heap contains the median.\n2. Remove the root from that heap.\n3. Rebalance the heaps, if necessary, using the same logic as in the `Insert` function.\n\n#### Helper Functions\n- **Swim**: Used to restore heap order by moving a node up.\n- **Sink**: Used to restore heap order by moving a node down.\n\nHere's a simplified code structure:\n\n```python\nclass MedianHeap:\n    def __init__(self):\n        self.max_heap = [None]  # 1-indexed\n        self.min_heap = [None]  # 1-indexed\n        self.max_size = 0\n        self.min_size = 0\n\n    def insert(self, num):\n        if self.max_size == 0 or num <= self.max_heap[1]:\n            self.max_heap.append(num)\n            self.max_size += 1\n            self.swim(self.max_heap, self.max_size, True)\n        else:\n            self.min_heap.append(num)\n            self.min_size += 1\n            self.swim(self.min_heap, self.min_size, False)\n\n        self.rebalance()\n\n    def median(self):\n        if self.max_size > self.min_size:\n            return self.max_heap[1]\n        elif self.min_size > self.max_size:\n            return self.min_heap[1]\n        else:\n            return (self.max_heap[1] + self.min_heap[1]) / 2.0\n\n    def delmedian(self):\n        if self.max_size >= self.min_size:\n            self.remove_root(self.max_heap, self.max_size, True)\n            self.max_size -= 1\n        else:\n            self.remove_root(self.min_heap, self.min_size, False)\n            self.min_size -= 1\n\n        self.rebalance()\n\n    def rebalance(self):\n        if self.max_size > self.min_size + 1:\n            self.min_heap.append(self.max_heap[1])\n            self.max_size -= 1\n            self.min_size += 1\n            self.remove_root(self.max_heap, self.max_size, True)\n            self.swim(self.min_heap, self.min_size, False)\n        elif self.min_size > self.max_size:\n            self.max_heap.append(self.min_heap[1])\n            self.min_size -= 1\n            self.max_size += 1\n            self.remove_root(self.min_heap, self.min_size, False)\n            self.swim(self.max_heap, self.max_size, True)\n\n    def swim(self, heap, k, is_max):\n        while k > 1 and ((is_max and heap[k] > heap[k // 2]) or (not is_max and heap[k] < heap[k // 2])):\n            heap[k], heap[k // 2] = heap[k // 2], heap[k]\n            k //= 2\n\n    def remove_root(self, heap, size, is_max):\n        heap[1], heap[size] = heap[size], heap[1]\n        heap.pop()\n        self.sink(heap, 1, size - 1, is_max)\n\n    def sink(self, heap, k, size, is_max):\n        while 2 * k <= size:\n            j = 2 * k\n            if j < size and ((is_max and heap[j] < heap[j + 1]) or (not is_max and heap[j] > heap[j + 1])):\n                j += 1\n            if (is_max and heap[k] >= heap[j]) or (not is_max and heap[k] <= heap[j]):\n                break\n            heap[k], heap[j] = heap[j], heap[k]\n            k = j\n\n# Example usage:\nmh = MedianHeap()\nmh.insert(1)\nmh.insert(5)\nmh.insert(3)\nprint(mh.median())  # Output should be 3\nmh.delmedian()\nprint(mh.median())  # Output should be 3.0\n```\n\nThis code uses arrays to represent max and min heaps. The `insert` method decides which heap to insert into and maintains balance between the heaps. The `median` method fetches the median, and `delmedian` removes the median, adjusting the heaps as necessary. The `swim` and `sink` methods maintain heap properties after insertion and deletion."
    }
]