[
    {
        "role": "user",
        "content": "Can you explain the difference between __getattr__ and __getattribute__ in Python? I am trying to understand when to define either of these methods. Also, according to the Python documentation, __getattribute__ applies to new-style classes. Can you clarify what new-style classes are?"
    },
    {
        "role": "assistant",
        "content": "Certainly! In Python, `__getattr__` and `__getattribute__` are special methods used for attribute access in classes, but they serve different purposes and are used in different situations.\n\n### `__getattribute__`\n\n- **Invocation**: `__getattribute__` is automatically called for every attribute access on an instance of a class. This means it applies to every single attribute request, regardless of whether the attribute exists or not.\n- **Custom Behavior**: You can override this method to define custom behavior for all attribute access attempts. However, since it intercepts every access, it\u2019s crucial to use it carefully to avoid infinite recursion.\n- **Usage**: Typically, when overriding `__getattribute__`, if you still want to access attributes normally, you should use `super()` to call the original `__getattribute__` method from the superclass, like this:\n  ```python\n  def __getattribute__(self, name):\n      # Custom code here\n      return super().__getattribute__(name)\n  ```\n\n### `__getattr__`\n\n- **Invocation**: `__getattr__` is only invoked when an attribute is not found by the usual methods. This means it\u2019s called only if the attribute doesn\u2019t exist or isn\u2019t accessible through normal means.\n- **Custom Behavior**: It's useful for defining a default behavior for missing attributes, providing a fallback mechanism.\n- **Usage**: You can implement `__getattr__` to return a default value or raise an appropriate error if an attribute is missing:\n  ```python\n  def __getattr__(self, name):\n      # Custom code here for missing attributes\n      return \"default value\"\n  ```\n\n### New-Style Classes\n\n- **Definition**: New-style classes were introduced in Python 2.2 to unify classes and types. They inherit from `object`, either directly or indirectly. In Python 3, all classes are new-style by default.\n- **Syntax**: To define a new-style class in Python 2.x, you would explicitly inherit from `object`:\n  ```python\n  class MyClass(object):\n      pass\n  ```\n- **Characteristics**: New-style classes provide a consistent object model, supporting features like descriptors, `__slots__`, and cooperative multiple inheritance using the C3 linearization algorithm.\n\n### When to Use Each\n\n- Use `__getattribute__` if you need to intercept all attribute accesses and potentially modify them or add logging.\n- Use `__getattr__` if you want to handle access to attributes that don\u2019t exist, providing a default behavior or value.\n\nIn modern Python (Python 3 and above), all classes you define are new-style classes, so you don\u2019t need to worry about the distinction unless dealing with legacy Python 2 code."
    }
]