[
    {
        "role": "user",
        "content": "What is the simplest method to implement a linked list in Python? I am familiar with Scheme where a linked list is defined by '(1 2 3 4 5). However, Python's lists [1, 2, 3, 4, 5] and tuples (1, 2, 3, 4, 5) are not actually linked lists. I am looking for a way to use linked lists in Python because they have beneficial properties such as constant-time concatenation and the ability to reference distinct parts of them. If they are made immutable, they become even easier to handle."
    },
    {
        "role": "assistant",
        "content": "To implement a linked list in Python, you can create a basic class structure where each node in the list is an object that contains some data and a reference (or link) to the next node. Below is a simple implementation of a singly linked list in Python:\n\n```python\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\nclass LinkedList:\n    def __init__(self):\n        self.head = None\n    \n    def append(self, data):\n        new_node = Node(data)\n        if not self.head:\n            self.head = new_node\n            return\n        last_node = self.head\n        while last_node.next:\n            last_node = last_node.next\n        last_node.next = new_node\n\n    def display(self):\n        current_node = self.head\n        while current_node:\n            print(current_node.data, end=\" -> \")\n            current_node = current_node.next\n        print(\"None\")\n    \n    def prepend(self, data):\n        new_node = Node(data)\n        new_node.next = self.head\n        self.head = new_node\n    \n    def insert_after(self, prev_node, data):\n        if not prev_node:\n            print(\"Previous node must be in the LinkedList.\")\n            return\n        new_node = Node(data)\n        new_node.next = prev_node.next\n        prev_node.next = new_node\n    \n    def delete_node(self, key):\n        current_node = self.head\n        if current_node and current_node.data == key:\n            self.head = current_node.next\n            current_node = None\n            return\n        prev_node = None\n        while current_node and current_node.data != key:\n            prev_node = current_node\n            current_node = current_node.next\n        if not current_node:\n            return\n        prev_node.next = current_node.next\n        current_node = None\n\n# Example usage:\nllist = LinkedList()\nllist.append(1)\nllist.append(2)\nllist.append(3)\nllist.prepend(0)\nllist.insert_after(llist.head.next, 1.5)\nllist.display()  # Output: 0 -> 1 -> 1.5 -> 2 -> 3 -> None\nllist.delete_node(1.5)\nllist.display()  # Output: 0 -> 1 -> 2 -> 3 -> None\n```\n\nIn this implementation:\n\n- The `Node` class represents each element in the linked list. It contains the data and a pointer to the next node.\n- The `LinkedList` class manages the nodes. It has methods to append, prepend, insert after a specific node, delete a node, and display the list.\n- `append` adds a node to the end of the list.\n- `prepend` adds a node to the beginning of the list.\n- `insert_after` inserts a new node after a given node.\n- `delete_node` removes a node by its value.\n- `display` prints the linked list in a readable format.\n\nYou can expand this implementation to include additional functionalities like reversing the list, finding a node, etc. This code demonstrates a mutable linked list, and you can modify it to create an immutable one by avoiding in-place modifications and using persistent data structures."
    }
]