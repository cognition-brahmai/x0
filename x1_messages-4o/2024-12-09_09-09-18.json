[
    {
        "role": "user",
        "content": "How can I implement an algorithm in Python to find the Nth Fibonacci Number?"
    },
    {
        "role": "assistant",
        "content": "To find the Nth Fibonacci number in Python, you can use various approaches such as recursion, iteration, or using dynamic programming (memoization). Below are a few different methods to achieve this:\n\n### 1. Iterative Approach:\n\nThe iterative approach is efficient and has a time complexity of O(N) with constant space complexity O(1).\n\n```python\ndef fibonacci_iterative(n):\n    if n <= 0:\n        return \"Input should be a positive integer.\"\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    \n    a, b = 0, 1\n    for _ in range(2, n):\n        a, b = b, a + b\n    return b\n\n# Example usage\nn = 10\nprint(f\"The {n}th Fibonacci number is: {fibonacci_iterative(n)}\")\n```\n\n### 2. Recursive Approach:\n\nThe recursive approach is straightforward but not efficient for large `n` due to its exponential time complexity O(2^N).\n\n```python\ndef fibonacci_recursive(n):\n    if n <= 0:\n        return \"Input should be a positive integer.\"\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        return fibonacci_recursive(n - 1) + fibonacci_recursive(n - 2)\n\n# Example usage\nn = 10\nprint(f\"The {n}th Fibonacci number is: {fibonacci_recursive(n)}\")\n```\n\n### 3. Dynamic Programming (Memoization):\n\nThis approach stores the results of subproblems to avoid redundant calculations, making it efficient with a time complexity of O(N) and space complexity O(N).\n\n```python\ndef fibonacci_memoization(n, memo={}):\n    if n in memo:\n        return memo[n]\n    if n <= 0:\n        return \"Input should be a positive integer.\"\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        memo[n] = fibonacci_memoization(n - 1, memo) + fibonacci_memoization(n - 2, memo)\n        return memo[n]\n\n# Example usage\nn = 10\nprint(f\"The {n}th Fibonacci number is: {fibonacci_memoization(n)}\")\n```\n\n### 4. Using Python's Built-in `lru_cache` Decorator:\n\nThis is another form of memoization using Python's built-in `functools.lru_cache`.\n\n```python\nfrom functools import lru_cache\n\n@lru_cache(maxsize=None)\ndef fibonacci_lru_cache(n):\n    if n <= 0:\n        return \"Input should be a positive integer.\"\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        return fibonacci_lru_cache(n - 1) + fibonacci_lru_cache(n - 2)\n\n# Example usage\nn = 10\nprint(f\"The {n}th Fibonacci number is: {fibonacci_lru_cache(n)}\")\n```\n\nChoose the method that best suits your needs based on the constraints and performance requirements of your specific problem."
    }
]