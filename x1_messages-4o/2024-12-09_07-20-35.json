[
    {
        "role": "user",
        "content": "How is the built-in function pow() implemented in Python? I am looking to write a program to calculate `a**b % c` where `b` and `c` are both very large numbers. I found that using `a**b % c` is slow but using `pow(a, b, c)` is much faster. Can anyone explain how Python implements this function or direct me to the source code file that implements this function?"
    },
    {
        "role": "assistant",
        "content": "The built-in `pow()` function in Python is optimized for efficiency, especially when it comes to computing large powers with modulus, as in `a**b % c`. The key to its efficiency is its use of an algorithm called \"exponentiation by squaring\" or \"modular exponentiation,\" which significantly reduces the number of multiplications required compared to a naive approach.\n\n### Explanation of the Algorithm:\n1. **Exponentiation by Squaring:** This technique reduces the complexity of computing `a**b` from `O(b)` to `O(log b)` by breaking the problem down into smaller parts. The idea is:\n   - If `b` is even, then `a**b = (a**(b//2))**2`.\n   - If `b` is odd, then `a**b = a * (a**(b-1))`.\n\n2. **Modulo Operation:** When calculating `a**b % c`, the algorithm applies the modulus operation at each step to keep the intermediate results manageable and prevent overflow, which is crucial when `b` is large.\n\n### Python's Implementation:\nIn Python, the `pow(a, b, c)` function is implemented in C for performance reasons, and is part of the Python C API. The actual implementation can be found in the Python source code, specifically in the file `Objects/longobject.c` for CPython.\n\nHere is a simple pseudo-code representation of how modular exponentiation works:\n\n```python\ndef modular_exponentiation(a, b, c):\n    result = 1\n    a = a % c  # Initial reduction\n    while b > 0:\n        if b % 2 == 1:  # If b is odd\n            result = (result * a) % c\n        b = b // 2\n        a = (a * a) % c  # Square a\n    return result\n\n# Usage\na, b, c = 2, 10**18, 1000000007\nprint(modular_exponentiation(a, b, c))\n```\n\nBy using `pow(a, b, c)`, Python takes advantage of this efficient algorithm to compute the result quickly, even for very large numbers. If you're dealing with large values, it's always recommended to use the built-in `pow()` function with three arguments for better performance."
    }
]