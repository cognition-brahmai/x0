[
    {
        "role": "user",
        "content": "What are the security risks associated with using Python's eval() function on untrusted strings? I have a class like:\n\n```python\nclass Foo(object):\n    a = 3\n    def bar(self, x): return x + a\n```\n\nI want to know:\n\n1. Is `eval(string, {\"f\": Foo()}, {})` unsafe? Specifically, is it possible to reach os or sys or something unsafe from a Foo instance?\n2. Is `eval(string, {}, {})` unsafe? Specifically, can I reach os or sys entirely from builtins like len and list?\n3. Is there a way to make builtins not present at all in the eval context?\n\nI am primarily concerned about protecting user data external to the program. Some unsafe strings like \"[0] * 100000000\" are not of concern to me, because at worst they slow/stop the program. \n\nAnd I am aware that `eval(string)` without custom dictionaries is unsafe in most cases."
    },
    {
        "role": "assistant",
        "content": "Using Python's `eval()` function on untrusted strings can indeed pose significant security risks, as it allows for the execution of arbitrary code. Let's address your concerns one by one:\n\n1. **`eval(string, {\"f\": Foo()}, {})` Safety:**\n\n   When you use `eval()` with a custom dictionary like `{\"f\": Foo()}`, the risk depends on what you allow to be accessed via the dictionary. In your case, you're allowing access to an instance of `Foo`. If your class `Foo` or its methods can indirectly access sensitive or system-level functions, then this can be exploited. For example, if `Foo` has methods that utilize `os` or `sys`, these could potentially be reached.\n\n   However, by itself, `Foo` does not grant access to `os` or `sys` unless explicitly coded to do so. You should carefully audit any methods or attributes of such classes to ensure they don't provide a backdoor to sensitive operations.\n\n2. **`eval(string, {}, {})` Safety:**\n\n   Using `eval()` with empty dictionaries for both globals and locals (i.e., `eval(string, {}, {})`) is safer than allowing full access to the global namespace. However, Python's built-in functions, such as `__import__`, can still be accessed by default and can be used to import modules like `os` or `sys`. \n\n   Attackers can construct strings that use these built-ins to access restricted parts of the system. For example, `eval('__import__(\"os\").system(\"ls\")', {}, {})` would execute the `ls` command on a Unix system.\n\n3. **Removing Built-ins from `eval`:**\n\n   You can remove built-ins by explicitly setting the `__builtins__` key in the globals dictionary to an empty dictionary. For example:\n\n   ```python\n   safe_globals = {\"__builtins__\": None}\n   eval(string, safe_globals, {})\n   ```\n\n   By doing this, you effectively eliminate access to all built-in functions and variables, significantly reducing the risk of executing harmful code. Note that this will also prevent the use of any built-in functions that you might want to allow, so you'll need to carefully manage what you include in the globals dictionary.\n\n**Additional Recommendations:**\n\n- **Use `ast.literal_eval`:** If you're only evaluating literals (strings, numbers, tuples, lists, dicts, booleans, and None), consider using `ast.literal_eval()`, which is safe for these types as it doesn't execute arbitrary code.\n  \n- **Sandboxing:** Consider using a library like `RestrictedPython` or running code in a secure, sandboxed environment to minimize risks further.\n\n- **Validation and Sanitization:** Always validate and sanitize any input before using `eval()`, even in a restricted context.\n\nRemember, using `eval()` with untrusted input should be avoided whenever possible due to the inherent risks involved."
    }
]