[
    {
        "role": "user",
        "content": "Generate a solution for the following problem that involves binary search\nGiven an array of size n, search for an element x"
    },
    {
        "role": "assistant",
        "content": "To solve the problem of searching for an element \\( x \\) in a sorted array of size \\( n \\) using binary search, follow these steps:\n\n1. **Initialization**:\n   - Set two pointers: `low` to 0 and `high` to \\( n - 1 \\).\n\n2. **Binary Search Loop**:\n   - While `low` is less than or equal to `high`:\n     1. Calculate the middle index: \n        \\[\n        \\text{mid} = \\text{low} + \\left(\\frac{\\text{high} - \\text{low}}{2}\\right)\n        \\]\n     2. Check if the middle element is equal to \\( x \\):\n        - If `arr[mid]` is equal to \\( x \\), return `mid` (the index of the element).\n     3. If the middle element is less than \\( x \\):\n        - Set `low` to `mid + 1`.\n     4. If the middle element is greater than \\( x \\):\n        - Set `high` to `mid - 1`.\n\n3. **Element Not Found**:\n   - If `low` exceeds `high`, return -1 indicating that \\( x \\) is not present in the array.\n\nHere is a Python implementation of the above algorithm:\n\n```python\ndef binary_search(arr, x):\n    low = 0\n    high = len(arr) - 1\n    \n    while low <= high:\n        mid = low + (high - low) // 2\n        \n        # Check if x is present at mid\n        if arr[mid] == x:\n            return mid\n        \n        # If x is greater, ignore left half\n        elif arr[mid] < x:\n            low = mid + 1\n        \n        # If x is smaller, ignore right half\n        else:\n            high = mid - 1\n    \n    # If we reach here, the element was not present\n    return -1\n\n# Sample usage:\narr = [2, 3, 4, 10, 40]\nx = 10\nresult = binary_search(arr, x)\n\nif result != -1:\n    print(f\"Element is present at index {result}\")\nelse:\n    print(\"Element is not present in the array\")\n```\n\n### Explanation:\n- The binary search algorithm works by repeatedly dividing the search interval in half. \n- If the value of the search key is less than the item in the middle of the interval, narrow the interval to the lower half. Otherwise, narrow it to the upper half.\n- The process repeats until the value is found or the interval is empty.\n- This approach ensures a time complexity of \\( O(\\log n) \\), which is efficient for large datasets compared to linear search."
    }
]