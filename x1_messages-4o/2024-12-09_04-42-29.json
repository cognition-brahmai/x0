[
    {
        "role": "user",
        "content": "How can I plot a decision boundary to separate two classes of data using Matplotlib's pyplot? I have sample data created from a Gaussian distribution via Python NumPy, where every data point is a 2D coordinate consisting of 2 rows. I have two classes, class1 and class2, with 100 data points each. I have already plotted the data points for each class, but I am unsure of how to plot the function of a decision boundary which I've devised to separate these classes.\n\nI have the following code:\n\n```python\nmu_vec1 = np.array([0,0])\ncov_mat1 = np.array([[2,0],[0,2]])\nx1_samples = np.random.multivariate_normal(mu_vec1, cov_mat1, 100)\nmu_vec1 = mu_vec1.reshape(1,2).T\n\nmu_vec2 = np.array([1,2])\ncov_mat2 = np.array([[1,0],[0,1]])\nx2_samples = np.random.multivariate_normal(mu_vec2, cov_mat2, 100)\nmu_vec2 = mu_vec2.reshape(1,2).T\n\ndef decision_boundary(x_vec, mu_vec1, mu_vec2):\n    g1 = (x_vec-mu_vec1).T.dot((x_vec-mu_vec1))\n    g2 = 2*( (x_vec-mu_vec2).T.dot((x_vec-mu_vec2)) )\n    return g1 - g2\n```\n\nHow can I plot this function to create a decision boundary?"
    },
    {
        "role": "assistant",
        "content": "To plot a decision boundary using Matplotlib's `pyplot`, you need to evaluate your decision function over a grid of points covering the area where your data points exist, and then plot the contour where the decision function equals zero. Here's how you can do it:\n\n1. **Set up the grid**: Create a meshgrid of points that span the data range.\n2. **Evaluate the decision function**: Compute the decision function for each point on this grid.\n3. **Plot the decision boundary**: Use `plt.contour` to plot the contour where the decision function is zero.\n\nHere's how you can implement it:\n\n```python\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Sample data\nmu_vec1 = np.array([0, 0])\ncov_mat1 = np.array([[2, 0], [0, 2]])\nx1_samples = np.random.multivariate_normal(mu_vec1, cov_mat1, 100)\nmu_vec2 = np.array([1, 2])\ncov_mat2 = np.array([[1, 0], [0, 1]])\nx2_samples = np.random.multivariate_normal(mu_vec2, cov_mat2, 100)\n\n# Define decision boundary function\ndef decision_boundary(x_vec, mu_vec1, mu_vec2):\n    g1 = (x_vec - mu_vec1).T.dot((x_vec - mu_vec1))\n    g2 = 2 * ((x_vec - mu_vec2).T.dot((x_vec - mu_vec2)))\n    return g1 - g2\n\n# Create a grid over the data range\nx_min, x_max = min(x1_samples[:,0].min(), x2_samples[:,0].min()) - 1, max(x1_samples[:,0].max(), x2_samples[:,0].max()) + 1\ny_min, y_max = min(x1_samples[:,1].min(), x2_samples[:,1].min()) - 1, max(x1_samples[:,1].max(), x2_samples[:,1].max()) + 1\nxx, yy = np.meshgrid(np.linspace(x_min, x_max, 200), np.linspace(y_min, y_max, 200))\n\n# Evaluate the decision function over the grid\nzz = np.array([decision_boundary(np.array([[x], [y]]), mu_vec1.reshape(2,1), mu_vec2.reshape(2,1)) for x, y in zip(xx.ravel(), yy.ravel())])\nzz = zz.reshape(xx.shape)\n\n# Plot the decision boundary and data points\nplt.figure(figsize=(8, 6))\nplt.scatter(x1_samples[:,0], x1_samples[:,1], marker='o', color='red', label='Class 1')\nplt.scatter(x2_samples[:,0], x2_samples[:,1], marker='^', color='blue', label='Class 2')\nplt.contour(xx, yy, zz, levels=[0], linewidths=2, colors='black')\nplt.xlabel('X1')\nplt.ylabel('X2')\nplt.title('Decision Boundary')\nplt.legend()\nplt.grid(True)\nplt.show()\n```\n\n### Explanation:\n- We create a mesh grid `xx, yy` using `np.meshgrid` which covers the range of your data.\n- We then compute the decision function `decision_boundary` at each point in the grid using a list comprehension to evaluate over `xx` and `yy`.\n- `plt.contour` is used to draw contours, and we specify `levels=[0]` to plot the decision boundary where the function value is zero.\n- Finally, we plot the decision boundary along with the data points to visualize the separation between the two classes."
    }
]