[
    {
        "role": "user",
        "content": "What is the correct way to check if an object is a typing.Generic in Python? I am trying to write a code to validate type hints and need to identify the type of the annotation. For instance, in the following code snippet, I attempt to inform the user about the expected value type:\n\n```python\nimport typing\n\ntyp = typing.Union[int, str]\n\nif issubclass(typ, typing.Union):\n    print('value type should be one of', typ.__args__)\nelif issubclass(typ, typing.Generic):\n    print('value type should be a structure of', typ.__args__[0])\nelse:\n    print('value type should be', typ)\n```\n\nHowever, this raises a TypeError: \"Unions cannot be used with issubclass()\". I also tried using isinstance, but it results in a similar TypeError: \"Unions cannot be used with isinstance()\". So, how can I correctly check if 'typ' is a 'typing.Generic'? I would prefer a solution that is backed by official documentation or a PEP to ensure its validity across future versions."
    },
    {
        "role": "assistant",
        "content": "In Python, the `typing` module provides a way to define type hints, and these types, including `Union`, `List`, `Dict`, etc., are not actual classes. Therefore, using `issubclass` or `isinstance` directly on them will not work as you encountered.\n\nTo check if an object is a `typing.Generic` or a specific type from the `typing` module, you can use the `__origin__` attribute, which holds the original class the generic was based on. For `Union`, you can check its type using `typing.get_origin` and `typing.get_args` functions available from Python 3.8 onward.\n\nHere's how you can modify your code to handle `typing.Generic` types properly:\n\n```python\nimport typing\nfrom typing import get_origin, get_args\n\ntyp = typing.Union[int, str]\n\norigin = get_origin(typ)\nargs = get_args(typ)\n\nif origin is typing.Union:\n    print('value type should be one of', args)\nelif origin and issubclass(origin, typing.Generic):\n    print('value type should be a structure of', args[0])\nelse:\n    print('value type should be', typ)\n```\n\n### Explanation:\n\n- **`get_origin(typ)`**: This function returns the origin class of the generic type. For `typing.Union[int, str]`, it will return `typing.Union`.\n\n- **`get_args(typ)`**: This function returns the arguments of the generic type. For `typing.Union[int, str]`, it will return `(int, str)`.\n\n- **Checking `origin`**: By examining `origin`, you can determine if the type is a `Union`, `List`, `Dict`, etc., and handle each case accordingly.\n\nThis method ensures your code is more robust and compatible with future versions of Python, as it leverages the intended way to interact with typing generics as of Python 3.8."
    }
]