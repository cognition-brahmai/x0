[
    {
        "role": "user",
        "content": "I have a library named \"example\" that I'm installing into my global site-packages directory. I am looking for a way to install two versions of it - one for production and another for testing, similar to how my web application and other things are versioned. Is it possible to specify something like \"python setup.py stage\" that will not only install a different egg into site-packages, but also rename the module from \"example\" to \"example_stage\" or something similar? If distutils cannot accomplish this, could you suggest any other tool that can?"
    },
    {
        "role": "assistant",
        "content": "To achieve the installation of two different versions of a library with distinct names, you can use a few different approaches. The standard `distutils` does not directly support this functionality, but you can use other tools and techniques to accomplish your goal.\n\n### Using `virtualenv`\nOne of the most common practices is to use virtual environments:\n\n1. **Create separate virtual environments** for production and testing:\n   ```bash\n   python -m venv env_production\n   python -m venv env_testing\n   ```\n\n2. **Activate the appropriate environment** and install the required version of the package:\n   ```bash\n   # For production\n   source env_production/bin/activate\n   pip install example==version_for_production\n\n   # For testing\n   source env_testing/bin/activate\n   pip install example==version_for_testing\n   ```\n\nThis way, you can manage different versions of the same library without having to rename anything or modify the library itself.\n\n### Using `pip` with `--target` or `--prefix`\nIf you really need to keep both in the global site-packages, you can use `pip` with specific directories:\n\n1. **Create separate directories** for each version:\n   ```bash\n   mkdir ~/site-packages-pro\n   mkdir ~/site-packages-test\n   ```\n\n2. **Install the package using `--target` or `--prefix`:**\n   ```bash\n   # For production\n   pip install example==version_for_production --target=~/site-packages-pro\n\n   # For testing\n   pip install example==version_for_testing --target=~/site-packages-test\n   ```\n\n3. **Modify your `PYTHONPATH`** to include the appropriate directory when running your application:\n   ```bash\n   export PYTHONPATH=~/site-packages-pro:$PYTHONPATH\n   # or\n   export PYTHONPATH=~/site-packages-test:$PYTHONPATH\n   ```\n\n### Using `setuptools` and Customize Installation\nIf you want to actually rename the module, you can use `setuptools` with a little customization:\n\n1. **Modify the `setup.py`** to include a custom command that renames the package:\n   ```python\n   from setuptools import setup, find_packages\n   import os\n\n   class CustomInstallCommand(install):\n       def run(self):\n           install.run(self)\n           # Rename the installed package directory\n           egg_info = os.path.join(self.install_lib, 'example')\n           new_name = os.path.join(self.install_lib, 'example_stage')\n           os.rename(egg_info, new_name)\n\n   setup(\n       name='example',\n       version='your_version',\n       packages=find_packages(),\n       cmdclass={\n           'install': CustomInstallCommand,\n       },\n   )\n   ```\n\n2. **Run your custom command**:\n   ```bash\n   python setup.py install\n   ```\n\nThis approach allows you to install and rename the module, but it requires modification of the library's build process, which might not be ideal if you're working with a third-party library.\n\n### Conclusion\nThe most robust and flexible solution is to use virtual environments. It keeps your development and production environments clean and separate without needing to alter the package installation process. If virtual environments are not an option and you need to install globally, using `pip` with `--target` or `--prefix` is a good compromise."
    }
]