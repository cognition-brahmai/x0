[
    {
        "role": "user",
        "content": "I'm developing a REST API using Django REST framework and I am trying to implement permissions to protect certain endpoints. I'm using permission classes for this purpose, but I am having difficulty when attempting to use different permission classes for different overridden ViewSet methods. Here's a snippet of my code:\n\n```python\nclass UserViewSet(viewsets.ModelViewSet):\n    queryset = User.objects.all()\n    serializer_class = UserSerializer\n\n    def create(self, request, *args, **kwargs):\n        return super(UserViewSet, self).create(request, *args, **kwargs)\n\n    @decorators.permission_classes(permissions.IsAdminUser)\n    def list(self, request, *args, **kwargs):\n        return super(UserViewSet, self).list(request, *args, **kwargs)\n```\n\nI want to allow user registration for unauthenticated users too but I don't want to allow anyone to list users, only staff should have that permission. From the Django REST framework docs, I see examples of protecting API views (not ViewSet methods) with the `permission_classes` decorator, and setting permission classes for the entire ViewSet, but it seems not to work on overridden ViewSet methods. Is there a way to apply permission classes to specific endpoints?"
    },
    {
        "role": "assistant",
        "content": "To apply different permission classes to specific methods within a Django REST Framework ViewSet, you can override the `get_permissions` method. This method allows you to dynamically assign permission classes based on the action being performed. Here's how you can achieve this in your code:\n\n```python\nfrom rest_framework import viewsets, permissions\nfrom rest_framework.decorators import action\n\nclass UserViewSet(viewsets.ModelViewSet):\n    queryset = User.objects.all()\n    serializer_class = UserSerializer\n\n    def get_permissions(self):\n        # Define a dictionary mapping action names to permission classes\n        permission_classes = {\n            'list': [permissions.IsAdminUser],  # Only admins can list users\n            'create': [permissions.AllowAny],  # Allow anyone to register\n            # Add more actions and their respective permission classes if needed\n        }\n        # Return the appropriate permission classes based on the action\n        return [permission() for permission in permission_classes.get(self.action, [permissions.IsAuthenticated])]\n\n    def create(self, request, *args, **kwargs):\n        return super(UserViewSet, self).create(request, *args, **kwargs)\n\n    def list(self, request, *args, **kwargs):\n        return super(UserViewSet, self).list(request, *args, **kwargs)\n```\n\n### Explanation\n\n- **`get_permissions` Method:** This method is overridden to dynamically choose permission classes based on the current action (`self.action`). The `self.action` attribute reflects the current action that is being performed (e.g., 'list', 'create', etc.).\n\n- **Permission Mapping:** You define a dictionary, `permission_classes`, where keys are action names and values are lists of permission classes that should be applied to those actions. \n\n- **Default Permission:** If the action is not explicitly mentioned in the dictionary, a default permission class (such as `IsAuthenticated`) is used. You can adjust this to fit your needs.\n\nThis setup allows you to specify different permissions for each action within your ViewSet, providing flexible control over who can access different endpoints."
    }
]