[
    {
        "role": "user",
        "content": "In Python, I have a class named `MyClass` with static/class variables `Foo` and `Bar` as shown below:\n\n```python\nclass MyClass:\n     Foo = 1\n     Bar = 2\n```\n\nIs there a way to invoke a custom method whenever `MyClass.Foo` or `MyClass.Bar` is invoked, prior to the value being returned? I am aware of the custom `__getattr__` method for instances of a class, but I need to use this class without creating any instances. Additionally, is it possible for a custom `__str__` method to be invoked when `str(MyClass.Foo)` is invoked?"
    },
    {
        "role": "assistant",
        "content": "To invoke a custom method whenever a class variable like `MyClass.Foo` or `MyClass.Bar` is accessed, you can utilize Python's descriptor protocol. Descriptors are objects that define methods like `__get__`, `__set__`, and `__delete__` to customize behavior for getting, setting, and deleting attributes.\n\nHere's how you can use a descriptor to intercept access to `Foo` and `Bar`:\n\n```python\nclass CustomDescriptor:\n    def __init__(self, name, initial_value=None):\n        self.name = name\n        self.value = initial_value\n\n    def __get__(self, instance, owner):\n        # Custom logic before returning the value\n        print(f\"Accessing {self.name} with value {self.value}\")\n        return self.value\n\n    def __set__(self, instance, value):\n        print(f\"Setting {self.name} to value {value}\")\n        self.value = value\n\nclass MyClass:\n    Foo = CustomDescriptor('Foo', 1)\n    Bar = CustomDescriptor('Bar', 2)\n\n# Example usage\nprint(MyClass.Foo)  # This will invoke CustomDescriptor.__get__\nMyClass.Foo = 10    # This will invoke CustomDescriptor.__set__\nprint(MyClass.Foo)\n```\n\nIn this code, `CustomDescriptor` is used to intercept access to `Foo` and `Bar`. The `__get__` method is called whenever the attribute is accessed, allowing you to perform any custom logic before returning the value.\n\nRegarding the `__str__` method, note that custom `__str__` methods are defined for classes, not for individual attributes like `MyClass.Foo`. However, you can define a custom `__str__` method within your descriptor class to be invoked when converting the value to a string.\n\nHere's how you can implement it:\n\n```python\nclass CustomDescriptor:\n    def __init__(self, name, initial_value=None):\n        self.name = name\n        self.value = initial_value\n\n    def __get__(self, instance, owner):\n        print(f\"Accessing {self.name} with value {self.value}\")\n        return self\n\n    def __set__(self, instance, value):\n        print(f\"Setting {self.name} to value {value}\")\n        self.value = value\n\n    def __str__(self):\n        return f\"Custom string representation of {self.name}: {self.value}\"\n\nclass MyClass:\n    Foo = CustomDescriptor('Foo', 1)\n    Bar = CustomDescriptor('Bar', 2)\n\n# Example usage\nprint(str(MyClass.Foo))  # This will invoke CustomDescriptor.__str__\n```\n\nWith this setup, `str(MyClass.Foo)` will invoke the `__str__` method defined within `CustomDescriptor`, allowing you to customize the string representation of `Foo` and `Bar`."
    }
]