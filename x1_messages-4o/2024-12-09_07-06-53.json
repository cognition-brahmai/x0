[
    {
        "role": "user",
        "content": "I have been recently working with Typescript and it's quite convenient to express objects with interfaces like 'Address' and 'Person'. The code looks pretty concise and it provides luxuries such as type checking and code completion while coding with 'Persons'. I am trying to find a similar way to do this in Python. I have been looking at Mypy and ABC but my attempts resulted in too much boilerplate. What is the pythonic way to create something similar to the Typescript interface?"
    },
    {
        "role": "assistant",
        "content": "In Python, while there isn't a direct equivalent to TypeScript's interfaces, you can achieve similar functionality using a combination of type hints, dataclasses, and abstract base classes (ABCs). Here's how you can mimic TypeScript interfaces in a Pythonic way:\n\n1. **Type Hints**: Use Python's type hints to specify the expected types of variables, function arguments, and return values. This won't enforce type checking at runtime, but tools like Mypy can be used for static type checking.\n\n2. **Dataclasses**: Introduced in Python 3.7, dataclasses provide a convenient way to define classes that are primarily used to store data. They automatically generate special methods like `__init__()` and `__repr__()`.\n\n3. **Abstract Base Classes (ABCs)**: Use ABCs from the `abc` module to define abstract methods that must be implemented by subclasses. This is useful if you want to enforce certain methods to be present in a class, similar to TypeScript interfaces.\n\nHere's an example that combines these concepts:\n\n```python\nfrom abc import ABC, abstractmethod\nfrom dataclasses import dataclass\nfrom typing import Protocol\n\n# Using Protocol for structural subtyping (Python 3.8+)\nclass AddressProtocol(Protocol):\n    street: str\n    city: str\n    zip_code: str\n\n@dataclass\nclass Address(AddressProtocol):\n    street: str\n    city: str\n    zip_code: str\n\n# Define an abstract base class for Person\nclass PersonInterface(ABC):\n    @abstractmethod\n    def get_full_name(self) -> str:\n        pass\n\n@dataclass\nclass Person(PersonInterface):\n    first_name: str\n    last_name: str\n    address: Address\n\n    def get_full_name(self) -> str:\n        return f\"{self.first_name} {self.last_name}\"\n\n# Example usage\naddress = Address(street=\"123 Main St\", city=\"Anytown\", zip_code=\"12345\")\nperson = Person(first_name=\"John\", last_name=\"Doe\", address=address)\n\nprint(person.get_full_name())\n```\n\n### Key Points:\n- **Protocols**: Introduced in Python 3.8, the `Protocol` class allows for structural subtyping (also known as \"duck typing\"). This is similar to TypeScript interfaces, where you define the structure rather than the inheritance.\n- **Dataclasses**: Reduce boilerplate by automatically generating methods like `__init__()`.\n- **ABC**: Enforce the implementation of methods in subclasses.\n\nBy using these tools, you can achieve a level of type safety and clarity in your Python code that resembles TypeScript interfaces."
    }
]