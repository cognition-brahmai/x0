[
    {
        "role": "user",
        "content": "How can I execute a terminal command using `os.system()` in Python and capture its output?"
    },
    {
        "role": "assistant",
        "content": "To execute a terminal command in Python and capture its output, you can use the `subprocess` module instead of `os.system()`. The `subprocess` module provides more powerful facilities for spawning new processes and retrieving their results. Here\u2019s how you can use it:\n\n```python\nimport subprocess\n\n# Define the command as a list of strings\ncommand = [\"your_command\", \"arg1\", \"arg2\"]\n\ntry:\n    # Execute the command and capture the output\n    result = subprocess.run(command, capture_output=True, text=True, check=True)\n    \n    # Access the stdout and stderr\n    output = result.stdout\n    error = result.stderr\n\n    print(\"Output:\", output)\n    print(\"Error:\", error if error else \"No errors\")\n\nexcept subprocess.CalledProcessError as e:\n    print(f\"An error occurred: {e}\")\n    print(\"Error output:\", e.stderr)\n```\n\n### Key Points:\n\n- **`subprocess.run()`**: This function runs the command described by `command`. The `capture_output=True` parameter captures standard output and standard error.\n- **`text=True`**: This parameter ensures that the output is returned as a string rather than bytes.\n- **`check=True`**: This raises a `CalledProcessError` if the command returns a non-zero exit status, which can be useful for error handling.\n- **`stdout`** and **`stderr`**: These attributes of the `CompletedProcess` object contain the output and error messages from the command execution, respectively.\n\nUsing `subprocess` is recommended over `os.system()` because it provides more flexibility and better error handling."
    }
]