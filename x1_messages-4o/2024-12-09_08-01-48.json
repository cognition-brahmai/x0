[
    {
        "role": "user",
        "content": "How can I validate SSL certificates with Python? I need to write a script that connects to several internal sites via HTTPS and verifies their SSL certificates. The certificates should be checked to ensure they are not expired and are issued for the correct address. We use our own internal corporate Certificate Authority for these sites, and we have the public key of the CA to verify the certificates against. The default Python behavior is to accept and use SSL certificates when using HTTPS, and even if a certificate is invalid, Python libraries such as urllib2 and Twisted will just use the certificate. How can I override this default behavior and verify a certificate in Python?"
    },
    {
        "role": "assistant",
        "content": "To validate SSL certificates in Python, you can use the `ssl` module along with `socket` to create a custom SSL context. This context will allow you to specify the certificate authority (CA) that you trust, which in your case is your internal corporate CA. Here's a step-by-step guide to achieve this:\n\n1. **Load the CA Certificate**: Load your internal corporate CA's public key (certificate) so it can be used to verify the SSL certificates of the internal sites.\n\n2. **Create a Secure SSL Context**: Use the `ssl` module to create an SSL context that will enforce certificate verification.\n\n3. **Connect and Verify**: Use the `ssl` context to connect to the HTTPS sites and verify the certificates.\n\nHere's a sample Python script demonstrating these steps:\n\n```python\nimport ssl\nimport socket\nfrom datetime import datetime\n\ndef verify_certificate(hostname, port, ca_file):\n    # Create an SSL context\n    context = ssl.create_default_context(ssl.Purpose.SERVER_AUTH)\n    context.load_verify_locations(cafile=ca_file)\n\n    # Connect to the server\n    with socket.create_connection((hostname, port)) as sock:\n        with context.wrap_socket(sock, server_hostname=hostname) as ssock:\n            # Get the server's certificate\n            cert = ssock.getpeercert()\n\n            # Validate the certificate\n            if not cert:\n                raise ValueError(\"No certificate received from the server.\")\n\n            # Check if the certificate has expired\n            expiry_date = datetime.strptime(cert['notAfter'], '%b %d %H:%M:%S %Y %Z')\n            if expiry_date < datetime.utcnow():\n                raise ValueError(f\"Certificate expired on {expiry_date}\")\n\n            # Check if the certificate was issued for this hostname\n            if not ssl.match_hostname(cert, hostname):\n                raise ValueError(f\"Certificate was not issued for {hostname}\")\n\n            print(f\"Certificate for {hostname} is valid.\")\n\n# Usage\nhostname = 'your.internal.site'\nport = 443\nca_file = 'path/to/your/internal/ca.pem'\n\ntry:\n    verify_certificate(hostname, port, ca_file)\nexcept Exception as e:\n    print(f\"Certificate verification failed: {e}\")\n```\n\n### Key Points:\n\n- **SSL Context**: `ssl.create_default_context()` is used to create an SSL context that we customize to ensure strict certificate validation.\n  \n- **CA Certificate**: Use `context.load_verify_locations(cafile=ca_file)` to specify the path to your internal CA certificate.\n\n- **Hostname Verification**: `ssl.match_hostname(cert, hostname)` is used to ensure the certificate is issued for the specified hostname.\n\n- **Certificate Expiry**: The expiry date is checked against the current date to ensure it hasn't expired.\n\nMake sure the `ca_file` path correctly points to your CA's certificate file, and replace `your.internal.site` and `path/to/your/internal/ca.pem` with your actual hostname and CA certificate path.\n\nThis script will raise exceptions if the certificate is invalid, expired, or not issued for the correct hostname, allowing you to handle these cases appropriately."
    }
]