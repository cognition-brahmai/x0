[
    {
        "role": "user",
        "content": "How can I use Python 3 type annotations to refer to any object that subclasses a parent class? For example, if I have an abstract base class 'FooBase', from which 'Foo1', 'Foo2', etc. are subclassed, how can I indicate that a function should accept any descendant of 'FooBase'? Will the following code be sufficient?\n\n```python\ndef do_something(self, bar:FooBase):\n    pass\n```\n\nOr will this only accept an object of class 'FooBase', which is impossible due to the abstract nature of 'FooBase'? If this is not the correct approach, do I need to build a 'Union' of all cases or is there a more abstract way to express this relationship?"
    },
    {
        "role": "assistant",
        "content": "Yes, your approach is correct. In Python 3, using type annotations to specify a parameter type as a base class, such as `FooBase`, will indeed allow any object that is an instance of `FooBase` or any of its subclasses to be accepted as an argument. This means that if `Foo1`, `Foo2`, etc., are subclasses of `FooBase`, they will all be valid types for the `bar` parameter in your `do_something` function.\n\nHere's your code for reference:\n\n```python\ndef do_something(self, bar: FooBase):\n    pass\n```\n\nThis annotation indicates that `bar` should be an instance of `FooBase` or any subclass of it. You do not need to use a `Union` to explicitly list all subclasses, as Python's type hinting system already understands class hierarchies and will accept instances of subclasses.\n\nIf `FooBase` is an abstract base class (ABC), it's typical to use it in type annotations this way, as it communicates the expected interface or base functionality that the `bar` parameter should adhere to, regardless of its specific subclass. This approach also leverages the power of polymorphism, which is one of the key principles of object-oriented programming."
    }
]