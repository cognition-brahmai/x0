[
    {
        "role": "user",
        "content": "How can I catch a Ctrl+C command in a multiprocess Python program and ensure that all processes exit gracefully? This solution needs to be compatible with both Unix and Windows. I've attempted the following code:\n\n```python\nimport multiprocessing\nimport time\nimport signal\nimport sys\n\njobs = []\n\ndef worker():\n    signal.signal(signal.SIGINT, signal_handler)\n    while(True):\n        time.sleep(1.1234)\n        print \"Working...\"\n\ndef signal_handler(signal, frame):\n    print 'You pressed Ctrl+C!'\n    # for p in jobs:\n    #     p.terminate()\n    sys.exit(0)\n\nif __name__ == \"__main__\":\n    for i in range(50):\n        p = multiprocessing.Process(target=worker)\n        jobs.append(p)\n        p.start()\n```\nIt somewhat works, but I'm not confident that it's the correct approach."
    },
    {
        "role": "assistant",
        "content": "Handling a `Ctrl+C` (SIGINT) signal in a multiprocess Python program requires a bit of careful consideration since the signal is sent to all processes in the group. To ensure that all child processes exit gracefully, you can implement a mechanism where the parent process handles the signal and then instructs the child processes to terminate.\n\nHere's a revised approach that should work on both Unix and Windows. This example uses a `multiprocessing.Event` to notify child processes when they should stop working and exit gracefully.\n\n```python\nimport multiprocessing\nimport time\nimport signal\nimport sys\n\ndef worker(stop_event, worker_id):\n    while not stop_event.is_set():\n        try:\n            # Simulate work by sleeping\n            time.sleep(1.1234)\n            print(f\"Worker {worker_id}: Working...\")\n        except KeyboardInterrupt:\n            pass\n    print(f\"Worker {worker_id}: Exiting...\")\n\ndef signal_handler(sig, frame, stop_event):\n    print('You pressed Ctrl+C!')\n    stop_event.set()\n\nif __name__ == \"__main__\":\n    jobs = []\n    stop_event = multiprocessing.Event()\n\n    # Set up signal handler in the main process\n    signal.signal(signal.SIGINT, lambda sig, frame: signal_handler(sig, frame, stop_event))\n\n    # Start the worker processes\n    for i in range(50):\n        p = multiprocessing.Process(target=worker, args=(stop_event, i))\n        jobs.append(p)\n        p.start()\n\n    # Wait for all jobs to finish\n    for job in jobs:\n        job.join()\n\n    print(\"All workers have exited gracefully.\")\n```\n\n### Explanation:\n\n1. **Event for Coordination**: We use a `multiprocessing.Event` named `stop_event` to coordinate the shutdown of processes. This event can be checked by each worker to know when to stop.\n\n2. **Signal Handling**: The parent process sets up a signal handler to catch `SIGINT` (Ctrl+C) and sets the `stop_event`. This signal handling should only be set up in the main process, not in the worker processes.\n\n3. **Worker Processes**: Each worker process runs in a loop checking the `stop_event`. When the event is set, they break out of the loop and exit gracefully.\n\n4. **Graceful Exit**: When `Ctrl+C` is pressed, the signal handler sets the `stop_event`, which signals all workers to stop their tasks. Each worker prints a message before exiting, ensuring a graceful shutdown.\n\nThis approach ensures that all processes are notified of the shutdown request and can clean up resources or finish their current task before exiting."
    }
]