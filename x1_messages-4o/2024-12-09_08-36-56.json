[
    {
        "role": "user",
        "content": "I am new to Ruby and I'm currently trying to import functions from a module that contains a tool I would like to continue using separately. In Python, I would do something like this:\n\n```python\ndef a():\n    ...\ndef b():\n    ...\nif __name__ == '__main__':\n    a()\n    b()\n```\n\nThis allows me to either run the program or import it as a module to use `a()` and/or `b()` separately. I would like to know what the equivalent paradigm is in Ruby."
    },
    {
        "role": "assistant",
        "content": "In Ruby, you can achieve a similar effect by defining your functions within a module and then using a conditional check to determine if the script is being run directly. Here's how you can structure your Ruby code:\n\n```ruby\nmodule MyModule\n  def self.a\n    # Your code for function a\n    puts \"Function a is called\"\n  end\n\n  def self.b\n    # Your code for function b\n    puts \"Function b is called\"\n  end\nend\n\nif __FILE__ == $PROGRAM_NAME\n  MyModule.a\n  MyModule.b\nend\n```\n\n### Explanation:\n\n- **Module Definition**: Define your functions inside a module. In this example, `MyModule` is the module containing the functions `a` and `b`. By using `self.a` and `self.b`, these functions become module methods and can be called without including or extending the module.\n\n- **Conditional Execution**: The line `if __FILE__ == $PROGRAM_NAME` checks if the current file is the main program being executed. This is equivalent to Python's `if __name__ == '__main__':`. If this condition is true, it means the script is being run directly, and you can call the functions as needed.\n\n- **Using the Module**: If you want to use these functions in another Ruby file, you can require the file containing the module and then call the functions as `MyModule.a` and `MyModule.b`.\n\nThis structure allows you to both execute the functions when the script is run directly and use them as part of a module in other Ruby programs."
    }
]