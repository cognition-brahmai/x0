[
    {
        "role": "user",
        "content": "In Django, I am working on creating a `MockMixin` for my tests which includes mocks for all instances that call external sources. For instance, each time I save a model in the admin panel, some remote URLs are called. I want to have these actions mocked in a way that it can be used like this:\n\n```python\nclass ExampleTestCase(MockedTestCase):\n    # tests\n```\n\nSo each time a model is saved in the admin during functional tests, this mock is applied instead of calling remote URLs. I can readily do this for a single test, but I am finding it more beneficial to have a global mock since I use it quite frequently. Is it possible to create such a global mock in Django?"
    },
    {
        "role": "assistant",
        "content": "Yes, you can create a `MockMixin` for your Django tests to globally mock external API calls or any other external resources that your models might interact with. This can be especially helpful for tests that involve saving models in the admin panel and calling remote URLs. Here's a general approach you can follow to achieve this:\n\n1. **Create a MockMixin:**\n\n   First, create a mixin that uses Python's `unittest.mock` library to patch the external calls. You can define methods to set up and tear down the mocks.\n\n   ```python\n   from unittest import mock\n\n   class MockMixin:\n       def setUp(self):\n           super().setUp()\n           # Patch the external calls here\n           self.patcher1 = mock.patch('path.to.your.external.call1')\n           self.mock_call1 = self.patcher1.start()\n\n           self.patcher2 = mock.patch('path.to.your.external.call2')\n           self.mock_call2 = self.patcher2.start()\n\n           # Add more patchers as needed\n\n       def tearDown(self):\n           super().tearDown()\n           self.patcher1.stop()\n           self.patcher2.stop()\n           # Stop any additional patchers\n   ```\n\n2. **Create a Base Test Case:**\n\n   Create a base test case class that inherits from both `MockMixin` and Django's `TestCase`. This base class can then be used by other test cases that require these mocks.\n\n   ```python\n   from django.test import TestCase\n\n   class MockedTestCase(MockMixin, TestCase):\n       pass\n   ```\n\n3. **Use the MockedTestCase:**\n\n   Now, you can use `MockedTestCase` in your test classes. This will ensure that all the mocks defined in `MockMixin` are applied to every test in those classes.\n\n   ```python\n   class ExampleTestCase(MockedTestCase):\n       def test_something(self):\n           # Your test logic here\n           pass\n   ```\n\n4. **Customize the Mocks:**\n\n   Inside the `setUp` method of `MockMixin`, you can customize how your mocked calls should behave. For example, you can set return values, side effects, or assert that certain calls were made.\n\nThis setup ensures that any time a model is saved in the admin or any other operation that triggers an external call, those calls are mocked, preventing real network requests and allowing you to test your application logic in isolation. This approach not only makes your tests faster but also more reliable by eliminating dependencies on external services."
    }
]