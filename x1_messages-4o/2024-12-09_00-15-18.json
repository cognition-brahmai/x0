[
    {
        "role": "user",
        "content": "What are the best practices for creating exceptions in Python? I recently saw a script where exceptions were created with strings as messages. I've read in several books that exceptions should never hold a string, because strings themselves can throw exceptions. Is this true? The script I saw was created for a specific use-case, where all in-house Python libraries needed to have a common error message format. Here is the code:\n\n```python\n\"\"\"\nBase Exception, Error\n\"\"\"\nclass Error(Exception):\n    def __init__(self, message):\n        self.message = message\n\n    def __str__(self):\n        return \"[ERROR] %s\\n\" % str(self.message)\n\n    def log(self):\n        ret = \"%s\" % str(self.message)\n        if(hasattr(self, \"reason\")):\n            return \"\".join([ret, \"\\n==&gt; %s\" % str(self.reason)])\n        return ret\n\nclass PCSException(Error):\n    def __init__(self, message, reason = None):\n        self.message = message\n        self.reason = reason\n    def __str__(self):\n        ret = \"[PCS_ERROR] %s\\n\" % str(self.message)\n        if(self.reason != None):\n            ret += \"[REASON] %s\\n\" % str(self.reason)\n        return ret\n```\n\nCan someone provide insight on whether this is a good or a bad practice, or suggest a better exception coding process/style?"
    },
    {
        "role": "assistant",
        "content": "Creating custom exceptions in Python is a common practice, especially when you need to handle specific errors in your application's domain. However, there are some best practices to consider to ensure that your exceptions are well-constructed and maintainable.\n\n### Best Practices for Creating Exceptions in Python\n\n1. **Subclass from the Right Exception Class**:\n   - Always subclass from Python's built-in `Exception` class, as you've done with the `Error` class. This ensures that your custom exceptions are compatible with Python's exception-handling mechanisms.\n\n2. **Use Descriptive Names**:\n   - Name your exception classes clearly to convey their purpose. `PCSException` is a good example, as it possibly stands for a specific domain within your application.\n\n3. **Avoid Storing Messages as Strings**:\n   - While the code you've shown uses strings for error messages and reasons, it is generally acceptable as long as you handle them properly. The concern about strings throwing exceptions is usually related to using raw strings without handling potential encoding or formatting issues.\n   - Instead of using only strings, consider using structured data, like dictionaries, to store additional information about the error. This makes it easier to handle and log errors programmatically.\n\n4. **Implement `__str__` and `__repr__`**:\n   - Implementing `__str__` provides a human-readable error message, which is helpful for debugging and logging. Ensure that `__str__` returns a string representation that is useful for understanding the error context.\n   - Consider also implementing `__repr__` for a more detailed representation, especially if your exceptions might be used in debugging sessions.\n\n5. **Include Additional Context**:\n   - If your exceptions need to carry additional context (like the `reason` in your example), make sure to include it in the exception's attributes. This makes it easier to access and log additional information related to the error.\n\n6. **Avoid Overly Complex Exceptions**:\n   - While adding context is beneficial, avoid making your exception classes too complex. They should be focused on conveying error information, not on executing business logic.\n\n7. **Document Your Exceptions**:\n   - Provide clear documentation for your custom exceptions, including when they are raised and how they should be handled. This is particularly important in larger codebases with multiple developers.\n\n### Example of Improved Custom Exception\n\nHere's an example of improving your exception classes:\n\n```python\nclass CustomError(Exception):\n    \"\"\"Base class for all custom exceptions.\"\"\"\n    def __init__(self, message, **kwargs):\n        super().__init__(message)\n        self.message = message\n        self.details = kwargs\n\n    def __str__(self):\n        details_str = \", \".join(f\"{key}={value}\" for key, value in self.details.items())\n        return f\"[ERROR] {self.message} ({details_str})\"\n\nclass PCSException(CustomError):\n    \"\"\"Exception raised for PCS specific errors.\"\"\"\n    def __init__(self, message, reason=None, **kwargs):\n        super().__init__(message, reason=reason, **kwargs)\n        self.reason = reason\n\n    def __str__(self):\n        base_str = super().__str__()\n        return f\"[PCS_ERROR] {base_str} [REASON] {self.reason}\" if self.reason else base_str\n```\n\n### Summary\n\nThe code you presented is a reasonable starting point for custom exceptions, but it can be improved by considering the best practices mentioned above. By structuring your exceptions to be informative and easy to use, you'll make error handling in your application more robust and maintainable."
    }
]