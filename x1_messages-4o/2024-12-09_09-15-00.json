[
    {
        "role": "user",
        "content": "How can an algorithm be designed to sort a list of numbers using Selection Sort?"
    },
    {
        "role": "assistant",
        "content": "Selection Sort is a straightforward comparison-based sorting algorithm. It divides the list into two parts: a sorted part and an unsorted part. The algorithm repeatedly selects the smallest (or largest, depending on sorting order) element from the unsorted part and moves it to the end of the sorted part. Here's how you can design an algorithm for Selection Sort:\n\n1. **Start with the entire list as the unsorted part** and an empty sorted part.\n\n2. **Repeat the following steps until the unsorted part is empty:**\n\n   a. **Find the smallest element** in the unsorted part of the list. You can do this by assuming the first element of the unsorted part is the smallest, then iterating through the unsorted part to find an element that is smaller.\n\n   b. **Swap the smallest element** found with the first element of the unsorted part. This effectively moves the smallest element to the end of the sorted part.\n\n   c. **Move the boundary** between the sorted and unsorted parts one element to the right. This means that the smallest element is now considered part of the sorted part.\n\n3. **Continue this process** until the entire list is sorted.\n\nHere's a simple implementation of Selection Sort in Python:\n\n```python\ndef selection_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        # Assume the minimum is the first element\n        min_index = i\n        # Iterate over the unsorted elements\n        for j in range(i + 1, n):\n            if arr[j] < arr[min_index]:\n                min_index = j\n        # Swap the found minimum element with the first element of the unsorted part\n        arr[i], arr[min_index] = arr[min_index], arr[i]\n\n# Example usage\nnumbers = [64, 25, 12, 22, 11]\nselection_sort(numbers)\nprint(\"Sorted list:\", numbers)\n```\n\n### Key Points:\n- **Time Complexity**: Selection Sort has a time complexity of \\(O(n^2)\\) in all cases (best, average, worst), where \\(n\\) is the number of elements in the list. This makes it inefficient for large datasets.\n- **Space Complexity**: It has a space complexity of \\(O(1)\\) because it is an in-place sorting algorithm and requires only a constant amount of additional memory space.\n- **Stability**: Selection Sort is not a stable sort, meaning that the relative order of equal elements may not be preserved.\n\nSelection Sort is easy to implement and understand, but it is generally not suitable for large lists due to its quadratic time complexity."
    }
]