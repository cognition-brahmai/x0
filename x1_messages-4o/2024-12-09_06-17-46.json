[
    {
        "role": "user",
        "content": "How can I use type hints in Python when both the `len` function and iteration is used over my parameter? I have a function that calls `len` on one of its parameters and iterates over the parameter. When I annotate the type with `Iterable`, or `Sized`, I get errors in `mypy`. Here is the code and the errors:\n\n```python\nfrom typing import Sized, Iterable\n\ndef foo(some_thing: Iterable):\n    print(len(some_thing))\n    for part in some_thing:\n        print(part)\n```\nThis gives an error: \n\n```Argument 1 to \"len\" has incompatible type \"Iterable[Any]\"; expected \"Sized\"```\n\nWhile annotating with `Sized`:\n\n```python\ndef foo(some_thing: Sized):\n    ...\n```\nGives errors:\n\n```Iterable expected\n\"Sized\" has no attribute \"__iter__\"```\n\nI tried to create a mixed class `SizedIterable` using `ABCMeta`, but `mypy` still complains about my `list` even after the subclass check works. Here is the code:\n\n```python\nfrom abc import ABCMeta\nfrom typing import Sized, Iterable\n\nclass SizedIterable(Sized, Iterable[str], metaclass=ABCMeta):\n    pass\n\ndef foo(some_thing: SizedIterable):\n    print(len(some_thing))\n    for part in some_thing:\n        print(part)\n\nfoo(['a', 'b', 'c'])\n```\nThis gives an error when using `foo` with a `list`:\n\n```Argument 1 to \"foo\" has incompatible type \"List[str]\"; expected \"SizedIterable\"```\n\nEven after defining a `__subclasshook__`:\n\n```python\nclass SizedIterable(Sized, Iterable[str], metaclass=ABCMeta):\n\n    @classmethod\n    def __subclasshook__(cls, subclass):\n        return Sized.__subclasscheck__(subclass) and Iterable.__subclasscheck__(subclass)\n```\nThe subclass check works, but `mypy` still complains about my `list`:\n\n```Argument 1 to \"foo\" has incompatible type \"List[str]\"; expected \"SizedIterable\"```\n\nI don't think casting `foo(cast(SizedIterable, ['a', 'b', 'c']))` is a good solution. How can I solve this problem?"
    },
    {
        "role": "assistant",
        "content": "The issue you're facing stems from the fact that `mypy` requires explicit type compatibility and doesn't recognize your custom type `SizedIterable` as being a `list`, even though it logically satisfies both `Sized` and `Iterable` constraints. The intersection of these two types is not directly expressible in Python's type system with `mypy` without some workaround.\n\nOne straightforward solution is to use the `Protocol` class from `typing`, which allows you to define a structural type that combines both `Sized` and `Iterable`. This way, you avoid the need for explicit inheritance and leverage `mypy`'s support for structural subtyping. Here's how you can do it:\n\n```python\nfrom typing import Protocol, Iterable, Sized\n\nclass SizedIterable(Protocol):\n    def __len__(self) -> int: ...\n    def __iter__(self) -> Iterable[str]: ...\n\ndef foo(some_thing: SizedIterable):\n    print(len(some_thing))\n    for part in some_thing:\n        print(part)\n\nfoo(['a', 'b', 'c'])\n```\n\n### Explanation:\n\n1. **Protocol**: This is used to define a structural type that specifies a set of methods that any conforming type must have. It's similar to interfaces in other languages.\n\n2. **SizedIterable Protocol**: It specifies that any type that has both a `__len__` method and an `__iter__` method will be considered a `SizedIterable`.\n\n3. **No Need for Inheritance**: Since `list` inherently supports both `__len__` and `__iter__`, it will automatically match this protocol without any need for explicit subclassing.\n\nThis approach should work seamlessly with `mypy` and allow you to use `foo` with any iterable and sized object, including lists, tuples, and other custom objects that implement these methods."
    }
]