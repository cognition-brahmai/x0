[
    {
        "role": "user",
        "content": "How can I inspect a Python class to safely identify user-defined class attributes? I have tried using functions like dir(), inspect.getmembers() and others but they return all class attributes including pre-defined ones like __class__, __doc__, __dict__, __hash__. I am looking for a solution where I only retrieve the user-defined class attributes and not the instance attributes. Here's an example of what I am trying to achieve:\n\n```python\nclass A:\n  a=10\n  b=20\n  def __init__(self):\n    self.c=30\n\ndir(A)\n# returns ['__doc__', '__init__', '__module__', 'a', 'b']\n\nget_user_attributes(A)\n# I want this to return ['a','b']\n```\n\nI tried solving this problem by parsing the class at the AST level but I haven't found a way to convert already parsed objects to an AST node tree since all AST info is discarded once a class has been compiled into bytecode. Can anyone help me with the implementation of the fictive function get_user_attributes(cls)?"
    },
    {
        "role": "assistant",
        "content": "To achieve your goal of identifying only the user-defined class attributes (and not instance attributes or built-in ones), you can make use of Python's `__dict__` attribute for the class. This attribute contains all the attributes defined directly in the class's scope (excluding inherited ones). You can filter out any special methods or attributes by checking if they have double underscores.\n\nHere's how you can implement the `get_user_attributes` function:\n\n```python\ndef get_user_attributes(cls):\n    # Get all attributes defined in the class's dictionary\n    class_dict = cls.__dict__\n    \n    # Filter out any attributes that are special methods (those with double underscores)\n    user_defined_attributes = [attr for attr in class_dict if not (attr.startswith('__') and attr.endswith('__'))]\n    \n    return user_defined_attributes\n\n# Example usage\nclass A:\n    a = 10\n    b = 20\n    def __init__(self):\n        self.c = 30\n\nprint(get_user_attributes(A))\n# Output: ['a', 'b']\n```\n\nThis function works by accessing the `__dict__` attribute of the class, which is a mapping of attribute names to their values. By filtering out any names that start and end with double underscores, you can isolate the attributes that are explicitly defined by the user in the class body. Keep in mind that this will only work for attributes defined directly in the class and not those set within methods or the constructor (like `self.c` in your example)."
    }
]