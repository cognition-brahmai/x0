[
    {
        "role": "user",
        "content": "In Python, I often encounter a situation where I use the same variable both within and outside a function, which leads to variable shadowing or a multiplication of local variables. Here's an example:\n\n```python\ndef whenadult(age):\n    return 18 - age\n\nage = 5\nneedtowait = whenadult(age)\n```\n\nIn this case, the `age` variable has the same logical role both when passed to the function and in the main code. I would like to avoid creating something like `l_age` in `whenadult`. Is there a pythonic way to solve this \"shadowing vs. variable multiplication\" dilemma? To be clear, I am looking for a Python best practice, rather than a discussion on local vs. global variables scope."
    },
    {
        "role": "assistant",
        "content": "In Python, variable shadowing occurs when a local variable in a function has the same name as a variable outside the function. This is a common situation, and there are several strategies you can use to handle it while maintaining clarity and readability in your code.\n\nHere are some Pythonic practices to avoid shadowing and maintain clean code:\n\n1. **Descriptive Naming**: Use more descriptive variable names that reflect the role or purpose of the variable. This can reduce confusion and make it clear whether a variable is intended to be used locally or globally. For example:\n\n    ```python\n    def years_until_adulthood(current_age):\n        return 18 - current_age\n\n    child_age = 5\n    years_to_wait = years_until_adulthood(child_age)\n    ```\n\n2. **Avoid Global Variables**: It's generally best practice to avoid using global variables unless absolutely necessary. Instead, pass variables as arguments to functions. This makes the function's dependencies clear and reduces the chance of unintended side effects.\n\n3. **Function-Specific Variables**: If a variable is only used within a function, keep it local to that function. This encapsulation prevents it from interfering with variables in other parts of the code.\n\n4. **Use Closures or Classes**: If you have related functions that share some state, consider using closures or classes to encapsulate the shared state. This approach can help avoid the need for global variables.\n\n5. **Refactoring**: If the function is doing more than one logical task or working with multiple related variables, consider refactoring your code to split the function into smaller, more focused functions.\n\nHere's an example using more descriptive names:\n\n```python\ndef calculate_years_until_adulthood(current_age):\n    return 18 - current_age\n\nchild_current_age = 5\nyears_to_wait_for_adulthood = calculate_years_until_adulthood(child_current_age)\n```\n\nIn this example, the function name and variable names are more descriptive, making it clear what each represents and helping to avoid any confusion regarding variable shadowing."
    }
]