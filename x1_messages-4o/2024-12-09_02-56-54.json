[
    {
        "role": "user",
        "content": "I am trying to use asyncio in Jupyter Notebook to get webpage HTML. I am using the following code:\n\n```python\nimport aiofiles\nimport aiohttp\nfrom aiohttp import ClientSession\n\nasync def get_info(url, session):\n    resp = await session.request(method=\"GET\", url=url)\n    resp.raise_for_status()\n    html = await resp.text(encoding='GB18030')\n    with open('test_asyncio.html', 'w', encoding='utf-8-sig') as f:\n        f.write(html)\n    return html\n    \nasync def main(urls):\n    async with ClientSession() as session:\n        tasks = [get_info(url, session) for url in urls]\n        return await asyncio.gather(*tasks)\n\nif __name__ == \"__main__\":\n    url = ['http://huanyuntianxiazh.fang.com/house/1010123799/housedetail.htm', 'http://zhaoshangyonghefu010.fang.com/house/1010126863/housedetail.htm']\n    result = asyncio.run(main(url))\n```\n\nHowever, I am getting a RuntimeError: \"asyncio.run() cannot be called from a running event loop\". What is the problem and how can I resolve it?"
    },
    {
        "role": "assistant",
        "content": "The error you're encountering is because Jupyter Notebooks use an event loop to run the notebook cells, and `asyncio.run()` tries to create a new event loop, which results in a `RuntimeError`. To solve this problem, you can use `nest_asyncio`, a library that allows you to run an asyncio event loop inside an existing loop, which is useful for running asynchronous code in environments like Jupyter Notebooks.\n\nHere's how you can modify your code to work in a Jupyter Notebook:\n\n1. Install `nest_asyncio` if you haven't already:\n\n   ```bash\n   pip install nest_asyncio\n   ```\n\n2. Import and apply `nest_asyncio` in your code:\n\n```python\nimport nest_asyncio\nimport asyncio\nimport aiofiles\nimport aiohttp\nfrom aiohttp import ClientSession\n\n# Apply nest_asyncio to allow nested event loops\nnest_asyncio.apply()\n\nasync def get_info(url, session):\n    resp = await session.request(method=\"GET\", url=url)\n    resp.raise_for_status()\n    html = await resp.text(encoding='GB18030')\n    with open('test_asyncio.html', 'w', encoding='utf-8-sig') as f:\n        f.write(html)\n    return html\n    \nasync def main(urls):\n    async with ClientSession() as session:\n        tasks = [get_info(url, session) for url in urls]\n        return await asyncio.gather(*tasks)\n\n# Define URLs\nurls = [\n    'http://huanyuntianxiazh.fang.com/house/1010123799/housedetail.htm',\n    'http://zhaoshangyonghefu010.fang.com/house/1010126863/housedetail.htm'\n]\n\n# Run the async main function\nresult = await main(urls)\n```\n\nThis code should work correctly in a Jupyter Notebook environment. The `nest_asyncio.apply()` call will allow the event loop to be reused, enabling you to use `await` directly in the notebook cells without running into the `RuntimeError`."
    }
]