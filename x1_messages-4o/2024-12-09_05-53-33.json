[
    {
        "role": "user",
        "content": "How can I prevent subprocesses in Python from receiving CTRL-C / Control-C / SIGINT? I am trying to build a wrapper for a dedicated server that operates in the shell. This wrapper initiates the server process via subprocess and manages its output. The server needs to be explicitly commanded to shut down gracefully, and so, CTRL-C should not reach the server process. Despite capturing the KeyboardInterrupt exception or overwriting the SIGINT-handler in Python, the server process still receives the CTRL-C and stops immediately. How can I prevent this from happening?"
    },
    {
        "role": "assistant",
        "content": "When you're using Python's `subprocess` module to manage a subprocess and you want to prevent it from being terminated by a `CTRL-C` signal (which sends a `SIGINT`), there are several strategies you can use. Here is one effective method:\n\n### Use `setsid` to Start the Subprocess in a New Session\n\nYou can start the subprocess in a new session using the `setsid` option. This prevents the subprocess from receiving signals sent to the terminal, including `SIGINT`.\n\nHere\u2019s how you can implement this:\n\n```python\nimport subprocess\nimport os\nimport signal\n\ndef run_subprocess():\n    process = subprocess.Popen(\n        ['your_server_command', 'arg1', 'arg2'],\n        preexec_fn=os.setsid,  # Start the process in a new session\n        stdout=subprocess.PIPE,\n        stderr=subprocess.PIPE\n    )\n\n    try:\n        stdout, stderr = process.communicate()\n        print(stdout)\n        if stderr:\n            print(stderr)\n    except KeyboardInterrupt:\n        print(\"CTRL-C pressed. Ignoring for subprocess.\")\n        # Optionally handle the subprocess termination here, if necessary\n\n    # To terminate the subprocess gracefully, you can use:\n    # os.killpg(os.getpgid(process.pid), signal.SIGTERM)\n    # This sends SIGTERM to the whole process group.\n\nif __name__ == \"__main__\":\n    run_subprocess()\n```\n\n### Explanation:\n\n1. **`preexec_fn=os.setsid`:** This call makes the subprocess its own session leader, and it will not receive signals from the parent process's terminal.\n\n2. **Handling `KeyboardInterrupt`:** You can catch `KeyboardInterrupt` in your main Python script and decide how to handle it without affecting the subprocess.\n\n3. **Graceful Termination:** When you want to terminate the subprocess gracefully, you can send a `SIGTERM` signal to the process group using `os.killpg` with the process group ID obtained via `os.getpgid(process.pid)`.\n\nThis approach isolates the subprocess from terminal signals, allowing you to manage its lifecycle independently of user interrupts like `CTRL-C`."
    }
]