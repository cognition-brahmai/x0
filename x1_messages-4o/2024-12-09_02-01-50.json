[
    {
        "role": "user",
        "content": "How can I define custom error codes and error messages in Python 2.4.3, and raise or trap exceptions in such a way that I know what error code or message to display? Specifically, I have an application with the following custom exceptions and methods:\n\n```\nclass AppError(Exception):\n    pass\n\nclass MissingInputError(AppError):\n    pass\n\nclass ValidationError(AppError):\n    pass\n```\n\nand methods `validate()` and `__validateMulti()` that validate and store input parameters. I want to define error codes and messages like \"Error 1100: Key parameter not found. Please verify your input.\", \"Error 1101: Date parameter not found. Please verify your input\", etc. I want to display these error messages to the user when an exception is thrown.\n\nIn a Stack Overflow comment, Bastien L\u00e9onard says that I don't need to always define a new `__init__` or `__str__`, by default, arguments will be placed in self.args and they will be printed by `__str__`. How can I implement this suggestion in my application?"
    },
    {
        "role": "assistant",
        "content": "In Python, you can define custom error codes and messages by extending the base `Exception` class and storing the error code and message as attributes of your custom exception classes. You don't need to redefine `__init__` or `__str__` for every custom exception if you follow a pattern where the error code and message are passed as arguments to the exception and stored in `self.args`.\n\nHere's how you can implement this approach in your application:\n\n```python\nclass AppError(Exception):\n    def __init__(self, error_code, message):\n        self.error_code = error_code\n        self.message = message\n        super(AppError, self).__init__(error_code, message)\n\n    def __str__(self):\n        return f\"Error {self.error_code}: {self.message}\"\n\nclass MissingInputError(AppError):\n    def __init__(self, error_code=1100, message=\"Key parameter not found. Please verify your input.\"):\n        super(MissingInputError, self).__init__(error_code, message)\n\nclass ValidationError(AppError):\n    def __init__(self, error_code=1101, message=\"Date parameter not found. Please verify your input.\"):\n        super(ValidationError, self).__init__(error_code, message)\n\ndef validate(input_data):\n    if 'key' not in input_data:\n        raise MissingInputError()\n    if 'date' not in input_data:\n        raise ValidationError()\n\ndef __validateMulti(input_data_list):\n    for input_data in input_data_list:\n        try:\n            validate(input_data)\n        except AppError as e:\n            print(e)  # This will print the error message with code\n\n# Example usage\ninput_data = {'key': 'value'}  # Missing 'date'\ntry:\n    validate(input_data)\nexcept AppError as e:\n    print(e)  # Output will be: \"Error 1101: Date parameter not found. Please verify your input.\"\n```\n\nIn this implementation:\n\n- `AppError` is the base class for custom exceptions, which takes `error_code` and `message` as parameters and stores them.\n- `MissingInputError` and `ValidationError` are specific exceptions that inherit from `AppError` and provide default error codes and messages.\n- The `__str__` method of `AppError` is overridden to format the error code and message when the exception is printed.\n- In the `validate` function, specific exceptions are raised based on the validation logic.\n- The `__validateMulti` function demonstrates how you can catch and handle these exceptions, printing the formatted error message and code.\n\nThis approach allows you to manage and display custom error messages and codes efficiently without needing to redefine `__init__` or `__str__` for each custom exception."
    }
]