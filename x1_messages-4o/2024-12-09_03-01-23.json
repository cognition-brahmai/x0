[
    {
        "role": "user",
        "content": "I am attempting to rotate an image using OpenCV and Python. Currently, my code rotates an input image and pads it with black borders. However, I want to crop the largest possible area within the rotated image, which I refer to as the axis-aligned bounded box. The previous solutions I found were not applicable as they were only valid for square images, while my images are rectangular. How can I achieve this?\n\nHere's the code I have so far:\n\n```python\nimport cv2\nimport numpy as np\n\n\ndef getTranslationMatrix2d(dx, dy):\n    \"\"\"\n    Returns a numpy affine transformation matrix for a 2D translation of\n    (dx, dy)\n    \"\"\"\n    return np.matrix([[1, 0, dx], [0, 1, dy], [0, 0, 1]])\n\n\ndef rotateImage(image, angle):\n    \"\"\"\n    Rotates the given image about it's centre\n    \"\"\"\n\n    image_size = (image.shape[1], image.shape[0])\n    image_center = tuple(np.array(image_size) / 2)\n\n    rot_mat = np.vstack([cv2.getRotationMatrix2D(image_center, angle, 1.0), [0, 0, 1]])\n    trans_mat = np.identity(3)\n\n    w2 = image_size[0] * 0.5\n    h2 = image_size[1] * 0.5\n\n    rot_mat_notranslate = np.matrix(rot_mat[0:2, 0:2])\n\n    tl = (np.array([-w2, h2]) * rot_mat_notranslate).A[0]\n    tr = (np.array([w2, h2]) * rot_mat_notranslate).A[0]\n    bl = (np.array([-w2, -h2]) * rot_mat_notranslate).A[0]\n    br = (np.array([w2, -h2]) * rot_mat_notranslate).A[0]\n\n    x_coords = [pt[0] for pt in [tl, tr, bl, br]]\n    x_pos = [x for x in x_coords if x > 0]\n    x_neg = [x for x in x_coords if x < 0]\n\n    y_coords = [pt[1] for pt in [tl, tr, bl, br]]\n    y_pos = [y for y in y_coords if y > 0]\n    y_neg = [y for y in y_coords if y < 0]\n\n    right_bound = max(x_pos)\n    left_bound = min(x_neg)\n    top_bound = max(y_pos)\n    bot_bound = min(y_neg)\n\n    new_w = int(abs(right_bound - left_bound))\n    new_h = int(abs(top_bound - bot_bound))\n    new_image_size = (new_w, new_h)\n\n    new_midx = new_w * 0.5\n    new_midy = new_h * 0.5\n\n    dx = int(new_midx - w2)\n    dy = int(new_midy - h2)\n\n    trans_mat = getTranslationMatrix2d(dx, dy)\n    affine_mat = (np.matrix(trans_mat) * np.matrix(rot_mat))[0:2, :]\n    result = cv2.warpAffine(image, affine_mat, new_image_size, flags=cv2.INTER_LINEAR)\n\n    return result\n```"
    },
    {
        "role": "assistant",
        "content": "To crop the largest possible axis-aligned bounding box from a rotated image, we need to first calculate the bounding box of the rotated image and then crop it accordingly. Your provided code already calculates the corners of the rotated image in the `rotateImage` function. We can use these coordinates to determine the bounding box and crop the image.\n\nHere's a step-by-step modification to achieve the desired result:\n\n1. After calculating the rotated image corners, determine the bounding box by finding the min and max x and y coordinates.\n2. Use these coordinates to crop the image after rotating it.\n\nHere's your updated code with the necessary changes:\n\n```python\nimport cv2\nimport numpy as np\n\ndef getTranslationMatrix2d(dx, dy):\n    \"\"\"\n    Returns a numpy affine transformation matrix for a 2D translation of\n    (dx, dy)\n    \"\"\"\n    return np.matrix([[1, 0, dx], [0, 1, dy], [0, 0, 1]])\n\ndef rotateImage(image, angle):\n    \"\"\"\n    Rotates the given image about its center and crops to the largest\n    possible axis-aligned bounding box.\n    \"\"\"\n\n    image_size = (image.shape[1], image.shape[0])\n    image_center = tuple(np.array(image_size) / 2)\n\n    rot_mat = np.vstack([cv2.getRotationMatrix2D(image_center, angle, 1.0), [0, 0, 1]])\n    trans_mat = np.identity(3)\n\n    w2 = image_size[0] * 0.5\n    h2 = image_size[1] * 0.5\n\n    rot_mat_notranslate = np.matrix(rot_mat[0:2, 0:2])\n\n    # Calculate the rotated image corners\n    corners = np.array([\n        [-w2, -h2],\n        [w2, -h2],\n        [w2, h2],\n        [-w2, h2]\n    ])\n\n    rotated_corners = [np.dot(rot_mat_notranslate, corner).A[0] for corner in corners]\n\n    # Find the bounding box of the rotated corners\n    x_coords = [pt[0] for pt in rotated_corners]\n    y_coords = [pt[1] for pt in rotated_corners]\n\n    min_x, max_x = min(x_coords), max(x_coords)\n    min_y, max_y = min(y_coords), max(y_coords)\n\n    # Compute the size of the new cropped image\n    new_w = int(max_x - min_x)\n    new_h = int(max_y - min_y)\n    new_image_size = (new_w, new_h)\n\n    # Adjust rotation matrix to account for translation\n    rot_mat[0, 2] -= min_x\n    rot_mat[1, 2] -= min_y\n\n    # Perform the affine transformation\n    result = cv2.warpAffine(image, rot_mat[0:2, :], new_image_size, flags=cv2.INTER_LINEAR)\n\n    return result\n\n# Example usage\nimage = cv2.imread('your_image.jpg')\nangle = 30  # example rotation angle\nrotated_cropped_image = rotateImage(image, angle)\ncv2.imwrite('rotated_cropped_image.jpg', rotated_cropped_image)\n```\n\nThis code will rotate the image and then crop it to the largest possible axis-aligned bounding box. The bounding box is determined by calculating the extremities of the rotated image's corners. Make sure to replace `'your_image.jpg'` with the path to your image and adjust the `angle` as needed."
    }
]