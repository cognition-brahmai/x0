[
    {
        "role": "user",
        "content": "In Python, given the classes A, B, and C where class C is a subclass of both A and B, is there a way to iterate through its superclasses (A and B)? I am looking for a way to achieve this and I have found a solution using the inspect module and getclasstree function. Is this solution considered \"Pythonic\"? Here is the code I have:\n\n```python\nclass A():\n    pass\nclass B():\n    pass\nclass C(A, B):\n    pass\n\ndef magicGetSuperClasses(cls):\n    return [o[0] for o in inspect.getclasstree([cls]) if type(o[0]) == type]\n```\n\nI am aiming to get the output as:\n\n```python\n>>> magicGetSuperClasses(C)\n(<type 'A'>, <type 'B'>)\n```"
    },
    {
        "role": "assistant",
        "content": "The solution you've found using the `inspect` module and the `getclasstree` function is a valid approach, but it might not be considered the most \"Pythonic\" way to iterate through the superclasses of a class. In Python, the `__mro__` attribute (method resolution order) of a class can be used to achieve this more directly and succinctly. The `__mro__` attribute provides a tuple of the class and its superclasses in the order they are used when searching for a method. Here's how you can use it:\n\n```python\nclass A:\n    pass\n\nclass B:\n    pass\n\nclass C(A, B):\n    pass\n\ndef magicGetSuperClasses(cls):\n    # Exclude the class itself and 'object' from the MRO\n    return cls.__mro__[1:-1]\n\n# Example usage\nprint(magicGetSuperClasses(C))  # Output: (<class '__main__.A'>, <class '__main__.B'>)\n```\n\n### Explanation:\n- `cls.__mro__` gives you a tuple containing the class itself followed by its superclasses up to the base `object`.\n- By slicing `cls.__mro__[1:-1]`, you exclude the class itself (at index 0) and the base `object` class (at the last index).\n\nThis approach is more direct and utilizes Python's built-in capabilities without needing additional imports, making it more \"Pythonic\"."
    }
]