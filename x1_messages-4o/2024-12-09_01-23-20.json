[
    {
        "role": "user",
        "content": "What is the order of execution for pytest fixtures? For an application I am testing, I want to create an `autouse=True` fixture, which monkeypatches `smtplib.SMTP.connect` to fail tests if they try to send an email unexpectedly. However, in scenarios where I do expect tests to send emails, I want to use a different fixture for logging those emails instead. This would most likely involve using the `smtpserver` fixture from `pytest-localserver` and monkeypatching the `connect` method to use the host/port returned by that fixture. I want this to work only if the autouse fixture is executed before the other fixture (loaded as funcarg). Is there a specific order in which fixtures are executed and is there a way to control or guarantee this execution order?"
    },
    {
        "role": "assistant",
        "content": "In pytest, the order of fixture execution is primarily determined by their scope and dependencies. Here's how you can manage and control the execution order for your fixtures:\n\n1. **Fixture Scope**: Fixtures can have different scopes: `function`, `class`, `module`, or `session`. Fixtures with broader scopes (e.g., `session`) are executed before those with narrower scopes (e.g., `function`). If both fixtures have the same scope, their order is determined by dependency.\n\n2. **Dependency Order**: If a fixture depends on another fixture, the dependency fixture will be executed first. You can specify dependencies by using fixtures as arguments in other fixtures or tests.\n\n3. **Autouse Fixtures**: Autouse fixtures are automatically used by tests and are executed before any fixture that is explicitly requested by the test function. If you set `autouse=True`, it will be executed for every test within the scope it's defined. This means that your `autouse=True` fixture will run before any explicitly requested fixtures.\n\nTo achieve your specific use case:\n\n- Define your `autouse` fixture to monkeypatch `smtplib.SMTP.connect` with a failing behavior. This fixture should have the same or broader scope than the fixture you want to use for logging emails.\n\n- Create a separate fixture for scenarios where email sending is expected. This fixture should depend on the `smtpserver` fixture from `pytest-localserver` and adjust the monkeypatching accordingly.\n\nHere is an illustrative example:\n\n```python\nimport pytest\nfrom unittest.mock import patch\nimport smtplib\n\n@pytest.fixture(autouse=True)\ndef prevent_unexpected_email(monkeypatch):\n    def fail_connect(*args, **kwargs):\n        raise RuntimeError(\"Unexpected email sending attempt\")\n    monkeypatch.setattr(smtplib.SMTP, \"connect\", fail_connect)\n\n@pytest.fixture\ndef expected_email_scenario(smtpserver, monkeypatch):\n    def custom_connect(host, port, *args, **kwargs):\n        return smtpserver.host, smtpserver.port\n    monkeypatch.setattr(smtplib.SMTP, \"connect\", custom_connect)\n    # Additional setup for smtpserver if necessary\n\ndef test_no_email():\n    with pytest.raises(RuntimeError, match=r\"Unexpected email sending attempt\"):\n        smtp = smtplib.SMTP('localhost')\n        smtp.connect()\n\ndef test_expected_email_scenario(expected_email_scenario):\n    smtp = smtplib.SMTP('localhost')\n    assert smtp.connect() == (expected_email_scenario.host, expected_email_scenario.port)\n```\n\nIn this setup:\n\n- The `prevent_unexpected_email` fixture is `autouse` and will run before any test or other fixtures.\n- The `expected_email_scenario` fixture specifically overrides the behavior for tests that expect to send emails and uses the `smtpserver` fixture.\n- The order is naturally managed by the autouse mechanism and fixture dependencies.\n\nEnsure that your tests requiring the `expected_email_scenario` fixture explicitly request it to override the autouse behavior for those specific cases."
    }
]