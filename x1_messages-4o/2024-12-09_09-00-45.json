[
    {
        "role": "user",
        "content": "How can I design a priority queue with insert, extract min, and decrease key operations using Python?"
    },
    {
        "role": "assistant",
        "content": "Designing a priority queue in Python that supports `insert`, `extract_min`, and `decrease_key` operations can be efficiently done using a binary heap. A min-heap is a complete binary tree where the key at each node is less than or equal to the keys of its children, which allows efficient implementation of the required operations. Here's a step-by-step guide to implementing this:\n\n### Step 1: Define the Priority Queue Class\n\nFirst, define a class to represent the priority queue. You'll need a list to store heap elements and a dictionary to keep track of the positions of each element for efficient `decrease_key` operations.\n\n```python\nclass PriorityQueue:\n    def __init__(self):\n        self.heap = []\n        self.position_map = {}\n\n    def _parent(self, index):\n        return (index - 1) // 2\n\n    def _left_child(self, index):\n        return 2 * index + 1\n\n    def _right_child(self, index):\n        return 2 * index + 2\n```\n\n### Step 2: Implement the Insert Operation\n\nThe `insert` operation adds a new element to the heap and maintains the heap property.\n\n```python\n    def insert(self, key, value):\n        self.heap.append((key, value))\n        index = len(self.heap) - 1\n        self.position_map[value] = index\n        self._heapify_up(index)\n```\n\n### Step 3: Implement the Extract Min Operation\n\nThe `extract_min` operation removes and returns the element with the minimum key.\n\n```python\n    def extract_min(self):\n        if not self.heap:\n            return None\n        min_elem = self.heap[0]\n        last_elem = self.heap.pop()\n        if self.heap:\n            self.heap[0] = last_elem\n            self.position_map[last_elem[1]] = 0\n            self._heapify_down(0)\n        del self.position_map[min_elem[1]]\n        return min_elem\n```\n\n### Step 4: Implement the Decrease Key Operation\n\nThe `decrease_key` operation decreases the key of a given element and adjusts the heap to maintain the heap property.\n\n```python\n    def decrease_key(self, value, new_key):\n        index = self.position_map.get(value)\n        if index is not None and new_key < self.heap[index][0]:\n            self.heap[index] = (new_key, value)\n            self._heapify_up(index)\n```\n\n### Step 5: Implement Helper Methods\n\nHelper methods `_heapify_up` and `_heapify_down` are used to maintain the heap property after insertions and deletions.\n\n```python\n    def _heapify_up(self, index):\n        while index > 0 and self.heap[self._parent(index)][0] > self.heap[index][0]:\n            self._swap(index, self._parent(index))\n            index = self._parent(index)\n\n    def _heapify_down(self, index):\n        smallest = index\n        left = self._left_child(index)\n        right = self._right_child(index)\n\n        if left < len(self.heap) and self.heap[left][0] < self.heap[smallest][0]:\n            smallest = left\n\n        if right < len(self.heap) and self.heap[right][0] < self.heap[smallest][0]:\n            smallest = right\n\n        if smallest != index:\n            self._swap(index, smallest)\n            self._heapify_down(smallest)\n\n    def _swap(self, i, j):\n        self.heap[i], self.heap[j] = self.heap[j], self.heap[i]\n        self.position_map[self.heap[i][1]], self.position_map[self.heap[j][1]] = i, j\n```\n\n### Usage\n\nHere's how you can use the `PriorityQueue` class:\n\n```python\npq = PriorityQueue()\npq.insert(3, 'A')\npq.insert(1, 'B')\npq.insert(2, 'C')\n\nprint(pq.extract_min())  # Output: (1, 'B')\npq.decrease_key('C', 0)\nprint(pq.extract_min())  # Output: (0, 'C')\n```\n\nThis implementation provides efficient operations: `insert` and `decrease_key` run in O(log n) time, while `extract_min` also runs in O(log n) time."
    }
]