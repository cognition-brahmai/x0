[
    {
        "role": "user",
        "content": "I am trying to unit test a Python class called 'UUT' which instantiates exactly two 'ClassToPatch' objects. I want to mock 'ClassToPatch' using the '@patch' decorator in a test case. How can I configure the Mock framework to return a new Mock object for each instantiation of 'ClassToPatch' so I can assert calls on each separately? Here's my current code:\n\n```python\nclass ClassToPatch():\n   def __init__(self, *args):\n       _do_some_init_stuff()\n\n   def some_func():\n       _do_stuff()\n\nclass UUT():\n    def __init__(self, *args)\n       resource_1 = ClassToPatch()\n       resource_2 = ClassToPatch()\n\nclass TestCase1(unittest.TestCase):\n\n    @patch('classToPatch.ClassToPatch',autospec=True)\n    def test_1(self,mock1,mock2):\n        _assert_stuff()\n```\n\nI have read the [manual](http://www.voidspace.org.uk/python/mock/) and I suspect this involves 'side_effect' and/or 'return_value', but I'm struggling to implement a solution. Could you provide a simple, direct example?"
    },
    {
        "role": "assistant",
        "content": "Certainly! To achieve what you want, you can use the `side_effect` feature of the `Mock` class. By setting `side_effect` to a function or a list of values, you can control what gets returned each time the mock is called.\n\nIn your case, you want each instantiation of `ClassToPatch` to return a new mock object. You can achieve this by defining a function that returns a new `Mock` object each time it's called. Here's how you can modify your test code to accomplish this:\n\n```python\nimport unittest\nfrom unittest.mock import patch, Mock\n\nclass ClassToPatch():\n    def __init__(self, *args):\n        pass  # _do_some_init_stuff()\n\n    def some_func(self):\n        pass  # _do_stuff()\n\nclass UUT():\n    def __init__(self, *args):\n        self.resource_1 = ClassToPatch()\n        self.resource_2 = ClassToPatch()\n\nclass TestCase1(unittest.TestCase):\n\n    @patch('path.to.ClassToPatch', autospec=True)\n    def test_1(self, MockClassToPatch):\n        # Define a function that returns a new Mock object every time it's called\n        def side_effect(*args, **kwargs):\n            return Mock()\n\n        # Set the side_effect of the mock to the function\n        MockClassToPatch.side_effect = side_effect\n\n        # Instantiate the class under test\n        uut = UUT()\n\n        # Access the mock instances\n        resource_1_mock = uut.resource_1\n        resource_2_mock = uut.resource_2\n\n        # Now you can assert calls on each mock separately\n        resource_1_mock.some_func()\n        resource_2_mock.some_func()\n\n        resource_1_mock.some_func.assert_called_once()\n        resource_2_mock.some_func.assert_called_once()\n\n# Run the test\nif __name__ == '__main__':\n    unittest.main()\n```\n\nIn this example:\n\n- `side_effect` is set to a function that returns a new `Mock` object each time `ClassToPatch` is instantiated.\n- This ensures that `resource_1` and `resource_2` in the `UUT` class are separate mock objects, allowing you to assert calls on them individually.\n\nRemember to replace `'path.to.ClassToPatch'` with the actual import path of your `ClassToPatch` class."
    }
]