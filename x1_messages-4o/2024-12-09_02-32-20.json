[
    {
        "role": "user",
        "content": "I am having trouble using docstrings with decorators in Python. When I create a decorator and apply it to a function with a docstring, the help function does not display the docstring of the decorated function as expected. For example:\n\n```python\ndef decorator(f):\n    def _decorator():\n        print 'decorator active'\n        f()\n    return _decorator\n\n@decorator\ndef foo():\n    '''the magic foo function'''\n    print 'this is function foo'\n\nhelp(foo)\n```\n\nWhen I call help on the function `foo`, it shows this output:\n\n```python\nHelp on function _decorator in module __main__:\n\n_decorator()\n```\n\nBut without the decorator, the help function displays the correct docstring:\n\n```python\nHelp on function foo in module __main__:\n\nfoo()\n    the magic foo function\n```\n\nI understand that the function `foo` is being wrapped by the decorator, so the function object is not the original `foo` function anymore. But is there a neat solution to get the docstring (and the help) as expected?"
    },
    {
        "role": "assistant",
        "content": "The issue you're experiencing is a common one when using decorators in Python. When a function is wrapped by a decorator, the original function's metadata, including its docstring, is lost by default. This happens because the decorator returns a new function, effectively replacing the original function.\n\nTo solve this problem, you can use the `functools.wraps` decorator, which is specifically designed to preserve the metadata of the original function when it is wrapped by another function. Here's how you can modify your `decorator` function to use `functools.wraps`:\n\n```python\nfrom functools import wraps\n\ndef decorator(f):\n    @wraps(f)\n    def _decorator():\n        print('decorator active')\n        f()\n    return _decorator\n\n@decorator\ndef foo():\n    '''the magic foo function'''\n    print('this is function foo')\n\nhelp(foo)\n```\n\nBy adding `@wraps(f)` above the inner function `_decorator`, you ensure that the metadata, such as the docstring, from the original function `f` is copied to the new function `_decorator`. Now, when you call `help(foo)`, it should correctly display the docstring of the original `foo` function:\n\n```plaintext\nHelp on function foo in module __main__:\n\nfoo()\n    the magic foo function\n```\n\nThis is a neat and standard way to handle the issue of lost metadata when using decorators in Python."
    }
]