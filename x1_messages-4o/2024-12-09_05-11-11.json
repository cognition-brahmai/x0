[
    {
        "role": "user",
        "content": "In Python, why does invoking the `__str__()` method on literals work on all types except `int`? For instance, when I try using `123.__str__()`, I encounter a SyntaxError. Isn't `123` an object of type `int`?\n\n```\n>>> \"hello world\".__str__()\n'hello world'\n>>> [].__str__()\n'[]'\n>>> 3.14.__str__()\n'3.14'\n>>> 3..__str__()\n'3.0'\n>>> 123.__str__()\n  File \"<stdin>\", line 1\n    123.__str__()\n              ^\nSyntaxError: invalid syntax\n```"
    },
    {
        "role": "assistant",
        "content": "In Python, every object is indeed an instance of a class, and `int` is no exception. Each integer literal is an instance of the `int` class, so it has all the methods defined for `int`, including `__str__()`. However, the reason why `123.__str__()` results in a `SyntaxError` is due to the way Python's lexer parses the number.\n\nHere's a breakdown of why this happens:\n\n1. **Decimal Point Confusion**: When you type `123.`, Python interprets this as the beginning of a floating-point number. Thus, `123.` is seen as an incomplete float, and the following `__str__()` is not recognized properly, leading to a syntax error.\n\n2. **Resolution Techniques**:\n   - **Parentheses**: You can resolve this ambiguity by using parentheses to clearly delineate the integer from the method call: `(123).__str__()`. This explicitly tells Python to treat `123` as an integer and then call the `__str__()` method on it.\n   - **Space**: Another method is to insert a space between the number and the dot: `123 .__str__()`. This makes the lexer interpret `123` as an integer before encountering the dot.\n\n3. **Float Literals**: For expressions like `3.14.__str__()`, Python correctly interprets `3.14` as a complete floating-point literal before encountering the method call, hence it works without issues. Similarly, `3..__str__()` works because the first dot completes the float literal `3.0`, and the second dot is used for method invocation.\n\nIn summary, the issue is not with the `int` type itself, but with the way Python's syntax rules parse numbers and dots. Using parentheses or spacing can help disambiguate your intentions to the interpreter."
    }
]