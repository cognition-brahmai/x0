[
    {
        "role": "user",
        "content": "I'm facing an issue with defining atomicAdd for doubles in CUDA. I have a code which was working fine with previous CUDA versions. However, after upgrading to CUDA 8 RC, I'm getting a compilation error when I include a function for atomicAdd that says \"function atomicAdd(double *, double) has already been defined\". If I remove my implementation, I get another error that says \"no instance of overloaded function atomicAdd matches the argument list argument types are: (double *, double)\". The error only appears when I compile with -arch=sm_35 or similar, not with -arch=sm_60. Renaming atomicAdd seems to solve the issue. Can someone confirm if this is a compiler bug? \n\nHere is the example code: \n\n```c\n__device__ double atomicAdd(double* address, double val)\n{\n    unsigned long long int* address_as_ull = (unsigned long long int*)address;\n    unsigned long long int old = *address_as_ull, assumed;\n    do {\n        assumed = old;\n        old = atomicCAS(address_as_ull, assumed,\n                __double_as_longlong(val + __longlong_as_double(assumed)));\n    } while (assumed != old);\n    return __longlong_as_double(old);\n}\n\n__global__ void kernel(double *a)\n{\n    double b=1.3;\n    atomicAdd(a,b);\n}\n\nint main(int argc, char **argv)\n{\n    double *a;\n    cudaMalloc(&a,sizeof(double));\n\n    kernel<<<1,1>>>(a);\n\n    cudaFree(a);\n    return 0;\n}\n```"
    },
    {
        "role": "assistant",
        "content": "The issue you're experiencing arises because, starting with CUDA 8, native support for `atomicAdd` on `double` types was introduced for compute capability 6.0 (Pascal architecture) and above. This means that for architectures with compute capability 6.0 and above, the CUDA toolkit provides its own implementation of `atomicAdd` for `double`. This is why you're seeing the \"function atomicAdd(double *, double) has already been defined\" error when you provide your own implementation.\n\nHowever, for compute capabilities below 6.0, such as 3.5 (Kepler architecture), there is no native support for `atomicAdd` on `double`. Therefore, when you remove your own implementation for these architectures, you encounter the error \"no instance of overloaded function atomicAdd matches the argument list\".\n\nTo resolve this issue, you need to conditionally compile your custom `atomicAdd` function based on the compute capability. You can use the `__CUDA_ARCH__` macro to determine the compute capability and decide whether to define your own `atomicAdd` function. Here's how you can do it:\n\n```c\n#if __CUDA_ARCH__ < 600\n__device__ double atomicAdd(double* address, double val)\n{\n    unsigned long long int* address_as_ull = (unsigned long long int*)address;\n    unsigned long long int old = *address_as_ull, assumed;\n    do {\n        assumed = old;\n        old = atomicCAS(address_as_ull, assumed,\n                __double_as_longlong(val + __longlong_as_double(assumed)));\n    } while (assumed != old);\n    return __longlong_as_double(old);\n}\n#endif\n\n__global__ void kernel(double *a)\n{\n    double b = 1.3;\n    atomicAdd(a, b);\n}\n\nint main(int argc, char **argv)\n{\n    double *a;\n    cudaMalloc(&a, sizeof(double));\n\n    kernel<<<1, 1>>>(a);\n\n    cudaFree(a);\n    return 0;\n}\n```\n\nThis code uses a preprocessor directive to include your custom `atomicAdd` implementation only when compiling for architectures with compute capability less than 6.0. This should resolve the compilation issues you're encountering."
    }
]