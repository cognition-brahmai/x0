[
    {
        "role": "user",
        "content": "In Python 2.7, I am trying to apply a function to rows in a pandas dataframe that don't contain NULL values in a specific column. My function is very simple and my code works perfectly when I check columns 'A' and 'B'. However, when I select column 'C', which contains list objects, I receive a ValueError: 'The truth value of an array with more than one element is ambiguous. Use a.any() or a.all(), occurred at index 1'. Why does pd.notnull() work only for integer and string columns but not for 'list columns'? Is there another way to check for NULL values in column 'C'? Here is the dataframe and the code I am using:\n\n```python\ndf=\n       A    B               C\n0    NaN   11             NaN\n1    two  NaN  ['foo', 'bar']\n2  three   33             NaN\n\ndef my_func(row):\n    print row\n\ndf[['A','B']].apply(lambda x: my_func(x) if(pd.notnull(x[0])) else x, axis = 1)\ndf[['A','C']].apply(lambda x: my_func(x) if(pd.notnull(x[1])) else x, axis = 1)\ndf[['A','C']].apply(lambda x: my_func(x) if(str(x[1]) != 'nan') else x, axis = 1)\n```"
    },
    {
        "role": "assistant",
        "content": "The issue you're encountering arises because `pd.notnull()` struggles with list-like objects in its default form. When dealing with columns containing list objects, `pd.notnull()` checks each element's individual truth value, which is why it raises a `ValueError`. Here's how you can address this problem:\n\n1. **Use `pd.notna()`:** This function works similarly to `pd.notnull()` but is a more modern approach and often more robust. However, it may still not handle list objects directly.\n\n2. **Custom Check for NULL Values:** Since lists and other complex objects can cause these issues, you need to implement a custom check for NULL values, considering the nature of the data you're dealing with.\n\nHere's an approach using a custom lambda function to check if a column contains NULL values, accounting for lists:\n\n```python\nimport pandas as pd\nimport numpy as np\n\ndf = pd.DataFrame({\n    'A': [np.nan, 'two', 'three'],\n    'B': [11, np.nan, 33],\n    'C': [np.nan, ['foo', 'bar'], np.nan]\n})\n\ndef my_func(row):\n    print(row)\n\n# Custom function to check for NOT NULL, considering lists\ndef is_not_null(val):\n    if isinstance(val, list):\n        # Check if the list is empty or contains NaN\n        return len(val) > 0 and not any(v is np.nan for v in val)\n    else:\n        return pd.notna(val)\n\ndf[['A', 'C']].apply(lambda x: my_func(x) if is_not_null(x[1]) else x, axis=1)\n```\n\n### Explanation:\n\n- **Custom `is_not_null` Function:** This function checks whether a value is a list and ensures it isn't empty or filled with `np.nan` values. For non-list values, it uses `pd.notna()` for checking NULL values.\n\n- **`apply` Method:** You apply this custom check within the lambda function, ensuring that rows are processed correctly according to the condition specified.\n\nUsing this approach should help you avoid the `ValueError` and correctly process rows with list objects in your DataFrame."
    }
]