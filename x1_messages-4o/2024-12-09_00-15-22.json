[
    {
        "role": "user",
        "content": "How can I look ahead one element (peek) in a Python generator? I'm having difficulty because as soon as I look at the next element, it disappears. For instance, when I run this code:\n```python\ngen = iter([1,2,3])\nnext_value = gen.next()  # okay, I looked forward and see that next_value = 1\n# but now:\nlist(gen)  # is [2, 3]  -- the first value is gone!\n```\nI see that the first value is gone when I convert the generator to a list. Similarly, in a more realistic scenario like this:\n```python\ngen = element_generator()\nif gen.next_value() == 'STOP':\n  quit_application()\nelse:\n  process(gen.next())\n```\nCan you help me create a generator that allows me to look at the next element without losing it?"
    },
    {
        "role": "assistant",
        "content": "To peek at the next element in a Python generator without actually consuming it, you can create a wrapper class around the generator. This wrapper will allow you to look ahead or \"peek\" at the next element without advancing the generator. Here's how you can achieve this:\n\n```python\nclass PeekableGenerator:\n    def __init__(self, generator):\n        self.generator = generator\n        self._cache = None\n        self._has_cache = False\n\n    def _fill_cache(self):\n        if not self._has_cache:\n            try:\n                self._cache = next(self.generator)\n                self._has_cache = True\n            except StopIteration:\n                self._cache = None\n                self._has_cache = False\n\n    def peek(self):\n        self._fill_cache()\n        return self._cache\n\n    def next(self):\n        self._fill_cache()\n        if self._has_cache:\n            result = self._cache\n            self._cache = None\n            self._has_cache = False\n            return result\n        else:\n            raise StopIteration\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        return self.next()\n\n# Example usage:\ndef element_generator():\n    yield 1\n    yield 2\n    yield 3\n\ngen = PeekableGenerator(element_generator())\nprint(gen.peek())  # Output: 1, peek at the first element\nprint(list(gen))   # Output: [1, 2, 3], all elements are still there\n```\n\n### Explanation:\n- **PeekableGenerator Class**: This class wraps a generator and provides `peek` and `next` methods.\n- **Cache Mechanism**: The `_cache` attribute temporarily stores the next element when you peek, and `_has_cache` indicates whether the cache is filled.\n- **`peek` Method**: It fills the cache without consuming the element from the generator.\n- **`next` Method**: It returns the cached element and clears the cache, effectively consuming the element.\n- **`__iter__` and `__next__` Methods**: These allow the `PeekableGenerator` to be used in a loop just like a normal generator.\n\nThis implementation lets you peek at the next element without consuming it, allowing you to decide whether to process or skip elements based on your logic."
    }
]