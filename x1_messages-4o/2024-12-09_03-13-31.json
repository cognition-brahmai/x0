[
    {
        "role": "user",
        "content": "I am trying to write a weighted version of the random.choice function in Python, where each element in the list has a different probability of being selected. I have written the following piece of code. However, I feel that this function is overly complex and not aesthetically pleasing. Can anyone suggest improvements or alternate methods to achieve this? Code cleanliness and readability are more important to me than efficiency. Here is the code I have:\n\n```python\ndef weightedChoice(choices):\n    \"\"\"Like random.choice, but each element can have a different chance of\n    being selected.\n\n    choices can be any iterable containing iterables with two items each.\n    Technically, they can have more than two items, the rest will just be\n    ignored.  The first item is the thing being chosen, the second item is\n    its weight.  The weights can be any numeric values, what matters is the\n    relative differences between them.\n    \"\"\"\n    space = {}\n    current = 0\n    for choice, weight in choices:\n        if weight > 0:\n            space[current] = choice\n            current += weight\n    rand = random.uniform(0, current)\n    for key in sorted(space.keys() + [current]):\n        if rand < key:\n            return choice\n        choice = space[key]\n    return None\n```"
    },
    {
        "role": "assistant",
        "content": "Your implementation of a weighted choice function can indeed be simplified and made more readable. The primary task is to maintain a cumulative sum of weights and use it to select an element based on a random value. Here's a clearer version of your function:\n\n```python\nimport random\n\ndef weighted_choice(choices):\n    \"\"\"Select an element from choices with different probabilities.\n\n    Args:\n        choices (iterable): An iterable of tuples where each tuple contains\n                            an element and its weight.\n\n    Returns:\n        The selected element based on the weighted probabilities.\n    \"\"\"\n    total_weight = sum(weight for _, weight in choices if weight > 0)\n    rand = random.uniform(0, total_weight)\n    cumulative_weight = 0\n\n    for element, weight in choices:\n        if weight > 0:\n            cumulative_weight += weight\n            if rand < cumulative_weight:\n                return element\n    return None\n```\n\n### Key Improvements:\n1. **Simplified Loop**: The loop directly calculates the cumulative weight and checks if the random number falls within the current range.\n2. **List Comprehension**: Used a list comprehension to sum the weights, improving readability.\n3. **Direct Return**: The function immediately returns the chosen element when the condition is met, eliminating the need for additional data structures.\n\n### Usage Example:\n```python\nchoices = [('apple', 10), ('banana', 20), ('cherry', 5)]\nresult = weighted_choice(choices)\nprint(result)  # This will print 'apple', 'banana', or 'cherry' based on the weights\n```\n\nThis approach is not only cleaner but also easier to understand at a glance."
    }
]