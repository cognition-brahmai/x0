[
    {
        "role": "user",
        "content": "In Python, I'm facing a problem with binding local variables to a lambda function and having it retain the correct reference when used. I have a loop that creates lambda functions and appends them to a list. When I run these functions, I expect to see the values 0 and 1 printed, but instead I see 1 printed twice. Here is the code I am using:\n\n```python\ndef pv(v) :\n  print v\n\nx = []\nfor v in range(2):\n  x.append(lambda : pv(v))\n\nfor xx in x:\n  xx()\n```\n\nI expected python lambdas to bind to the reference a local variable is pointing to, behind the scenes. However that does not seem to  be the case. I have encountered this problem in a large system where the lambda is doing modern C++'s equivalent of a bind ('boost::bind' for example) where in such case you would bind to a smart ptr or copy construct a copy for the lambda. I'm quite surprised with the behaviour since I would not expect this from a language with a garbage collector. How can I bind a local variable to a lambda function and have it retain the correct reference when used?"
    },
    {
        "role": "assistant",
        "content": "The issue you're encountering is due to how closures in Python capture variables. In Python, lambda functions (and other closures) capture variables by reference, not by value. This means that the variable `v` in your lambda function refers to the same `v` defined in the loop, which is why when the loop ends, the value of `v` is 1, and both lambda functions end up printing 1.\n\nTo capture the value of `v` at each iteration, you can use a default argument in the lambda function. This technique effectively \"locks in\" the current value of `v` for each lambda by using a default argument. Here's how you can modify your code to achieve the expected behavior:\n\n```python\ndef pv(v):\n    print(v)\n\nx = []\nfor v in range(2):\n    x.append(lambda v=v: pv(v))  # Capture the current value of v as a default argument\n\nfor xx in x:\n    xx()\n```\n\nWith this modification, each lambda function captures its own value of `v` at the time of creation, resulting in the expected output:\n\n```\n0\n1\n```\n\nThis approach leverages Python's function default argument values to capture the current state of the loop variable."
    }
]