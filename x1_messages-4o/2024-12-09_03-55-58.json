[
    {
        "role": "user",
        "content": "In Python, why does `x==y` sometimes call `y.__eq__(x)` even though the Python documentation states that `x==y` should call `x.__eq__(y)`? How can I determine when my object's `__cmp__` or `__eq__` methods are going to get called? I have noticed that `y.__eq__(x)` is called in preference to `x.__eq__(y)`, which contradicts the documentation. For example, I have the following classes:\n\n```python\nclass TestCmp(object):\n    def __cmp__(self, other):\n        print \"__cmp__ got called\"\n        return 0\n\nclass TestEq(object):\n    def __eq__(self, other):\n        print \"__eq__ got called\"\n        return True\n```\nWhen I create instances of these classes and compare them with integers, this is what happens:\n\n```python\ntc = TestCmp()\nte = TestEq()\n\n1 == tc  # __cmp__ got called\ntc == 1  # __cmp__ got called\n\n1 == te  # __eq__ got called\nte == 1  # __eq__ got called\n```\nFurther, I have subclassed the `str` class and overridden the `__cmp__` and `__eq__` methods:\n\n```python\nclass TestStrCmp(str):\n    def __new__(cls, value):\n        return str.__new__(cls, value)\n    \n    def __cmp__(self, other):\n        print \"__cmp__ got called\"\n        return 0\n\nclass TestStrEq(str):\n    def __new__(cls, value):\n        return str.__new__(cls, value)\n    \n    def __eq__(self, other):\n        print \"__eq__ got called\"\n        return True\n```\nWhen I compare instances of these classes with a string, the behavior is different:\n\n```python\ntsc = TestStrCmp(\"a\")\ntse = TestStrEq(\"a\")\n\n\"b\" == tsc  # No output\ntsc == \"b\"  # No output\n\n\"b\" == tse  # __eq__ got called\ntse == \"b\"  # __eq__ got called\n```\nBased on Mark Dickinson's answer and comment, I understand that:\n\n1. Rich comparison overrides `__cmp__`\n2. `__eq__` is its own `__rop__` to its `__op__` (and similar for `__lt__`, `__ge__`, etc)\n3. If the left object is a builtin or new-style class, and the right is a subclass of it, the right object's `__rop__` is tried before the left object's `__op__`\n\nHowever, the behavior with `TestCmp` is still unclear. `tc` is not a subclass of `int`, so I would expect `1.__cmp__(tc)` to be called, but it's not. Why is that?"
    },
    {
        "role": "assistant",
        "content": "The behavior you're observing in Python when using comparison operators like `==` is influenced by several factors, including the presence of rich comparison methods and the type hierarchy of the objects involved. Let's break down the behavior you're seeing:\n\n### Behavior Explanation\n\n1. **Rich Comparison vs. `__cmp__`:**\n   - In Python 2, the `__cmp__` method is a legacy way of handling comparisons. It is called when neither object involved in the comparison has rich comparison methods (`__eq__`, `__ne__`, `__lt__`, `__le__`, `__gt__`, `__ge__`).\n   - If a class defines any of the rich comparison methods (like `__eq__`), these take precedence over `__cmp__`.\n\n2. **The `__eq__` and `__ne__` Methods:**\n   - These methods are considered \"rich comparison\" methods. If `__eq__` is defined, it will be used over `__cmp__` when checking equality.\n   - The `__eq__` method is symmetric, meaning if `x.__eq__(y)` is not implemented or returns `NotImplemented`, Python will try `y.__eq__(x)`.\n\n3. **Subclass Behavior:**\n   - If the left-hand operand of a comparison is a built-in type or a superclass of the right-hand operand, and the right-hand operand has overridden the comparison method, Python will attempt to call the method on the right operand first. This is to allow subclasses to refine or override the behavior of comparisons.\n\n### Your Observations\n\n1. **With `TestCmp` and `TestEq`:**\n   - `TestCmp` uses `__cmp__`, and since integers do not have a custom `__eq__`, `__cmp__` is called when comparing with integers.\n   - `TestEq` overrides `__eq__`, so it gets called instead of `__cmp__` when comparing with integers.\n\n2. **With `TestStrCmp` and `TestStrEq`:**\n   - `TestStrCmp` is a subclass of `str`, and since `str` provides its own rich comparison methods, these are used first. Since your `__cmp__` is not a rich comparison method and is not invoked, you see no output.\n   - `TestStrEq` overrides `__eq__`, so its custom implementation is used when comparing with strings.\n\n### Why `1 == tc` Calls `tc.__cmp__(1)`\n\nThe rule of thumb is that if the right operand is a subclass of the left operand, Python will give the right operand the first opportunity to handle the comparison. However, `int` is a built-in type that doesn\u2019t know how to handle `TestCmp`, so `tc.__cmp__(1)` is called.\n\nThe behavior can be tricky because it depends on how Python internally optimizes comparisons and handles built-in types versus user-defined types. In Python 3, `__cmp__` is removed, and only rich comparison methods are used, which makes the behavior more consistent.\n\n### Conclusion\n\nThe behavior you're experiencing is primarily due to the interaction between Python's type system and its method resolution order within the context of operators. Understanding which methods are called when can be challenging due to the complex interplay of these factors, especially in Python 2. In Python 3, the situation is simplified with the removal of `__cmp__` and the reliance solely on rich comparison methods."
    }
]