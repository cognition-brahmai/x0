[
    {
        "role": "user",
        "content": "How can I dynamically add a property to a class in Python? I am trying to build a mock class that behaves like a database result set. For instance, if a database query returned a dictionary like `{'ab':100, 'cd':200}`, I want to be able to get the value of 'ab' by calling dummy.ab and get 100. I attempted to do this by creating a class that inherits from dict and using setattr in the constructor to add properties, but this resulted in the property being an object. I also tried replacing the setattr line with `k = property(lambda x: vs[i])` but that didn't work either. What is the correct method to create instance properties at runtime in Python?"
    },
    {
        "role": "assistant",
        "content": "To dynamically add properties to a class in Python and have them behave as attributes that can be accessed like `dummy.ab`, you can use the `__getattr__` method or the `__setattr__` method to override the default behavior of attribute access. Here's how you can implement a class that behaves like a database result set:\n\n```python\nclass MockResultSet:\n    def __init__(self, data):\n        # Store the dictionary data\n        self._data = data\n\n    def __getattr__(self, name):\n        # This method is called when trying to access an attribute that doesn't exist\n        try:\n            return self._data[name]\n        except KeyError:\n            raise AttributeError(f\"'{self.__class__.__name__}' object has no attribute '{name}'\")\n    \n    def __setattr__(self, name, value):\n        # If the name is '_data', set it normally\n        if name == \"_data\":\n            super().__setattr__(name, value)\n        else:\n            # Otherwise, add/update the attribute in the data dictionary\n            self._data[name] = value\n\n# Example usage:\ndata = {'ab': 100, 'cd': 200}\ndummy = MockResultSet(data)\n\nprint(dummy.ab)  # Output: 100\nprint(dummy.cd)  # Output: 200\n\n# You can also add new attributes dynamically\ndummy.ef = 300\nprint(dummy.ef)  # Output: 300\n```\n\n### Explanation:\n\n- **`__init__` Method**: Initialize the class with a dictionary that represents your result set. Store this dictionary in a private attribute `_data`.\n\n- **`__getattr__` Method**: This method is called only when an attribute is not found in the usual places (like the instance's `__dict__`). It checks if the requested attribute name exists in the `_data` dictionary. If it exists, it returns the corresponding value. Otherwise, it raises an `AttributeError`.\n\n- **`__setattr__` Method**: This method allows you to dynamically add attributes to the instance. If the attribute being set is `_data`, it uses the parent class's `__setattr__` to store it in the instance's `__dict__`. For other attributes, it updates the `_data` dictionary.\n\nThis approach allows you to access dictionary keys as attributes and add new attributes dynamically, simulating how you might interact with a database result set."
    }
]