[
    {
        "role": "user",
        "content": "I am working on a project where I am trying to extract text from several JPGs that contain information on capital punishment records. The images have text with horizontal underlines which is causing issues with the Optical Character Recognition (OCR) I am using. I am using pytesseract for OCR and I have noticed that the presence of underlines is making the OCR extremely poor. How can I remove these horizontal lines from the images to improve my OCR results? I have tried using OpenCV and followed some tutorials but I am not able to understand the C++ code and translate it into Python. Here's the Python code I have so far:\n\n```python\nimport cv2\n\n# Inverted grayscale\nimg = cv2.imread('rsnippet.jpg', cv2.IMREAD_GRAYSCALE)\nimg = cv2.bitwise_not(img)\n\n# Transform inverted grayscale to binary\nth = cv2.adaptiveThreshold(img, 255, cv2.ADAPTIVE_THRESH_MEAN_C,\n                            cv2.THRESH_BINARY, 15, -2)\n\n# An alternative; Not sure if `th` or `th2` is optimal here\nth2 = cv2.threshold(img, 170, 255, cv2.THRESH_BINARY)[1]\n\n# Create corresponding structure element for horizontal lines.\n# Start by cloning th/th2.\nhoriz = th.copy()\nr, c = horiz.shape\n\n# Lost after here - not understanding intuition behind sizing/partitioning\n```"
    },
    {
        "role": "assistant",
        "content": "To remove horizontal lines from images and improve OCR results, you can use morphological operations in OpenCV. The process involves detecting the horizontal lines and then removing them from the image. Here's a step-by-step approach in Python using OpenCV:\n\n1. Convert the image to grayscale.\n2. Apply adaptive thresholding to create a binary image.\n3. Use morphological operations to detect and remove the horizontal lines.\n\nBelow is the Python code that accomplishes this:\n\n```python\nimport cv2\nimport numpy as np\n\n# Read the image in grayscale\nimg = cv2.imread('rsnippet.jpg', cv2.IMREAD_GRAYSCALE)\n\n# Apply adaptive thresholding to get a binary image\nthresh = cv2.adaptiveThreshold(img, 255, cv2.ADAPTIVE_THRESH_MEAN_C,\n                               cv2.THRESH_BINARY_INV, 15, 10)\n\n# Define a horizontal kernel for detecting horizontal lines\nhorizontal_kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (25, 1))\n\n# Detect horizontal lines using morphological operations\ndetected_lines = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, horizontal_kernel, iterations=2)\n\n# Subtract the detected lines from the binary image\nimg_without_lines = cv2.subtract(thresh, detected_lines)\n\n# Invert the image back to original for OCR processing\nimg_result = cv2.bitwise_not(img_without_lines)\n\n# Display the images for debugging\ncv2.imshow(\"Detected Lines\", detected_lines)\ncv2.imshow(\"Image Without Lines\", img_result)\ncv2.waitKey(0)\ncv2.destroyAllWindows()\n\n# Now you can use pytesseract on img_result\nimport pytesseract\n\n# Use pytesseract to do OCR on the cleaned image\ntext = pytesseract.image_to_string(img_result)\nprint(text)\n```\n\n### Explanation:\n- **Adaptive Thresholding**: Converts the grayscale image to a binary image, which makes it easier to detect lines.\n- **Morphological Operations**: Use a horizontal kernel to detect horizontal lines. The size of the kernel `(25, 1)` is chosen based on the typical length of lines you want to detect. You can adjust this size depending on your images.\n- **Subtract Lines**: The detected lines are subtracted from the binary image to clean it up.\n- **Invert Image**: The cleaned image is inverted back for OCR processing.\n\n### Tips:\n- Adjust the `horizontal_kernel` size according to the line thickness and spacing in your images.\n- If the lines are not completely removed, try adjusting the parameters of the morphological operations or the thresholding method.\n- You can also experiment with different methods of thresholding if the current settings don't work perfectly for all images.\n\nThis should help you preprocess your images to improve the accuracy of OCR with pytesseract."
    }
]