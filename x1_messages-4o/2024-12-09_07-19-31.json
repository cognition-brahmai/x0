[
    {
        "role": "user",
        "content": "How can I handle KeyboardInterrupt events with Python's multiprocessing Pools? I have a script that uses a multiprocessing pool to calculate the squares of a range of numbers. When I run the script and interrupt it by pressing `^C`, the process simply hangs and I have to kill it manually. How can I modify my code such that a `^C` command causes all of the processes to exit gracefully? Here is the code I'm currently using:\n\n```python\nfrom multiprocessing import Pool\nfrom time import sleep\nfrom sys import exit\n\ndef slowly_square(i):\n    sleep(1)\n    return i*i\n\ndef go():\n    pool = Pool(8)\n    try:\n        results = pool.map(slowly_square, range(40))\n    except KeyboardInterrupt:\n        # **** THIS PART NEVER EXECUTES. ****\n        pool.terminate()\n        print \"You cancelled the program!\"\n        sys.exit(1)\n    print \"\\nFinally, here are the results: \", results\n\nif __name__ == \"__main__\":\n    go()\n```"
    },
    {
        "role": "assistant",
        "content": "Handling `KeyboardInterrupt` events in a Python script that uses a `multiprocessing.Pool` can be a bit tricky because of the way the pool manages worker processes. When you press `^C`, the `KeyboardInterrupt` exception is raised in the main process, but the worker processes may not handle it properly, which can lead to the hanging behavior you observed.\n\nTo handle `KeyboardInterrupt` gracefully, you can use the `pool.close()`, `pool.join()`, and `pool.terminate()` methods effectively. Here's how you can modify your code:\n\n```python\nfrom multiprocessing import Pool\nfrom time import sleep\nimport sys\nimport signal\n\ndef init_worker():\n    signal.signal(signal.SIGINT, signal.SIG_IGN)\n\ndef slowly_square(i):\n    sleep(1)\n    return i * i\n\ndef go():\n    pool = Pool(8, init_worker)\n    try:\n        results = pool.map_async(slowly_square, range(40))\n        results = results.get(60)  # Set a timeout to prevent indefinite blocking\n    except KeyboardInterrupt:\n        pool.terminate()\n        pool.join()\n        print(\"\\nYou cancelled the program!\")\n        sys.exit(1)\n    except Exception as e:\n        pool.terminate()\n        pool.join()\n        print(\"\\nAn error occurred: \", e)\n        sys.exit(1)\n    else:\n        pool.close()\n        pool.join()\n        print(\"\\nFinally, here are the results: \", results)\n\nif __name__ == \"__main__\":\n    go()\n```\n\n### Key Modifications:\n\n1. **Initialization with `init_worker`:** \n   - Use `init_worker` function to ignore `SIGINT` in the workers. This prevents them from capturing the `KeyboardInterrupt`.\n\n2. **Use `map_async` instead of `map`:** \n   - `map_async` is non-blocking, allowing you to set a timeout with `.get()` to prevent indefinite blocking.\n\n3. **Graceful Shutdown:**\n   - `pool.terminate()`: Immediately stops the worker processes.\n   - `pool.join()`: Waits for the worker processes to exit.\n   - `pool.close()`: Prevents any more tasks from being submitted to the pool before joining.\n\n4. **Exception Handling:**\n   - Catch generic exceptions to handle any unexpected errors and ensure the pool is properly terminated.\n\nBy using these techniques, you can ensure that your script responds to `^C` interrupts gracefully and exits cleanly."
    }
]