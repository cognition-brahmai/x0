[
    {
        "role": "user",
        "content": "How can an AI assist in locating the first occurrence of a given number in a sorted array using C++?"
    },
    {
        "role": "assistant",
        "content": "To locate the first occurrence of a given number in a sorted array using C++, you can use a modified version of the binary search algorithm. Since the array is sorted, binary search is efficient, and with a slight modification, you can ensure that you find the first occurrence of the target number. Here's how you can implement it:\n\n```cpp\n#include <iostream>\n#include <vector>\n\nint findFirstOccurrence(const std::vector<int>& arr, int target) {\n    int left = 0;\n    int right = arr.size() - 1;\n    int result = -1; // Initialize result to -1, assuming target is not found\n\n    while (left <= right) {\n        int mid = left + (right - left) / 2; // Calculate mid-point to prevent overflow\n\n        if (arr[mid] == target) {\n            result = mid;  // Update result to current mid\n            right = mid - 1; // Move left to find the first occurrence\n        } else if (arr[mid] < target) {\n            left = mid + 1; // Move right\n        } else {\n            right = mid - 1; // Move left\n        }\n    }\n\n    return result;\n}\n\nint main() {\n    std::vector<int> arr = {1, 2, 2, 3, 3, 3, 4, 5, 5};\n    int target = 3;\n\n    int index = findFirstOccurrence(arr, target);\n\n    if (index != -1) {\n        std::cout << \"First occurrence of \" << target << \" is at index \" << index << \".\" << std::endl;\n    } else {\n        std::cout << target << \" is not in the array.\" << std::endl;\n    }\n\n    return 0;\n}\n```\n\n### Explanation:\n\n1. **Initialization**: Start with two pointers, `left` and `right`, representing the bounds of the search space. Initialize `result` to `-1` to handle the case where the target is not found in the array.\n\n2. **Binary Search Loop**: Continue the loop while `left` is less than or equal to `right`.\n\n3. **Calculate Midpoint**: Compute the midpoint index to avoid overflow using `left + (right - left) / 2`.\n\n4. **Check Midpoint**:\n   - If the element at `mid` is equal to the target, update `result` with `mid` and move `right` to `mid - 1` to continue searching for an earlier occurrence.\n   - If the element at `mid` is less than the target, move `left` to `mid + 1`.\n   - If the element at `mid` is greater than the target, move `right` to `mid - 1`.\n\n5. **Return Result**: After exiting the loop, `result` will either be `-1` (if the target is not found) or the index of the first occurrence of the target.\n\nThis algorithm efficiently finds the first occurrence with a time complexity of O(log n), which is optimal for searching in a sorted array."
    }
]