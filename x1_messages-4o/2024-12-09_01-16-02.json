[
    {
        "role": "user",
        "content": "How can I programmatically set the docstring in Python? I've created a wrapper function that returns a function, and I would like to set the docstring of the returned function. I tried setting __doc__ like this:\n\n```python\ndef wrapper(a):\n    def add_something(b):\n       return a + b\n    add_something.__doc__ = 'Adds ' + str(a) + ' to `b`'\n    return add_something\n```\n\nThen I tried accessing it like this:\n\n```python\nadd_three = wrapper(3)\nadd_three.__doc__\n```\n\nThis should return 'Adds 3 to `b`, but I found out that __doc__ is read-only and I can't set it this way. How should I do it?\n\nAdditional information: I'm trying to create testcases for unittest automatically. I have a wrapper function that creates a class object that is a subclass of unittest.TestCase. When I create this class and try to set the docstring of testSomething, I get an 'AttributeError: attribute '__doc__' of 'instancemethod' objects is not writable' error.\n\n```python\nimport unittest\ndef makeTestCase(filename, my_func):\n    class ATest(unittest.TestCase):\n        def testSomething(self):\n            # Running test in here with data in filename and function my_func\n            data  = loadmat(filename)\n            result = my_func(data)\n            self.assertTrue(result > 0)\n\n    return ATest\n```\n\n```python\ndef my_func(): pass\nMyTest = makeTestCase('some_filename', my_func)\nMyTest.testSomething.__doc__ = 'This should be my docstring'\n```"
    },
    {
        "role": "assistant",
        "content": "In Python, the `__doc__` attribute is indeed writable for functions and methods, despite the error message you encountered. The issue arises because when you define methods within a class, such as `testSomething` in your `ATest` class, they are turned into instance methods which can have writable `__doc__` attributes. However, the specific error you are encountering might be due to trying to set the `__doc__` attribute on a bound method, rather than on the function itself.\n\nHere's how you can set the docstring for methods in classes programmatically:\n\n1. Define the method as a function outside of the class.\n2. Set the `__doc__` attribute of this function.\n3. Assign this function as a method of your class.\n\nHere's how you could modify your code:\n\n```python\nimport unittest\nfrom types import FunctionType\n\ndef makeTestCase(filename, my_func):\n    def test_something(self):\n        # Running test in here with data in filename and function my_func\n        data  = loadmat(filename)\n        result = my_func(data)\n        self.assertTrue(result > 0)\n\n    # Set the docstring for the function\n    test_something.__doc__ = f'Test with file {filename} using {my_func.__name__}'\n\n    # Assign this function as a method of the class\n    test_method = FunctionType(test_something.__code__, globals(), 'testSomething', \n                               test_something.__defaults__, test_something.__closure__)\n    test_method.__doc__ = test_something.__doc__\n    \n    class ATest(unittest.TestCase):\n        pass\n\n    setattr(ATest, 'testSomething', test_method)\n\n    return ATest\n\ndef my_func(data):\n    # Example function logic\n    return sum(data)\n\n# Example usage\nMyTest = makeTestCase('some_filename', my_func)\nprint(MyTest.testSomething.__doc__)\n```\n\nHere, I've used `FunctionType` to create a new function object from the code of `test_something`. This is necessary to ensure that the function and its `__doc__` attribute are correctly set before it is assigned to the class. This approach ensures you can programmatically set the docstring and assign it as a method of your test class."
    }
]