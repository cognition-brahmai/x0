[
    {
        "role": "user",
        "content": "How can I use binary COPY table FROM with psycopg2 in Python to transfer tens of millions of rows from multidimensional array files into a PostgreSQL database? Currently, my data is mostly 32-bit floating point numbers and I am trying to avoid converting from real to text to real. I am currently using psycopg2's `copy_from` to insert data, but I want to use a binary mode to preserve the floating point precision and potentially improve speed.\n\nHere's my database DDL:\n\n```sql\nCREATE TABLE num_data\n(\n  id serial PRIMARY KEY NOT NULL,\n  node integer NOT NULL,\n  ts smallint NOT NULL,\n  val1 real,\n  val2 double precision\n);\n```\n\nAnd here's my Python code:\n\n```python\n# Just one row of data\nnum_row = [23253, 342, -15.336734, 2494627.949375]\n\nimport psycopg2\n# Python3:\nfrom io import StringIO\n# Python2, use: from cStringIO import StringIO\n\nconn = psycopg2.connect(\"dbname=mydb user=postgres\")\ncurs = conn.cursor()\n\n# Convert floating point numbers to text, write to COPY input\ncpy = StringIO()\ncpy.write('\\t'.join([repr(x) for x in num_row]) + '\\n')\n\n# Insert data; database converts text back to floating point numbers\ncpy.seek(0)\ncurs.copy_from(cpy, 'num_data', columns=('node', 'ts', 'val1', 'val2'))\nconn.commit()\n```\n\nIs there an equivalent way to use binary mode to keep the floating point numbers in binary?"
    },
    {
        "role": "assistant",
        "content": "To use binary mode for the `COPY` command in PostgreSQL with `psycopg2`, you'll need to ensure that the data is in the correct binary format that PostgreSQL expects. This format requires a bit more preparation than textual data, as it involves preparing a binary representation of the data that matches PostgreSQL's binary format for each data type.\n\nHere\u2019s how you can achieve this:\n\n1. **Prepare the Binary Data**: You need to construct a binary file-like object that follows PostgreSQL's binary format for the `COPY` command. This involves writing the data in a specific binary format, including headers and data type-specific binary representations.\n\n2. **Use `copy_expert`**: `psycopg2` provides the `copy_expert` method, which allows you to execute a `COPY` command with more control, including specifying binary mode.\n\nBelow is an example of how you might write the binary data and use `copy_expert` to perform the binary copy:\n\n```python\nimport psycopg2\nimport struct\nfrom io import BytesIO\n\n# Example row of data\nnum_row = [23253, 342, -15.336734, 2494627.949375]\n\n# Establish a connection to the PostgreSQL database\nconn = psycopg2.connect(\"dbname=mydb user=postgres\")\ncurs = conn.cursor()\n\n# Prepare a binary file-like object\nbinary_data = BytesIO()\n\n# Write the PostgreSQL binary format header\nbinary_data.write(struct.pack('11sii', b'PGCOPY\\n\\xff\\r\\n\\x00', 0, 0))\n\n# Write the data row in binary format\n# 1. Number of fields\nbinary_data.write(struct.pack('!h', 4))\n\n# 2. Field 1 (node: integer)\nbinary_data.write(struct.pack('!i', 4))  # Length of the field\nbinary_data.write(struct.pack('!i', num_row[0]))\n\n# 3. Field 2 (ts: smallint)\nbinary_data.write(struct.pack('!i', 2))  # Length of the field\nbinary_data.write(struct.pack('!h', num_row[1]))\n\n# 4. Field 3 (val1: real)\nbinary_data.write(struct.pack('!i', 4))  # Length of the field\nbinary_data.write(struct.pack('!f', num_row[2]))\n\n# 5. Field 4 (val2: double precision)\nbinary_data.write(struct.pack('!i', 8))  # Length of the field\nbinary_data.write(struct.pack('!d', num_row[3]))\n\n# Write the end-of-data marker\nbinary_data.write(struct.pack('!h', -1))\n\n# Rewind the BytesIO object to the beginning\nbinary_data.seek(0)\n\n# Perform the COPY operation in binary mode\ncurs.copy_expert(\"COPY num_data (node, ts, val1, val2) FROM STDIN WITH (FORMAT binary)\", binary_data)\n\n# Commit the transaction\nconn.commit()\n\n# Close the cursor and connection\ncurs.close()\nconn.close()\n```\n\n### Key Points:\n- **Header and Footer**: The binary format includes a header (11-byte signature followed by two 32-bit integers) and an end-of-data marker.\n- **Field Lengths and Types**: Each field's length and binary representation must match the PostgreSQL expected format. For example, integers are 4 bytes, smallints are 2 bytes, reals are 4 bytes (float), and doubles are 8 bytes (double precision).\n- **Binary Format**: This is a low-level operation requiring precise data formatting, so ensure all types match exactly what PostgreSQL expects.\n\nThis binary method is efficient for large data transfers but requires careful handling of data formats."
    }
]