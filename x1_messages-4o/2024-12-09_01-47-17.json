[
    {
        "role": "user",
        "content": "I'm working with Python logging and I have a setup that includes a MongoHandler and a StreamHandler. I would like to set different levels for these two handlers. Is it possible to achieve this with my current setup or do I need a second Logger object? Here is my code:\n\n```python\nimport logging\n\nclass MongoHandler(logging.Handler):\n    def __init__(self):\n        logging.Handler.__init__(self)\n        from pymongo import Connection\n        self.db = Connection('db_server').db_name\n\n    def emit(self, record):\n        try:\n            self.db.Logging.save(record.__dict__)\n        except:\n            print 'Logging Error:  Unable to save log entry to db'\n\nmh = MongoHandler()\nsh = logging.StreamHandler()\nformatter = logging.Formatter('%(asctime)s - %(threadName)s - %(levelname)s - %(message)s')\nsh.setFormatter(formatter)\nlog = logging.getLogger('DeviceMonitor_%s' % hostname)\nlog.addHandler(mh)\nlog.addHandler(sh)\nlog.setLevel(logging.INFO)\n```"
    },
    {
        "role": "assistant",
        "content": "Yes, you can set different logging levels for each handler without needing to create a second Logger object. In Python's logging module, handlers can have their own levels set independently of the logger level. The logger's level acts as a global filter, but each handler can further filter which messages it handles based on its own level.\n\nHere's how you can set different levels for your `MongoHandler` and `StreamHandler`:\n\n```python\nimport logging\n\nclass MongoHandler(logging.Handler):\n    def __init__(self):\n        super().__init__()\n        from pymongo import MongoClient\n        self.client = MongoClient('db_server')\n        self.db = self.client.db_name\n\n    def emit(self, record):\n        try:\n            log_entry = self.format(record)\n            # Assuming the log entry should be stored in a collection called 'logs'\n            self.db.logs.insert_one({'log_entry': log_entry})\n        except Exception as e:\n            print(f'Logging Error: Unable to save log entry to db: {e}')\n\nmh = MongoHandler()\nsh = logging.StreamHandler()\n\nformatter = logging.Formatter('%(asctime)s - %(threadName)s - %(levelname)s - %(message)s')\nsh.setFormatter(formatter)\nmh.setFormatter(formatter)  # Optionally set formatter for MongoHandler if needed\n\nlog = logging.getLogger('DeviceMonitor_%s' % hostname)\nlog.addHandler(mh)\nlog.addHandler(sh)\n\n# Set different levels for the handlers\nmh.setLevel(logging.ERROR)  # For example, only log ERROR and above to MongoDB\nsh.setLevel(logging.INFO)   # Log INFO and above to the stream\n\nlog.setLevel(logging.DEBUG) # Set the logger level to the lowest threshold you want to capture\n\n```\n\n### Key Points:\n- **Handler Levels**: `mh.setLevel(logging.ERROR)` sets the level for `MongoHandler` to `ERROR`, meaning only `ERROR` and `CRITICAL` logs will be passed to it.\n- **StreamHandler Levels**: `sh.setLevel(logging.INFO)` sets the level for `StreamHandler` to `INFO`, so it will handle `INFO`, `WARNING`, `ERROR`, and `CRITICAL` logs.\n- **Logger Level**: `log.setLevel(logging.DEBUG)` is set to the lowest level you want to capture. Handlers will further filter the logs they handle based on their own levels.\n\nBy setting levels on the handlers, you ensure that each handler processes only the log records it is meant to, without needing multiple logger objects."
    }
]