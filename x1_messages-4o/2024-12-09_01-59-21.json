[
    {
        "role": "user",
        "content": "How can I adapt an iterator to behave like a file-like object in Python? I have a generator producing a list of strings and I'm looking for a Python utility or adapter that could make it look like a file. For instance, I have the following code:\n\n```python\ndef str_fn():\n    for c in 'a', 'b', 'c':\n        yield c * 3\nfor s in str_fn():\n    print s\n```\n\nThis code prints 'aaa', 'bbb', 'ccc'. I would like to use something like a magic adapter to create a stream from my `str_fn()` generator, so that I can read from it like from a file. The following is an example of what I'm trying to achieve:\n\n```python\nstream = some_magic_adaptor(str_fn())\nwhile True:\n   data = stream.read(4)\n   if not data:\n       break\n   print data\n```\n\nThis should print 'aaab', 'bbcc', 'c'. As the data may be big and needs to be streamable (each fragment is a few kilobytes, the entire stream is tens of megabytes), I do not want to eagerly evaluate the whole generator before passing it to the stream adapter."
    },
    {
        "role": "assistant",
        "content": "To adapt an iterator or generator to behave like a file-like object in Python, you can create a custom class that implements the necessary methods, such as `read()`. Here's an example of how you could implement such an adapter:\n\n```python\nclass IteratorFileAdapter:\n    def __init__(self, iterator):\n        self.iterator = iterator\n        self.buffer = ''\n\n    def read(self, size=-1):\n        while size < 0 or len(self.buffer) < size:\n            try:\n                # Append the next value from the iterator to the buffer\n                self.buffer += next(self.iterator)\n            except StopIteration:\n                # If the iterator is exhausted, break the loop\n                break\n        if size < 0:\n            # If size is negative, return everything\n            result, self.buffer = self.buffer, ''\n        else:\n            # Otherwise, return only the requested size\n            result, self.buffer = self.buffer[:size], self.buffer[size:]\n        return result\n\n# Example usage\ndef str_fn():\n    for c in 'a', 'b', 'c':\n        yield c * 3\n\nstream = IteratorFileAdapter(iter(str_fn()))\nwhile True:\n    data = stream.read(4)\n    if not data:\n        break\n    print(data)\n```\n\n### Explanation:\n\n1. **IteratorFileAdapter Class**: This class takes an iterator and simulates a file-like object with a `read()` method.\n\n2. **Buffer**: The `buffer` is used to store data temporarily when the `read()` method is called. This allows you to handle cases where the amount of data requested (`size`) does not match the size of the next item from the iterator exactly.\n\n3. **Read Method**:\n   - It appends items from the iterator to the buffer until it has enough data to fulfill the requested `size` or until the iterator is exhausted.\n   - It returns the requested size of data and maintains any leftover in the buffer for future reads.\n\n4. **Handling Exhaustion**: When the iterator is exhausted, it stops appending to the buffer and returns whatever remains.\n\nThis approach allows you to stream data from the generator efficiently without loading it all into memory at once."
    }
]