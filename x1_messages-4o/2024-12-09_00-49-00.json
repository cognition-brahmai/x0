[
    {
        "role": "user",
        "content": "How can I intercept calls to Python's \"magic\" methods in new style classes? I have a class `ShowMeList` that I want to use to wrap around a list and it works fine for non-magic methods, but the wrapper function is not being called for magic methods. Here is the code I have:\n\n```python\nclass ShowMeList(object):\n    def __init__(self, it):\n        self._data = list(it)\n\n    def __getattr__(self, name):\n        attr = object.__getattribute__(self._data, name)\n        if callable(attr):\n            def wrapper(*a, **kw):\n                print \"before the call\"\n                result = attr(*a, **kw)\n                print \"after the call\"\n                return result\n            return wrapper\n        return attr\n```\n\nAnd here is how I am using it:\n\n```python\n>>> l = ShowMeList(range(8))\n\n>>> l #call to __repr__\n<__main__.ShowMeList object at 0x9640eac>\n\n>>> l.append(9)\nbefore the call\nafter the call\n\n>>> len(l._data)\n9\n```\n\nWhen I don't inherit from `object` the wrapper function is called for magic methods as expected:\n\n```python\n>>> l = ShowMeList(range(8))\n\n>>> l #call to __repr__\nbefore the call\nafter the call\n[0, 1, 2, 3, 4, 5, 6, 7]\n\n>>> l.append(9)\nbefore the call\nafter the call\n\n>>> len(l._data)\n9\n```\n\nHow can I accomplish this intercept with new style classes?"
    },
    {
        "role": "assistant",
        "content": "In Python, new-style classes (those that inherit from `object`) have a more complex method resolution order (MRO) and attribute access mechanism, which can make it tricky to intercept magic methods directly using `__getattr__`. Magic methods are usually looked up on the class, rather than the instance, which is why your `__getattr__` method isn't being called for them.\n\nTo intercept magic methods in new-style classes, you can explicitly define these magic methods in your `ShowMeList` class and delegate them to the wrapped list, adding any additional logic you want (such as printing \"before the call\" and \"after the call\").\n\nHere's how you can modify your `ShowMeList` class to intercept some common magic methods like `__repr__`, `__getitem__`, `__setitem__`, and `__len__`:\n\n```python\nclass ShowMeList(object):\n    def __init__(self, it):\n        self._data = list(it)\n\n    def __getattr__(self, name):\n        attr = getattr(self._data, name)\n        if callable(attr):\n            def wrapper(*a, **kw):\n                print(\"before the call\")\n                result = attr(*a, **kw)\n                print(\"after the call\")\n                return result\n            return wrapper\n        return attr\n\n    # Intercept magic methods\n    def __repr__(self):\n        print(\"before the call\")\n        result = repr(self._data)\n        print(\"after the call\")\n        return result\n\n    def __getitem__(self, index):\n        print(\"before the call\")\n        result = self._data[index]\n        print(\"after the call\")\n        return result\n\n    def __setitem__(self, index, value):\n        print(\"before the call\")\n        self._data[index] = value\n        print(\"after the call\")\n\n    def __len__(self):\n        print(\"before the call\")\n        result = len(self._data)\n        print(\"after the call\")\n        return result\n\n# Usage\nl = ShowMeList(range(8))\nprint(l)  # should print before and after messages and the list\nl.append(9)  # should print before and after messages\nprint(len(l))  # should print before and after messages and the length\n```\n\nBy explicitly defining these magic methods and wrapping their behavior, you can intercept their calls and add any custom logic you want, such as logging or debugging. You can extend this pattern for any other magic methods you need to intercept."
    }
]