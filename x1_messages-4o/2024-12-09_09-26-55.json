[
    {
        "role": "user",
        "content": "How can I build a min-heap data structure using an array in Python?"
    },
    {
        "role": "assistant",
        "content": "Building a min-heap in Python using an array is a common task, and Python's `heapq` module provides a very efficient implementation of a min-heap. However, if you'd like to implement a min-heap from scratch to understand how it works, here's a simple way to do it:\n\n### Step-by-step Implementation:\n\n1. **Understanding Min-Heap**:\n   - A min-heap is a complete binary tree where the value of each node is less than or equal to the values of its children.\n   - This property makes the smallest element the root of the tree.\n\n2. **Array Representation**:\n   - For a node at index `i`, its parent is at index `(i - 1) // 2`.\n   - Its left child is at index `2 * i + 1` and its right child is at index `2 * i + 2`.\n\n3. **Operations**:\n   - **Insert**: Add the new element at the end of the array and \"bubble up\" to maintain the heap property.\n   - **Extract Min**: Remove the root element (the smallest), replace it with the last element, and \"bubble down\" to maintain the heap property.\n\nHere's a simple implementation:\n\n```python\nclass MinHeap:\n    def __init__(self):\n        self.heap = []\n\n    def insert(self, key):\n        self.heap.append(key)\n        self._bubble_up(len(self.heap) - 1)\n\n    def _bubble_up(self, index):\n        parent_index = (index - 1) // 2\n        if index > 0 and self.heap[index] < self.heap[parent_index]:\n            self.heap[index], self.heap[parent_index] = self.heap[parent_index], self.heap[index]\n            self._bubble_up(parent_index)\n\n    def extract_min(self):\n        if len(self.heap) == 0:\n            raise IndexError(\"extract_min from an empty heap\")\n        min_element = self.heap[0]\n        self.heap[0] = self.heap[-1]\n        self.heap.pop()\n        self._bubble_down(0)\n        return min_element\n\n    def _bubble_down(self, index):\n        smallest = index\n        left_child = 2 * index + 1\n        right_child = 2 * index + 2\n\n        if left_child < len(self.heap) and self.heap[left_child] < self.heap[smallest]:\n            smallest = left_child\n\n        if right_child < len(self.heap) and self.heap[right_child] < self.heap[smallest]:\n            smallest = right_child\n\n        if smallest != index:\n            self.heap[index], self.heap[smallest] = self.heap[smallest], self.heap[index]\n            self._bubble_down(smallest)\n\n    def get_min(self):\n        if len(self.heap) == 0:\n            raise IndexError(\"get_min from an empty heap\")\n        return self.heap[0]\n\n    def size(self):\n        return len(self.heap)\n\n    def is_empty(self):\n        return len(self.heap) == 0\n\n# Example usage:\nmin_heap = MinHeap()\nmin_heap.insert(3)\nmin_heap.insert(1)\nmin_heap.insert(6)\nmin_heap.insert(5)\nmin_heap.insert(2)\nmin_heap.insert(4)\n\nprint(\"Min element:\", min_heap.get_min())  # Output: Min element: 1\n\nprint(\"Extract min:\", min_heap.extract_min())  # Output: Extract min: 1\nprint(\"Min element after extraction:\", min_heap.get_min())  # Output: Min element: 2\n```\n\n### Explanation:\n- **Insert**: Add the element at the end and adjust the heap by moving the element up until the heap property is restored.\n- **Extract Min**: Swap the root with the last element, remove the last element, and adjust the heap by moving the new root down.\n\nThis implementation efficiently manages the min-heap properties using an array, and provides a clear understanding of how heap operations work."
    }
]