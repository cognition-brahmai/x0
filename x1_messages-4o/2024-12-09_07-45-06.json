[
    {
        "role": "user",
        "content": "I am defining a decorator using a class in Python and need to automatically transfer the `__name__`, `__module__`, and `__doc__` attributes. Usually, I would use the @wraps decorator from functools. However, I'm not sure how to do this with a class. Is there a standard decorator that can automate the creation of these attributes? Also, how can I automate the get method for creating bound methods? Are there any methods I might be missing? Here's the code I have:\n\n```python\nclass memoized:\n    \"\"\"Decorator that caches a function's return value each time it is called.\n    If called later with the same arguments, the cached value is returned, and\n    not re-evaluated.\n    \"\"\"\n    def __init__(self, func):\n        super().__init__()\n        self.func = func\n        self.cache = {}\n\n    def __call__(self, *args):\n        try:\n            return self.cache[args]\n        except KeyError:\n            value = self.func(*args)\n            self.cache[args] = value\n            return value\n        except TypeError:\n            # uncacheable -- for instance, passing a list as an argument.\n            # Better to not cache than to blow up entirely.\n            return self.func(*args)\n\n    def __repr__(self):\n        return self.func.__repr__()\n\n    def __get__(self, obj, objtype):\n        return functools.partial(self.__call__, obj)\n\n    __doc__ = property(lambda self:self.func.__doc__)\n    __module__ = property(lambda self:self.func.__module__)\n    __name__ = property(lambda self:self.func.__name__)\n```"
    },
    {
        "role": "assistant",
        "content": "To automatically transfer the `__name__`, `__module__`, and `__doc__` attributes when using a class-based decorator, you can use the `functools.update_wrapper` function. This function is typically used in conjunction with a function-based decorator, but it can also be used in a class-based decorator by calling it inside the `__init__` method. Here's how you can modify your `memoized` class to achieve this:\n\n```python\nimport functools\n\nclass memoized:\n    \"\"\"Decorator that caches a function's return value each time it is called.\n    If called later with the same arguments, the cached value is returned, and\n    not re-evaluated.\n    \"\"\"\n    def __init__(self, func):\n        super().__init__()\n        self.func = func\n        self.cache = {}\n        functools.update_wrapper(self, func)\n\n    def __call__(self, *args):\n        try:\n            return self.cache[args]\n        except KeyError:\n            value = self.func(*args)\n            self.cache[args] = value\n            return value\n        except TypeError:\n            # uncacheable -- for instance, passing a list as an argument.\n            # Better to not cache than to blow up entirely.\n            return self.func(*args)\n\n    def __repr__(self):\n        return repr(self.func)\n\n    def __get__(self, obj, objtype=None):\n        # Create a bound method\n        return functools.partial(self.__call__, obj)\n\n# Example usage\n@memoized\ndef fibonacci(n):\n    \"\"\"Return the nth Fibonacci number.\"\"\"\n    if n in (0, 1):\n        return n\n    return fibonacci(n - 1) + fibonacci(n - 2)\n```\n\n### Key Points:\n\n1. **`functools.update_wrapper`:** This function is responsible for copying the `__name__`, `__module__`, and `__doc__` attributes (among others) from the original function to the instance of the class. By calling `functools.update_wrapper(self, func)`, the decorator class instance will have these attributes transferred from the decorated function.\n\n2. **Bound Methods:** The `__get__` method is used to bind the function to an instance if the decorator is applied to a method of a class. This method uses `functools.partial` to return a callable that behaves like a bound method.\n\n3. **`__repr__`:** This method provides a string representation of the function, ensuring that the decorated function's `repr` is used.\n\nBy applying these changes, your class-based decorator will maintain the `__name__`, `__module__`, and `__doc__` attributes as expected, similar to using the `@wraps` decorator in a function-based decorator."
    }
]