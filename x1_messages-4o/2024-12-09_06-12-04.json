[
    {
        "role": "user",
        "content": "Is there a method in Django to ensure the `post_save` signal does not trigger the same handler twice, without having to override the `save()` function? I am currently developing an application for order fulfillment data that is completely separate from our Order model, and I want to keep all fulfillment related code isolated from our Order model. The rest of the framework is unaware of the fulfillment application and using post_save hooks. If we decide to drop the fulfillment service, I want to be able to delete the fulfillment app without changing anything about our core code."
    },
    {
        "role": "assistant",
        "content": "In Django, signals like `post_save` can sometimes lead to multiple triggers of the same handler, especially in scenarios involving complex model interactions or when the signal is inadvertently connected multiple times. To ensure that the `post_save` signal does not trigger the same handler twice without having to override the `save()` method, you can take the following approaches:\n\n1. **Use a Flag:** Implement a flag that checks if the handler has already been executed. This can be achieved by using a thread-local or request-local storage to keep track of whether the signal has been processed for a particular instance.\n\n2. **Disconnect Signals Temporarily:** If the duplication is due to the same signal being registered multiple times, you can disconnect the signal temporarily in your handler after the first execution. However, this approach might require careful handling to avoid missing other legitimate signal calls.\n\n3. **Ensure Unique Connection:** Make sure that the signal is connected only once. This can be done by checking if the signal handler is already connected before connecting it again. You can maintain a registry, or simply connect the signal in the application configuration's `ready()` method to ensure it only happens once when the app is loaded.\n\n4. **Use a Decorator to Control Execution:** Write a decorator that ensures the signal handler executes only once per instance. This decorator can act as a guard to prevent re-execution.\n\nHere's a simple example using a flag:\n\n```python\nfrom django.db.models.signals import post_save\nfrom django.dispatch import receiver\nfrom threading import local\n\n# Thread-local storage to maintain state\n_thread_locals = local()\n\ndef is_handler_executed(instance_id):\n    return getattr(_thread_locals, 'instance_id', None) == instance_id\n\ndef set_handler_executed(instance_id):\n    _thread_locals.instance_id = instance_id\n\n@receiver(post_save, sender=Order)\ndef my_handler(sender, instance, created, **kwargs):\n    if is_handler_executed(instance.id):\n        return\n    # Your logic here\n    # ...\n\n    # Mark as executed\n    set_handler_executed(instance.id)\n```\n\nIn this example, `_thread_locals` is used to store the state of whether the handler has been executed for a specific instance. The `is_handler_executed` function checks if the handler has already run for the current instance, and `set_handler_executed` marks it as executed.\n\nRemember that managing this at the signal level is a specific solution and should be tested thoroughly, especially in a multi-threaded environment or when using asynchronous task queues."
    }
]