[
    {
        "role": "user",
        "content": "I am working with a blueprinted Flask app where I need to send 'sidebar data' to Jinja in many routes. Currently, I am importing my 'generate_sidebar_data()' function into every blueprint and using the following code to send variables with 'render_template':\n\n```python\nvar1, var2, var3 = generate_sidebar_data()\nreturn render_template('template.html',\n                           var1=var1,\n                           var2=var2,\n                           var3=var3\n                      )\n```\nI am looking for a more efficient way to do this. Ideally, I want to use a decorator with the route that will do the same thing as the above code. Is it possible to send variables to Jinja from inside a decorator function? For instance, something like this:\n\n```python\n@blueprint.route('/')\n@include_sidebar_data\ndef frontpage():\n    return render_template('template.html')\n```"
    },
    {
        "role": "assistant",
        "content": "Yes, you can definitely achieve this by creating a custom decorator that populates the template context with the sidebar data before rendering. You can use Flask's `before_request` or a custom decorator to inject the sidebar data into your template context.\n\nHere's a basic example of how you might implement a custom decorator to include sidebar data:\n\n```python\nfrom functools import wraps\nfrom flask import g, render_template\n\ndef include_sidebar_data(f):\n    @wraps(f)\n    def decorated_function(*args, **kwargs):\n        # Generate the sidebar data\n        var1, var2, var3 = generate_sidebar_data()\n\n        # Store the data in Flask's `g` object (a global namespace for request)\n        g.sidebar_data = {'var1': var1, 'var2': var2, 'var3': var3}\n\n        # Call the original function\n        return f(*args, **kwargs)\n    return decorated_function\n\n@blueprint.route('/')\n@include_sidebar_data\ndef frontpage():\n    # Access the sidebar data from the `g` object and pass it to the template\n    return render_template('template.html', **g.sidebar_data)\n```\n\n### Explanation:\n\n1. **Decorator Function**: The `include_sidebar_data` decorator wraps around your route function. It generates the sidebar data and stores it in Flask's `g` object, which is a global namespace for the current request.\n\n2. **Accessing Data in the Route**: In your route function, you access the stored sidebar data from `g` and pass it to the template using `render_template`.\n\n3. **Using `g`**: The `g` object is a good place to store data that you want to share across functions during a request, as it is unique to each request.\n\nThis approach ensures that your sidebar data is automatically included with every request that uses the `@include_sidebar_data` decorator, reducing code duplication and keeping your codebase DRY (Don't Repeat Yourself)."
    }
]