[
    {
        "role": "user",
        "content": "How can I check a variable against a Union type at runtime in Python 3.6? I am trying to write a function decorator that uses Python 3.6 type hints to check that a dictionary of argument types matches the type hints. However, I am facing an issue when the function has a parameter using the Union type. For instance, consider the following function:\n\n```python\nfrom typing import Union\n\ndef bark(myname: str, descr: Union[int, str], mynum: int = 3) -> str:\n    return descr + myname * mynum\n```\n\nI can check a variable against the type hint of 'myname' like this:\n\n```python\nisinstance('Arnold', bark.__annotations__['myname'])\n```\n\nBut, I am unable to do the same for 'descr' like this:\n\n```python\nisinstance(3, bark.__annotations__['descr'])\n```\n\nThis is because Union cannot be used with isinstance or issubclass. I have tried to implement this check myself but I am unsuccessful so far. The 'descr' type hint is shown as `typing.Union[int, str]` in the REPL but I can't access the list of the types at runtime. Is there a proper way to access this information?"
    },
    {
        "role": "assistant",
        "content": "In Python 3.6, `Union` types from the `typing` module cannot be directly used with `isinstance` or `issubclass` checks, as you've noticed. However, you can work around this limitation by inspecting the `Union` type to extract its component types and then using `isinstance` to check against each of them.\n\nHere's a function that can help you perform this check:\n\n```python\nfrom typing import Union, get_type_hints\n\ndef is_instance_of_union(value, union_type):\n    # Extract the component types from the Union\n    try:\n        types = union_type.__args__\n    except AttributeError:\n        # It's not a Union, so just do a normal isinstance check\n        return isinstance(value, union_type)\n    \n    # Check if the value is an instance of any of the component types\n    return any(isinstance(value, t) for t in types)\n\ndef type_checked(func):\n    def wrapper(*args, **kwargs):\n        # Get type hints from the function\n        hints = get_type_hints(func)\n        \n        # Map arguments to their type hints\n        for name, value in zip(func.__code__.co_varnames, args):\n            if name in hints:\n                expected_type = hints[name]\n                if not is_instance_of_union(value, expected_type):\n                    raise TypeError(f\"Argument {name} must be of type {expected_type}\")\n        \n        # Check keyword arguments\n        for name, value in kwargs.items():\n            if name in hints:\n                expected_type = hints[name]\n                if not is_instance_of_union(value, expected_type):\n                    raise TypeError(f\"Argument {name} must be of type {expected_type}\")\n        \n        # Call the original function\n        return func(*args, **kwargs)\n    return wrapper\n\n# Decorate the function\n@type_checked\ndef bark(myname: str, descr: Union[int, str], mynum: int = 3) -> str:\n    return descr + myname * mynum\n\n# Example usage\ntry:\n    print(bark('Arnold', 'Hello', 3))  # This should work\n    print(bark('Arnold', 42, 3))       # This should also work\n    print(bark('Arnold', 3.14, 3))     # This should raise a TypeError\nexcept TypeError as e:\n    print(e)\n```\n\nIn this implementation, the `is_instance_of_union` function checks if a value matches any of the types specified in a `Union`. The `type_checked` decorator inspects the type hints of the function it decorates and uses `is_instance_of_union` to validate the arguments against their expected types.\n\nThis way, you can enforce type checking at runtime for functions using `Union` in their type annotations."
    }
]