[
    {
        "role": "user",
        "content": "I have two numpy arrays with different shapes, but they share the same length. I want to shuffle these arrays in such a way that the corresponding elements continue to match. I have provided some code that achieves this, however, it feels inefficient and I would prefer an in-place operation due to the large size of the arrays. Is there a more efficient way to do this that also reduces memory usage and is more elegant?"
    },
    {
        "role": "assistant",
        "content": "Certainly! When you have two numpy arrays that you want to shuffle in unison, you can achieve this efficiently by using permutation indices. This approach allows for in-place shuffling, minimizing memory usage. Here's an elegant and efficient way to do it:\n\n```python\nimport numpy as np\n\n# Example arrays\narray1 = np.array([1, 2, 3, 4, 5])\narray2 = np.array([[10, 20], [30, 40], [50, 60], [70, 80], [90, 100]])\n\n# Ensure both arrays have the same length along the first dimension\nassert array1.shape[0] == array2.shape[0]\n\n# Generate a permutation of indices\npermutation = np.random.permutation(array1.shape[0])\n\n# Apply the permutation to both arrays in-place\narray1[:] = array1[permutation]\narray2[:] = array2[permutation]\n\n# Result\nprint(\"Shuffled array1:\", array1)\nprint(\"Shuffled array2:\", array2)\n```\n\n### Key Points:\n- **Permutation Indices**: We generate a permutation of indices using `np.random.permutation`, which provides a random ordering of indices.\n- **In-place Assignment**: We use slicing `[:]` to reorder the arrays in-place, which reduces memory overhead by not creating additional copies.\n- **Consistency**: Both arrays are shuffled using the same set of permutation indices, ensuring that corresponding elements remain aligned.\n\nThis method is efficient and leverages numpy's capabilities to handle large arrays effectively."
    }
]