[
    {
        "role": "user",
        "content": "How can I run an ansible playbook using a python script? I'm trying to find the equivalent Python code for running the following ansible commands:\n\n```\nansible -i hosts dbservers -m setup\nansible-playbook -i hosts -vvvv -k site.yml\n```\n\nI've been looking at the Ansible API documentation (http://docs.ansible.com/developing_api.html) but there are limited examples there."
    },
    {
        "role": "assistant",
        "content": "Running Ansible playbooks using Python can be done using the Ansible Runner or by directly utilizing the Ansible Python API. Below, I'll provide a simple example using both methods to achieve what you want:\n\n### Method 1: Using Ansible Runner\n\nAnsible Runner is a tool and Python library that helps in interfacing with Ansible.\n\nFirst, you need to install Ansible Runner:\n\n```bash\npip install ansible-runner\n```\n\nThen you can use it in your script as follows:\n\n```python\nimport ansible_runner\n\n# Running an ad-hoc command (equivalent to ansible -i hosts dbservers -m setup)\nresult = ansible_runner.run(private_data_dir='.', playbook=None, inventory='hosts', module='setup', hosts='dbservers')\nprint(result.status)  # Should return 'successful'\nprint(result.rc)  # Return code, 0 if successful\nprint(result.stdout)  # Stdout from the command\n\n# Running a playbook (equivalent to ansible-playbook -i hosts -vvvv -k site.yml)\nresult = ansible_runner.run(private_data_dir='.', playbook='site.yml', verbosity=4, inventory='hosts', passwordless_sudo=False)\nprint(result.status)  # Should return 'successful'\nprint(result.rc)  # Return code, 0 if successful\nprint(result.stdout)  # Stdout from the command\n```\n\n### Method 2: Using Ansible's Python API\n\nThis method requires a bit more setup. Below is an example:\n\n```python\nfrom ansible.executor.task_queue_manager import TaskQueueManager\nfrom ansible.parsing.dataloader import DataLoader\nfrom ansible.inventory.manager import InventoryManager\nfrom ansible.vars.manager import VariableManager\nfrom ansible.playbook.play import Play\nfrom ansible.plugins.callback import CallbackBase\n\n# Callback to capture results\nclass ResultsCallback(CallbackBase):\n    def __init__(self):\n        super().__init__()\n        self.host_ok = {}\n        self.host_failed = {}\n        self.host_unreachable = {}\n\n    def v2_runner_on_ok(self, result):\n        host = result._host.get_name()\n        self.host_ok[host] = result\n\n    def v2_runner_on_failed(self, result, ignore_errors=False):\n        host = result._host.get_name()\n        self.host_failed[host] = result\n\n    def v2_runner_on_unreachable(self, result):\n        host = result._host.get_name()\n        self.host_unreachable[host] = result\n\n# Setup\nloader = DataLoader()\ninventory = InventoryManager(loader=loader, sources='hosts')\nvariable_manager = VariableManager(loader=loader, inventory=inventory)\noptions = {'verbosity': 4, 'ask_pass': True}\n\n# Callback\ncallback = ResultsCallback()\n\n# Running the adhoc command\nplay_source = dict(\n    name=\"Ansible Ad-Hoc\",\n    hosts='dbservers',\n    gather_facts='no',\n    tasks=[\n        dict(action=dict(module='setup', args='')),\n    ]\n)\nplay = Play().load(play_source, variable_manager=variable_manager, loader=loader)\ntqm = None\n\ntry:\n    tqm = TaskQueueManager(\n        inventory=inventory,\n        variable_manager=variable_manager,\n        loader=loader,\n        options=options,\n        passwords=None,\n        stdout_callback=callback,\n    )\n    result = tqm.run(play)\nfinally:\n    if tqm is not None:\n        tqm.cleanup()\n\n# Running a playbook (requires more setup, consider using ansible-runner for simplicity)\n# This is a simplified example and might need additional setup to handle passwords, etc.\n\n# Note: Direct API usage can be complex and may require additional configuration for real-world scenarios.\n```\n\n### Summary\n\n- **Ansible Runner** is simpler and preferred for most cases as it abstracts a lot of the complexity.\n- **Direct Ansible API** usage provides more control but is more complex and requires handling various Ansible internals.\n\nFor any real-world application, ensure you handle exceptions and any security concerns, such as password management, appropriately."
    }
]