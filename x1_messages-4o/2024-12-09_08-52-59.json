[
    {
        "role": "user",
        "content": "How can I create a C++ class that implements a queue data structure?"
    },
    {
        "role": "assistant",
        "content": "Creating a C++ class to implement a queue data structure involves defining the class with member variables to store queue elements and member functions to perform queue operations like enqueue, dequeue, and checking if the queue is empty or full. Below is a simple implementation using an array to store the elements of the queue:\n\n```cpp\n#include <iostream>\nusing namespace std;\n\nclass Queue {\nprivate:\n    int front;\n    int rear;\n    int size;\n    int* queue;\n\npublic:\n    // Constructor to initialize the queue\n    Queue(int s) {\n        front = -1;\n        rear = -1;\n        size = s;\n        queue = new int[size];\n    }\n\n    // Destructor to free up the allocated memory\n    ~Queue() {\n        delete[] queue;\n    }\n\n    // Function to add element to the queue\n    void enqueue(int element) {\n        if ((rear + 1) % size == front) {\n            cout << \"Queue is full!\" << endl;\n        } else {\n            if (front == -1) {\n                front = 0;\n            }\n            rear = (rear + 1) % size;\n            queue[rear] = element;\n            cout << element << \" enqueued to the queue.\" << endl;\n        }\n    }\n\n    // Function to remove element from the queue\n    int dequeue() {\n        if (front == -1) {\n            cout << \"Queue is empty!\" << endl;\n            return -1;\n        } else {\n            int element = queue[front];\n            if (front == rear) {\n                front = rear = -1;\n            } else {\n                front = (front + 1) % size;\n            }\n            cout << element << \" dequeued from the queue.\" << endl;\n            return element;\n        }\n    }\n\n    // Function to check if the queue is empty\n    bool isEmpty() {\n        return front == -1;\n    }\n\n    // Function to check if the queue is full\n    bool isFull() {\n        return (rear + 1) % size == front;\n    }\n\n    // Function to get the front element of the queue\n    int peek() {\n        if (isEmpty()) {\n            cout << \"Queue is empty!\" << endl;\n            return -1;\n        }\n        return queue[front];\n    }\n};\n\nint main() {\n    Queue q(5);\n\n    q.enqueue(10);\n    q.enqueue(20);\n    q.enqueue(30);\n    q.enqueue(40);\n    \n    cout << q.dequeue() << \" dequeued from queue.\" << endl;\n    cout << \"Front element is: \" << q.peek() << endl;\n\n    q.enqueue(50);\n    q.enqueue(60);\n\n    while (!q.isEmpty()) {\n        cout << q.dequeue() << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}\n```\n\n### Explanation:\n\n- **Private Members**:\n  - `int front, rear`: Indices to keep track of the front and rear of the queue.\n  - `int size`: Maximum capacity of the queue.\n  - `int* queue`: Dynamic array to store the elements of the queue.\n\n- **Public Member Functions**:\n  - `Queue(int s)`: Constructor to initialize the queue with a given size.\n  - `~Queue()`: Destructor to deallocate the memory used by the queue.\n  - `void enqueue(int element)`: Adds an element to the rear of the queue.\n  - `int dequeue()`: Removes an element from the front of the queue.\n  - `bool isEmpty()`: Checks if the queue is empty.\n  - `bool isFull()`: Checks if the queue is full.\n  - `int peek()`: Returns the front element without removing it.\n\nThis implementation uses a circular array to efficiently manage the space and operations of the queue."
    }
]