[
    {
        "role": "user",
        "content": "I am trying to compare an image with a list of other images and return a subset which share up to 70% similarity, just like Google image search. I have some existing code that uses OpenCV in Python, but I'm not sure how to modify it to achieve my goal. The code loads an image, converts it to grayscale, extracts SURF features, and then trains a kNN algorithm. It then iterates over a list of model images, finding similar keypoints. However, I'm not sure how to compare the original image with the list of images and get only the similar images. Is there a method to do this?"
    },
    {
        "role": "assistant",
        "content": "To achieve your goal of comparing an image with a list of other images and returning those with up to 70% similarity using OpenCV in Python, you can follow these steps. It seems you are already extracting SURF features, which is a good approach for feature-based image comparison. Below is a general outline of how you can modify your existing code to achieve the desired functionality:\n\n1. **Load and Preprocess Images**: Load your query image and the list of model images. Convert them to grayscale if they are not already.\n\n2. **Extract Features**: Use the SURF feature extractor to extract keypoints and descriptors from both the query image and each model image.\n\n3. **Match Features**: Use a feature matcher to find correspondences between the descriptors of the query image and each model image. A popular choice is the BFMatcher with a distance metric like the Euclidean distance.\n\n4. **Filter Good Matches**: Use the ratio test proposed by Lowe to filter out good matches. For example, consider matches where the distance is less than a certain ratio of the distance to the second-best match.\n\n5. **Calculate Similarity**: For each model image, calculate the similarity based on the number of good matches. Normalize this value by dividing by the number of keypoints in the query image or the model image, whichever is smaller.\n\n6. **Select Similar Images**: Define a threshold for similarity (e.g., 0.7 for 70% similarity) and select the images that meet or exceed this threshold.\n\nHere is a sample code to illustrate these steps:\n\n```python\nimport cv2\nimport numpy as np\n\ndef extract_features(image):\n    # Initialize the SURF detector\n    surf = cv2.xfeatures2d.SURF_create(hessianThreshold=400)\n    keypoints, descriptors = surf.detectAndCompute(image, None)\n    return keypoints, descriptors\n\ndef match_features(des1, des2):\n    # Use BFMatcher with default params\n    bf = cv2.BFMatcher(cv2.NORM_L2, crossCheck=False)\n    matches = bf.knnMatch(des1, des2, k=2)\n    # Apply ratio test\n    good_matches = []\n    for m, n in matches:\n        if m.distance < 0.75 * n.distance:\n            good_matches.append(m)\n    return good_matches\n\ndef calculate_similarity(image1, image2):\n    # Extract features\n    kp1, des1 = extract_features(image1)\n    kp2, des2 = extract_features(image2)\n    \n    # Match features\n    good_matches = match_features(des1, des2)\n    \n    # Calculate similarity\n    if len(kp1) == 0 or len(kp2) == 0:\n        return 0\n    similarity = len(good_matches) / min(len(kp1), len(kp2))\n    return similarity\n\ndef find_similar_images(query_image, model_images, threshold=0.7):\n    similar_images = []\n    for model_image in model_images:\n        similarity = calculate_similarity(query_image, model_image)\n        if similarity >= threshold:\n            similar_images.append(model_image)\n    return similar_images\n\n# Example usage:\nquery_image = cv2.imread('query.jpg', cv2.IMREAD_GRAYSCALE)\nmodel_images = [cv2.imread(f'model{i}.jpg', cv2.IMREAD_GRAYSCALE) for i in range(n)]\n\nsimilar_images = find_similar_images(query_image, model_images)\n\n# similar_images will contain images with at least 70% similarity\n```\n\nMake sure you have OpenCV's \"xfeatures2d\" module available, which contains the SURF implementation. If not, you may need to install the `opencv-contrib-python` package.\n\nThis code should help you identify the images that are similar to your query image based on feature matching. Adjust the `hessianThreshold` and ratio test values based on your specific dataset and requirements for optimal results."
    }
]