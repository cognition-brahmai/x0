[
    {
        "role": "user",
        "content": "I am working on a Python application that has multiple small database access functions using SQLAlchemy. My goal is to avoid having a lot of boilerplate session handling code around these functions. I have numerous functions that look something like this:\n\n```\ndef get_ticket_history(Session, ticket_id):\n    s = Session()\n    try:\n        rows = s.query(TicketHistory)\\\n                .filter(TicketHistory.ticket_fk==ticket_id)\\\n                .order_by(TicketHistory.id.desc()).all()\n        s.commit()\n        return rows\n    except:\n        s.rollback()\n        raise\n    finally:\n        s.close()\n```\n\nI'm trying to refactor these functions to reduce repetition, but I'm not sure I have the best approach yet. So far, I've come up with the following:\n\n```\ndef execute(Session, fn, *args, **kwargs):\n    s = Session()\n    try:\n        ret = fn(s, *args, **kwargs)\n        s.commit()\n        return ret\n    except:\n        s.rollback()\n        raise\n    finally:\n        s.close()\n\ndef get_ticket_history(self, ticket_id):\n    def sql_fn(s):\n        return s.query(TicketHistory)\\\n                .filter(TicketHistory.ticket_fk==ticket_id)\\\n                .order_by(TicketHistory.id.desc()).all()\n    return execute(self.sentinel_session, sql_fn)\n```\n\nIs there a better or more idiomatic way of doing this in Python? Could using a decorator be a good solution?"
    },
    {
        "role": "assistant",
        "content": "Your approach to refactor the session handling into a separate function is a solid step towards reducing boilerplate code. Using a decorator is indeed a more idiomatic and elegant solution in Python for this kind of task. It allows you to apply the session management logic to any function that requires it, without explicitly wrapping each function call.\n\nHere's how you can achieve this using a decorator:\n\n```python\nfrom functools import wraps\n\ndef session_handler(Session):\n    def decorator(fn):\n        @wraps(fn)\n        def wrapper(*args, **kwargs):\n            s = Session()\n            try:\n                ret = fn(s, *args, **kwargs)\n                s.commit()\n                return ret\n            except:\n                s.rollback()\n                raise\n            finally:\n                s.close()\n        return wrapper\n    return decorator\n\n# Usage example\n@session_handler(Session)\ndef get_ticket_history(s, ticket_id):\n    return s.query(TicketHistory)\\\n            .filter(TicketHistory.ticket_fk == ticket_id)\\\n            .order_by(TicketHistory.id.desc()).all()\n```\n\n### Explanation:\n1. **Decorator Function**: The `session_handler` function is a decorator factory, which takes a `Session` class or factory function as an argument and returns a decorator.\n\n2. **Inner Decorator (`decorator`)**: This is the actual decorator that wraps the target function (`fn`) with the session management logic.\n\n3. **Wrapper Function (`wrapper`)**: This function is what gets executed instead of the original function. It opens a session, executes the function, handles exceptions, commits or rolls back the transaction, and finally closes the session.\n\n4. **Using `@wraps`**: The `@wraps(fn)` decorator is used to preserve the metadata of the original function, such as its name and docstring.\n\nBy using this decorator, you can now easily apply the same session management logic to any function that needs it, simply by adding `@session_handler(Session)` above its definition. This approach is clean, reusable, and aligns well with Python's idiomatic practices."
    }
]