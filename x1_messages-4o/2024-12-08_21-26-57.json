[
    {
        "role": "user",
        "content": "Can you solve this Ruby puzzle? Implement a hashtable with separate chaining to handle collisions with a capacity of 10. But here's the catch, the hash function should be a mathematical equation that involves the sum of the ASCII values of the characters in the string key. Can you provide a method to insert a key-value pair into the hashtable and another method to retrieve the value associated with a given key? Oh, and there's one more thing, each bucket should be sorted in alphabetical order based on the keys. Good luck!"
    },
    {
        "role": "assistant",
        "content": "Certainly! Let's implement a hashtable in Ruby with separate chaining to handle collisions. We'll use an array of linked lists to manage collisions, and the hash function will involve the sum of the ASCII values of the characters in the string key. Additionally, we'll ensure each bucket is sorted alphabetically based on the keys.\n\nHere's a Ruby implementation:\n\n```ruby\nclass Node\n  attr_accessor :key, :value, :next\n\n  def initialize(key, value)\n    @key = key\n    @value = value\n    @next = nil\n  end\nend\n\nclass LinkedList\n  def initialize\n    @head = nil\n  end\n\n  def insert_sorted(key, value)\n    new_node = Node.new(key, value)\n    if @head.nil? || @head.key >= key\n      new_node.next = @head\n      @head = new_node\n    else\n      current = @head\n      while current.next && current.next.key < key\n        current = current.next\n      end\n      new_node.next = current.next\n      current.next = new_node\n    end\n  end\n\n  def find(key)\n    current = @head\n    while current\n      return current.value if current.key == key\n      current = current.next\n    end\n    nil\n  end\nend\n\nclass HashTable\n  def initialize\n    @capacity = 10\n    @buckets = Array.new(@capacity) { LinkedList.new }\n  end\n\n  def hash_function(key)\n    key.chars.map(&:ord).sum % @capacity\n  end\n\n  def insert(key, value)\n    index = hash_function(key)\n    @buckets[index].insert_sorted(key, value)\n  end\n\n  def retrieve(key)\n    index = hash_function(key)\n    @buckets[index].find(key)\n  end\nend\n\n# Example usage\nhashtable = HashTable.new\nhashtable.insert(\"apple\", 100)\nhashtable.insert(\"banana\", 200)\nhashtable.insert(\"grape\", 300)\n\nputs hashtable.retrieve(\"apple\")   # Output: 100\nputs hashtable.retrieve(\"banana\")  # Output: 200\nputs hashtable.retrieve(\"grape\")   # Output: 300\n```\n\n### Explanation:\n- **Node**: Represents each key-value pair in the linked list.\n- **LinkedList**: Manages the linked list operations, including inserting nodes in alphabetical order and finding a node by key.\n- **HashTable**: Manages the array of linked lists (buckets).\n  - **hash_function**: Computes the hash value based on the sum of ASCII values of the key's characters, modulo the capacity.\n  - **insert**: Inserts a key-value pair into the appropriate bucket in sorted order.\n  - **retrieve**: Retrieves the value associated with a given key.\n\nThis solution ensures that each bucket is sorted alphabetically, and collisions are handled using separate chaining."
    }
]