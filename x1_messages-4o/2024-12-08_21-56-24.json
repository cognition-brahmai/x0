[
    {
        "role": "user",
        "content": "In C#, how can one create a regular expression pattern that validates a date with a month/day/year structure and also ensures that the year falls within the range of 1900 to 2099? Could you provide a comprehensive solution that recognizes all valid dates within the specified range while excluding any invalid entries or partial matches? Additionally, can you elaborate on how to modify the provided code snippet to handle leap years, time zones, or other date-related variations? Please include examples of how these modifications would affect the pattern's functionality."
    },
    {
        "role": "assistant",
        "content": "To create a regular expression pattern in C# that validates a date with a month/day/year structure and ensures the year falls within the range of 1900 to 2099, you can use the following pattern:\n\n```csharp\nusing System;\nusing System.Text.RegularExpressions;\n\nclass Program\n{\n    static void Main()\n    {\n        string pattern = @\"^(?:(?:(?:0?[13578]|1[02])/(?:0?[1-9]|[12][0-9]|3[01]))|(?:(?:0?[469]|11)/(?:0?[1-9]|[12][0-9]|30))|(?:0?2/(?:0?[1-9]|1[0-9]|2[0-8])))\\/(19|20)\\d\\d$|^(0?2/29)/(19|20)(0[48]|[2468][048]|[13579][26])$\";\n\n        Regex regex = new Regex(pattern);\n\n        string[] testDates = {\n            \"01/31/2000\", \"02/29/2000\", \"02/29/1900\", \"04/31/2004\", \"06/30/2020\",\n            \"11/31/1999\", \"12/31/2099\", \"02/28/1900\", \"02/28/2001\", \"02/29/2004\"\n        };\n\n        foreach (string date in testDates)\n        {\n            Console.WriteLine($\"{date}: {regex.IsMatch(date)}\");\n        }\n    }\n}\n```\n\n### Explanation of the Regular Expression Pattern:\n\n1. **Month and Day Validation:**\n   - `0?[13578]|1[02]`: Matches months with 31 days (January, March, May, July, August, October, December).\n   - `0?[469]|11`: Matches months with 30 days (April, June, September, November).\n   - `0?2`: Matches February, handling both 28 and 29 days separately.\n\n2. **Day Validation within Months:**\n   - `(?:0?[1-9]|[12][0-9]|3[01])`: Valid days for months with 31 days.\n   - `(?:0?[1-9]|[12][0-9]|30)`: Valid days for months with 30 days.\n   - `(?:0?[1-9]|1[0-9]|2[0-8])`: Valid days for February except leap day.\n\n3. **Leap Year Check:**\n   - `0?2/29`: February 29th, specifically for leap years.\n   - `(19|20)(0[48]|[2468][048]|[13579][26])`: Matches leap years between 1900 and 2099.\n\n4. **Year Validation:**\n   - `(19|20)\\d\\d`: Ensures the year is between 1900 and 2099.\n\n### Leap Year Handling:\n\nThe regex separately checks for February 29th and ensures it's a valid leap year by checking the divisibility rules for leap years. Leap years are divisible by 4, but not every year divisible by 4 is a leap year (e.g., 1900 is not a leap year, but 2000 is).\n\n### Examples of Functionality:\n\n- `01/31/2000`: Valid (31 days in January).\n- `02/29/2000`: Valid (2000 is a leap year).\n- `02/29/1900`: Invalid (1900 is not a leap year).\n- `04/31/2004`: Invalid (April has 30 days).\n- `12/31/2099`: Valid (December 31st).\n\n### Time Zones and Other Variations:\n\nRegular expressions are not well-suited for handling time zones or complex date calculations like those involving different calendar systems. For these, you would typically use C#'s `DateTime` or `DateTimeOffset` classes, which provide comprehensive support for date and time manipulation, including time zones, daylight saving time, and leap seconds.\n\nIf you need to handle time zones or more advanced date scenarios, consider combining regex validation with `DateTime.TryParseExact` for parsing and validating dates within your application logic. Here's an additional example of how you might use `DateTime.TryParseExact`:\n\n```csharp\nDateTime dateValue;\nif (DateTime.TryParseExact(\"02/29/2004\", \"MM/dd/yyyy\", null, System.Globalization.DateTimeStyles.None, out dateValue))\n{\n    Console.WriteLine(\"Valid Date\");\n}\nelse\n{\n    Console.WriteLine(\"Invalid Date\");\n}\n```\n\nThis approach allows you to use C#'s built-in capabilities to handle more complex date scenarios beyond what regular expressions can achieve."
    }
]