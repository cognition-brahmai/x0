[
    {
        "role": "user",
        "content": "I have an OHLC price data set which I have parsed from CSV into a Pandas dataframe and resampled to 15 min bars. The dataframe contains 500047 entries with datetime index from '1998-05-04 04:45:00' to '2012-08-07 00:15:00'. The data columns are 'Close', 'High', 'Low', and 'Open', all of which are float64 data types. I want to add various calculated columns to this dataframe, starting with ones such as period Range (H-L) and then booleans to indicate the occurrence of price patterns that I will define, for example, a hammer candle pattern. I have defined several functions for these calculations, but I am not sure how to map these functions to the dataframe columns. Additionally, I would like to know how to reference different rows (e.g. T-1, T-2 etc.) from within the function definition for price patterns that are determined with reference to more than a single bar."
    },
    {
        "role": "assistant",
        "content": "To add calculated columns and detect patterns in your dataframe, you can utilize Pandas' powerful data manipulation capabilities. Here's a step-by-step guide to achieve this:\n\n### Adding Calculated Columns\n\n1. **Period Range (H-L):**\n   You can calculate the range (High-Low) for each row and create a new column for it.\n   ```python\n   df['Range'] = df['High'] - df['Low']\n   ```\n\n2. **Price Patterns:**\n   For detecting patterns such as a hammer candle, you can define a function and use `apply()` to map it to the dataframe.\n\n### Defining Functions and Mapping\n\n1. **Define Your Pattern Function:**\n   You can define a function to detect specific patterns. For example, here's a simple hammer pattern detection:\n   ```python\n   def is_hammer(row):\n       # Assuming a hammer pattern has a long lower shadow and a small body\n       body = abs(row['Close'] - row['Open'])\n       lower_shadow = min(row['Close'], row['Open']) - row['Low']\n       upper_shadow = row['High'] - max(row['Close'], row['Open'])\n       # Define conditions for a hammer\n       return (lower_shadow > 2 * body) and (upper_shadow < body)\n\n   # Apply this function to each row\n   df['Hammer'] = df.apply(is_hammer, axis=1)\n   ```\n\n2. **Referencing Different Rows:**\n   To reference previous rows (e.g., T-1, T-2), you can use the `shift()` function. Here's how you can reference previous rows:\n   ```python\n   def custom_pattern(row):\n       current_close = row['Close']\n       previous_close = row['Close'].shift(1)\n       two_bars_ago_close = row['Close'].shift(2)\n       # Add logic based on these references\n       return some_boolean_condition\n\n   df['CustomPattern'] = df.apply(custom_pattern, axis=1)\n   ```\n\n   Note that when using `shift()`, you should apply it directly on the column outside the function, since `shift()` cannot be used inside `apply()` directly. Modify `custom_pattern` to take the entire column as an argument if you want to apply `shift()`.\n\n3. **Using Rolling Windows:**\n   For patterns that involve multiple bars, you may find it useful to use rolling windows:\n   ```python\n   def detect_pattern(series):\n       # Access series of values\n       return some_boolean_condition_based_on_series\n\n   df['Pattern'] = df['Close'].rolling(window=3).apply(detect_pattern)\n   ```\n\n### Example of Using `shift()`\n\nFor a pattern that involves comparing the current row with previous ones, you could do something like:\n\n```python\ndef example_pattern(df):\n    # Access current and previous rows\n    current = df.iloc[-1]\n    previous = df.iloc[-2]\n    # Define your pattern logic\n    return current['Close'] > previous['Close']\n\n# Using shift to create columns for previous values\ndf['Prev_Close'] = df['Close'].shift(1)\ndf['Pattern'] = df.apply(lambda row: example_pattern(df.loc[:row.name]), axis=1)\n```\n\nWith these methods, you should be able to add calculated columns and detect price patterns in your OHLC data efficiently. Adjust the pattern logic as needed to fit your specific requirements."
    }
]