[
    {
        "role": "user",
        "content": "How can I properly override the `__setattr__` and `__getattribute__` methods in new-style classes in Python? I have a specific use case where I want to handle a few special names and I want the default behavior for anything else. For `__getattribute__`, I can trigger the default behavior by raising an `AttributeError`, but how can I achieve the same for `__setattr__`? Here is an example where I am trying to implement a class with immutable fields \"A\", \"B\", and \"C\". I'm not sure what should replace the question marks to request the default behavior for any attribute name that is not \"A\", \"B\", or \"C\". I know that with old-style classes, the answer would be `self.__dict__[name] = value`, but documentation suggests this is not the solution for new-style classes.\n\n```python\nclass ABCImmutable(SomeSuperclass):\n    def __getattribute__(self, name):\n        if name in (\"A\", \"B\", \"C\"):\n            return \"Immutable value of %s\" % name\n        else:\n            # This should trigger the default behavior for any other\n            # attribute name.\n            raise AttributeError()\n\n    def __setattr__(self, name, value):\n        if name in (\"A\", \"B\", \"C\"):\n            raise AttributeError(\"%s is an immutable attribute.\")\n        else:\n            # How do I request the default behavior?\n            ???\n```"
    },
    {
        "role": "assistant",
        "content": "To properly override the `__setattr__` and `__getattribute__` methods in a new-style class in Python, you need to ensure that you are correctly handling both special cases and default behavior. Here's how you can implement this for a class that has immutable fields \"A\", \"B\", and \"C\".\n\nFor the `__getattribute__` method, you are already on the right track by raising an `AttributeError` for attributes other than \"A\", \"B\", and \"C\". However, instead of raising an `AttributeError` to trigger the default behavior, you should call the superclass's `__getattribute__` method.\n\nFor the `__setattr__` method, you should use the `super()` function to invoke the default `__setattr__` method, which handles setting the attribute in the usual way for attributes other than \"A\", \"B\", and \"C\".\n\nHere's an implementation example:\n\n```python\nclass ABCImmutable(SomeSuperclass):\n    def __getattribute__(self, name):\n        if name in (\"A\", \"B\", \"C\"):\n            return \"Immutable value of %s\" % name\n        else:\n            # Call the superclass's __getattribute__ for default behavior\n            return super().__getattribute__(name)\n\n    def __setattr__(self, name, value):\n        if name in (\"A\", \"B\", \"C\"):\n            raise AttributeError(f\"{name} is an immutable attribute.\")\n        else:\n            # Use super() to invoke the default behavior of __setattr__\n            super().__setattr__(name, value)\n\n# Example usage\nobj = ABCImmutable()\nprint(obj.A)  # Output: Immutable value of A\n\n# Trying to set an immutable attribute\ntry:\n    obj.A = 10\nexcept AttributeError as e:\n    print(e)  # Output: A is an immutable attribute.\n\n# Setting a non-immutable attribute\nobj.D = 20\nprint(obj.D)  # Output: 20\n```\n\n### Explanation:\n\n1. **`__getattribute__`:** \n   - For \"A\", \"B\", and \"C\", you return a custom immutable value.\n   - For other attributes, you call `super().__getattribute__(name)` to let the normal attribute access mechanism handle it.\n\n2. **`__setattr__`:**\n   - For \"A\", \"B\", and \"C\", you raise an `AttributeError` to prevent modification, enforcing immutability.\n   - For other attributes, you use `super().__setattr__(name, value)` to set the attribute normally.\n\nThis approach ensures that you handle special cases explicitly while deferring to the default behavior for all other attributes."
    }
]