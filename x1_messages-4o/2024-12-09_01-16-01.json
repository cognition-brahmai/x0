[
    {
        "role": "user",
        "content": "Is there a way to launch an IPython shell or prompt when my program encounters a line of code that raises an exception? I am interested in the context and variables in the scope and subscopes where the exception was raised. Similar to what Visual Studio's debugging provides when an uncaught exception is thrown, I want to be able to view the call stack and the variables present at every level. Is it possible to do this using IPython? Additionally, using the `-pdb` option when launching IPython doesn't seem to do what I want. I have tried running a script using the command `ipython -pdb exceptionTest.py`, but it only gives me access to the global variables of the script, not the local variables of a function in the script. Is there any way to access the variables inside the function?\n\nHere is the script I am testing:\n\n```python\ndef func():\n    z = 2\n    g = 'b'\n    raise NameError(\"This error will not be caught, but IPython still\"\n                    \"won't summon pdb, and I won't be able to consult\"\n                    \"the z or g variables.\")\n\nx = 1\ny = 'a'\n\nfunc()\n```\n\nAnd here is the command I am using to execute it:\n\n```shell\nipython -pdb exceptionTest.py\n```"
    },
    {
        "role": "assistant",
        "content": "To achieve the kind of interactive debugging you're looking for with IPython, you can use the `ipdb` module, which is an IPython-enabled version of `pdb`, the Python debugger. `ipdb` allows you to set a breakpoint where an exception occurs and inspect the state of your program, including local variables within functions.\n\nHere's how you can modify your script to drop into an IPython shell upon encountering an exception:\n\n1. First, make sure you have `ipdb` installed. You can install it using pip if you haven't already:\n\n   ```shell\n   pip install ipdb\n   ```\n\n2. Modify your script to use `ipdb`'s `post_mortem` function, which will allow you to inspect the traceback when an exception is raised:\n\n   ```python\n   import ipdb\n   import sys\n\n   def func():\n       z = 2\n       g = 'b'\n       raise NameError(\"This error will not be caught, but IPython still\"\n                       \" won't summon pdb, and I won't be able to consult\"\n                       \" the z or g variables.\")\n\n   x = 1\n   y = 'a'\n\n   if __name__ == \"__main__\":\n       try:\n           func()\n       except Exception:\n           _, _, tb = sys.exc_info()\n           ipdb.post_mortem(tb)\n   ```\n\n3. Run your script as usual:\n\n   ```shell\n   python exceptionTest.py\n   ```\n\nWhen the exception is raised, `ipdb.post_mortem()` will launch an IPython shell at the point of the exception, allowing you to inspect both local and global variables. You can navigate the stack frames and inspect variables using commands like `up`, `down`, `print`, etc., just like in a regular debugging session.\n\nThis approach gives you the full interactivity of IPython combined with the debugging capabilities of `pdb`."
    }
]