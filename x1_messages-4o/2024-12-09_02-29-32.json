[
    {
        "role": "user",
        "content": "In Python, I am aware that I can convert a string to an integer using any base in the range [2,36] using the function `int(string,base)`. Now, I am trying to find an elegant inverse function for the same. This function should take an integer and a base as inputs and return a string as output. For instance, if I input `str_base(224,15)`, it should give `'ee'` as output. I have tried to come up with a solution using the following code:\n```python\ndef digit_to_char(digit):\n    if digit < 10: return chr(ord('0') + digit)\n    else: return chr(ord('a') + digit - 10)\n\ndef str_base(number,base):\n    if number < 0:\n        return '-' + str_base(-number,base)\n    else:\n        (d,m) = divmod(number,base)\n        if d:\n            return str_base(d,base) + digit_to_char(m)\n        else:\n            return digit_to_char(m)\n```\nNote that `digit_to_char()` works for bases <= 169 arbitrarily using ASCII characters after `'z'` as digits for bases above 36. Is there a Python built-in, library function, or a more elegant inverse function of `int(string,base)`?"
    },
    {
        "role": "assistant",
        "content": "Your implementation of `str_base` is quite elegant and should work well for bases up to 169 as you've defined it. However, if you're looking for something more standard or built-in, Python doesn't have a built-in function that directly serves as an inverse to `int(string, base)` for arbitrary bases. \n\nHowever, your solution is quite clean, and you can make it slightly more elegant by using Python's built-in features. If you want to keep it within the standard base range (up to 36), you can use the built-in `string` module which provides `string.digits` and `string.ascii_lowercase` to get the digit characters. Here's a refined version of your function:\n\n```python\nimport string\n\ndef digit_to_char(digit):\n    if digit < 10:\n        return string.digits[digit]\n    else:\n        return string.ascii_lowercase[digit - 10]\n\ndef str_base(number, base):\n    if number < 0:\n        return '-' + str_base(-number, base)\n    else:\n        digits = []\n        while number:\n            number, remainder = divmod(number, base)\n            digits.append(digit_to_char(remainder))\n        return ''.join(reversed(digits)) or '0'\n\n# Example usage\nprint(str_base(224, 15))  # Output: 'ee'\n```\n\n### Explanation:\n\n- **`digit_to_char` Function**: Uses `string.digits` and `string.ascii_lowercase` to map digits to characters, which is clear and straightforward.\n  \n- **`str_base` Function**: Accumulates the remainders in a list (`digits`), appends characters, and uses `reversed()` and `join()` to build the final string. This approach is iterative and avoids recursion, which can be beneficial for very large numbers due to Python's recursion limit.\n\nThis approach is efficient and keeps the logic clear. It handles edge cases, such as when the number is zero, by returning `'0'`. If you need to handle bases beyond 36 and want to stick with ASCII conventions, your original code is already well-suited for that task."
    }
]