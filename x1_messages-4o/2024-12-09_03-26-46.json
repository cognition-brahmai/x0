[
    {
        "role": "user",
        "content": "I am experiencing an issue with my Python unit test module (`test.py`) which imports functions from another module (`keyboard.py`). In my test, I am trying to apply mock patches to two functions, `get_keys()` and `wait_keys()`, from the `keyboard.py` module. However, when I run the test, I observe that the mock patches are returning values in the inverse order. When I call these functions from the interactive console at a breakpoint or inspect the values when called normally, the two mocked functions return each other's fake return values. Below is the code and console output I'm working with:\n\n`keyboard.py`:\n```python\ndef get_keys(keyList, timeStamped):\n    return event.getKeys(keyList=keyList, timeStamped=timeStamped)\n\ndef wait_keys(keyList, timeStamped):\n    return event.waitKeys(keyList=keyList, timeStamped=timeStamped)\n```\n\n`test.py`:\n```python\n@mock.patch('keyboard.wait_keys')\n@mock.patch('keyboard.get_keys')\ndef test_2(self, mock_waitKeys, mock_getKeys):\n\n    mock_waitKeys.return_value = [['wait_keys!', 0.1]]\n    mock_getKeys.return_value = [['get_keys!',0.1]]\n\n    run_blocks(trials,noise,win,expInfo, incorrect, tone1, tone2, experiment_details,allPoints,32,60)            \n```\n\nConsole output:\n```python\nget_keys()\nOut[2]: [['wait_keys!', 0.1]]\nwait_keys()\nOut[3]: [['get_keys!', 0.1]]\n```\nWhy are my mock patches appearing in the wrong order?"
    },
    {
        "role": "assistant",
        "content": "The issue you're experiencing with the mock patches returning values in inverse order is due to the order of the patch decorators in your `test.py`. When using multiple patch decorators, it's important to understand that they are applied in the reverse order of how they are written in the code. This means that the first decorator (the one closest to the function definition) corresponds to the last argument in the function signature.\n\nIn your case, the order of decorators is:\n\n```python\n@mock.patch('keyboard.wait_keys')\n@mock.patch('keyboard.get_keys')\n```\n\nThis order means that `mock.patch('keyboard.get_keys')` is applied first, and its corresponding mock object will be passed as the second argument to the test function. Meanwhile, `mock.patch('keyboard.wait_keys')` is applied second, and its mock object will be passed as the first argument. This is why you are seeing the inverse order.\n\nTo fix this, simply reverse the order of the patch decorators to match the order of the arguments in your test function:\n\n```python\n@mock.patch('keyboard.get_keys')\n@mock.patch('keyboard.wait_keys')\ndef test_2(self, mock_getKeys, mock_waitKeys):\n\n    mock_waitKeys.return_value = [['wait_keys!', 0.1]]\n    mock_getKeys.return_value = [['get_keys!', 0.1]]\n\n    run_blocks(trials, noise, win, expInfo, incorrect, tone1, tone2, experiment_details, allPoints, 32, 60)\n```\n\nNow the mock objects will correspond correctly to the functions they are intended to patch, and you should see the expected output when running your test."
    }
]