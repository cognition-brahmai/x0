[
    {
        "role": "user",
        "content": "I'm currently working on a Django project where I have a `uuid` field that is not a primary key. The generated migration is as follows:\n\n```python\nfrom __future__ import unicode_literals\n\nfrom django.db import migrations, models\nimport uuid\n\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        ....\n    ]\n\n    operations = [\n        ...\n        migrations.AddField(\n            model_name='device',\n            name='uuid',\n            field=models.UUIDField(default=uuid.uuid4, unique=True),\n        ),\n        ...\n    ]\n```\n\nHowever, when I attempt to run `python manage.py migrate`, I encounter the following error:\n\n`django.db.utils.IntegrityError: could not create unique index \"restaurants_device_uuid_key\" DETAIL:  Key (uuid)=(f3858ded-b8e0-4ac0-8436-8a61b10efc73) is duplicated.`\n\nInterestingly, this issue does not seem to occur with primary keys. I'm not certain if this is because they are created by the database and not internally by Django. How can I add a uuid field and ensure that migrations work without producing duplicate values?"
    },
    {
        "role": "assistant",
        "content": "The issue you're encountering is due to the fact that the `uuid` field is being populated with default values for existing records, and these defaults are being generated at the time of migration creation rather than at runtime, leading to potential duplicates.\n\nHere\u2019s a step-by-step approach to resolve the issue:\n\n1. **Create a Temporary Field**: Introduce a temporary nullable `UUIDField` to your model without setting it to unique initially. This allows you to add the field without violating any uniqueness constraints.\n\n2. **Generate UUIDs for Existing Records**: Use a data migration to populate this temporary UUID field with unique values. This can be done via a Python script that iterates over existing records and assigns a UUID value.\n\n3. **Alter the Field**: Once all existing records have a UUID, alter the field to be unique and non-nullable. This involves two migration steps: one for setting the field as unique and another for setting it as non-nullable.\n\n4. **Remove the Temporary Field**: If necessary, rename the field or adjust your model to reflect the change.\n\nHere's how you can implement this:\n\n### Step 1: Create the Temporary Field\n\nModify your model to add a new nullable UUID field without unique constraint:\n\n```python\nfrom django.db import models\nimport uuid\n\nclass Device(models.Model):\n    # Other fields...\n    uuid = models.UUIDField(null=True, default=None)\n```\n\nGenerate a new migration for this change:\n\n```bash\npython manage.py makemigrations\n```\n\n### Step 2: Create a Data Migration to Populate UUIDs\n\nCreate a data migration to populate the `uuid` field:\n\n```bash\npython manage.py makemigrations --empty your_app_name\n```\n\nModify the generated migration file to fill in the UUIDs:\n\n```python\nfrom django.db import migrations, models\nimport uuid\n\ndef populate_uuids(apps, schema_editor):\n    Device = apps.get_model('your_app_name', 'Device')\n    for device in Device.objects.all():\n        device.uuid = uuid.uuid4()\n        device.save()\n\nclass Migration(migrations.Migration):\n\n    dependencies = [\n        # Add the previous migration here\n    ]\n\n    operations = [\n        migrations.RunPython(populate_uuids),\n    ]\n```\n\n### Step 3: Alter the Field to be Unique and Non-Nullable\n\nUpdate your model to make the `uuid` field unique and non-nullable:\n\n```python\nclass Device(models.Model):\n    # Other fields...\n    uuid = models.UUIDField(unique=True, default=uuid.uuid4)\n```\n\nGenerate a new migration for this change:\n\n```bash\npython manage.py makemigrations\n```\n\nNow apply all these migrations:\n\n```bash\npython manage.py migrate\n```\n\nThis approach ensures that all records have a unique UUID before enforcing the uniqueness constraint, thereby avoiding the IntegrityError you encountered."
    }
]