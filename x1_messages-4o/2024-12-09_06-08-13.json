[
    {
        "role": "user",
        "content": "How can I rotate an image tensor (B, C, H, W) around its center in PyTorch in a way that supports autograd without using NumPy, Kornia, or torchvision.transforms? I am trying to create an autograd compatible version of torchvision.transforms.RandomRotation() for visualization techniques like DeepDream and want to avoid artifacts as much as possible. My current code is as follows, but I'm not sure how to create the rotation function:\n\n```python\nimport torch\nimport math\nimport random\nimport torchvision.transforms as transforms\nfrom PIL import Image\n\ndef preprocess_simple(image_name, image_size):\n    Loader = transforms.Compose([transforms.Resize(image_size), transforms.ToTensor()])\n    image = Image.open(image_name).convert('RGB')\n    return Loader(image).unsqueeze(0)\n\ndef deprocess_simple(output_tensor, output_name):\n    output_tensor.clamp_(0, 1)\n    Image2PIL = transforms.ToPILImage()\n    image = Image2PIL(output_tensor.squeeze(0))\n    image.save(output_name)\n\ndef rotate_tensor(tensor, radians):\n    ...\n    return rotated_tensor\n\nr_degrees = 5\nangle_range = list(range(-r_degrees, r_degrees))\nn = random.randint(angle_range[0], angle_range[len(angle_range)-1])\n\nang_rad = angle * math.pi / 180\n\ntest_tensor = torch.randn(1,3,512,512)\n\noutput_tensor = rotate_tensor(test_tensor, ang_rad)\n```"
    },
    {
        "role": "assistant",
        "content": "To rotate an image tensor around its center in PyTorch while maintaining autograd compatibility, you can use an affine transformation matrix. This approach avoids using external libraries like NumPy, Kornia, or torchvision.transforms, and ensures that the operation is differentiable. Here's how you can implement the `rotate_tensor` function:\n\n```python\nimport torch\nimport math\nimport random\nimport torchvision.transforms as transforms\nfrom PIL import Image\n\ndef preprocess_simple(image_name, image_size):\n    Loader = transforms.Compose([transforms.Resize(image_size), transforms.ToTensor()])\n    image = Image.open(image_name).convert('RGB')\n    return Loader(image).unsqueeze(0)\n\ndef deprocess_simple(output_tensor, output_name):\n    output_tensor.clamp_(0, 1)\n    Image2PIL = transforms.ToPILImage()\n    image = Image2PIL(output_tensor.squeeze(0))\n    image.save(output_name)\n\ndef rotate_tensor(tensor, radians):\n    # Get the batch size, channels, height, and width\n    B, C, H, W = tensor.size()\n\n    # Compute the center of the image\n    center_y, center_x = H / 2, W / 2\n\n    # Create the rotation matrix\n    cos_theta = torch.cos(radians)\n    sin_theta = torch.sin(radians)\n    \n    # Affine transformation matrix for rotation\n    rotation_matrix = torch.tensor([\n        [cos_theta, -sin_theta, (1 - cos_theta) * center_x + sin_theta * center_y],\n        [sin_theta, cos_theta, (1 - sin_theta) * center_x - cos_theta * center_y]\n    ], dtype=tensor.dtype, device=tensor.device)\n\n    # Create a grid for affine_grid\n    theta = rotation_matrix.unsqueeze(0).expand(B, -1, -1)\n    grid = torch.nn.functional.affine_grid(theta, size=tensor.size(), align_corners=False)\n\n    # Apply grid_sample to perform the rotation\n    rotated_tensor = torch.nn.functional.grid_sample(tensor, grid, mode='bilinear', padding_mode='zeros', align_corners=False)\n\n    return rotated_tensor\n\nr_degrees = 5\nangle_range = list(range(-r_degrees, r_degrees))\nangle = random.randint(angle_range[0], angle_range[len(angle_range)-1])\n\nang_rad = angle * math.pi / 180\n\ntest_tensor = torch.randn(1, 3, 512, 512)\n\noutput_tensor = rotate_tensor(test_tensor, ang_rad)\n```\n\n### Explanation:\n- **Affine Transformation Matrix**: The matrix is constructed using cosine and sine of the rotation angle to rotate around the center of the image.\n- **Affine Grid**: The `affine_grid` function creates a grid of transformed coordinates for the input image.\n- **Grid Sample**: The `grid_sample` function is used to sample the input tensor using the grid created. This function handles the interpolation and ensures the operation is differentiable, allowing backpropagation through the rotation.\n\nThis approach should provide an autograd-compatible rotation of your image tensor without introducing noticeable artifacts, especially for small rotation angles."
    }
]