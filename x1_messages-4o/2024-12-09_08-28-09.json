[
    {
        "role": "user",
        "content": "I am working with Python unit tests where I have a set of tests that share a common set of tests. In my code, I have a BaseTest class with a common test and two subclasses, SubTest1 and SubTest2, each with its own test. When I run my tests, I notice that the common test in the BaseTest class is also being run. However, I want to restructure my code so that the common test in the BaseTest class is not run. Instead, I just want the tests in the SubTest1 and SubTest2 classes to run. How can I achieve this?\n\nHere's the code I'm working with:\n\n```python\nimport unittest\n\nclass BaseTest(unittest.TestCase):\n\n    def testCommon(self):\n        print 'Calling BaseTest:testCommon'\n        value = 5\n        self.assertEquals(value, 5)\n\nclass SubTest1(BaseTest):\n\n    def testSub1(self):\n        print 'Calling SubTest1:testSub1'\n        sub = 3\n        self.assertEquals(sub, 3)\n\n\nclass SubTest2(BaseTest):\n\n    def testSub2(self):\n        print 'Calling SubTest2:testSub2'\n        sub = 4\n        self.assertEquals(sub, 4)\n\nif __name__ == '__main__':\n    unittest.main()\n```\n\nThe output of the above is:\n\n```python\nCalling BaseTest:testCommon\n.Calling BaseTest:testCommon\n.Calling SubTest1:testSub1\n.Calling BaseTest:testCommon\n.Calling SubTest2:testSub2\n.\n----------------------------------------------------------------------\nRan 5 tests in 0.000s\n\nOK\n```"
    },
    {
        "role": "assistant",
        "content": "To achieve the behavior you want, where the `testCommon` method in the `BaseTest` class is not executed directly, you can make use of the fact that unittest will not run test methods from a class that is not directly instantiated. You can achieve this by making `BaseTest` an abstract base class. Here's how you can modify your code:\n\n```python\nimport unittest\n\nclass BaseTest(unittest.TestCase):\n\n    # Mark the common test as an abstract method\n    def testCommon(self):\n        raise NotImplementedError(\"Subclasses should implement this!\")\n\nclass SubTest1(BaseTest):\n\n    def testCommon(self):\n        print('Calling SubTest1:testCommon')\n        value = 5\n        self.assertEqual(value, 5)\n\n    def testSub1(self):\n        print('Calling SubTest1:testSub1')\n        sub = 3\n        self.assertEqual(sub, 3)\n\nclass SubTest2(BaseTest):\n\n    def testCommon(self):\n        print('Calling SubTest2:testCommon')\n        value = 5\n        self.assertEqual(value, 5)\n\n    def testSub2(self):\n        print('Calling SubTest2:testSub2')\n        sub = 4\n        self.assertEqual(sub, 4)\n\nif __name__ == '__main__':\n    unittest.main()\n```\n\nIn this modified code:\n\n- I've overridden the `testCommon` method in each subclass (`SubTest1` and `SubTest2`) to ensure that it is implemented there. This way, the common logic is controlled in the subclasses.\n\n- The base class `BaseTest` now contains a `testCommon` method that raises a `NotImplementedError`, ensuring that it should not be directly instantiated or run. This acts as a placeholder reminding that subclasses should provide their own implementation of `testCommon`.\n\n- With this structure, when you run your tests, only the test methods defined in `SubTest1` and `SubTest2` will be executed. The `BaseTest` class won't be directly instantiated, and hence its `testCommon` method won't run by itself."
    }
]