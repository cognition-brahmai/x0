[
    {
        "role": "user",
        "content": "I am trying to understand Python closures. In the following code snippet, I am able to print the value of the variable 'counter' from inside the 'bar' function.\n\n```python\ndef foo():\n    counter = 1\n    def bar():\n        print(\"bar\", counter)\n    return bar\n\nbar = foo()\n\nbar()\n```\n\nHowever, when I attempt to increment the variable 'counter' from within the 'bar' function, I encounter an UnboundLocalError error.\n\n```python\nUnboundLocalError: local variable 'counter' referenced before assignment\n```\n\nHere is the code snippet with the increment statement included.\n\n```python\ndef foo():\n    counter = 1\n    def bar():\n        counter += 1\n        print(\"bar\", counter)\n    return bar\n\nbar = foo()\n\nbar()\n```\n\nIs it true that in a Python closure, you only have read access to variables in the outer function?"
    },
    {
        "role": "assistant",
        "content": "In Python, closures do indeed have access to variables from the enclosing scope. However, when you try to modify a non-local variable from within an inner function, Python treats it as a local variable by default. This is why you encounter the `UnboundLocalError`\u2014Python thinks you're trying to increment a local `counter` variable that hasn't been initialized yet within the `bar` function.\n\nTo modify a non-local variable within a nested function, you need to explicitly declare it as non-local using the `nonlocal` keyword. Here's how you can modify your code to increment `counter`:\n\n```python\ndef foo():\n    counter = 1\n    def bar():\n        nonlocal counter  # Declare counter as non-local\n        counter += 1\n        print(\"bar\", counter)\n    return bar\n\nbar = foo()\n\nbar()  # This will now print \"bar 2\"\n```\n\nBy using the `nonlocal` keyword, you're telling Python that `counter` is not a local variable within `bar`, but is instead defined in an enclosing scope, allowing you to modify it."
    }
]