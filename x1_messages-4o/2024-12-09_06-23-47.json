[
    {
        "role": "user",
        "content": "How can I run multiple coroutines concurrently with asyncio in Python, specifically using the websockets library to create a websocket server? I have a simple echo server, but I want to add a feature that sends a message to the client periodically every 60 seconds. I'm not sure how to do this because the connection_handler is constantly waiting for incoming messages, which means the server can only take action after it has received a message from the client. Is there something I'm missing or does this scenario require a different approach, possibly a framework based on events/callbacks rather than one based on coroutines like Tornado?\n\nHere's my current code:\n\n```python\nimport asyncio\nimport websockets\n\n@asyncio.coroutine\ndef connection_handler(websocket, path):\n    while True:\n        msg = yield from websocket.recv()\n        if msg is None:  # connection lost\n            break\n        yield from websocket.send(msg)\n\nstart_server = websockets.serve(connection_handler, 'localhost', 8000)\nasyncio.get_event_loop().run_until_complete(start_server)\nasyncio.get_event_loop().run_forever()\n```"
    },
    {
        "role": "assistant",
        "content": "To run multiple coroutines concurrently with `asyncio`, you can use the `asyncio.gather()` function to manage multiple tasks, or create a new task using `asyncio.create_task()` (or `asyncio.ensure_future()` in older versions). This allows you to handle both incoming messages and sending periodic messages.\n\nHere's how you can modify your code to include a coroutine that sends a message to the client every 60 seconds:\n\n```python\nimport asyncio\nimport websockets\n\nasync def connection_handler(websocket, path):\n    # Start a separate task for sending periodic messages\n    periodic_task = asyncio.create_task(send_periodic_message(websocket))\n\n    try:\n        while True:\n            msg = await websocket.recv()\n            if msg is None:  # connection lost\n                break\n            await websocket.send(msg)\n    finally:\n        # Cancel the periodic task if the connection is lost\n        periodic_task.cancel()\n\nasync def send_periodic_message(websocket):\n    while True:\n        try:\n            await asyncio.sleep(60)  # Wait for 60 seconds\n            await websocket.send(\"Periodic message\")\n        except asyncio.CancelledError:\n            # Handle task cancellation\n            break\n\nstart_server = websockets.serve(connection_handler, 'localhost', 8000)\n\nloop = asyncio.get_event_loop()\nloop.run_until_complete(start_server)\nloop.run_forever()\n```\n\n### Key Points:\n\n1. **`asyncio.create_task()`**: This is used to run `send_periodic_message()` concurrently with the `connection_handler` coroutine. It allows both tasks to run independently.\n\n2. **`try` and `finally` block**: This ensures that if the connection is lost or an error occurs, the periodic task is properly cancelled.\n\n3. **`asyncio.sleep(60)`**: This pauses the `send_periodic_message()` coroutine for 60 seconds before sending the next message. Adjust this duration as needed for your use case.\n\nThis setup allows the WebSocket server to both respond to incoming messages and send periodic messages to the client independently."
    }
]