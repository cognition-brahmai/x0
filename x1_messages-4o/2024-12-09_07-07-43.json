[
    {
        "role": "user",
        "content": "I am using asyncio in my Python code where I have a function that runs periodically and performs an operation. This function continues until a shutdown flag is set. However, when the shutdown flag is set, the function completes but the pending tasks are not executed. The error I receive is:\n\n```python\ntask: <Task pending coro=<report() running at script.py:33> wait_for=<Future pending cb=[Task._wakeup()]>>\n```\n\nHere is the relevant part of my code:\n\n```python\n@asyncio.coroutine\ndef do_something_periodically():\n    while True:\n        asyncio.async(my_expensive_operation())\n        yield from asyncio.sleep(my_interval)\n        if shutdown_flag_is_set:\n            print(\"Shutting down\")\n            break\n```\n\nHow can I correctly schedule a shutdown of this event loop, ensuring that all current jobs finish executing before exiting? To provide some context, I am developing a system monitor which reads from /proc/stat every 5 seconds, computes the CPU usage during that period, and sends the result to a server. I want the monitoring jobs to continue scheduling until I receive a SIGTERM signal. Afterwards, I want to stop scheduling new jobs, wait for all current jobs to finish, and gracefully exit the application."
    },
    {
        "role": "assistant",
        "content": "To ensure that all pending tasks complete before your asyncio event loop shuts down, you can follow these steps:\n\n1. **Handle the SIGTERM Signal**: Use the `signal` module to catch the SIGTERM signal and set a shutdown flag.\n\n2. **Use a Task List**: Keep track of your running tasks and ensure they all complete before shutting down.\n\n3. **Wait for Pending Tasks**: After setting the shutdown flag, wait for all pending tasks to finish before closing the loop.\n\nHere's an example implementation of your code with these modifications:\n\n```python\nimport asyncio\nimport signal\n\nshutdown_flag_is_set = False\npending_tasks = []\n\ndef shutdown_signal_handler():\n    global shutdown_flag_is_set\n    print(\"SIGTERM received. Preparing to shutdown...\")\n    shutdown_flag_is_set = True\n\nasync def my_expensive_operation():\n    # Simulate a long-running operation\n    await asyncio.sleep(2)\n    print(\"Completed an operation\")\n\nasync def do_something_periodically():\n    global pending_tasks\n    while not shutdown_flag_is_set:\n        task = asyncio.create_task(my_expensive_operation())\n        pending_tasks.append(task)\n        # Clean up finished tasks\n        pending_tasks = [t for t in pending_tasks if not t.done()]\n        await asyncio.sleep(5)\n    print(\"Shutting down\")\n\nasync def main():\n    # Register the signal handler\n    loop = asyncio.get_running_loop()\n    loop.add_signal_handler(signal.SIGTERM, shutdown_signal_handler)\n\n    # Start the periodic task\n    periodic_task = asyncio.create_task(do_something_periodically())\n\n    # Wait for the periodic task to complete\n    await periodic_task\n\n    # Wait for all pending tasks to finish\n    if pending_tasks:\n        print(\"Waiting for pending tasks to complete...\")\n        await asyncio.gather(*pending_tasks)\n\n    print(\"All tasks completed. Exiting.\")\n\n# Run the main function\nif __name__ == '__main__':\n    asyncio.run(main())\n```\n\n### Explanation:\n\n1. **Signal Handling**: We register a signal handler for SIGTERM using `loop.add_signal_handler()`. This sets the `shutdown_flag_is_set` flag to `True` when a SIGTERM signal is received.\n\n2. **Task Management**: We keep a list of `pending_tasks` and append each new task to this list. We periodically clean this list of completed tasks to avoid memory leaks.\n\n3. **Graceful Shutdown**: After the shutdown flag is set, we break out of the loop in `do_something_periodically` and then wait for all pending tasks to finish using `await asyncio.gather(*pending_tasks)`.\n\nThis approach ensures that your application stops scheduling new tasks upon receiving a shutdown signal but allows all already scheduled tasks to complete before exiting the application."
    }
]