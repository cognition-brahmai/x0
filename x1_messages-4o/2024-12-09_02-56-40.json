[
    {
        "role": "user",
        "content": "How can I add input fields dynamically with wtforms? I have a table of addresses that can vary in count and I want to be able to edit them all on one page. I've tried to create a form with wtforms to edit one address and then multiply it in a jinja2 `for loop` and append to the html properties `name` and `id` the `loop.index0` from the iteration. However, this approach isn't working because I can't pass the `name` parameter manually to the field function since wtforms creates the `name` html-parameter from the variable name of the initial Form. Is there a way to add a prefix or postfix to the name of a form I want to render? Or maybe my approach is completely wrong?\n\nHere is the form I have:\n\n```python\nclass AdressForm(Form):\n    name = TextField()\n```\n\nAnd this is my template approach:\n\n```python\n{% for address in addresses %}\n    {{ forms.render_field(addressform.name, id = \"name_\" ~ loop.index0, \n                          name = \"name_\" ~ loop.index0, value = address.name) }}\n{% endfor %}\n```"
    },
    {
        "role": "assistant",
        "content": "To handle dynamic forms with WTForms, especially when you want to manage multiple instances of the same form (like multiple addresses), you might want to use WTForms' built-in `FormField` and `FieldList` features. This allows you to manage a list of forms dynamically.\n\nHere's how you can adjust your approach to handle a dynamic number of address forms:\n\n1. **Define a Form for Each Address:**\n\n    You already have this part. Let's keep your `AddressForm` as it is:\n\n    ```python\n    from wtforms import Form, StringField\n\n    class AddressForm(Form):\n        name = StringField('Name')\n    ```\n\n2. **Create a Main Form that Holds Multiple Address Forms:**\n\n    Use `FieldList` and `FormField` to create a form that holds multiple instances of `AddressForm`.\n\n    ```python\n    from wtforms import Form, FieldList, FormField\n\n    class AddressListForm(Form):\n        addresses = FieldList(FormField(AddressForm), min_entries=1)\n    ```\n\n3. **Render the Form in Your Template:**\n\n    When rendering the form in your template, you can iterate over the `addresses` field and render each sub-form individually:\n\n    ```html\n    <form method=\"POST\">\n        {% for address_form in address_list_form.addresses %}\n            <div>\n                {{ address_form.name.label }} \n                {{ address_form.name(id=\"name_\" ~ loop.index0) }}\n            </div>\n        {% endfor %}\n        <button type=\"submit\">Submit</button>\n    </form>\n    ```\n\n4. **Handle Form Submission:**\n\n    When you submit the form, make sure to populate the `FieldList` with the correct number of entries based on the input data:\n\n    ```python\n    from flask import Flask, request, render_template\n\n    app = Flask(__name__)\n\n    @app.route('/addresses', methods=['GET', 'POST'])\n    def addresses():\n        address_list_form = AddressListForm()\n\n        if request.method == 'POST':\n            # Populate the FieldList with the correct number of entries\n            address_list_form = AddressListForm(request.form)\n            if address_list_form.validate():\n                # Process the form data\n                for address_form in address_list_form.addresses:\n                    print(address_form.name.data)\n                # Handle form submission logic\n        else:\n            # Initialize the form with existing address data\n            # This could be fetched from a database, for example\n            existing_addresses = [{'name': 'Address 1'}, {'name': 'Address 2'}]\n            for address in existing_addresses:\n                address_list_form.addresses.append_entry(address)\n\n        return render_template('address_template.html', address_list_form=address_list_form)\n\n    if __name__ == '__main__':\n        app.run(debug=True)\n    ```\n\nThis approach allows you to dynamically manage a list of forms using WTForms' capabilities, ensuring that each form instance is handled correctly both in the front-end and back-end. Adjust the `min_entries` in the `FieldList` as needed, and make sure to initialize the form with existing data when rendering it for the first time."
    }
]