[
    {
        "role": "user",
        "content": "You have been given a set of N numbers, and your task is to find the sum of the smallest subset of these numbers that adds up to exactly K. Each number in the set can only be used once in the subset.\nWrite a Python function that takes in two arguments: a list of N numbers and an integer K, and returns the sum of the smallest subset of the numbers that adds up to exactly K.\nExample Input:\nnums = [3, 5, 1, 8, 2]\nK = 9\nExample Output:\n6 (the subset [3, 5, 1] adds up to 9, and has the smallest sum of any subset that adds up to 9)\nNote: If there is no subset of the numbers that adds up to exactly K, return -1."
    },
    {
        "role": "assistant",
        "content": "To find the sum of the smallest subset of numbers that adds up to exactly \\( K \\), we can utilize a dynamic programming approach similar to the \"0/1 Knapsack\" problem. Here's a Python function that implements this logic:\n\n```python\ndef smallest_subset_sum(nums, K):\n    # Create a DP table where dp[i][j] will be True if there is a subset of the first i numbers that adds up to j\n    dp = [[False] * (K + 1) for _ in range(len(nums) + 1)]\n    dp[0][0] = True  # Base case: a sum of 0 can always be achieved with an empty subset\n    \n    # Fill the DP table\n    for i in range(1, len(nums) + 1):\n        for j in range(K + 1):\n            if j >= nums[i - 1]:\n                dp[i][j] = dp[i - 1][j] or dp[i - 1][j - nums[i - 1]]\n            else:\n                dp[i][j] = dp[i - 1][j]\n    \n    # If there's no subset that adds up to K, return -1\n    if not dp[len(nums)][K]:\n        return -1\n    \n    # Find the subset with the smallest sum\n    min_sum = float('inf')\n    for i in range(len(nums), 0, -1):\n        if dp[i][K]:\n            subset_sum = 0\n            subset = []\n            j = K\n            while j > 0:\n                if not dp[i - 1][j]:\n                    subset.append(nums[i - 1])\n                    subset_sum += nums[i - 1]\n                    j -= nums[i - 1]\n                i -= 1\n            \n            min_sum = min(min_sum, subset_sum)\n    \n    return min_sum\n\n# Example usage\nnums = [3, 5, 1, 8, 2]\nK = 9\nprint(smallest_subset_sum(nums, K))  # Output: 6\n```\n\n### Explanation:\n\n1. **DP Table Initialization**: We initialize a 2D list `dp` where `dp[i][j]` indicates whether there is a subset of the first `i` numbers that adds up to `j`.\n\n2. **Base Case**: We can always achieve a sum of `0` with an empty subset, so `dp[0][0] = True`.\n\n3. **Filling the DP Table**: We iterate through each number and update our DP table to reflect whether a specific sum can be achieved with the current subset of numbers.\n\n4. **Check for Feasibility**: If `dp[len(nums)][K]` is `False`, it means there's no subset that sums to `K`, and we return `-1`.\n\n5. **Find the Smallest Subset Sum**: We backtrack through our DP table to construct the subset and calculate its sum, ensuring it's the smallest possible subset sum that adds up to `K`.\n\nThis algorithm efficiently finds the desired subset sum using dynamic programming."
    }
]