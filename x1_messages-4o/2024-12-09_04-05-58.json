[
    {
        "role": "user",
        "content": "I have a model with a FileField in Django 1.5, which holds user uploaded files. For space efficiency, I want to avoid duplicates. I've managed to calculate the uploaded file's md5 checksum and store the file with a name based on its md5sum. However, I'm struggling with discarding an uploaded duplicate and using the existing file instead. I want to keep the existing file and not overwrite it. The upload handler I'm using is `django.core.files.uploadhandler.TemporaryFileUploadHandler`. Here's the code I'm using:\n\n```\ndef media_file_name(instance, filename):\n    h = instance.md5sum\n    basename, ext = os.path.splitext(filename)\n    return os.path.join('mediafiles', h[0:1], h[1:2], h + ext.lower())\n\nclass Media(models.Model):\n    orig_file = models.FileField(upload_to=media_file_name)\n    md5sum = models.CharField(max_length=36)\n    ...\n\n    def save(self, *args, **kwargs):\n            if not self.pk:  # file is new\n                md5 = hashlib.md5()\n                for chunk in self.orig_file.chunks():\n                    md5.update(chunk)\n                self.md5sum = md5.hexdigest()\n            super(Media, self).save(*args, **kwargs)\n```\n\nHow can I discard an uploaded duplicate and use the existing file instead?"
    },
    {
        "role": "assistant",
        "content": "To handle the scenario where you want to discard an uploaded duplicate file and use the existing file instead, you can modify your `save` method in the `Media` model to check if a file with the same MD5 checksum already exists before saving the new file. Here's how you can achieve this:\n\n1. Query the database for an existing file with the same MD5 checksum.\n2. If such a file exists, use the existing file instead of saving the new one.\n3. If no file with the same checksum exists, save the new file as usual.\n\nHere's the updated code:\n\n```python\nfrom django.core.exceptions import ValidationError\nimport os\nimport hashlib\n\ndef media_file_name(instance, filename):\n    h = instance.md5sum\n    basename, ext = os.path.splitext(filename)\n    return os.path.join('mediafiles', h[0:1], h[1:2], h + ext.lower())\n\nclass Media(models.Model):\n    orig_file = models.FileField(upload_to=media_file_name)\n    md5sum = models.CharField(max_length=36)\n\n    def save(self, *args, **kwargs):\n        # Calculate the MD5 checksum of the uploaded file\n        md5 = hashlib.md5()\n        for chunk in self.orig_file.chunks():\n            md5.update(chunk)\n        self.md5sum = md5.hexdigest()\n\n        # Check if a file with the same MD5 checksum already exists\n        existing_media = Media.objects.filter(md5sum=self.md5sum).first()\n\n        if existing_media:\n            # If a duplicate is found, use the existing file and raise a validation error\n            self.orig_file = existing_media.orig_file\n            self.md5sum = existing_media.md5sum\n            raise ValidationError(\"Duplicate file detected. Using the existing file instead.\")\n\n        # If no duplicate is found, proceed with saving the new file\n        super(Media, self).save(*args, **kwargs)\n```\n\n### Key Points:\n\n- **MD5 Checksum Calculation**: Before saving, the MD5 checksum of the uploaded file is calculated.\n- **Duplicate Check**: It queries the database to check if a file with the same MD5 checksum already exists.\n- **Handling Duplicates**: If a duplicate exists, it uses the existing file's details instead of saving a new file and raises a `ValidationError` to notify that a duplicate was detected.\n- **Saving New Files**: If no duplicate exists, it proceeds to save the new file as usual.\n\nThis approach ensures that your storage is used efficiently by avoiding duplicates while maintaining a consistent and predictable behavior for file uploads."
    }
]