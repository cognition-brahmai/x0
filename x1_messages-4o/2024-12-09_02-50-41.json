[
    {
        "role": "user",
        "content": "How can I conditionally call the original method when mocking in Python? In my specific scenario, I want to fake a return value if `bar=='x'`, otherwise I want to call the original method as shown in the example below:\n\n```python\ndef mocked_some_method(bar):\n    if bar=='x':\n        return 'fake'\n    return some_how_call_original_method(bar)\n\nwith mock.patch('mylib.foo.some_method', mocked_some_method):\n    do_some_stuff()\n```\n\nThe method I want to fake is `mylib.foo.some_method` which is used inside `do_some_stuff()`. This is an integration test where `mylib.foo.some_method` is a dispatcher that gets used very often. However, in one instance, I need to fake the result."
    },
    {
        "role": "assistant",
        "content": "To achieve what you're aiming for, you can utilize Python's `unittest.mock` library to patch the method and conditionally call the original method. You can capture the original method before patching it and call it within your mock function when needed. Here's how you can implement it:\n\n```python\nfrom unittest import mock\nfrom mylib.foo import some_method as original_some_method\n\ndef mocked_some_method(bar):\n    if bar == 'x':\n        return 'fake'\n    # Call the original method if the condition is not met\n    return original_some_method(bar)\n\nwith mock.patch('mylib.foo.some_method', side_effect=mocked_some_method):\n    do_some_stuff()\n```\n\n### Explanation:\n1. **Capture the Original Method**: Before patching, import and store the reference to the original method. This is done with `from mylib.foo import some_method as original_some_method`.\n\n2. **Define the Mock Function**: Create a mock function (`mocked_some_method`) that checks the condition (`bar == 'x'`). If the condition is met, return the fake value. Otherwise, call the original method using the stored reference (`original_some_method`).\n\n3. **Patch with Side Effect**: Use `mock.patch` with the `side_effect` parameter set to the `mocked_some_method`. This allows the mock function to be called with the same arguments as the original method.\n\n4. **Integration**: Inside the `with` block, any call to `mylib.foo.some_method` within `do_some_stuff()` will use your `mocked_some_method`.\n\nThis approach ensures that you can conditionally control the behavior of the method while still retaining the ability to call the original method as needed."
    }
]