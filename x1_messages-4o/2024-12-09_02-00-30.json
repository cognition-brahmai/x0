[
    {
        "role": "user",
        "content": "Is there a method to access the original function in a mocked function or method such that I can modify the arguments and pass it to the original function? I am working with a module where I want to change the arguments passed to a method instead of replacing its return value. Here's the code I have so far:\n\nmodule.py:\n\n```python\nfrom third_party import ThirdPartyClass\n\nThirdPartyClass.do_something('foo', 'bar')\nThirdPartyClass.do_something('foo', 'baz')\n```\ntests.py:\n\n```python\n@mock.patch('module.ThirdPartyClass.do_something')\ndef test(do_something):\n    # Instead of directly overriding its return value\n    # I'd like to modify the arguments passed to this function.\n\n    # change return value, no matter inputs\n    do_something.return_value = 'foo'\n\n    # change return value, based on inputs, but have no access to the original function\n    do_something.side_effect = lambda x, y: y, x\n\n    # how can I wrap do_something, so that I can modify its inputs and pass it back to the original function?\n    # much like a decorator?\n```\n\nI've tried something like this, but it doesn't work and seems repetitive:\n\n```python\ndef test():\n    from third_party import ThirdPartyClass\n    original_do_something = ThirdPartyClass.do_something\n\n    with mock.patch('module.ThirdPartyClass.do_something' as mocked_do_something:\n        def side_effect(arg1, arg2):\n            return original_do_something(arg1, 'overridden')\n\n        mocked_do_something.side_effect = side_effect\n\n        # execute module.py\n```\n\nIs there a better way to do this?"
    },
    {
        "role": "assistant",
        "content": "Certainly! You can achieve this by capturing the original function before mocking it, then using the `side_effect` to call the original function with modified arguments. Here's how you can structure your test to modify the arguments and call the original function:\n\n```python\nfrom unittest import mock\nimport module\nfrom third_party import ThirdPartyClass\n\n# Capture the original function\noriginal_do_something = ThirdPartyClass.do_something\n\n@mock.patch('module.ThirdPartyClass.do_something')\ndef test(mocked_do_something):\n    # Define a side effect function that modifies the arguments\n    def side_effect(arg1, arg2):\n        # Modify the arguments as needed\n        modified_arg1 = arg1\n        modified_arg2 = 'overridden'  # or any other modification you need\n        \n        # Call the original function with modified arguments\n        return original_do_something(modified_arg1, modified_arg2)\n\n    # Assign the side effect function to the mocked object\n    mocked_do_something.side_effect = side_effect\n\n    # Execute the code that triggers the call\n    # This should be your test logic that makes use of the module\n    module.ThirdPartyClass.do_something('foo', 'bar')\n\n# Ensure to call the test function if running as a script\nif __name__ == \"__main__\":\n    test()\n```\n\n### Explanation:\n1. **Capturing the Original Function**: Before patching, store a reference to the original `do_something` method so you can call it later with modified arguments.\n\n2. **Using `side_effect`**: Define a `side_effect` function that takes the same arguments as the method you're mocking. Modify the arguments as needed and call the original function.\n\n3. **Patching and Executing**: Use `mock.patch` to replace the `do_something` method with your mock. When the method is called during the test, it will use your `side_effect`, modify the arguments, and call the original function with these modified arguments.\n\nBy following these steps, you can modify the input arguments and pass them to the original function while testing."
    }
]