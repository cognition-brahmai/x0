[
    {
        "role": "user",
        "content": "How can I find all the pairs in an array of positive integers whose sum is divisible by 3 using C++? The input array is as follows:\nint arr[] = {3, 4, 5, 6, 7, 8, 9, 10, 11, 12};\nAnd the output should be a list of pairs represented as a vector of pairs, as follows:\n[(3, 9), (4, 8), (5, 7), (6, 12)]\nPlease implement the algorithm using the unordered_map data structure in C++."
    },
    {
        "role": "assistant",
        "content": "To solve this problem, you can use an `unordered_map` to keep track of the frequencies of the remainders when each number in the array is divided by 3. The key idea is to use the property that for two numbers to sum to a value divisible by 3, the remainders of those two numbers when divided by 3 must add up to either 0 or 3.\n\nHere's how you can implement the algorithm in C++:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <utility> // for std::pair\n\nstd::vector<std::pair<int, int>> findPairsDivisibleByThree(int arr[], int n) {\n    std::unordered_map<int, std::vector<int>> remainderMap;\n    std::vector<std::pair<int, int>> result;\n\n    // Populate the unordered_map with remainders and corresponding numbers\n    for (int i = 0; i < n; ++i) {\n        int remainder = arr[i] % 3;\n        remainderMap[remainder].push_back(arr[i]);\n    }\n\n    // For remainder 0, pairs can be formed among themselves\n    if (remainderMap.count(0) > 0) {\n        std::vector<int>& zeroRemainder = remainderMap[0];\n        for (size_t i = 0; i < zeroRemainder.size(); ++i) {\n            for (size_t j = i + 1; j < zeroRemainder.size(); ++j) {\n                result.emplace_back(zeroRemainder[i], zeroRemainder[j]);\n            }\n        }\n    }\n\n    // For remainder 1 and 2, pairs can be formed between them\n    if (remainderMap.count(1) > 0 && remainderMap.count(2) > 0) {\n        std::vector<int>& oneRemainder = remainderMap[1];\n        std::vector<int>& twoRemainder = remainderMap[2];\n        for (int num1 : oneRemainder) {\n            for (int num2 : twoRemainder) {\n                result.emplace_back(num1, num2);\n            }\n        }\n    }\n\n    return result;\n}\n\nint main() {\n    int arr[] = {3, 4, 5, 6, 7, 8, 9, 10, 11, 12};\n    int n = sizeof(arr) / sizeof(arr[0]);\n\n    std::vector<std::pair<int, int>> pairs = findPairsDivisibleByThree(arr, n);\n\n    std::cout << \"Pairs whose sum is divisible by 3: \";\n    for (const auto& p : pairs) {\n        std::cout << \"(\" << p.first << \", \" << p.second << \") \";\n    }\n\n    return 0;\n}\n```\n\n### Explanation\n- **Remainder Calculation**: For each element in the array, calculate its remainder when divided by 3, and store it in an `unordered_map`, where the key is the remainder and the value is a vector of numbers with that remainder.\n  \n- **Pair Formation**:\n  - **Remainder 0**: Pair numbers with remainder 0 with each other.\n  - **Remainder 1 and 2**: Pair numbers with remainder 1 with numbers having remainder 2, as (1 + 2) % 3 = 0.\n\n- **Complexity**: The time complexity is O(n^2) in the worst case due to the nested loops when forming pairs, but it is efficient for a reasonable number of operations given the constraints."
    }
]