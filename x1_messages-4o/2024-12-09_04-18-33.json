[
    {
        "role": "user",
        "content": "Can someone explain how the Python attribute lookup process works? Specifically, what does Python do when you write x.foo? I have encountered some behavior that I don't understand when using the __getattribute__ method with instances of type 'type' and type 'object'. For example, in the following Python code, I'm not sure why the metaclass __getattribute__ method gets called.\n\n```python\nclass Meta(type):\n    def __getattribute__(self, name):\n        print(\"Metaclass getattribute invoked:\", self)\n        return type.__getattribute__(self, name)\n\n    def __getattr__(self, item):\n        print('Metaclass getattr invoked: ', item)\n        return None\n\nclass C(object, metaclass=Meta):\n    def __getattribute__(self, name):\n        print(\"Class getattribute invoked:\", args)\n        return object.__getattribute__(self, name)\n\nc=C()\n```\n\nWhen I run the following lines:\n\n```python\nC.__new__\nC.__getattribute__\nC.xyz\nc.__new__\nc.__getattribute__\n```\nI get this output:\n```\nMetaclass getattribute invoked: <class '__main__.C'>\n<built-in method __new__ of type object at 0x1E1B80B0>\n\nMetaclass getattribute invoked: <class '__main__.C'>\n<function __getattribute__ at 0x01457F18>\n\nMetaclass getattribute invoked: <class '__main__.C'>\nMetaclass getattr invoked:  xyz\nNone\n\nClass getattribute invoked: (<__main__.C object at 0x013E7550>, '__new__')\n<built-in method __new__ of type object at 0x1E1B80B0>\n\nClass getattribute invoked: (<__main__.C object at 0x01438DB0>, '__getattribute__')\nMetaclass getattribute invoked: <class '__main__.C'>\n<bound method C.__getattribute__ of <__main__.C object at 0x01438DB0>>\n```\nI understand that __getattribute__ is different for instances of type 'type' and type 'object'. However, I don't understand why the metaclass __getattribute__ method gets called when object contains a method __getattribute__ and C inherits from object. Can someone explain this or direct me to some related documentation?"
    },
    {
        "role": "assistant",
        "content": "Certainly! To understand the behavior you're observing, let's break down how attribute lookup works in Python, specifically when dealing with metaclasses and instances.\n\n### Attribute Lookup Process\n\n1. **Instance Attribute Lookup**: When you access an attribute on an instance `x.foo`, Python first checks if the attribute is present in the instance's `__dict__`. If not found, it proceeds to the class `C` and follows the Method Resolution Order (MRO) to look for the attribute in the class and its base classes.\n\n2. **Class Attribute Lookup**: When you access an attribute on a class `C.foo`, Python checks the class's `__dict__` first. If the attribute is not found, Python then looks at the metaclass (in this case, `Meta`) and follows the MRO for the metaclass hierarchy.\n\n3. **Metaclass and `__getattribute__`**: When you define a metaclass like `Meta` with a `__getattribute__` method, it controls attribute access on the class `C` itself, not its instances. So accessing `C.__new__`, `C.__getattribute__`, and `C.xyz` invokes the metaclass's `__getattribute__`.\n\n### Explanation of Your Output\n\n- **`C.__new__` and `C.__getattribute__`**: When you access these attributes, the metaclass's `__getattribute__` is called because these are attributes of the class `C`, not an instance of `C`. The metaclass handles these lookups.\n\n- **`C.xyz`**: The attribute `xyz` doesn't exist, so after `__getattribute__` fails to find it, Python calls `__getattr__` on the metaclass, which is why you see \"Metaclass getattr invoked\".\n\n- **`c.__new__` and `c.__getattribute__`**: These are instance attribute accesses. Here, the instance's `__getattribute__` method is invoked, which falls back on `object.__getattribute__` for the lookup. When `c.__getattribute__` is accessed, it further calls the class method, which is why you see the metaclass's `__getattribute__` invoked again.\n\n### Key Points\n\n- **Metaclass `__getattribute__`**: Handles attribute access on the class itself.\n- **Instance `__getattribute__`**: Handles attribute access on instances and follows the instance's class MRO.\n\n### Further Documentation\n\nFor more in-depth understanding, you can refer to the Python documentation on [data model](https://docs.python.org/3/reference/datamodel.html), particularly the sections on attribute access and metaclasses. The intricacies of metaclasses and attribute resolution can be complex, but the key is understanding that metaclasses operate on the class level, whereas instance methods like `__getattribute__` operate on the instance level."
    }
]