[
    {
        "role": "user",
        "content": "I am developing an API using FastAPI and Pydantic. My goal is to create PATCH endpoints that allow editing 1 or N fields of a record at once, and I want the client to only pass the necessary fields in the payload. For example, in the following code, for the POST request, I want every field to be required. However, in the PATCH endpoint, I don't mind if the payload only contains the 'description' field. Hence, I want to make all fields optional. I have tried using the 'Optional' keyword from Python's typing module, but it is leading to a lot of code repetition. Is there a better way to achieve this?\n\n```python\nclass Item(BaseModel):\n    name: str\n    description: str\n    price: float\n    tax: float\n\n@app.post(\"/items\", response_model=Item)\nasync def post_item(item: Item):\n    ...\n\n@app.patch(\"/items/{item_id}\", response_model=Item)\nasync def update_item(item_id: str, item: Item):\n    ...\n```\n\nNaive approach:\n\n```python\nclass UpdateItem(BaseModel):\n    name: Optional[str] = None\n    description: Optional[str] = None\n    price: Optional[float] = None\n    tax: Optional[float]\n```"
    },
    {
        "role": "assistant",
        "content": "To avoid code repetition when creating a patch endpoint with optional fields, you can make use of Pydantic's `Config` class and the `update_forward_refs` method to dynamically create an update model based on your existing model. This way, you don't have to manually define all fields as optional in a separate class. Here's how you can achieve this:\n\n1. Define your main `Item` model as usual with all required fields.\n2. Create a utility function or a dynamic class that converts all fields of the original model to optional fields for the patch operation.\n\nHere's an example of how you can implement it:\n\n```python\nfrom typing import Optional\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel, create_model\n\napp = FastAPI()\n\nclass Item(BaseModel):\n    name: str\n    description: str\n    price: float\n    tax: float\n\n# Utility function to create an optional version of a Pydantic model\ndef create_patch_model(base_model):\n    optional_fields = {field: (Optional[field_type], None) for field, field_type in base_model.__annotations__.items()}\n    patch_model = create_model(f'{base_model.__name__}Patch', **optional_fields)\n    return patch_model\n\n# Create the UpdateItem model with all fields optional\nUpdateItem = create_patch_model(Item)\n\n@app.post(\"/items\", response_model=Item)\nasync def post_item(item: Item):\n    # Implementation for creating an item\n    return item\n\n@app.patch(\"/items/{item_id}\", response_model=Item)\nasync def update_item(item_id: str, item: UpdateItem):\n    # Implementation for updating an item\n    # Here you can selectively update fields based on the non-None attributes of `item`\n    return item\n\n```\n\n### Explanation:\n\n- **`create_patch_model` Function**: This function takes a base Pydantic model and returns a new model with all fields set to optional. It uses Pydantic's `create_model` function to dynamically create a new model class.\n\n- **Dynamic Model Creation**: By utilizing Pydantic's `create_model`, you can efficiently create a patch model without manually redefining the fields.\n\n- **Usage in Endpoint**: In the `update_item` endpoint, the `UpdateItem` model is used to allow partial updates, and you can handle the logic based on which fields are not `None`.\n\nThis approach keeps your code DRY (Don't Repeat Yourself) and makes it easy to manage changes in your main model without having to update the patch model separately."
    }
]