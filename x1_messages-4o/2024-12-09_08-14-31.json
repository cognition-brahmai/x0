[
    {
        "role": "user",
        "content": "Why am I encountering a problem when trying to create a class that inherits from str or int? For example, when I use the following code:\n\n```python\nclass C(str):\n   def __init__(self, a, b):\n     str.__init__(self,a)\n     self.b = b\n\nC(\"a\", \"B\")\n```\n\nI get a TypeError: `str() takes at most 1 argument (2 given)`. The same error happens if I try to use `int` instead of `str`, but it works with custom classes. Do I need to use `__new__` instead of `__init__`? If so, why?"
    },
    {
        "role": "assistant",
        "content": "When you create a class that inherits from built-in immutable types like `str` or `int`, you need to use `__new__` instead of `__init__` to handle the initialization of the base type. This is because immutable types do not allow their instances to be modified after they are created, so their initialization must be done in `__new__`, which is responsible for creating the instance itself.\n\nHere's why you need to use `__new__`:\n\n1. **Immutable Nature**: `str` and `int` are immutable, meaning their value cannot be changed after they are created. The `__init__` method is used to initialize an already created instance, which is not suitable for immutable types.\n\n2. **Instance Creation**: `__new__` is a static method responsible for returning a new instance of the class. When you are dealing with immutable types, you need to ensure that the instance is correctly initialized before it is returned, which is what `__new__` is for.\n\nHere's how you can modify your class to use `__new__`:\n\n```python\nclass C(str):\n    def __new__(cls, a, b):\n        # Create the instance of the base class using __new__\n        instance = super(C, cls).__new__(cls, a)\n        # Additional attributes can be set here\n        instance.b = b\n        return instance\n\n# Example usage\nc = C(\"a\", \"B\")\nprint(c)  # Output: a\nprint(c.b)  # Output: B\n```\n\nIn this code:\n\n- `__new__` is called with `cls` as the first argument, which is the class itself. This allows for creating an instance of the class.\n- `super(C, cls).__new__(cls, a)` is used to create an instance of `str` initialized with `a`.\n- `instance.b = b` sets the additional attribute `b` on the instance.\n\nUsing `__new__` ensures that the immutable part of the object is correctly initialized, while `__init__` can still be used for additional attributes if necessary, although in this pattern, additional attributes are typically set in `__new__`."
    }
]