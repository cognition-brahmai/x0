[
    {
        "role": "user",
        "content": "I am working on a task where I need to log every action performed on some SQLAlchemy-Models. I have after_insert, after_delete and before_update hooks set up, where I intend to save the previous and current representation of the model. However, I am encountering a problem: When I attempt to find a model in the before_update hook, SQLAlchemy returns a modified or \"dirty\" version. How can I obtain the previous version of the model before updating it? Is there an alternative way to track model changes? \n\nHere's the code I'm using:\n\n```python\ndef keep_logs(cls):\n    @event.listens_for(cls, 'after_delete')\n    def after_delete_trigger(mapper, connection, target):\n        pass\n\n    @event.listens_for(cls, 'after_insert')\n    def after_insert_trigger(mapper, connection, target):\n        pass\n\n    @event.listens_for(cls, 'before_update')\n    def before_update_trigger(mapper, connection, target):\n        prev = cls.query.filter_by(id=target.id).one()\n        # comparing previous and current model\n\n\nMODELS_TO_LOGGING = (\n    User,\n)\nfor cls in MODELS_TO_LOGGING:\n    keep_logs(cls)\n```"
    },
    {
        "role": "assistant",
        "content": "To track changes in SQLAlchemy models and capture the previous state before an update, you need to handle the \"dirty\" state of the model more effectively. The issue you're facing arises because, by the time the `before_update` event is triggered, the model instance is already in a \"dirty\" state with changes in memory. Here's how you can address this:\n\n1. **Use SQLAlchemy's Inspection API**: This API allows you to inspect the state of an instance and access its \"dirty\" attributes before committing the changes to the database.\n\n2. **Snapshot the state before changes**: Capture the state of the instance before the update occurs, so you can compare it with the post-update state.\n\nHere\u2019s how you can implement this:\n\n```python\nfrom sqlalchemy import inspect\nfrom sqlalchemy.orm.attributes import get_history\n\ndef keep_logs(cls):\n    @event.listens_for(cls, 'after_delete')\n    def after_delete_trigger(mapper, connection, target):\n        # Log deletion\n        pass\n\n    @event.listens_for(cls, 'after_insert')\n    def after_insert_trigger(mapper, connection, target):\n        # Log insertion\n        pass\n\n    @event.listens_for(cls, 'before_update')\n    def before_update_trigger(mapper, connection, target):\n        # Use the inspection API to get the previous state\n        state = inspect(target)\n        changes = {}\n\n        for attr in state.attrs:\n            hist = get_history(target, attr.key)\n            if hist.has_changes():\n                # Store the old and new value\n                changes[attr.key] = {\n                    'old': hist.deleted[0] if hist.deleted else None,\n                    'new': hist.added[0] if hist.added else None\n                }\n        \n        # Log the changes as needed\n        print(f\"Changes for {target}: {changes}\")\n\nMODELS_TO_LOGGING = (\n    User,\n)\nfor cls in MODELS_TO_LOGGING:\n    keep_logs(cls)\n```\n\n### Explanation:\n- **Inspection API**: `inspect(target)` provides a `state` object for the `target` instance, which can be used to access the current state and track changes.\n- **get_history**: This function is used to retrieve the history of a specific attribute. It returns a `History` object with `added`, `unchanged`, and `deleted` lists to show attribute changes.\n- **Logging**: Once you have the `changes` dictionary with old and new values, you can log it to your preferred logging mechanism.\n\nThis approach ensures you can track the changes made to each attribute of your SQLAlchemy model before the update is committed, allowing you to log the differences effectively."
    }
]