[
    {
        "role": "user",
        "content": "How can I execute a *.PY file from a *.IPYNB file using Jupyter notebook? I am working in a Python Notebook and I want to pack a large input code into a *.PY file and call this file from the notebook. However, when I execute the *.PY file from the notebook, it doesn't recognize any libraries or variables loaded in the notebook. Is there a way to solve this issue? For instance, I have the following code:\n\n```python\nIn[1]:\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nIn[2]:\ndef f(x):\n    return np.exp(-x ** 2)\n\nIn[3]:\nx = np.linspace(-1, 3, 100)\n\nIn[4]:\n%run script.py\n```\n\nHere, the 'script.py' file contains the following code:\n\n```python\nplt.plot(x, f(x))\nplt.xlabel(\"Eje $x$\",fontsize=16)\nplt.ylabel(\"$f(x)$\",fontsize=16)\nplt.title(\"Funcion $f(x)$\")\n```\n\nIn the actual problem, my *.PY file has more than 4 lines of code."
    },
    {
        "role": "assistant",
        "content": "To execute a `.py` file from a Jupyter Notebook while ensuring that it recognizes the libraries and variables loaded in the notebook, you can use one of the following methods:\n\n### Method 1: Use `%run`\n\nThe `%run` magic command in Jupyter should allow you to execute a Python script and share the environment. However, if your script doesn't recognize the variables or libraries from the notebook, make sure the script does not redefine or overwrite them. Your setup should work if the libraries and variables are properly loaded before `%run`.\n\nExample:\n```python\n%run script.py\n```\n\nEnsure that `script.py` doesn't include any imports or variable definitions that conflict with your notebook.\n\n### Method 2: Use `exec` with `open`\n\nYou can read the script file and execute it in the current namespace using `exec`:\n\n```python\nwith open('script.py') as file:\n    exec(file.read())\n```\n\nThis method directly incorporates the code from `script.py` into your current notebook session, ensuring it has access to any existing variables and imports.\n\n### Method 3: Use `importlib`\n\nYou can use `importlib` to import the script as a module if it's structured as such, but this requires a bit more setup:\n\n1. Ensure your `script.py` is in the same directory as your notebook or is in the Python path.\n2. Import it as a module:\n\n```python\nimport importlib.util\nimport sys\n\nspec = importlib.util.spec_from_file_location(\"module.name\", \"script.py\")\nfoo = importlib.util.module_from_spec(spec)\nsys.modules[\"module.name\"] = foo\nspec.loader.exec_module(foo)\n```\n\nThis method allows you to execute the script and access the functions and variables defined in it, but you need to ensure the script is structured properly as a module.\n\n### Common Issues\n\n- **Path Issues:** Ensure that the path to `script.py` is correct relative to your notebook.\n- **Variable Conflicts:** Ensure that your script does not redefine variables or imports that might conflict with your notebook environment.\n- **Namespace Conflicts:** Be careful with the use of global variables and ensure that the script's actions are compatible with the notebook's namespace.\n\nBy using one of these methods, you should be able to execute your `.py` file from within your Jupyter Notebook and have it recognize the necessary libraries and variables."
    }
]