[
    {
        "role": "user",
        "content": "How can I prevent distutils from changing the shebang line in my Python script? Specifically, I want to keep the shebang line as `#!/usr/bin/env python` instead of it being converted to `#!/whatever/absolute/path/is/my/python`. I'm encountering this issue while using grok in a virtual environment, which doesn't allow me to move the development directory around due to the inclusion of absolute paths in the shebang directive. This poses two problems: \n1. I want to be able to move my development directory from one location to another without issues, which isn't possible with the current setup. \n2. I would like to copy the virtual environment to another computer and run it there, which is not possible with hardcoded paths."
    },
    {
        "role": "assistant",
        "content": "To prevent `distutils` or `setuptools` from altering the shebang line in your Python scripts, you can use the following approach. This involves modifying the setup script or using a custom command class to control the behavior of the script installation process.\n\n### Method 1: Using `setuptools` with `entry_points`\n\nInstead of relying on the `scripts` argument in `setup()`, use `entry_points` in `setuptools`. This lets you define console scripts without having to worry about the shebang line.\n\n```python\nfrom setuptools import setup\n\nsetup(\n    name='your_package',\n    version='1.0',\n    packages=['your_package'],\n    entry_points={\n        'console_scripts': [\n            'your_script_name = your_package.module:function',\n        ],\n    },\n)\n```\n\n### Method 2: Custom `install_scripts` Command\n\nIf you need to use `distutils` or have specific reasons to stick to scripts, you can override the `install_scripts` command to customize the shebang line.\n\n1. Create a custom command class:\n\n```python\nfrom distutils.command.install_scripts import install_scripts as orig_install_scripts\n\nclass install_scripts(orig_install_scripts):\n    def run(self):\n        orig_install_scripts.run(self)\n        for script in self.get_outputs():\n            with open(script, 'rb') as f:\n                lines = f.readlines()\n            with open(script, 'wb') as f:\n                for line in lines:\n                    if line.startswith(b'#!'):\n                        f.write(b'#!/usr/bin/env python\\n')\n                    else:\n                        f.write(line)\n```\n\n2. Use this class in your `setup.py`:\n\n```python\nfrom distutils.core import setup\nfrom your_module_name import install_scripts\n\nsetup(\n    name='your_package',\n    version='1.0',\n    packages=['your_package'],\n    scripts=['path/to/your_script'],\n    cmdclass={'install_scripts': install_scripts},\n)\n```\n\n### Method 3: Manual Script Adjustment\n\nAs a last resort, if you have a small number of scripts and the above methods do not suit your needs, manually adjust the shebang lines after installation:\n\n1. Install your package normally.\n2. Use a simple script or command to replace the shebang lines in the installed scripts.\n\n```bash\nsed -i '1s|^.*$|#!/usr/bin/env python|' /path/to/installed/script\n```\n\n### Considerations\n\n- **Portability**: Using `#!/usr/bin/env python` is more portable as it allows the environment to determine the appropriate Python interpreter.\n- **Virtual Environments**: When copying virtual environments, consider tools like `virtualenv-clone` or `pip freeze` to recreate the environment elsewhere.\n- **Shebangs in Entry Points**: When using `entry_points`, `setuptools` will automatically handle the shebang line, pointing to the correct interpreter.\n\nThese methods should help you maintain a flexible and portable development environment without being tied down by hardcoded paths."
    }
]