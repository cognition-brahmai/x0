[
    {
        "role": "user",
        "content": "I recently executed some commands in Python where I made a dictionary using both lambda and regular functions as keys. This indicates that both types of functions are hashable. However, when I tried creating a dictionary with a list as a key, I received a TypeError indicating that the list is unhashable. I also noticed that the hash of a function is not necessarily its ID. The `__hash__` method seems to be explicitly defined for lambdas. I am curious to know, what is the reason behind making functions hashable and what exactly is the hash of a function?\n\n<pre><code>\n&gt;&gt;&gt; {lambda x: 1: 'a'}\n{&lt;function __main__.&lt;lambda&gt;&gt;: 'a'}\n\n&gt;&gt;&gt; def p(x): return 1\n&gt;&gt;&gt; {p: 'a'}\n{&lt;function __main__.p&gt;: 'a'}\n\n&gt;&gt;&gt; m = lambda x: 1\n&gt;&gt;&gt; id(m)\n140643045241584\n&gt;&gt;&gt; hash(m)\n8790190327599\n&gt;&gt;&gt; m.__hash__()\n8790190327599\n</code></pre>"
    },
    {
        "role": "assistant",
        "content": "Functions in Python are hashable because they are first-class objects, which means they can be treated like any other object (e.g., integers, strings) in the language. Being hashable allows functions to be used as keys in dictionaries and elements in sets, which is useful for certain advanced programming techniques.\n\nThe hash of a function is essentially a unique identifier that allows it to be used efficiently in hash tables (the underlying data structure for dictionaries and sets). The hash value is computed in such a way that different objects (even if they are of the same type) have different hash values, reducing the likelihood of hash collisions.\n\n### Reasons for Making Functions Hashable:\n1. **Uniqueness**: Functions are often used as keys when you need to associate metadata or cache results based on a particular function.\n   \n2. **Efficiency**: Hashing allows for O(1) average-time complexity for lookup operations in dictionaries and sets.\n   \n3. **Consistency**: Hashable objects need to be immutable, and functions, by default, behave like immutable objects, meaning they don\u2019t change state after creation.\n\n### Understanding Function Hashes:\n- **Hash vs. ID**: The `hash()` function gives a hash value, which is not the same as the memory address (`id()`). The `id()` function returns a unique identifier for an object during its lifetime, whereas the `hash()` function computes a hash value based on the object's content and state.\n  \n- **__hash__ Method**: The `__hash__` method in functions (including lambdas) is implemented to return a hash value that is consistent across calls. This value is derived based on several internal attributes, ensuring that two function objects with the same content will have the same hash value.\n\n### Why Lists are Unhashable:\n- Lists are mutable, meaning their contents can change, which could lead to inconsistencies in hash values. This mutability makes them unsuitable as dictionary keys or set elements because it would violate the immutability requirement for hashable objects.\n\nIn summary, functions are hashable because they have consistent, immutable characteristics that align well with the requirements of hash-based collections, and the hash value of a function is designed to uniquely represent it for efficient storage and retrieval."
    }
]