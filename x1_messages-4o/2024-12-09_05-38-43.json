[
    {
        "role": "user",
        "content": "How can I create a class-based decorator in Python 2.7, which can decorate either a method or a function and accepts at least one additional parameter? I have seen many Python decorator examples, such as function style decorators, class style decorators, decorators without arguments, decorators with arguments, method friendly decorators, function friendly decorators and decorators that can decorate both methods and functions. However, I have not come across an example that combines all of these features. I want to be able to use this decorator in the following way:\n\n```python\nclass MyDecorator(object):\n    def __init__(self, fn, argument):\n        self.fn = fn\n        self.arg = argument\n\n    def __get__(self, ....):\n        # voodoo magic for handling distinction between method and function here\n\n    def __call__(self, *args, *kwargs):\n        print \"In my decorator before call, with arg %s\" % self.arg\n        self.fn(*args, **kwargs)\n        print \"In my decorator after call, with arg %s\" % self.arg\n\n\nclass Foo(object):\n    @MyDecorator(\"foo baby!\")\n    def bar(self):\n        print \"in bar!\"\n\n\n@MyDecorator(\"some other func!\")\ndef some_other_function():\n    print \"in some other function!\"\n\nsome_other_function()\nFoo().bar()\n```\n\nAnd I would expect to see:\n```python\nIn my decorator before call, with arg some other func!\nin some other function!\nIn my decorator after call, with arg some other func!\nIn my decorator before call, with arg foo baby!\nin bar!\nIn my decorator after call, with arg foo baby!\n```"
    },
    {
        "role": "assistant",
        "content": "Creating a class-based decorator in Python 2.7 that can handle both functions and methods while accepting additional parameters involves a bit of \"voodoo magic\" indeed. The key part is managing the distinction between a method and a function, which typically involves the use of `__get__` to handle the descriptor protocol and properly bind the function to the instance.\n\nHere's how you can achieve this:\n\n```python\nclass MyDecorator(object):\n    def __init__(self, argument):\n        self.arg = argument\n\n    def __call__(self, fn):\n        self.fn = fn\n        return self\n\n    def __get__(self, instance, owner):\n        # If accessed through an instance, bind the function to the instance\n        if instance is not None:\n            return self._create_bound_method(instance)\n        # Otherwise, return the unbound function (class method)\n        return self\n    \n    def _create_bound_method(self, instance):\n        def bound_method(*args, **kwargs):\n            print \"In my decorator before call, with arg %s\" % self.arg\n            self.fn(instance, *args, **kwargs)\n            print \"In my decorator after call, with arg %s\" % self.arg\n        return bound_method\n\n    def __call__(self, *args, **kwargs):\n        # Handle the case when it's a standalone function\n        print \"In my decorator before call, with arg %s\" % self.arg\n        self.fn(*args, **kwargs)\n        print \"In my decorator after call, with arg %s\" % self.arg\n\n# Example usage\nclass Foo(object):\n    @MyDecorator(\"foo baby!\")\n    def bar(self):\n        print \"in bar!\"\n\n@MyDecorator(\"some other func!\")\ndef some_other_function():\n    print \"in some other function!\"\n\nsome_other_function()\nFoo().bar()\n```\n\n### Explanation:\n- **`__init__`:** The constructor stores the additional argument.\n- **`__call__`:** This method is first used to wrap the function/method itself when the decorator is applied. It is called again when the function/method is invoked.\n- **`__get__`:** This method makes the decorator class a descriptor, allowing it to distinguish between when it's being accessed as a method versus a function. It checks if an instance is passed and binds the function accordingly.\n- **`_create_bound_method`:** This helper function creates a bound method that includes the instance as the first argument, crucial for method calls.\n\nThis setup should give you the expected behavior, allowing the decorator to work seamlessly with both standalone functions and class methods."
    }
]