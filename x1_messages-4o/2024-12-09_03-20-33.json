[
    {
        "role": "user",
        "content": "Can someone explain the difference between the two Python functions `functools.wraps` and `update_wrapper`? I am finding it difficult to understand their differences. Could you also provide some code examples to illustrate this?"
    },
    {
        "role": "assistant",
        "content": "Certainly! Both `functools.wraps` and `functools.update_wrapper` are utilities provided by Python's `functools` module to help with the creation of decorators. They are used to preserve the metadata of the original function when it is wrapped by another function (often a decorator).\n\n### `functools.update_wrapper`\n\n`update_wrapper` is a function that updates the wrapper function (the function that is wrapping another function) to look more like the wrapped function by copying attributes such as the docstring, name, and module.\n\n#### Usage:\n\n```python\nfrom functools import update_wrapper\n\ndef my_decorator(func):\n    def wrapper(*args, **kwargs):\n        \"\"\"This is the wrapper function.\"\"\"\n        print(\"Before calling the function\")\n        result = func(*args, **kwargs)\n        print(\"After calling the function\")\n        return result\n    update_wrapper(wrapper, func)\n    return wrapper\n\n@my_decorator\ndef say_hello():\n    \"\"\"This function says hello.\"\"\"\n    print(\"Hello!\")\n\nsay_hello()\nprint(say_hello.__name__)  # Outputs: say_hello\nprint(say_hello.__doc__)   # Outputs: This function says hello.\n```\n\n### `functools.wraps`\n\n`wraps` is a convenience decorator provided by `functools` that applies `update_wrapper` to the wrapper function. It is typically used inside a decorator to make the syntax cleaner and more concise.\n\n#### Usage:\n\n```python\nfrom functools import wraps\n\ndef my_decorator(func):\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        \"\"\"This is the wrapper function.\"\"\"\n        print(\"Before calling the function\")\n        result = func(*args, **kwargs)\n        print(\"After calling the function\")\n        return result\n    return wrapper\n\n@my_decorator\ndef say_hello():\n    \"\"\"This function says hello.\"\"\"\n    print(\"Hello!\")\n\nsay_hello()\nprint(say_hello.__name__)  # Outputs: say_hello\nprint(say_hello.__doc__)   # Outputs: This function says hello.\n```\n\n### Key Differences\n\n1. **Syntax**: \n   - `update_wrapper` is a function that requires manual invocation.\n   - `wraps` is a decorator that is used with the `@` syntax.\n\n2. **Readability**: \n   - `wraps` is more concise and makes the decorator code more readable by reducing boilerplate.\n\n3. **Functionality**: \n   - Both achieve the same end result of preserving original function metadata, but `wraps` is simply a more syntactically convenient way to do so.\n\nIn summary, use `functools.wraps` within your custom decorators to make your code cleaner and more readable while preserving the metadata of the original function being decorated."
    }
]