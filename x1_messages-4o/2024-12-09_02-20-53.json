[
    {
        "role": "user",
        "content": "I am attempting to understand the difference between the `__getattr__` and `__getattribute__` methods in Python, but I'm finding it challenging. I've come across an explanation stating that `__getattribute__` is invoked before looking at the actual attributes on the object and can lead to infinite recursions very easily, which I don't fully understand. It's also suggested that I should probably be using `__getattr__`, but I don't know why. I've learned that if `__getattribute__` fails, `__getattr__` is called, which makes me wonder why there are two different methods that seem to serve the same purpose. What should I use if I am implementing new style classes? I'm looking for clear code examples and thorough explanations, and I'm willing to read any relevant documentation."
    },
    {
        "role": "assistant",
        "content": "Understanding the difference between `__getattr__` and `__getattribute__` can indeed be a bit tricky at first, but let's break it down with clear explanations and examples.\n\n### `__getattribute__`\n\n- **Purpose**: `__getattribute__` is a special method that is called automatically when any attribute of an object is accessed. It is always invoked, regardless of whether the attribute exists or not.\n- **Potential for Infinite Recursion**: Because `__getattribute__` is called for every attribute access, if you try to access an attribute directly inside the `__getattribute__` method without handling it properly, it will call `__getattribute__` again, potentially leading to infinite recursion.\n- **Usage**: If you need to customize behavior for all attribute accesses, you can override this method. However, be cautious and usually call the base class's method to prevent infinite loops.\n\n### `__getattr__`\n\n- **Purpose**: `__getattr__` is only called when an attribute is not found by the usual means. It provides a way to define a fallback for missing attributes.\n- **Usage**: It's more common and safer to use `__getattr__` when you want to handle cases where an attribute does not exist, without affecting the usual attribute access.\n\n### Key Differences\n\n1. **Invocation Timing**:\n   - `__getattribute__`: Called for every attribute access.\n   - `__getattr__`: Called only when an attribute is not found.\n\n2. **Safety**:\n   - `__getattribute__` can easily lead to infinite recursion.\n   - `__getattr__` is safer for handling missing attributes.\n\n### Code Examples\n\nHere's an example to illustrate the usage of both methods:\n\n```python\nclass MyClass:\n    def __init__(self):\n        self.existing_attribute = 'I exist!'\n\n    def __getattribute__(self, name):\n        print(f\"__getattribute__ called for {name}\")\n        try:\n            # To avoid recursion, use super() to call the base class's __getattribute__\n            return super().__getattribute__(name)\n        except AttributeError:\n            print(f\"{name} not found, delegating to __getattr__\")\n            # If the attribute does not exist, let __getattr__ handle it\n            return self.__getattr__(name)\n\n    def __getattr__(self, name):\n        print(f\"__getattr__ called for {name}\")\n        return f\"Default value for {name}\"\n\n# Usage\nobj = MyClass()\n\n# This will use __getattribute__ and find the existing attribute\nprint(obj.existing_attribute)\n\n# This will use __getattribute__, not find the attribute, and then call __getattr__\nprint(obj.non_existent_attribute)\n```\n\n### When to Use Each\n\n- **Use `__getattribute__`** if you need to intercept and customize behavior for *every* attribute access. Be very careful to avoid infinite recursion by using `super()` to access the base implementation.\n- **Use `__getattr__`** when you want to provide a default or fallback behavior for attributes that do not exist.\n\n### Documentation\n\nFor more information, refer to the [Python data model documentation](https://docs.python.org/3/reference/datamodel.html#object.__getattr__) where these methods are described in detail."
    }
]