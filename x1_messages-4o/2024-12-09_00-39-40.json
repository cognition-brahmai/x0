[
    {
        "role": "user",
        "content": "How can I use `functools.lru_cache` inside classes in Python without causing memory leaks? In my current implementation, the `foo` instance is not being released even though it's out of scope and has no referrer other than the `lru_cache`. Why is the `lru_cache` holding on to the instance, doesn't it use some hash and not the actual object? What is the best way to use `lru_cache` inside classes? Here is my current code:\n\n```python\nfrom functools import lru_cache\nclass BigClass:\n    pass\nclass Foo:\n    def __init__(self):\n        self.big = BigClass()\n    @lru_cache(maxsize=16)\n    def cached_method(self, x):\n        return x + 5\n\ndef fun():\n    foo = Foo()\n    print(foo.cached_method(10))\n    print(foo.cached_method(10)) # use cache\n    return 'something'\n\nfun()\n\nimport gc; gc.collect()  # collect garbage\nlen([obj for obj in gc.get_objects() if isinstance(obj, Foo)]) # is 1\n```\nEven after deleting `Foo`, the `Foo`/`BigClass` instances are still residing in memory."
    },
    {
        "role": "assistant",
        "content": "The issue you're encountering arises from how `functools.lru_cache` works in relation to instance methods. When you use `lru_cache` on a method, it creates a cache that is specific to the method and implicitly holds a reference to the instance (`self`) through the bound method object. This means that as long as the cache exists, it will keep a reference to the instance, preventing it from being garbage collected.\n\nHere are several strategies to mitigate this issue and use `lru_cache` with methods in a class without causing memory leaks:\n\n1. **Use `lru_cache` with a static method or a standalone function**: This avoids the instance reference in the cache.\n\n2. **Manually clear the cache**: You can clear the cache when you know it's safe to release the instance.\n\n3. **Use a weak reference**: This is an advanced solution where you can use `weakref.WeakMethod` or a custom implementation to ensure that the cache does not hold strong references to the instance.\n\nHere's how you can implement these strategies:\n\n### Using a Standalone Function\n\nConvert the method into a standalone function, passing the instance explicitly if needed:\n\n```python\nfrom functools import lru_cache\n\nclass BigClass:\n    pass\n\nclass Foo:\n    def __init__(self):\n        self.big = BigClass()\n\ndef cached_method(foo, x):\n    return x + 5\n\ncached_method = lru_cache(maxsize=16)(cached_method)\n\ndef fun():\n    foo = Foo()\n    print(cached_method(foo, 10))\n    print(cached_method(foo, 10))  # use cache\n    return 'something'\n\nfun()\n```\n\n### Manually Clearing the Cache\n\nClear the cache when the instance is no longer needed:\n\n```python\nfrom functools import lru_cache\n\nclass BigClass:\n    pass\n\nclass Foo:\n    def __init__(self):\n        self.big = BigClass()\n\n    @lru_cache(maxsize=16)\n    def cached_method(self, x):\n        return x + 5\n\ndef fun():\n    foo = Foo()\n    print(foo.cached_method(10))\n    print(foo.cached_method(10))  # use cache\n    Foo.cached_method.cache_clear()  # Clear cache explicitly\n    return 'something'\n\nfun()\n```\n\n### Using Weak References\n\nImplement a weak reference-based cache:\n\n```python\nimport weakref\nfrom functools import lru_cache, wraps\n\nclass BigClass:\n    pass\n\nclass Foo:\n    def __init__(self):\n        self.big = BigClass()\n\n    def cached_method(self, x):\n        return self._cached_method_impl(self, x)\n    \n    @staticmethod\n    @lru_cache(maxsize=16)\n    def _cached_method_impl(ref, x):\n        self = ref()\n        if self is None:\n            return None  # Handle case where self is gone\n        return x + 5\n\n\ndef fun():\n    foo = Foo()\n    foo_ref = weakref.ref(foo)\n    print(foo.cached_method(10))\n    print(foo.cached_method(10))  # use cache\n    del foo  # Remove strong reference to foo\n    return 'something'\n\nfun()\n\nimport gc; gc.collect()  # collect garbage\n```\n\nThis implementation ensures that the `Foo` instance is not held strongly by the cache. By using the weak reference, you allow the instance to be garbage collected when there are no other strong references to it."
    }
]