[
    {
        "role": "user",
        "content": "Can you provide examples of Python dictionaries using interesting and uncommon keys, apart from the standard strings or integers? Additionally, how can I define a new hashable quickly and efficiently? I understand that for a key to be hashable, it must be immutable and comparable, having either an __eq__() or __cmp__() method."
    },
    {
        "role": "assistant",
        "content": "Certainly! In Python, dictionary keys can be of any immutable type, and this includes not only strings and integers but also tuples, frozensets, and even custom objects as long as they are hashable and comparable. Here are some examples of dictionaries with unconventional keys:\n\n### Examples of Unconventional Dictionary Keys\n\n1. **Tuples as Keys:**\n   ```python\n   coordinates = {\n       (0, 0): \"Origin\",\n       (1, 2): \"Point A\",\n       (2, 1): \"Point B\"\n   }\n   print(coordinates[(1, 2)])  # Output: Point A\n   ```\n\n2. **Frozensets as Keys:**\n   ```python\n   frozenset_dict = {\n       frozenset([1, 2, 3]): \"Set A\",\n       frozenset([4, 5, 6]): \"Set B\"\n   }\n   print(frozenset_dict[frozenset([1, 2, 3])])  # Output: Set A\n   ```\n\n3. **Custom Objects as Keys:**\n   To use custom objects as dictionary keys, you must ensure they are immutable and implement the `__hash__` and `__eq__` methods.\n\n   ```python\n   class Point:\n       def __init__(self, x, y):\n           self.x = x\n           self.y = y\n\n       def __eq__(self, other):\n           return self.x == other.x and self.y == other.y\n\n       def __hash__(self):\n           return hash((self.x, self.y))\n\n   point_dict = {\n       Point(1, 2): \"Point A\",\n       Point(3, 4): \"Point B\"\n   }\n   print(point_dict[Point(1, 2)])  # Output: Point A\n   ```\n\n### Defining a New Hashable Object\n\nTo define a new hashable object quickly and efficiently, you need to ensure your object is immutable and has the necessary methods for hashing and comparison. Here\u2019s a simple example using a named tuple for convenience:\n\n```python\nfrom collections import namedtuple\n\nclass HashablePoint(namedtuple('HashablePoint', ['x', 'y'])):\n    __slots__ = ()  # To make it immutable\n\n    def __eq__(self, other):\n        return isinstance(other, HashablePoint) and self.x == other.x and self.y == other.y\n\n    def __hash__(self):\n        return hash((self.x, self.y))\n\n# Usage\npoint_dict = {\n    HashablePoint(1, 2): \"Point A\",\n    HashablePoint(3, 4): \"Point B\"\n}\nprint(point_dict[HashablePoint(1, 2)])  # Output: Point A\n```\n\nIn this example, `HashablePoint` is an immutable and hashable object that can be used as a dictionary key. Using `namedtuple` makes the code concise and efficient. The `__slots__` is used to prevent the creation of `__dict__`, which helps in maintaining immutability."
    }
]