[
    {
        "role": "user",
        "content": "I am trying to override special methods on an instance in Python. I have tried the following code:\n\n```python\nclass A(object):\n    pass\n\ndef __repr__(self):\n    return \"A\"\n\nfrom types import MethodType\na = A()\nprint(a)\nprint(repr(a))\nsetattr(a, \"__repr__\", MethodType(__repr__, a, a.__class__))\nprint(a)\nprint(repr(a))\n```\n\nWhen calling `repr(a)`, instead of returning the expected \"A\", it still returns the original representation. However, when I try the equivalent with a non-special method, it works:\n\n```python\nclass A(object):\n    def foo(self):\n        return \"foo\"\n\ndef bar(self):\n    return \"bar\"\n\nfrom types import MethodType\na = A()\nprint(a.foo())\nsetattr(a, \"foo\", MethodType(bar, a, a.__class__))\nprint(a.foo())\n```\n\nThis correctly changes the output of `a.foo()` from \"foo\" to \"bar\". Why doesn't the overriding work with the special `__repr__` method? Is there a way to achieve this?"
    },
    {
        "role": "assistant",
        "content": "In Python, special methods (also known as \"dunder\" methods, short for double underscore) like `__repr__` are typically looked up on the class, not the instance. This is why overriding them directly on an instance doesn't have the expected effect. When you call `repr(a)`, Python internally looks for `__repr__` on the class of `a`, not the instance itself.\n\nThis behavior is due to how Python's method resolution order works for special methods. For efficiency, special methods are looked up on the type (class) instead of the instance. As a result, changes to the `__repr__` method on the instance level do not affect the behavior of `repr()`.\n\nTo achieve the desired behavior of customizing `__repr__` for a specific instance, you can use the following approach:\n\n1. Use a class-level default implementation for `__repr__`.\n2. Customize the `__repr__` method at the instance level by modifying the class itself or using a proxy method.\n\nHere's an example of how you can achieve this by modifying the class of the instance dynamically:\n\n```python\nclass A(object):\n    def __repr__(self):\n        return \"<A instance>\"\n\n# Define a new __repr__ method\ndef custom_repr(self):\n    return \"A\"\n\n# Create an instance of A\na = A()\n\n# Print the default repr\nprint(a)          # Output: <A instance>\nprint(repr(a))    # Output: <A instance>\n\n# Dynamically modify the class of the instance\na.__class__ = type('CustomA', (A,), {'__repr__': custom_repr})\n\n# Print the modified repr\nprint(a)          # Output: A\nprint(repr(a))    # Output: A\n```\n\nIn this example, we create a new class `CustomA` that inherits from `A` and overrides the `__repr__` method with `custom_repr`. We then assign this new class to the instance `a` using `a.__class__ = ...`. This way, the special method `__repr__` is correctly overridden for that particular instance."
    }
]