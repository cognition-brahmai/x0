[
    {
        "role": "user",
        "content": "I am new to Python and I am using the Quickstart: Extract printed text (OCR) using the REST API and Python in Computer Vision for text detection in Sales Fliers. The algorithm provided has coordinates Ymin, XMax, Ymin, and Xmax and draws bounding boxes for each line of text. However, I want to group the texts that are close by to have a single delimited frame. For example, in the image provided, I would like to have 2 bounding boxes containing the closest text. How can I merge these bounding boxes by close distances?"
    },
    {
        "role": "assistant",
        "content": "To merge bounding boxes based on proximity, you can follow a strategy that involves calculating the distance between bounding boxes and merging those that are close to each other. Here's a general approach you can take:\n\n1. **Extract Bounding Boxes**: First, extract all bounding boxes from the OCR results. Each bounding box will have coordinates for the top-left and bottom-right corners: `(xmin, ymin, xmax, ymax)`.\n\n2. **Calculate Distances**: Define a function to calculate the distance between two bounding boxes. A simple approach is to calculate the Euclidean distance between the centers of the bounding boxes or the distance between the edges.\n\n3. **Define a Threshold**: Determine a distance threshold below which bounding boxes should be considered close enough to merge. This threshold might need some tuning based on your specific use case and the characteristics of your images.\n\n4. **Merge Bounding Boxes**: Iterate through the list of bounding boxes and merge those that are within the defined threshold. When merging, you'll want to create a new bounding box that encompasses all the merged boxes. This can be done by calculating the minimum and maximum x and y coordinates of the group.\n\n5. **Repeat if Necessary**: If merging bounding boxes results in new boxes that are close to others, you may need to repeat the process to ensure all close boxes are merged.\n\nHere's a simple implementation in Python to get you started:\n\n```python\nimport numpy as np\n\ndef calculate_distance(box1, box2):\n    # Calculate the Euclidean distance between the centers of two boxes\n    center1 = ((box1[0] + box1[2]) / 2, (box1[1] + box1[3]) / 2)\n    center2 = ((box2[0] + box2[2]) / 2, (box2[1] + box2[3]) / 2)\n    return np.sqrt((center1[0] - center2[0]) ** 2 + (center1[1] - center2[1]) ** 2)\n\ndef merge_boxes(boxes, threshold):\n    merged_boxes = []\n    visited = [False] * len(boxes)\n    \n    for i in range(len(boxes)):\n        if visited[i]:\n            continue\n        current_box = boxes[i]\n        for j in range(i + 1, len(boxes)):\n            if visited[j]:\n                continue\n            if calculate_distance(current_box, boxes[j]) < threshold:\n                # Merge the boxes\n                current_box = (\n                    min(current_box[0], boxes[j][0]),  # xmin\n                    min(current_box[1], boxes[j][1]),  # ymin\n                    max(current_box[2], boxes[j][2]),  # xmax\n                    max(current_box[3], boxes[j][3])   # ymax\n                )\n                visited[j] = True\n        merged_boxes.append(current_box)\n        visited[i] = True\n    \n    return merged_boxes\n\n# Example usage\nbounding_boxes = [\n    (10, 10, 50, 50),  # Example bounding boxes\n    (55, 10, 100, 50),\n    (200, 200, 250, 250),\n    # Add more bounding boxes as needed\n]\n\nthreshold = 20  # Define your threshold\nmerged_boxes = merge_boxes(bounding_boxes, threshold)\n\nprint(\"Merged Bounding Boxes:\", merged_boxes)\n```\n\nThis script calculates the distance between the centers of bounding boxes and merges them if they are within a specified threshold. Adjust the threshold value based on your specific needs to get the best results. You might need to tweak the distance calculation method depending on your specific use case and image characteristics."
    }
]