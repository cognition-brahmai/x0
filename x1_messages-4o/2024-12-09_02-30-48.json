[
    {
        "role": "user",
        "content": "Why do we need to use the dunder methods like `__getitem__` instead of the usual operator access when calling via super in Python? When I use the code:\n\n```python\nclass MyDict(dict):\n    def __getitem__(self, key):\n        return super()[key]\n```\n\nI get `TypeError: 'super' object is not subscriptable`. Instead, I have to use `super().__getitem__(key)`, but I don't understand why we can't use the operator access. Also, I have the same question regarding other dunder methods like `__getattr__`, `__init__`, etc. The Python documentation does attempt to explain this, but I'm still unclear about it."
    },
    {
        "role": "assistant",
        "content": "In Python, `super()` is used to call methods from a parent class, which is particularly useful in methods that override a base class in inheritance hierarchies. However, `super()` itself is not a complete object that supports all standard operations directly (like subscripting with `[]`), which is why using `super()` with operator-based access can lead to errors like the one you encountered (`TypeError: 'super' object is not subscriptable`).\n\nHere's a breakdown of why you can't use operator access (like `super()[key]`) and why you have to call the dunder methods explicitly:\n\n1. **`super()` Object**: The `super()` object is a proxy object that delegates method calls to a parent or sibling class. It\u2019s not a dictionary or any specific data structure itself, which means it doesn't automatically support every operation or operator that an instance of the actual class does.\n\n2. **Dunder Methods vs. Operators**: Operators in Python are syntactic sugar for calling dunder methods. For example, accessing an item with `obj[key]` is syntactic sugar for `obj.__getitem__(key)`. When you use an operator like `[]`, Python looks for the appropriate dunder method on the instance you\u2019re working with. However, since `super()` is not a fully-fledged instance of the class it proxies for, you have to explicitly call the dunder method (`super().__getitem__(key)`) to delegate the operation to the parent class.\n\n3. **Explicit Method Calls**: When you use `super().__getitem__(key)`, you are explicitly calling the `__getitem__` method on the parent class, which is the intended use of `super()`. This explicit nature is necessary because `super()` doesn\u2019t automatically translate operators to method calls.\n\n4. **Consistency Across Dunder Methods**: This behavior is consistent across all dunder methods, such as `__getattr__`, `__init__`, etc., because they rely on explicit method resolution rather than operator overloading. The use of `super()` requires you to directly call these methods because it bypasses the usual instance-to-method binding that allows operator overloading.\n\nIn summary, when you want to leverage `super()` to access a method from a base class, you need to explicitly call the dunder method because `super()` does not inherently support operator syntax. This ensures that you are clearly directing Python to use the method resolution order to find and call the appropriate method from the base class."
    }
]