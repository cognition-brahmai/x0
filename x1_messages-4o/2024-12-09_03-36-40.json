[
    {
        "role": "user",
        "content": "How can I use pyplot to display a line graph of up to 30 lines and also add a functionality to quickly show and hide individual lines on the graph? I am looking for a solution like using checkboxes on the legend to show and hide lines, similar to showing and hiding layers in image editors like Paint.Net. Is this possible with pyplot, or are there other modules that are somewhat easy to distribute?"
    },
    {
        "role": "assistant",
        "content": "Creating an interactive line graph with up to 30 lines using `matplotlib.pyplot` is certainly possible. While `matplotlib` itself provides basic interactive capabilities, for more advanced interactivity like checkboxes for showing and hiding lines, you'll want to use additional tools such as `mplcursors` or `plotly`. However, for a solution directly within `matplotlib`, you can integrate it with `widgets` from `matplotlib` or `ipywidgets` in Jupyter Notebooks.\n\nHere\u2019s how you can achieve this with `matplotlib` and `widgets`:\n\n### Using `matplotlib` with `widgets`\n\n1. **Install Necessary Packages**:\n   Ensure you have `matplotlib` and `ipywidgets` installed.\n\n   ```sh\n   pip install matplotlib ipywidgets\n   ```\n\n2. **Create the Interactive Plot**:\n\n   ```python\n   import matplotlib.pyplot as plt\n   import numpy as np\n   from matplotlib.widgets import CheckButtons\n\n   # Sample data\n   x = np.linspace(0, 10, 100)\n   lines = [np.sin(x + i) for i in range(30)]  # generate 30 sine waves\n\n   fig, ax = plt.subplots()\n   plt.subplots_adjust(left=0.2, right=0.8)\n\n   line_objects = [ax.plot(x, line, label=f'Line {i}')[0] for i, line in enumerate(lines)]\n\n   # Adding CheckButtons for interactivity\n   rax = plt.axes([0.85, 0.15, 0.1, 0.7])\n   labels = [f'Line {i}' for i in range(len(lines))]\n   visibility = [True for _ in range(len(lines))]\n   check = CheckButtons(rax, labels, visibility)\n\n   def toggle_lines(label):\n       index = labels.index(label)\n       line_objects[index].set_visible(not line_objects[index].get_visible())\n       plt.draw()\n\n   check.on_clicked(toggle_lines)\n\n   ax.legend(loc='upper left', bbox_to_anchor=(1, 1))\n   plt.show()\n   ```\n\n### Explanation\n\n- **Data Generation**: The code generates 30 sinusoidal lines. You can replace this with your own data.\n- **CheckButtons**: This widget creates checkboxes for each line, allowing you to toggle visibility.\n- **Event Handling**: The `toggle_lines` function is triggered whenever a checkbox is clicked, which toggles the visibility of the corresponding line.\n\n### Alternative: Using `Plotly`\n\nIf you prefer more built-in interactivity, you might consider using `plotly`. It provides interactive legends by default, allowing users to click on legend items to hide or show lines.\n\n```python\nimport plotly.graph_objects as go\nimport numpy as np\n\n# Sample data\nx = np.linspace(0, 10, 100)\nfig = go.Figure()\n\n# Add 30 lines\nfor i in range(30):\n    y = np.sin(x + i)\n    fig.add_trace(go.Scatter(x=x, y=y, mode='lines', name=f'Line {i}'))\n\n# Show the plot\nfig.show()\n```\n\n### Summary\n\n- **`matplotlib` + `widgets`**: Offers a native way to add checkboxes for line visibility, suitable for desktop applications or Jupyter Notebooks.\n- **`plotly`**: Provides out-of-the-box interactivity with an intuitive interface for hiding/showing lines via the legend, easy to distribute for web applications.\n\nChoose the method that best fits your environment and distribution needs."
    }
]