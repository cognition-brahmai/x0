[
    {
        "role": "user",
        "content": "In Django Rest Framework (DRF) 3, I am trying to add a non-model field to a ModelSerializer in my Django application. For instance, I need to include a field that isn't actually present in my model. Here is my current code:\n\n```python\nclass TestSerializer(serializers.ModelSerializer):\n    url = serializers.HyperlinkedIdentityField(view_name='vote_detail')\n    non_field = serializers.CharField()  # no corresponding model property.\n\n    class Meta:\n        model = vote_model\n        fields = (\"url\", \"non_field\")\n\n    def create(self, validated_data):\n      print(direction=validated_data['non_field'])\n```\n\nBut, when I run this, DRF 3 is throwing me an error:\n\n```python\nGot AttributeError when attempting to get a value for field `non_field` on serializer `TestSerializer`.\nThe serializer field might be named incorrectly and not match any attribute or key on the `Test` instance.\nOriginal exception text was: 'Test' object has no attribute 'non_field'.\n```\n\nI have looked at some solutions on Stack Overflow, but they seem to be applicable for DRF 2. Is there a way to solve this issue in DRF 3?"
    },
    {
        "role": "assistant",
        "content": "In Django Rest Framework (DRF) 3, the error you're encountering is due to the `non_field` not being part of your model, and therefore the serializer doesn't know how to retrieve its value. To include a non-model field in your serializer, you need to override the `to_representation` method and ensure that the field is properly managed during serialization and deserialization.\n\nHere's how you can modify your `TestSerializer` to handle the `non_field` correctly:\n\n```python\nfrom rest_framework import serializers\n\nclass TestSerializer(serializers.ModelSerializer):\n    url = serializers.HyperlinkedIdentityField(view_name='vote_detail')\n    non_field = serializers.CharField(write_only=True)  # Mark it as write_only if you only need it during creation\n\n    class Meta:\n        model = vote_model\n        fields = (\"url\", \"non_field\")\n\n    def to_representation(self, instance):\n        \"\"\"Override to add 'non_field' during serialization.\"\"\"\n        representation = super().to_representation(instance)\n        # Add extra data to the representation dict\n        representation['non_field'] = \"Your default value\"  # Or any computed value you want to include\n        return representation\n\n    def create(self, validated_data):\n        # Handle the 'non_field' as needed during creation\n        non_field_value = validated_data.pop('non_field', None)\n        print(f\"Direction: {non_field_value}\")\n        # Proceed with creating the object\n        instance = super().create(validated_data)\n        return instance\n```\n\n### Key Points:\n1. **write_only=True**: The `non_field` is marked as `write_only` to indicate that it is only necessary during input (creation or update) and does not need to be part of the serialized output.\n\n2. **to_representation**: You override this method to include any additional fields or modifications to the serialized output. This allows you to add the `non_field` or any computed value to the output representation.\n\n3. **create Method**: The `create` method is adjusted to handle `non_field` by popping it from the `validated_data` as it's not part of the model field set.\n\nBy using this approach, you ensure that `non_field` is properly managed during both serialization and deserialization processes."
    }
]