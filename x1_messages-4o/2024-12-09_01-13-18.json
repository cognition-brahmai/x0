[
    {
        "role": "user",
        "content": "I am trying to dynamically load a Python class using a string that represents the class like 'my_package.my_module.MyClass'. What is the best way to do this in Python, similar to the 'Class.forName()' function in Java? It is important that it works on Google App Engine. Ideally, I would like to have a function that can accept the Fully Qualified Name (FQN) of the class as a string and return a reference to the class. For instance:\n\n```python\nmy_class = load_class('my_package.my_module.MyClass')\nmy_instance = my_class()\n```"
    },
    {
        "role": "assistant",
        "content": "To dynamically load a Python class using its fully qualified name as a string, you can use the `importlib` module, which is part of the Python standard library. This module provides functions to import modules and access their attributes, which is what you need to achieve your goal. Below is a function that accomplishes this:\n\n```python\nimport importlib\n\ndef load_class(fqn):\n    \"\"\"\n    Load a class from a string representing its fully qualified name.\n\n    :param fqn: Fully qualified name of the class, e.g., 'my_package.my_module.MyClass'\n    :return: The class object\n    \"\"\"\n    module_name, class_name = fqn.rsplit('.', 1)\n    module = importlib.import_module(module_name)\n    cls = getattr(module, class_name)\n    return cls\n\n# Example usage:\nmy_class = load_class('my_package.my_module.MyClass')\nmy_instance = my_class()\n```\n\n### How It Works:\n1. **`rsplit('.', 1)`**: This splits the fully qualified name into the module path and the class name. The `1` specifies that it should split only once, from the right.\n2. **`importlib.import_module(module_name)`**: Dynamically imports the module specified by the module path.\n3. **`getattr(module, class_name)`**: Retrieves the class from the module using its name.\n\nThis function should work on any standard Python environment, including Google App Engine, as long as the module and class are accessible and properly deployed within the environment.\n\n### Considerations:\n- Ensure that the module you are trying to load is in the Python path.\n- Handle exceptions for cases where the module or class does not exist to avoid runtime errors. You might want to add try-except blocks for `ModuleNotFoundError` and `AttributeError`.\n- Make sure that the class has a default constructor if you plan to instantiate it without arguments."
    }
]