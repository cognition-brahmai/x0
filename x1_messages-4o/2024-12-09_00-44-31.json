[
    {
        "role": "user",
        "content": "What is the difference between using __new__ and __init__ when defining a metaclass in Python? I have seen metaclasses being set up using both methods, like so:\n\n```python\nclass SomeMetaClass(type):\n    def __new__(cls, name, bases, dict):\n        #do stuff here\n```\n\nand like this:\n\n```python\nclass SomeMetaClass(type):\n    def __init__(self, name, bases, dict):\n        #do stuff here\n```\n\nIs there any particular reason to prefer one over the other? Specifically, I know that in a regular class, __new__ can be used to implement caching, but this does not seem to be the case in a metaclass, as __new__ is only called upon class creation. Can you clarify this?"
    },
    {
        "role": "assistant",
        "content": "In Python, metaclasses are a powerful feature that allow you to customize class creation. When defining a metaclass, `__new__` and `__init__` serve different purposes, and understanding their roles can help you decide when to use each.\n\n### `__new__` in Metaclasses\n\n- **Purpose**: `__new__` is responsible for creating the class itself. It is called before `__init__`, and it is where the actual class object is created.\n- **Use Case**: If you need to modify how the class itself is constructed, such as altering the class dictionary before the class is created, or if you want to return a completely different object instead of the class, then you should use `__new__`.\n\n```python\nclass SomeMetaClass(type):\n    def __new__(cls, name, bases, class_dict):\n        # Modify class_dict or do some processing\n        class_dict['new_attr'] = 'I am added by __new__'\n        return super().__new__(cls, name, bases, class_dict)\n```\n\n### `__init__` in Metaclasses\n\n- **Purpose**: `__init__` is responsible for initializing the class after it has been created. It is not used to create the class but to perform additional initialization.\n- **Use Case**: If you need to perform actions after the class has been created, such as modifying class attributes, setting up additional properties, or registering the class in some registry, you should use `__init__`.\n\n```python\nclass SomeMetaClass(type):\n    def __init__(cls, name, bases, class_dict):\n        # Perform post-creation initialization\n        cls.initialized_attr = 'I am added by __init__'\n        super().__init__(name, bases, class_dict)\n```\n\n### Key Differences\n\n- **Timing**: `__new__` is called before the class is created, whereas `__init__` is called after the class has been created.\n- **Functionality**: Use `__new__` if you need to control the creation of the class itself. Use `__init__` if you need to perform additional setup after the class has been created.\n- **Return Value**: `__new__` must return the newly created class object, while `__init__` does not return anything and works with the already created class.\n\n### When to Prefer One Over the Other\n\n- Use `__new__` if you need to influence or replace the class creation process.\n- Use `__init__` if you want to perform additional initialization after the class object has been created.\n\nIn most common scenarios, `__init__` is sufficient for metaclass customization. However, if you need to exert control over the class creation itself, `__new__` becomes necessary."
    }
]