[
    {
        "role": "user",
        "content": "In the following Python code, I am encountering an `UnboundLocalError`. My understanding is that local functions should share the local variables of the containing function. However, that doesn't seem to be the case here. Even though `a` is an immutable value in this context, it shouldn't be causing a problem. The code is as follows:\n\n```python\ndef outer():\n    a = 0\n    def inner():\n        a += 1\n    inner()\nouter()\n```\nIt appears that the inner function has copies of all the references in the parent function. I've noticed that I don't get the `UnboundLocalError` exception if the value of `a` is wrapped in a mutable type. Can someone clarify this behavior, and direct me to the relevant Python documentation?"
    },
    {
        "role": "assistant",
        "content": "The issue you're encountering with the `UnboundLocalError` is due to the way Python handles variable scope and assignments within nested functions. When you try to modify a variable defined in an outer function from within an inner function, Python treats `a` as a local variable within `inner()` due to the assignment operation `a += 1`. However, since `a` is not initialized within `inner()`, this results in an `UnboundLocalError`.\n\nHere's a breakdown of what's happening:\n\n1. **Variable Scope**: In Python, if you assign a value to a variable anywhere within a function, that variable is considered local to that function unless explicitly declared otherwise using the `nonlocal` or `global` keywords.\n\n2. **UnboundLocalError**: Since `a += 1` is equivalent to `a = a + 1`, Python tries to read the value of `a` before it has been assigned a value within the local scope of `inner()`, which raises an `UnboundLocalError`.\n\n3. **Mutable Types**: When you wrap `a` in a mutable type (like a list or a dictionary), you are modifying the object that `a` refers to, rather than trying to reassign `a` itself. This avoids the `UnboundLocalError` because you're not making an assignment to `a`; you're modifying the contents of the object `a` refers to.\n\nTo fix this issue, you can use the `nonlocal` keyword to indicate that `a` is not a local variable within `inner()`, but rather a variable from an enclosing scope:\n\n```python\ndef outer():\n    a = 0\n    def inner():\n        nonlocal a\n        a += 1\n    inner()\n    print(a)  # This will print 1\nouter()\n```\n\nThe `nonlocal` keyword allows you to assign to variables in the nearest enclosing scope (excluding globals), allowing you to modify `a` as expected.\n\nFor further reading, you can refer to the Python documentation on [scopes and namespaces](https://docs.python.org/3/reference/executionmodel.html#resolution-of-names) which explains these concepts in detail."
    }
]