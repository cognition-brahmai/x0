[
    {
        "role": "user",
        "content": "How can I implement the Repository Pattern in Python? I am looking to decouple persistence logic from domain logic. The Repository Pattern is featured in the post \"Untangle Domain and Persistence Logic with Curator\" and the idea comes from a section of the \"Domain-Driven Design\" book and Martin Fowler. The model class does not contain any persistence logic, instead, the app declares repository subclasses whose instances function like in-memory collections of model instances. Each repository persists the model in different ways, for instance, to SQL (various schema conventions), to Riak or other noSQL and to memory (for caching). I am also curious about how the Repository Pattern differs from the Active Record Pattern (for instance, Django ORM) and the Data Mapper Pattern (for instance, SQLAlchemy's Classical Mappings)."
    },
    {
        "role": "assistant",
        "content": "Implementing the Repository Pattern in Python is a great way to separate your domain logic from your persistence logic. This separation allows you to manage the data access layer independently of the business logic and makes your application more flexible and easier to maintain. Here's a basic guide on how you can implement the Repository Pattern in Python:\n\n### Step-by-Step Implementation\n\n1. **Define Your Domain Model:**\n   First, define your domain model as plain Python classes. These classes should not contain any persistence logic.\n\n   ```python\n   class Product:\n       def __init__(self, product_id, name, price):\n           self.product_id = product_id\n           self.name = name\n           self.price = price\n\n       def __repr__(self):\n           return f\"Product(id={self.product_id}, name={self.name}, price={self.price})\"\n   ```\n\n2. **Define a Repository Interface:**\n   Create an abstract repository class that outlines the methods for accessing and manipulating the data.\n\n   ```python\n   from abc import ABC, abstractmethod\n\n   class ProductRepository(ABC):\n\n       @abstractmethod\n       def add(self, product):\n           pass\n\n       @abstractmethod\n       def remove(self, product_id):\n           pass\n\n       @abstractmethod\n       def get_by_id(self, product_id):\n           pass\n\n       @abstractmethod\n       def list(self):\n           pass\n   ```\n\n3. **Implement Concrete Repositories:**\n   You can implement different repositories for various storage mechanisms (e.g., in-memory, SQL, NoSQL).\n\n   **In-Memory Repository:**\n\n   ```python\n   class InMemoryProductRepository(ProductRepository):\n       def __init__(self):\n           self.products = {}\n\n       def add(self, product):\n           self.products[product.product_id] = product\n\n       def remove(self, product_id):\n           if product_id in self.products:\n               del self.products[product_id]\n\n       def get_by_id(self, product_id):\n           return self.products.get(product_id)\n\n       def list(self):\n           return list(self.products.values())\n   ```\n\n   **SQL Repository (using SQLAlchemy):**\n\n   ```python\n   from sqlalchemy.orm import sessionmaker\n\n   class SQLProductRepository(ProductRepository):\n       def __init__(self, session):\n           self.session = session\n\n       def add(self, product):\n           self.session.add(product)\n           self.session.commit()\n\n       def remove(self, product_id):\n           product = self.get_by_id(product_id)\n           if product:\n               self.session.delete(product)\n               self.session.commit()\n\n       def get_by_id(self, product_id):\n           return self.session.query(Product).get(product_id)\n\n       def list(self):\n           return self.session.query(Product).all()\n   ```\n\n### Differences Between Repository, Active Record, and Data Mapper\n\n- **Repository Pattern:**\n  - The Repository Pattern abstracts the data access layer and provides a collection-like interface for accessing domain objects.\n  - It helps separate domain logic from persistence logic, making the application easier to maintain and test.\n\n- **Active Record Pattern:**\n  - In the Active Record pattern, each object is responsible for its own persistence. This means that the domain objects contain methods for saving, updating, and deleting themselves from the database.\n  - This pattern is simpler to implement but can lead to the mixing of domain logic and persistence logic, making it harder to maintain as the application grows.\n  - Example in Django ORM: Models have methods like `.save()` and `.delete()`.\n\n- **Data Mapper Pattern:**\n  - The Data Mapper pattern separates the domain objects from the database operations. It uses a separate class or layer to manage the database operations.\n  - This pattern is more complex but provides a clear separation between domain logic and persistence logic.\n  - Example in SQLAlchemy: The ORM layer manages the database interactions, while the domain objects remain unaware of these details.\n\nBy using the Repository Pattern, you can achieve a clean separation between your business logic and data access layers, which is particularly beneficial in applications that need to support multiple storage mechanisms or complex business logic."
    }
]