[
    {
        "role": "user",
        "content": "What is the correct way to declare custom exception classes in Python that are compatible with Python 2.5, but also adhere to the standards of Python 2.6 and Python 3.*? I want to include additional data in my Exception object, such as a string or any other object relevant to the exception. However, I'm encountering a deprecation warning in Python 2.6.2 with my current approach:\n\n```python\n>>> class MyError(Exception):\n...     def __init__(self, message):\n...         self.message = message\n... \n>>> MyError(\"foo\")\n_sandbox.py:3: DeprecationWarning: BaseException.message has been deprecated as of Python 2.6\n```\n\nI also know that `Exception` has a magic parameter called `args`, but I'm unsure how to utilize it. Is it necessary to override `__init__`, `__str__`, `__unicode__`, or `__repr__` methods for creating custom exceptions?"
    },
    {
        "role": "assistant",
        "content": "To create custom exception classes in Python that are compatible across Python 2.5, 2.6, and 3.x, and to avoid the deprecation warning you mentioned, you should handle exception arguments using the `args` attribute. The `args` attribute is a tuple that stores all positional arguments passed to the exception. This approach ensures compatibility across different Python versions.\n\nHere's a recommended way to declare a custom exception class:\n\n```python\nclass MyError(Exception):\n    def __init__(self, message, additional_data=None):\n        # Initialize with the message and any additional data\n        self.message = message\n        self.additional_data = additional_data\n        # Store all arguments in the args tuple for compatibility\n        super(MyError, self).__init__(message, additional_data)\n\n    def __str__(self):\n        # Customize the string representation of the exception\n        return f\"MyError: {self.message}, Additional Data: {self.additional_data}\"\n\n# Example usage:\ntry:\n    raise MyError(\"Something went wrong\", additional_data={\"key\": \"value\"})\nexcept MyError as e:\n    print(e)\n```\n\n### Key Points:\n1. **Initialization:** Use the `__init__` method to initialize your custom attributes and call the base class's `__init__` method with all arguments. This allows the `args` attribute to correctly store the exception's arguments.\n\n2. **Message Attribute:** Avoid using `self.message` directly as it was deprecated. Instead, you can customize the `__str__` method to provide a specific string representation if needed.\n\n3. **String Representation:** Override the `__str__` method for a human-readable representation of the exception. You can also override the `__repr__` method if a more formal representation is required.\n\n4. **Compatibility:** This approach is compatible with Python 2.5, 2.6, and 3.x, as it avoids using the deprecated `message` attribute directly and instead utilizes `args` for storing arguments.\n\nBy following these guidelines, you will have a custom exception class that is robust and compatible with various Python versions."
    }
]