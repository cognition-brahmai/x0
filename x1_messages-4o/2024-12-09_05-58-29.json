[
    {
        "role": "user",
        "content": "How can I annotate the possible types of *args and **kwargs with Python's type annotations with abstract base classes? Specifically, I am trying to express that the sensible arguments to a function are either an int or two ints. I attempted to annotate the type as Union[Tuple[int, int], Tuple[int]], but this does not work. I am getting errors from mypy that I don't understand. How can I annotate the sensible types for *args and **kwargs?\n\nHere is the code I am working with:\n\n```python\nfrom typing import Union, Tuple\n\ndef foo(*args: Union[Tuple[int, int], Tuple[int]]):\n    try:\n        i, j = args\n        return i + j\n    except ValueError:\n        assert len(args) == 1\n        i = args[0]\n        return i\n\n# ok\nprint(foo((1,)))\nprint(foo((1, 2)))\n# mypy does not like this\nprint(foo(1))\nprint(foo(1, 2))\n```\n\nHere are the error messages from mypy:\n\n```python\nt.py: note: In function \"foo\":\nt.py:6: error: Unsupported operand types for + (\"tuple\" and \"Union[Tuple[int, int], Tuple[int]]\")\nt.py: note: At top level:\nt.py:12: error: Argument 1 to \"foo\" has incompatible type \"int\"; expected \"Union[Tuple[int, int], Tuple[int]]\"\nt.py:14: error: Argument 1 to \"foo\" has incompatible type \"int\"; expected \"Union[Tuple[int, int], Tuple[int]]\"\nt.py:15: error: Argument 1 to \"foo\" has incompatible type \"int\"; expected \"Union[Tuple[int, int], Tuple[int]]\"\nt.py:15: error: Argument 2 to \"foo\" has incompatible type \"int\"; expected \"Union[Tuple[int, int], Tuple[int]]\"\n```"
    },
    {
        "role": "assistant",
        "content": "To annotate the possible types of `*args` in a way that allows either one integer or two integers, you need to adjust the type hints to indicate that `*args` can be a sequence of integers. The `Union[Tuple[int, int], Tuple[int]]` annotation is not appropriate for `*args` because `*args` is not a tuple itself, but a sequence of arguments.\n\nHere's how you can modify your code to make it work with `mypy` and express the intended behavior:\n\n```python\nfrom typing import Tuple, overload, Literal\n\n@overload\ndef foo(a: int) -> int: ...\n@overload\ndef foo(a: int, b: int) -> int: ...\n\ndef foo(*args: int) -> int:\n    if len(args) == 1:\n        return args[0]\n    elif len(args) == 2:\n        return args[0] + args[1]\n    else:\n        raise ValueError(\"foo() accepts either 1 or 2 integer arguments\")\n\n# ok\nprint(foo(1))\nprint(foo(1, 2))\n# not ok, will raise ValueError\n# print(foo(1, 2, 3))\n```\n\nIn this version:\n\n1. **Overloading**: We use function overloading to define two separate cases for `foo`: one taking a single integer and another taking two integers. This helps `mypy` understand the intended function signatures.\n\n2. **Runtime Check**: In the actual function implementation, a runtime check ensures that either one or two integers are passed.\n\n3. **Type Annotations**: `*args: int` indicates that `args` is a sequence of integers, which matches the expected usage of `foo`.\n\nThis approach should satisfy both `mypy` and the intended behavior of your code."
    }
]