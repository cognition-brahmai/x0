[
    {
        "role": "user",
        "content": "How can I create a Python decorator with optional arguments? I have a decorator currently setup but it behaves differently when I pass a method name and when I don't. The decorator `foo_register` decorates `my_function` but does not make it to `decorator` function. However, when I pass a method name 'say_hi', it works as expected. I understand that I can check inside the `foo_register` to see if the first argument is a decorator and if so, then I would return `decorator(method_name)` instead of `decorator`. However, this approach of checking if it's a callable seems hackish. Is there a better way to create a multi-use decorator like this?\n\nHere's the decorator I'm working with:\n\n```python\nfrom functools import wraps\n\ndef foo_register(method_name=None):\n    \"\"\"Does stuff.\"\"\"\n    def decorator(method):\n        if method_name is None:\n            method.gw_method = method.__name__\n        else:\n            method.gw_method = method_name\n        @wraps(method)\n        def wrapper(*args, **kwargs):\n            method(*args, **kwargs)\n        return wrapper\n    return decorator\n```\n\nHere's how it behaves when I don't pass any method name:\n\n```python\n@foo_register\ndef my_function():\n    print('hi...')\n```\n\nAnd here's how it behaves when I pass a method name:\n\n```python\n@foo_register('say_hi')\ndef my_function():\n    print('hi...')\n```"
    },
    {
        "role": "assistant",
        "content": "To create a Python decorator that can accept optional arguments, you need to distinguish between when the decorator is called with or without arguments. The typical approach is to use a combination of function definitions to handle both cases. If the decorator is called without arguments, it receives only the function to be decorated. If it is called with arguments, it receives those arguments and returns another function that receives the function to be decorated.\n\nHere's how you can modify your `foo_register` decorator to handle both cases:\n\n```python\nfrom functools import wraps\n\ndef foo_register(method_name=None):\n    \"\"\"Decorator that can be used with or without arguments.\"\"\"\n    def decorator(method):\n        # Assign the method name if not provided\n        if method_name is None:\n            method.gw_method = method.__name__\n        else:\n            method.gw_method = method_name\n        \n        @wraps(method)\n        def wrapper(*args, **kwargs):\n            return method(*args, **kwargs)\n        \n        return wrapper\n    \n    # Check if the decorator is called without arguments\n    if callable(method_name):\n        # The function to be decorated is provided directly\n        return decorator(method_name)\n    \n    return decorator\n\n# Use without passing a method name\n@foo_register\ndef my_function():\n    print('hi...')\n\n# Use with passing a method name\n@foo_register('say_hi')\ndef another_function():\n    print('hi again...')\n\n# Testing the functions\nmy_function()          # Output: hi...\nanother_function()     # Output: hi again...\n\nprint(my_function.gw_method)  # Output: my_function\nprint(another_function.gw_method)  # Output: say_hi\n```\n\n### Explanation:\n- The `foo_register` function checks if `method_name` is callable. If it is, this means the decorator has been called without parentheses, and `method_name` is actually the function to be decorated.\n- If `method_name` is not callable, it proceeds as before, expecting a method name or `None` as an argument.\n- The `decorator` function is defined inside `foo_register` and is responsible for wrapping the actual method, setting the `gw_method` attribute as needed.\n  \nThis approach allows you to use the `foo_register` decorator both with and without arguments, providing flexibility in its usage."
    }
]