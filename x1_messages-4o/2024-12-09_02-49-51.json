[
    {
        "role": "user",
        "content": "I am developing a series of add-ons for Anki, an open-source flashcard program. The add-ons are Python packages and are imported by the base app. I am trying to find a way to ship these packages along with their dependencies without modifying the global state or manually editing the vendored packages. How can I import an arbitrary package from the `_vendor` directory, especially since relative imports don't work for packages that have dependencies imported through absolute references? I've tried several methods but none of them have worked. I can't modify the sys path or the packages themselves. Is there a way to ship a dependency tree of third-party packages with my code without resorting to these methods?"
    },
    {
        "role": "assistant",
        "content": "Shipping third-party packages with your Anki add-ons without modifying the global state or the packages themselves can be challenging, but there are some strategies you can consider to achieve this:\n\n1. **Virtual Environment Isolation**: Create a virtual environment specifically for your add-ons and package it along with your add-ons. This way, you can manage dependencies separately from the global Python environment. You can use tools like `venv` or `virtualenv` to create this isolated environment.\n\n2. **Use PYTHONPATH**: You can set the `PYTHONPATH` environment variable within your add-on's startup script to include your `_vendor` directory. This allows Python to search the specified directory for modules when importing.\n\n3. **Zip Import**: Package your dependencies in a zip file and use Python's built-in support for importing from zip files. You can include this zip file in your add-on and adjust the `sys.path` temporarily within your add-on's code to include this zip file.\n\n4. **Namespace Packages**: If your add-on and its dependencies can be structured as namespace packages, you can place them within a common top-level package. This allows you to keep all your dependencies within your package's directory structure without modifying their import paths.\n\n5. **Custom Importer**: Implement a custom import hook using Python's import machinery (`importlib`). This can allow you to control how modules are loaded from your `_vendor` directory without altering the global state.\n\nHere's a basic example of using a custom importer:\n\n```python\nimport sys\nimport importlib.abc\nimport importlib.util\nimport os\n\nclass VendorImporter(importlib.abc.MetaPathFinder, importlib.abc.Loader):\n    def __init__(self, vendor_path):\n        self.vendor_path = vendor_path\n\n    def find_spec(self, fullname, path, target=None):\n        # Check if the module is in the vendor directory\n        module_path = os.path.join(self.vendor_path, *fullname.split('.')) + '.py'\n        if os.path.exists(module_path):\n            return importlib.util.spec_from_file_location(fullname, module_path, loader=self)\n        return None\n\n    def create_module(self, spec):\n        return None\n\n    def exec_module(self, module):\n        with open(module.__spec__.origin, 'rb') as f:\n            code = f.read()\n        exec(code, module.__dict__)\n\nvendor_path = os.path.join(os.path.dirname(__file__), '_vendor')\nsys.meta_path.insert(0, VendorImporter(vendor_path))\n```\n\nThis example demonstrates how to create a custom importer that looks for modules within a `_vendor` directory. You can expand upon this to support more complex package structures.\n\n6. **Use a Dependency Manager**: If possible, consider packaging your add-ons using a dependency manager like `pip` with a `requirements.txt` or `Pipfile`, allowing users to install dependencies in their environment.\n\nEach of these approaches has its own trade-offs, so you'll need to choose the one that best fits your specific needs and constraints."
    }
]