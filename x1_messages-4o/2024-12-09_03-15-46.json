[
    {
        "role": "user",
        "content": "I am having difficulty understanding how variable scope and name resolution work in Python. I have written three functions: okay0(), okay1(), and broken(). The functions okay0() and okay1() work as expected, but the function broken() raises an exception. Can anyone explain why this is happening or provide a detailed explanation of how variable scope and name resolution work in Python? Here is the code for reference:\n\n```python\n# Why does this code work fine\ndef okay0():\n    def foo():\n        L = []\n        def bar():\n            L.append(5)\n        bar()\n        return L\n    foo()\n\n# and so does this\ndef okay1():\n    def foo():\n        def bar():\n            L.append(5)\n        L = []\n        bar()\n        return L\n    foo()\n\n# but the following code raises an exception?\ndef broken():\n    def foo():\n        L = []\n        bar()\n        return L\n    def bar():\n        L.append(5)\n    foo()\n\n# Example\ntest_list = [okay0, okay1, broken]\nfor test_function in test_list:\n    try:\n        test_function()\n    except:\n        print(\"broken\")\n    else:\n        print(\"okay\")\n```"
    },
    {
        "role": "assistant",
        "content": "To understand why the `broken()` function raises an exception, we need to take a closer look at Python's variable scope and name resolution, which are governed by the LEGB rule: Local, Enclosing, Global, and Built-in.\n\n### LEGB Rule:\n1. **Local:** Variables defined within a function.\n2. **Enclosing:** Variables in the local scope of any enclosing functions.\n3. **Global:** Variables defined at the top level of a module or declared global in a function.\n4. **Built-in:** Names preassigned in the built-in names module.\n\n### Let's analyze each function:\n\n#### `okay0()`\nIn this function, `L` is defined inside the `foo()` function, and the `bar()` function is a nested function that modifies `L`. The `bar()` function has access to the `L` variable because it is enclosed within `foo()` where `L` is defined, satisfying the LEGB rule.\n\n#### `okay1()`\nSimilarly, in this function, `bar()` is defined before `L`, but it is still enclosed within `foo()`. When `bar()` is called, it modifies `L`. This works because `L` is defined in the enclosing scope (inside `foo()`), and Python resolves `L` correctly due to the enclosing scope rule.\n\n#### `broken()`\nThe issue with `broken()` arises from the fact that `bar()` is defined outside of `foo()`. When `bar()` is called inside `foo()`, it tries to append to `L`, but `L` is not defined within `bar()` or in any enclosing scope (as far as `bar()` is concerned), so Python raises an exception.\n\nIn more detail:\n- Inside `foo()`, `L` is a local variable.\n- `bar()` is defined outside of `foo()`, so it does not have access to `L` defined within `foo()`.\n- When `bar()` tries to use `L`, it cannot find `L` in its own local scope or in the global scope, leading to a `NameError`.\n\n### Solution:\n\nTo fix the `broken()` function, you can pass `L` as an argument to `bar()`:\n\n```python\ndef broken():\n    def foo():\n        L = []\n        bar(L)\n        return L\n    def bar(L):\n        L.append(5)\n    foo()\n```\n\nBy passing `L` as an argument, you explicitly provide `bar()` with access to the `L` list, resolving the scope issue."
    }
]