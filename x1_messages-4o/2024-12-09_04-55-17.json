[
    {
        "role": "user",
        "content": "I am having issues when trying to create a table using PyODBC in MSSQL2008. I have verified the syntax using SQL Management Studio and it works fine, but when I run my Python script, it fails. Here's the code I am using:\n\n```python\nimport pyodbc\n\ndef SQL(QUERY, target = '...', DB = '...'):\n    cnxn = pyodbc.connect('DRIVER={SQL Server};SERVER=' + target + DB+';UID=user;PWD=pass')\n    cursor = cnxn.cursor()\n    cursor.execute(QUERY)\n    cpn = []\n\n    for row in cursor:\n        cpn.append(row)\n    return cpn\n\nprint SQL(\"CREATE TABLE dbo.Approvals (ID SMALLINT NOT NULL IDENTITY PRIMARY KEY, HostName char(120));\")\n```\n\nAnd here's the error message I get:\n\n```python\nTraceback (most recent call last):\n  File \"test_sql.py\", line 25, in <module>\n    print SQL(\"CREATE TABLE dbo.Approvals (ID SMALLINT NOT NULL IDENTITY PRIMARY KEY, HostName char(120));\")\n  File \"test_sql.py\", line 20, in SQL\n    for row in cursor:\npyodbc.ProgrammingError: No results.  Previous SQL was not a query.\n```\n\nI have the \"SQL Server\" driver installed (it's default) and I'm running Windows 7 against a Windows 2008 SQL Server environment (Not an express database). Can anyone help me understand why this is happening?"
    },
    {
        "role": "assistant",
        "content": "The error you are encountering is due to the fact that you are trying to iterate over a cursor after executing a `CREATE TABLE` statement, which does not return any result set. The `ProgrammingError: No results. Previous SQL was not a query` error occurs because the SQL statement executed is not a query that returns data to be fetched.\n\nHere's how you can fix the issue:\n\n1. **Separate Execution from Fetching**: For SQL commands like `CREATE`, `INSERT`, `UPDATE`, or `DELETE`, you don't need to fetch any rows, so you can modify your function to handle these types of statements differently.\n\n2. **Commit Changes**: When you execute a command that modifies the database, you should commit the changes.\n\nHere is a revised version of your function:\n\n```python\nimport pyodbc\n\ndef SQL(QUERY, target='...', DB='...'):\n    cnxn = pyodbc.connect('DRIVER={SQL Server};SERVER=' + target + ';DATABASE=' + DB + ';UID=user;PWD=pass')\n    cursor = cnxn.cursor()\n    try:\n        cursor.execute(QUERY)\n        \n        # If the QUERY is a SELECT statement, fetch the results\n        if QUERY.strip().upper().startswith(\"SELECT\"):\n            results = cursor.fetchall()\n            return results\n        else:\n            # Commit the transaction for commands that modify the database\n            cnxn.commit()\n            return \"Query executed successfully.\"\n    except Exception as e:\n        # Handle exceptions and return the error message\n        return str(e)\n    finally:\n        cursor.close()\n        cnxn.close()\n\n# Now execute your CREATE TABLE command\nresult = SQL(\"CREATE TABLE dbo.Approvals (ID SMALLINT NOT NULL IDENTITY PRIMARY KEY, HostName char(120));\")\nprint(result)\n```\n\n### Key Points:\n\n- **Commit Changes**: Use `cnxn.commit()` after executing non-query commands to save the changes in the database.\n- **Check Command Type**: Use `startswith(\"SELECT\")` to determine if the command requires fetching data.\n- **Error Handling**: Add a `try-except-finally` block to handle any potential exceptions and ensure resources are properly closed.\n- **Database Connection String**: Ensure the connection string is correctly formatted and includes the `DATABASE` parameter.\n\nThis should resolve the issue you are facing and allow you to execute both data-modifying and data-retrieving SQL commands using the same function."
    }
]