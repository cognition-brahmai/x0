[
    {
        "role": "user",
        "content": "How can I correctly use Django's assertJSONEqual to verify the response of a view that returns a JsonResponse? I am using Python 3.4 and Django 1.7. Here is my view code that returns a JsonResponse:\n\n```python\ndef add_item_to_collection(request):\n    #(...)\n    return JsonResponse({'status':'success'})\n```\n\nAnd, I am attempting to verify the view's response using this unit test:\n\n```python\nclass AddItemToCollectionTest(TestCase):\n\n    def test_success_when_not_added_before(self):\n        response = self.client.post('/add-item-to-collection')\n        self.assertEqual(response.status_code, 200)\n        self.assertJSONEqual(response.content, {'status': 'success'})\n```\n\nHowever, when I run my test, the assertJSONEqual() line raises the following exception:\n\n```python\nError\nTraceback (most recent call last):\n  File \"E:\\Projects\\collecthub\\app\\collecthub\\collecting\\tests.py\", line 148, in test_success_when_added_before\n    self.assertJSONEqual(response.content, {'status': 'OK'})\n  File \"E:\\Projects\\collecthub\\venv\\lib\\site-packages\\django\\test\\testcases.py\", line 675, in assertJSONEqual\n    data = json.loads(raw)\n  File \"C:\\Python34\\Lib\\json\\__init__.py\", line 312, in loads\n    s.__class__.__name__))\nTypeError: the JSON object must be str, not 'bytes'\n```\n\nWhat is the correct way to check the content of such a response? Why am I getting a type error when I try to compare the raw value against a dictionary in assertJSONEqual()?"
    },
    {
        "role": "assistant",
        "content": "The issue you're encountering is due to the fact that in Python 3, `response.content` returns a `bytes` object, while `json.loads()` expects a `str` object. To resolve this, you need to decode the `bytes` object to a `str` before passing it to `json.loads()`. Here's how you can modify your test to work correctly:\n\n```python\nclass AddItemToCollectionTest(TestCase):\n\n    def test_success_when_not_added_before(self):\n        response = self.client.post('/add-item-to-collection')\n        self.assertEqual(response.status_code, 200)\n        # Decode the response content from bytes to str\n        response_content_str = response.content.decode('utf-8')\n        # Use assertJSONEqual with the decoded string\n        self.assertJSONEqual(response_content_str, {'status': 'success'})\n```\n\n### Explanation:\n1. **Decoding**: Since `response.content` is a `bytes` object, you need to decode it into a `str` using `decode('utf-8')`. This converts the byte stream to a string that can be properly handled by `json.loads()` inside `assertJSONEqual`.\n\n2. **assertJSONEqual**: Once you have the `response.content` as a string, `assertJSONEqual` can correctly parse it as JSON and compare it against the dictionary `{'status': 'success'}`.\n\nBy making this change, your test should run without raising a `TypeError`. This change is necessary due to how Python 3 handles strings and bytes differently compared to Python 2."
    }
]