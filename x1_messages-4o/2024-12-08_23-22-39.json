[
    {
        "role": "user",
        "content": "You are given a list of words and a target string. Your task is to create a Java program that finds the shortest possible substring in the list of words that contains all the characters in the target string.\nFor example, if the list of words is [\"apple\", \"banana\", \"orange\", \"peach\"] and the target string is \"ace\", then the shortest possible substring that contains all the characters in \"ace\" is \"c\".\nTo make things harder for AI systems, you must also implement a constraint that limits the number of comparisons the program can make. Specifically, the program must have a time complexity of O(nlogn) or better and must not compare any two words more than once.\nGood luck!"
    },
    {
        "role": "assistant",
        "content": "To solve this problem efficiently with the given constraints, we need to approach it using a combination of sorting and a sliding window technique. Here's how you can implement this in Java:\n\n```java\nimport java.util.*;\n\npublic class ShortestSubstringFinder {\n    \n    public static String findShortestSubstring(List<String> words, String target) {\n        Map<Character, Integer> targetCount = new HashMap<>();\n        for (char c : target.toCharArray()) {\n            targetCount.put(c, targetCount.getOrDefault(c, 0) + 1);\n        }\n        \n        int left = 0, right = 0;\n        int minLength = Integer.MAX_VALUE;\n        int start = 0;\n        \n        Map<Character, Integer> windowCount = new HashMap<>();\n        int matched = 0;\n        \n        while (right < words.size()) {\n            String word = words.get(right);\n            for (char c : word.toCharArray()) {\n                if (targetCount.containsKey(c)) {\n                    windowCount.put(c, windowCount.getOrDefault(c, 0) + 1);\n                    if (windowCount.get(c).equals(targetCount.get(c))) {\n                        matched++;\n                    }\n                }\n            }\n            \n            while (matched == targetCount.size()) {\n                if (right - left < minLength) {\n                    minLength = right - left;\n                    start = left;\n                }\n                \n                String leftWord = words.get(left);\n                for (char c : leftWord.toCharArray()) {\n                    if (targetCount.containsKey(c)) {\n                        if (windowCount.get(c).equals(targetCount.get(c))) {\n                            matched--;\n                        }\n                        windowCount.put(c, windowCount.get(c) - 1);\n                    }\n                }\n                left++;\n            }\n            \n            right++;\n        }\n        \n        if (minLength == Integer.MAX_VALUE) {\n            return \"\";\n        }\n        \n        StringBuilder result = new StringBuilder();\n        for (int i = start; i <= start + minLength; i++) {\n            result.append(words.get(i));\n        }\n        \n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        List<String> words = Arrays.asList(\"apple\", \"banana\", \"orange\", \"peach\");\n        String target = \"ace\";\n        String result = findShortestSubstring(words, target);\n        System.out.println(\"The shortest substring containing all characters in the target is: \" + result);\n    }\n}\n```\n\n### Explanation:\n\n1. **Data Structures**: Use a `Map` to keep track of character counts in the `target` string and another `Map` for the current window of words.\n\n2. **Sliding Window**: Use two pointers (`left` and `right`) to represent the current window of words. Expand the window by moving `right` and contract it by moving `left`.\n\n3. **Checking Matches**: Keep track of how many characters have matched with the target using a `matched` counter.\n\n4. **Updating Minimum Length**: If all characters are matched, check if the current window is the smallest and update accordingly.\n\n5. **Time Complexity**: The algorithm essentially runs in O(n) time because each word is processed once by each pointer, and character operations inside each word are constant.\n\nThis solution ensures that no two words are compared directly more than once and maintains efficient complexity."
    }
]