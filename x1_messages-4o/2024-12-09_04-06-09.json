[
    {
        "role": "user",
        "content": "I am trying to implement the decorator pattern in Python and I am wondering if there is a way to write a decorator that only implements the function it wants to modify, without the need to write boiler-plate for all the functions that need to be forwarded to the decorated object. Is there a way to write a generic method that forwards all unimplemented function-calls to the decorated object?\n\nHere is the initial code I have:\n\n```python\nclass foo(object):\n    def f1(self):\n        print \"original f1\"\n    def f2(self):\n        print \"original f2\"\n\nclass foo_decorator(object):\n    def __init__(self, decoratee):\n        self._decoratee = decoratee\n    def f1(self):\n        print \"decorated f1\"\n        self._decoratee.f1()\n    def f2(self):              # I would like to leave that part out\n        self._decoratee.f2()\n```\n\nI would like to have calls to `foo_decorator.f2` forwarded to `decoratee.f2` automatically, without explicitly implementing `f2` in `foo_decorator`."
    },
    {
        "role": "assistant",
        "content": "You can achieve this behavior by utilizing Python's `__getattr__` method. This special method is called when an attribute is not found in the normal places (i.e., it is not an instance attribute, and it's not found in the class tree for self). By implementing `__getattr__`, you can forward any method or attribute call that isn't explicitly defined in the decorator class to the decorated object. Here's how you can modify your `foo_decorator` class to achieve this:\n\n```python\nclass foo(object):\n    def f1(self):\n        print(\"original f1\")\n    def f2(self):\n        print(\"original f2\")\n\nclass foo_decorator(object):\n    def __init__(self, decoratee):\n        self._decoratee = decoratee\n\n    def f1(self):\n        print(\"decorated f1\")\n        self._decoratee.f1()\n\n    def __getattr__(self, name):\n        # Forward any other attribute/method calls to the decoratee\n        return getattr(self._decoratee, name)\n\n# Usage\ndecorated_foo = foo_decorator(foo())\ndecorated_foo.f1()  # Calls the decorated f1\ndecorated_foo.f2()  # Automatically forwards to the original f2\n```\n\nIn this implementation:\n\n- The method `f1` is explicitly decorated, so it behaves differently.\n- The `__getattr__` method is used to forward any other method or attribute calls to the decorated object (`self._decoratee`). This means that if you call `f2` on an instance of `foo_decorator`, it will automatically be forwarded to the `f2` method of the `foo` instance."
    }
]