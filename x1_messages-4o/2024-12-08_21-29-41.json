[
    {
        "role": "user",
        "content": "In the given JavaScript binary search algorithm to locate the integer value of 8 within the sorted array [2, 3, 6, 7, 8, 10, 12], add a constraint to handle the situation where the array may contain duplicate values and the algorithm should return the index of the first occurrence of the target value with optimal efficiency. Is it possible to modify the existing algorithm to achieve this additional requirement?"
    },
    {
        "role": "assistant",
        "content": "Yes, it is possible to modify the existing binary search algorithm to find the first occurrence of a target value in a sorted array, even if the array contains duplicate values. The idea is to continue the search on the left side of the array whenever the target is found, to ensure that the first occurrence is located. Here's an example of how you can modify the binary search algorithm to achieve this:\n\n```javascript\nfunction binarySearchFirstOccurrence(arr, target) {\n    let left = 0;\n    let right = arr.length - 1;\n    let result = -1;\n\n    while (left <= right) {\n        let mid = Math.floor((left + right) / 2);\n\n        if (arr[mid] === target) {\n            result = mid; // Update result to the current index\n            right = mid - 1; // Continue searching in the left half\n        } else if (arr[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n\n    return result;\n}\n\nconst arr = [2, 3, 6, 7, 8, 8, 10, 12];\nconst target = 8;\nconst index = binarySearchFirstOccurrence(arr, target);\nconsole.log(index); // Output: 4\n```\n\nIn this modified algorithm:\n\n- We maintain a variable `result` to store the index of the first occurrence of the target value.\n- Whenever the target is found, we update `result` and continue searching in the left half of the array by adjusting the `right` pointer to `mid - 1`.\n- This ensures that we find the first occurrence of the target value even if there are duplicates in the array.\n- The algorithm continues to work efficiently with a time complexity of O(log n)."
    }
]