[
    {
        "role": "user",
        "content": "I am working on a Django application where I need to save both the old and new values whenever changes are made to a model. This is for the purpose of premoderation of content, so that an administrator can view all changes in a separate table and make a decision whether to apply them or not. Could anyone provide examples or working code to solve this problem?"
    },
    {
        "role": "assistant",
        "content": "To implement pre-moderation of changes in a Django application, you can create a change log model that will store the old and new values of the fields whenever a change is made to a model instance. Below is an approach you can use to achieve this:\n\n1. Define a `ChangeLog` model to store changes.\n\n2. Override the `save` method of the model you want to track to create a change log entry.\n\n3. Create an admin interface to allow administrators to approve or reject changes.\n\nHere's a step-by-step example:\n\n### Step 1: Define the `ChangeLog` model\n\nCreate a `ChangeLog` model that will store changes to the fields of your tracked model.\n\n```python\nfrom django.db import models\nfrom django.contrib.auth.models import User\n\nclass ChangeLog(models.Model):\n    model_name = models.CharField(max_length=255)\n    instance_id = models.PositiveIntegerField()\n    field_name = models.CharField(max_length=255)\n    old_value = models.TextField(null=True, blank=True)\n    new_value = models.TextField(null=True, blank=True)\n    change_made_by = models.ForeignKey(User, on_delete=models.SET_NULL, null=True, blank=True)\n    change_date = models.DateTimeField(auto_now_add=True)\n    is_approved = models.BooleanField(default=False)\n\n    def __str__(self):\n        return f\"Change in {self.model_name} (ID: {self.instance_id}) - {self.field_name}\"\n```\n\n### Step 2: Override the `save` method\n\nOverride the `save` method of the model you want to track changes for.\n\n```python\nfrom django.db import models\nfrom django.contrib.auth.models import User\nfrom .models import ChangeLog\n\nclass TrackedModel(models.Model):\n    name = models.CharField(max_length=255)\n    description = models.TextField()\n\n    def save(self, *args, **kwargs):\n        if self.pk:  # Check if the object already exists (i.e., it's being updated)\n            old_instance = TrackedModel.objects.get(pk=self.pk)\n            for field in self._meta.fields:\n                field_name = field.name\n                if field_name in ['id']:  # Skip the 'id' field\n                    continue\n                old_value = getattr(old_instance, field_name)\n                new_value = getattr(self, field_name)\n                if old_value != new_value:\n                    ChangeLog.objects.create(\n                        model_name=self.__class__.__name__,\n                        instance_id=self.pk,\n                        field_name=field_name,\n                        old_value=old_value,\n                        new_value=new_value,\n                        change_made_by=kwargs.get('user', None)\n                    )\n        super(TrackedModel, self).save(*args, **kwargs)\n```\n\n### Step 3: Admin Interface for Approving Changes\n\nYou can add a simple admin interface to review and approve/reject changes.\n\n```python\nfrom django.contrib import admin\nfrom .models import ChangeLog, TrackedModel\n\nclass ChangeLogAdmin(admin.ModelAdmin):\n    list_display = ('model_name', 'instance_id', 'field_name', 'old_value', 'new_value', 'is_approved')\n    actions = ['approve_changes']\n\n    def approve_changes(self, request, queryset):\n        for change_log in queryset:\n            if not change_log.is_approved:\n                # Update the actual model instance\n                model_class = apps.get_model(app_label='your_app_name', model_name=change_log.model_name)\n                instance = model_class.objects.get(pk=change_log.instance_id)\n                setattr(instance, change_log.field_name, change_log.new_value)\n                instance.save()\n                change_log.is_approved = True\n                change_log.save()\n\n    approve_changes.short_description = \"Approve selected changes\"\n\nadmin.site.register(ChangeLog, ChangeLogAdmin)\nadmin.site.register(TrackedModel)\n```\n\n### Additional Considerations\n\n- **User Tracking:** Ensure that when calling `save`, you pass the current user to track who made the changes.\n- **Concurrency:** Consider handling any concurrent updates that might affect change tracking.\n- **Security:** Ensure the user has the right permissions to approve or reject changes.\n\nThis setup provides a basic framework for pre-moderation by logging changes and allowing an admin to approve them before they are applied. Adjust and extend this solution as needed to fit your specific use case."
    }
]