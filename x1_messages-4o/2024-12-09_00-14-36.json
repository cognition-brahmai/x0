[
    {
        "role": "user",
        "content": "I am a beginner in Python and having trouble understanding inheritance and the `__init__()` method. I have two classes, `Num` and `Num2`, where `Num2` inherits from `Num`. In the first class `Num`, I have an `__init__()` method that initializes a variable `n1`. In the second class `Num2`, I have a method `show()` that prints `n1`. This works fine. However, when I add an `__init__()` method in `Num2` that initializes a new variable `n2`, the code throws an error that `Num2` has no attribute `n1`. How can `Num2` access `n1` in this case?\n\nHere is my code:\n\n```python\nclass Num:\n    def __init__(self,num):\n        self.n1 = num\n\nclass Num2(Num):\n    def show(self):\n        print self.n1\n\nmynumber = Num2(8)\nmynumber.show()\n```\n\nThis works fine and prints `8`.\n\nBut when I modify `Num2` like this:\n\n```python\nclass Num2(Num):\n    def __init__(self,num):\n        self.n2 = num*2\n    def show(self):\n        print self.n1,self.n2\n```\n\nI get an error that `Num2` has no attribute `n1`. How can I solve this?"
    },
    {
        "role": "assistant",
        "content": "The problem you're encountering arises because when you add a custom `__init__()` method to the `Num2` class, it overrides the `__init__()` method of its parent class `Num`. This means the initialization logic in `Num` is no longer automatically executed when you create an instance of `Num2`.\n\nTo ensure that the initialization logic from the parent class is executed as well, you need to explicitly call the `__init__()` method of the parent class inside the `__init__()` method of the child class. You can do this using the `super()` function. Here's how you can modify your code to solve the problem:\n\n```python\nclass Num:\n    def __init__(self, num):\n        self.n1 = num\n\nclass Num2(Num):\n    def __init__(self, num):\n        super().__init__(num)  # Call the parent's __init__ method\n        self.n2 = num * 2\n    \n    def show(self):\n        print(self.n1, self.n2)\n\nmynumber = Num2(8)\nmynumber.show()\n```\n\nWith this modification, when you create an instance of `Num2`, it will first call the `__init__()` method of `Num` to initialize `n1`, and then proceed with the additional initialization logic in `Num2` to set `n2`. This way, both `n1` and `n2` are properly initialized, and you won't encounter an error when trying to access `n1`."
    }
]