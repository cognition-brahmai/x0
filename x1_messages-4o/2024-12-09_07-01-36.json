[
    {
        "role": "user",
        "content": "How can I add custom decorators to FastAPI endpoints? I have written an `auth_required` decorator that I want to apply to my endpoints. However, the two ways I've tried to apply it haven't worked. The first method doesn't function because `router.post` creates a router that gets saved into the APIRouter object's `self.routes`. The second method fails to verify the pydantic object and for any request model, it produces an error saying `missing args, missing kwargs`. Should I modify the existing endpoint in `router.routes` or should I use something like `functools.wraps`?\n\nHere is the code for my decorator:\n```python\ndef auth_required(func):\n    def wrapper(*args, **kwargs):\n        if user_ctx.get() is None:\n            raise HTTPException(...)\n        return func(*args, **kwargs)\n    return wrapper\n```\nAnd here are the two ways I've tried to use it:\n```python\n@auth_required\n@router.post(...)\n```\nand\n```python\n@router.post(...)\n@auth_required\n```"
    },
    {
        "role": "assistant",
        "content": "When working with FastAPI and trying to apply custom decorators like `auth_required`, it's important to ensure the decorator is compatible with FastAPI's dependency injection system. The issue you're facing is likely due to the way the decorator interacts with FastAPI's request handling and Pydantic model validation. \n\nHere\u2019s a way to apply your `auth_required` decorator correctly:\n\n1. **Use `functools.wraps`**: This will ensure that metadata from the original function (like its name and docstring) is preserved, which can be important for FastAPI's automatic documentation generation.\n\n2. **Modify the decorator to handle HTTP requests**: Make sure that the decorator can work with FastAPI's request and response cycle. This might involve adjusting how arguments are passed through the decorator.\n\nHere's how you can modify your `auth_required` decorator and apply it:\n\n### Modify the `auth_required` Decorator\n\n```python\nfrom functools import wraps\nfrom fastapi import HTTPException\nfrom fastapi import Request\nfrom typing import Callable\n\ndef auth_required(func: Callable) -> Callable:\n    @wraps(func)\n    async def wrapper(*args, **kwargs):\n        # Ensure the request is passed in correctly\n        request: Request = kwargs.get('request')\n        if request is None:\n            for arg in args:\n                if isinstance(arg, Request):\n                    request = arg\n                    break\n        \n        # Check your user context or authentication logic\n        if user_ctx.get() is None:\n            raise HTTPException(status_code=401, detail=\"Unauthorized\")\n        \n        return await func(*args, **kwargs)\n    return wrapper\n```\n\n### Apply the Decorator to an Endpoint\n\nWhen applying the decorator, make sure it's used after the `@router` decorator:\n\n```python\nfrom fastapi import APIRouter, Request\n\nrouter = APIRouter()\n\n@router.post(\"/your-endpoint\")\n@auth_required\nasync def your_endpoint(request: Request, your_model: YourModel):\n    # Your endpoint logic here\n    return {\"message\": \"Success\"}\n```\n\n### Explanation\n\n- **Order of Decorators**: By placing `@auth_required` after `@router.post(...)`, you ensure that the endpoint is registered with FastAPI properly and then wrapped by your decorator.\n  \n- **Handling `Request`**: The decorator now tries to extract the `Request` object from either `args` or `kwargs`. This ensures you can access request-specific data like headers or user context within the decorator.\n\n- **Asynchronous Support**: The `wrapper` function is defined as `async` and uses `await` to call `func`, ensuring compatibility with async endpoints, which is typical in FastAPI.\n\nBy following these steps, you should be able to apply your custom `auth_required` decorator to FastAPI endpoints effectively."
    }
]