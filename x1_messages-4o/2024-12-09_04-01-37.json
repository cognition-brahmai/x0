[
    {
        "role": "user",
        "content": "I am trying to understand why `__new__` in Python new-style classes is not a class method. The Changelog for Python 2.2, where new-style classes were introduced, says the following about the `__new__` function: \"`__new__` is a static method, not a class method. I initially thought it would have to be a class method, and that's why I added the `classmethod` primitive. Unfortunately, with class methods, upcalls don't work right in this case, so I had to make it a static method with an explicit class as its first argument.\" I'm not clear on why class methods wouldn't work for this purpose and why `__new__` ended up not being a class method. Can anyone explain what Guido refers to when he says that \"upcalls don't work right in this case\"?"
    },
    {
        "role": "assistant",
        "content": "The choice to make `__new__` a static method rather than a class method in Python's new-style classes is rooted in how `__new__` is intended to function and how method resolution works, especially concerning inheritance and method calls up the class hierarchy.\n\nHere's a breakdown of why `__new__` is a static method and not a class method:\n\n1. **Role of `__new__`**: The `__new__` method is responsible for creating a new instance of a class. It is called before `__init__`, and it's the method that actually allocates memory for the instance. Because of this, `__new__` needs to be able to decide which class to instantiate, which is passed as the first argument.\n\n2. **Static vs. Class Method**:\n   - A static method, like `__new__`, does not receive the class as its implicit first argument. Instead, it receives the class explicitly as its first parameter (usually named `cls`). This allows `__new__` to be flexible and to instantiate the appropriate class directly.\n   - A class method, on the other hand, automatically receives the class it was called on as its first argument. While this might seem convenient, it introduces complications when you're dealing with inheritance and calling `super()`.\n\n3. **Upcalls and Inheritance**:\n   - When using inheritance, you often want to call the superclass's method using `super()`. If `__new__` were a class method, it would automatically pass the current class, not the superclass, which complicates the instantiation process.\n   - With `__new__` as a static method, you explicitly pass the class you want to instantiate. This makes it straightforward to control and ensures that the correct class is instantiated, which is particularly important when you're dealing with multiple inheritance or complex inheritance hierarchies.\n\nGuido's mention of \"upcalls don't work right\" refers to these complications that arise when trying to manage the class being passed around automatically in a hierarchy. By making `__new__` a static method, Python avoids these complications, allowing developers to explicitly manage class instantiation and making the method more predictable and flexible in complex inheritance scenarios."
    }
]