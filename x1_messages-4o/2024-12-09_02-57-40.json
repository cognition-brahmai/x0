[
    {
        "role": "user",
        "content": "How can I create multiple ModelAdmins or views for the same model in Django admin? Specifically, I have a Django model called Posts and I want to customize the list of objects displayed on the page in different ways by setting variables such as list_display or overriding the queryset method in my ModelAdmin. For example, at the URL /admin/myapp/post, I want to list all post objects; at /admin/myapp/myposts, I want to list all posts belonging to the user; and at /admin/myapp/draftpost, I want to list all posts that have not yet been published. However, when I try to register more than one ModelAdmin for the same model, I encounter an AlreadyRegistered exception. Ideally, I would like to avoid putting everything into a single ModelAdmin class and writing my own 'urls' function to return a different queryset depending on the URL."
    },
    {
        "role": "assistant",
        "content": "To create multiple views for the same model in Django Admin, you can use a combination of custom admin views and proxy models. Here's how you can achieve that:\n\n### Step 1: Define Proxy Models\n\nProxy models allow you to create different representations of the same underlying database table. By using proxy models, you can register multiple `ModelAdmin` classes for the same table.\n\n```python\nfrom django.db import models\n\nclass Post(models.Model):\n    title = models.CharField(max_length=255)\n    content = models.TextField()\n    author = models.ForeignKey(User, on_delete=models.CASCADE)\n    published = models.BooleanField(default=False)\n    # Other fields...\n\n    def __str__(self):\n        return self.title\n\nclass PostProxyAll(Post):\n    class Meta:\n        proxy = True\n        verbose_name = 'All Post'\n        verbose_name_plural = 'All Posts'\n\nclass PostProxyUser(Post):\n    class Meta:\n        proxy = True\n        verbose_name = 'My Post'\n        verbose_name_plural = 'My Posts'\n\nclass PostProxyDraft(Post):\n    class Meta:\n        proxy = True\n        verbose_name = 'Draft Post'\n        verbose_name_plural = 'Draft Posts'\n```\n\n### Step 2: Register Proxy Models with Custom ModelAdmin Classes\n\nCreate different `ModelAdmin` classes for each view you want to implement and register them with the corresponding proxy models.\n\n```python\nfrom django.contrib import admin\n\nclass PostAdmin(admin.ModelAdmin):\n    list_display = ['title', 'author', 'published']\n    # Customize as needed\n\nclass MyPostAdmin(admin.ModelAdmin):\n    list_display = ['title', 'author', 'published']\n\n    def get_queryset(self, request):\n        qs = super().get_queryset(request)\n        return qs.filter(author=request.user)\n\nclass DraftPostAdmin(admin.ModelAdmin):\n    list_display = ['title', 'author', 'published']\n\n    def get_queryset(self, request):\n        qs = super().get_queryset(request)\n        return qs.filter(published=False)\n\nadmin.site.register(PostProxyAll, PostAdmin)\nadmin.site.register(PostProxyUser, MyPostAdmin)\nadmin.site.register(PostProxyDraft, DraftPostAdmin)\n```\n\n### Step 3: Customize the Admin URLs\n\nThe models should automatically appear in the admin under the names defined in their `Meta` class, but if you want to customize the URLs further, you might need to extend the admin views. However, using proxy models as shown above will give you separate sections in the admin interface with different querysets.\n\n### Additional Customization\n\nIf you need more customization, such as custom templates or additional views, you can create custom admin views by extending the admin URLs. Here\u2019s a basic outline:\n\n1. **Override the admin site URLs**: Define a custom admin site class and override the `get_urls` method.\n\n2. **Add custom views**: Use view functions and link them to specific URLs.\n\nBy using proxy models, you effectively avoid the `AlreadyRegistered` exception while allowing multiple views for the same underlying model data."
    }
]