[
    {
        "role": "user",
        "content": "How can I use Django ORM to annotate a count with a condition? Specifically, I want to get all published articles from my models, sorted by unique readership from the last 30 minutes. This means I want to count how many distinct views each published article got in the last half an hour, and then produce a list of articles sorted by these distinct views. I tried a certain solution but it resulted in a syntax error. Here's the code I used:\n\n```python\nclass Article(models.Model):\n    author = models.ForeignKey(User)\n    published = models.BooleanField(default=False)\n\nclass Readership(models.Model):\n    reader = models.ForeignKey(User)\n    which_article = models.ForeignKey(Article)\n    what_time = models.DateTimeField(auto_now_add=True)\n```\n\n```python\ndate = datetime.now()-timedelta(minutes=30)\narticles = Article.objects.filter(published=True).extra(select = {\n  \"views\" : \"\"\"\n  SELECT COUNT(*)\n  FROM myapp_readership\n    JOIN myapp_article on myapp_readership.which_article_id = myapp_article.id\n  WHERE myapp_readership.reader_id = myapp_user.id\n  AND myapp_readership.what_time > %s \"\"\" % date,\n}).order_by(\"-views\")\n```\nThe error I received was: syntax error at or near \"01\" (where \"01\" was the datetime object inside extra)."
    },
    {
        "role": "assistant",
        "content": "To achieve your goal of counting distinct views for each published article from the last 30 minutes, and then sorting these articles by the number of distinct views, you should use `annotate` along with `Count` and `Q` objects in Django ORM. The `extra` method is generally not recommended because it introduces raw SQL, which can be error-prone and database-specific.\n\nHere's how you can refactor your query using Django ORM:\n\n```python\nfrom django.db.models import Count, Q\nfrom django.utils import timezone\nfrom datetime import timedelta\n\n# Calculate the time 30 minutes ago from now\ndate_threshold = timezone.now() - timedelta(minutes=30)\n\n# Annotate each article with a count of distinct views in the last 30 minutes\narticles = Article.objects.filter(\n    published=True\n).annotate(\n    unique_views=Count(\n        'readership', \n        filter=Q(readership__what_time__gt=date_threshold), \n        distinct=True\n    )\n).order_by('-unique_views')\n\n# Now `articles` will be sorted by the number of distinct views in descending order\n```\n\n### Explanation:\n1. **`timezone.now()`**: Use `timezone.now()` instead of `datetime.now()` to ensure compatibility with Django's time zone settings.\n   \n2. **`filter=Q(...)`**: Use `Q` objects to filter the related `Readership` objects with a condition that the `what_time` is greater than the calculated threshold (`date_threshold`).\n\n3. **`Count` with `distinct=True`**: Count distinct `readership` entries by specifying `distinct=True`. This ensures you're counting unique views per article.\n\n4. **`order_by('-unique_views')`**: Sort articles by the annotated field `unique_views` in descending order.\n\nThis approach leverages Django ORM capabilities and avoids raw SQL, making it more readable, maintainable, and portable across different database backends."
    }
]