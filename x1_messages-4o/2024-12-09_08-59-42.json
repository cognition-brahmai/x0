[
    {
        "role": "user",
        "content": "I have a code snippet that checks a given value against multiple ranges and returns a specific message based on the range it falls into. However, the code is not very readable and reusable. How can I reorganize it to make it more readable and reusable?"
    },
    {
        "role": "assistant",
        "content": "To improve the readability and reusability of your code, you can refactor it by using functions and a more structured approach. Here's a general idea of how you can reorganize your code:\n\n1. **Use Functions**: Break down the code into smaller functions that handle specific tasks. This will make it easier to read and maintain.\n\n2. **Use Data Structures**: Use lists or dictionaries to define the ranges and their corresponding messages. This makes the code more flexible and easier to update.\n\n3. **Use Looping and Conditional Logic**: Simplify the logic by using loops and conditional statements to check the ranges.\n\nHere's an example of how you might refactor your code:\n\n```python\ndef get_message_for_value(value, ranges):\n    \"\"\"\n    Determines the message for a given value based on predefined ranges.\n\n    :param value: The value to check.\n    :param ranges: A list of tuples, where each tuple contains the range (inclusive) and the corresponding message.\n    :return: The message corresponding to the range the value falls into, or a default message if no range matches.\n    \"\"\"\n    for range_tuple in ranges:\n        lower_bound, upper_bound, message = range_tuple\n        if lower_bound <= value <= upper_bound:\n            return message\n    return \"Value out of range\"\n\ndef main():\n    # Define the ranges and corresponding messages\n    ranges = [\n        (0, 10, \"Value is between 0 and 10\"),\n        (11, 20, \"Value is between 11 and 20\"),\n        (21, 30, \"Value is between 21 and 30\"),\n        # Add more ranges as needed\n    ]\n\n    # Example usage\n    value_to_check = 15\n    message = get_message_for_value(value_to_check, ranges)\n    print(message)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Key Points:\n- **Data Structure**: The `ranges` list holds tuples, each containing a lower bound, an upper bound, and a message. This makes it easy to add or modify ranges and messages.\n- **Function**: The `get_message_for_value` function encapsulates the logic for determining the message based on the value and the ranges, making the code more modular.\n- **Readability**: The code is organized and easy to follow, with clear separation of logic and data.\n\nBy using this approach, your code becomes more readable, maintainable, and easier to extend with additional ranges and messages."
    }
]