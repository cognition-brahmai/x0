[
    {
        "role": "user",
        "content": "What is the most Pythonic way to declare an abstract class property? For instance, I'm writing an abstract class where its non-abstract class methods require the concrete class to have a specific class attribute. For instance, if instances of each concrete class can be constructed by matching against a different regular expression, I want to give my ABC the following:\n\n```python\n@classmethod\ndef parse(cls, s):\n    m = re.fullmatch(cls.PATTERN, s)\n    if not m:\n        raise ValueError(s)\n    return cls(**m.groupdict())\n```\nSince overriding of abstract methods and properties is checked at instance creation time, not at subclass creation time, using `abc.abstractmethod` to ensure concrete classes have `PATTERN` attributes won't work. However, I want something there to indicate that I didn't forget to define `PATTERN` on the ABC; the concrete classes are supposed to define their own. What is the most Pythonic way to achieve this?\n\nI have considered the following options:\n\n- Pile of decorators:\n\n```python\n@property\n@abc.abstractmethod\ndef PATTERN(self):\n    pass\n```\n- Tower of decorators:\n\n```python\n@property\n@classmethod\n@abc.abstractmethod\ndef PATTERN(cls):\n    pass\n```\n- Dummy value:\n\n```python\nPATTERN = ''\n```\n- Error-inducing dummy value:\n\n```python\nPATTERN = None\n```\n- Do nothing: There can be a note in the ABC's docstring somewhere, but the ABC itself shouldn't have anything in the way of a `PATTERN` attribute.\n- Any other options?"
    },
    {
        "role": "assistant",
        "content": "To create an abstract class property that requires subclasses to define a specific class attribute in Python, you can use the `abc` module effectively. However, since `abc.abstractmethod` is typically used for instance methods, not class attributes, a different approach is necessary.\n\nHere are some Pythonic ways to enforce the presence of a class attribute like `PATTERN`:\n\n### Using a Metaclass Approach\n\nYou can define a metaclass to enforce the presence of the `PATTERN` attribute:\n\n```python\nimport abc\n\nclass MetaPattern(abc.ABCMeta):\n    def __init__(cls, name, bases, namespace):\n        super().__init__(name, bases, namespace)\n        if not hasattr(cls, 'PATTERN'):\n            raise TypeError(f\"Class {name} must define a class attribute 'PATTERN'.\")\n\nclass AbstractBase(metaclass=MetaPattern):\n    @classmethod\n    def parse(cls, s):\n        import re\n        m = re.fullmatch(cls.PATTERN, s)\n        if not m:\n            raise ValueError(s)\n        return cls(**m.groupdict())\n```\n\n### Using a Class Method with Assertion\n\nAnother approach is to use a class method with an assertion:\n\n```python\nimport abc\nimport re\n\nclass AbstractBase(abc.ABC):\n    @classmethod\n    def parse(cls, s):\n        assert cls.PATTERN is not None, \"Subclasses must define a PATTERN class attribute\"\n        m = re.fullmatch(cls.PATTERN, s)\n        if not m:\n            raise ValueError(s)\n        return cls(**m.groupdict())\n\nclass ConcreteClass(AbstractBase):\n    PATTERN = r\"\\d+\"\n\n# This will raise an AssertionError if PATTERN is not defined\nconcrete = ConcreteClass()\nconcrete.parse('123')\n```\n\n### Dummy Value with Abstract Property\n\nThough you've mentioned some options already, using a dummy value combined with abstract property can work too. Use this for documentation and signaling intent:\n\n```python\nimport abc\nimport re\n\nclass AbstractBase(abc.ABC):\n    PATTERN = None  # Indicate this should be overridden\n\n    @classmethod\n    @abc.abstractmethod\n    def pattern(cls):\n        pass\n\n    @classmethod\n    def parse(cls, s):\n        if cls.PATTERN is None:\n            raise NotImplementedError(f\"{cls.__name__} must define a PATTERN class attribute.\")\n        m = re.fullmatch(cls.PATTERN, s)\n        if not m:\n            raise ValueError(s)\n        return cls(**m.groupdict())\n\nclass ConcreteClass(AbstractBase):\n    PATTERN = r\"\\d+\"\n\n    @classmethod\n    def pattern(cls):\n        return cls.PATTERN\n\n# This will work as PATTERN is defined\nconcrete = ConcreteClass()\nconcrete.parse('123')\n```\n\n### Summary\n\n- **Metaclass Approach**: Provides compile-time check on class attribute presence, which is very clean.\n- **Assertion in Class Method**: Offers a runtime check with clear error messaging.\n- **Dummy Value with Abstract Property**: Signals intent and provides documentation that the attribute should be overridden.\n\nThe best approach depends on your specific needs and how strict you want the enforcement to be. The metaclass method is generally the most robust for ensuring attribute presence at class definition time."
    }
]