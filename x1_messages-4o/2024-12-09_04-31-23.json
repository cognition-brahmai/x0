[
    {
        "role": "user",
        "content": "In Python, when defining a function with an array parameter, what is the scope of that parameter? For instance, when using the following code:\n\n```python\ndef f(a, L=[]):\n    L.append(a)\n    return L\n\nprint f(1)\nprint f(2)\nprint f(3)\n```\n\nThe output is:\n\n```python\n[1]\n[1, 2]\n[1, 2, 3]\n```\n\nThis is confusing as I would expect this behavior only if the array was static and it should be reset with each call. But in the second example where I define the list inside the function:\n\n```python\ndef f(a):\n    L = []\n    L.append(a)\n    return L\n```\n\nI see the expected behavior (the array is reset on each call). Can you please explain the line `def f(a, L=[]):` and what is the scope of the `L` variable?"
    },
    {
        "role": "assistant",
        "content": "The behavior you're observing in the first example is due to how default arguments work in Python. When you define a function with a default argument like `L=[]`, the default value is evaluated only once at the point of function definition, not each time the function is called. This means that if the default value is a mutable object like a list, all calls to the function that don't provide their own `L` argument will share the same list.\n\nHere's a step-by-step explanation of what's happening in your first example:\n\n1. When you define the function `f(a, L=[])`, the default list `L` is created once and is shared across all calls to `f` that don't specify a second argument.\n\n2. The first call `f(1)` appends `1` to the list `L`, so `L` becomes `[1]`.\n\n3. The second call `f(2)` appends `2` to the same list `L`, which is now `[1, 2]`.\n\n4. The third call `f(3)` appends `3` to the same list `L`, resulting in `[1, 2, 3]`.\n\nIn contrast, in your second example:\n\n```python\ndef f(a):\n    L = []\n    L.append(a)\n    return L\n```\n\nA new list `L` is created every time the function is called, so each call gets its own separate list, and the output is as expected for each call.\n\nTo avoid this behavior with mutable default arguments, you can use `None` as the default value and then check for it inside the function, creating a new list if necessary:\n\n```python\ndef f(a, L=None):\n    if L is None:\n        L = []\n    L.append(a)\n    return L\n```\n\nThis pattern ensures that a new list is created for each call to the function that doesn't provide an `L` argument, preventing the shared state issue you encountered."
    }
]