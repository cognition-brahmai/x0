[
    {
        "role": "user",
        "content": "How can I use a tensorflow metric function within keras models in Python 3.5.2 and Tensorflow rc 1.1?\n\nI tried to call the tensorflow metric function in keras using the following code:\n\n```python\nimport pandas\nimport numpy\nimport tensorflow.contrib.keras as keras\nimport tensorflow\n\ndef target_function(row):\n    return float(row[0] - row[1] < 0.5)\n\ndf = pandas.DataFrame(numpy.random.rand(10000,2))\nlabel = df.apply(target_function, axis=1)\n\ninput_layer = keras.layers.Input(shape=(2,))\nnet = keras.layers.Dense(1)(input_layer)\n\nmodel = keras.models.Model(inputs=[input_layer], outputs=[net])\nmodel.compile(loss='binary_crossentropy', optimizer='adam', metrics=[tensorflow.metrics.auc])\n\nmodel.fit(df.as_matrix(), label.as_matrix(), epochs=10, validation_split=0.2, batch_size=100)\n```\n\nBut it results in the following error:\n\n```\nUsing TensorFlow backend.\nTraceback (most recent call last):\n  File \"/Users/ophir/dev/ophir/tf_keras_metrics.py\", line 49, in <module>\n    metrics=[precision, recall, tensorflow.metrics.auc]\n  File \"/Users/ophir/anaconda3/envs/p3/lib/python3.5/site-packages/keras/engine/training.py\", line 956, in compile\n    metric_result = masked_metric_fn(y_true, y_pred, mask=masks[i])\n  File \"/Users/ophir/anaconda3/envs/p3/lib/python3.5/site-packages/keras/engine/training.py\", line 489, in masked\n    return K.mean(score_array)\n  File \"/Users/ophir/anaconda3/envs/p3/lib/python3.5/site-packages/keras/backend/tensorflow_backend.py\", line 1120, in mean\n    axis = _normalize_axis(axis, ndim(x))\n  File \"/Users/ophir/anaconda3/envs/p3/lib/python3.5/site-packages/keras/backend/tensorflow_backend.py\", line 437, in ndim\n    dims = x.get_shape()._dims\nAttributeError: 'tuple' object has no attribute 'get_shape'\n```\n\nAfter incorporating a suggestion, I changed my code to:\n\n```python\nimport pandas\nimport numpy\nimport tensorflow.contrib.keras as keras\nimport tensorflow\n\ndef metric_function(y_true, y_pred):\n    return tensorflow.metrics.precision(y_true,y_pred)[0]\n\ndef target_function(row):\n    return float(row[0] - row[1] < 0.5)\n\ndf = pandas.DataFrame(numpy.random.rand(10000,2))\nlabel = df.apply(target_function, axis=1)\n\ninput_layer = keras.layers.Input(shape=(2,))\nnet = keras.layers.Dense(1)(input_layer)\n\nmodel = keras.models.Model(inputs=[input_layer], outputs=[net])\nmodel.compile(loss='binary_crossentropy', optimizer='adam', metrics=[metric_function])\n\nmodel.fit(df.as_matrix(), label.as_matrix(), epochs=10, validation_split=0.2, batch_size=100)\n```\n\nBut I still encountered an error:\n\n```\n/Users/ophir/anaconda3/envs/p3/bin/python /Users/ophir/dev/ophir/tf_keras_metrics.py\nTrain on 8000 samples, validate on 2000 samples\nEpoch 1/10\n2017-04-04 16:05:30.959006: W tensorflow/core/platform/cpu_feature_guard.cc:45] The TensorFlow library wasn't compiled to use SSE4.2 instructions, but these are available on your machine and could speed up CPU computations.\n2017-04-04 16:05:30.959022: W tensorflow/core/platform/cpu_feature_guard.cc:45] The TensorFlow library wasn't compiled to use AVX instructions, but these are available on your machine and could speed up CPU computations.\n2017-04-04 16:05:30.959026: W tensorflow/core/platform/cpu_feature_guard.cc:45] The TensorFlow library wasn't compiled to use AVX2 instructions, but these are available on your machine and could speed up CPU computations.\n2017-04-04 16:05:30.959031: W tensorflow/core/platform/cpu_feature_guard.cc:45] The TensorFlow library wasn't compiled to use FMA instructions, but these are available on your machine and could speed up CPU computations.\n2017-04-04 16:05:31.124262: W tensorflow/core/framework/op_kernel.cc:1152] Failed precondition: Attempting to use uninitialized value precision/true_positives/count\n     [[Node: precision/true_positives/count/read = Identity[T=DT_FLOAT, _class=[\"loc:@precision/true_positives/count\"], _device=\"/job:localhost/replica:0/task:0/cpu:0\"](precision/true_positives/count)]]\nTraceback (most recent call last):\n  File \"/Users/ophir/anaconda3/envs/p3/lib/python3.5/site-packages/tensorflow/python/client/session.py\", line 1051, in _do_call\n    return fn(*args)\n  File \"/Users/ophir/anaconda3/envs/p3/lib/python3.5/site-packages/tensorflow/python/client/session.py\", line 1033, in _run_fn\n    status, run_metadata)\n  File \"/Users/ophir/anaconda3/envs/p3/lib/python3.5/contextlib.py\", line 66, in __exit__\n    next(self.gen)\n  File \"/Users/ophir/anaconda3/envs/p3/lib/python3.5/site-packages/tensorflow/python/framework/errors_impl.py\", line 466, in raise_exception_on_not_ok_status\n    pywrap_tensorflow.TF_GetCode(status))\ntensorflow.python.framework.errors_impl.FailedPreconditionError: Attempting to use uninitialized value precision/true_positives/count\n     [[Node: precision/true_positives/count/read = Identity[T=DT_FLOAT, _class=[\"loc:@precision/true_positives/count\"], _device=\"/job:localhost/replica:0/task:0/cpu:0\"](precision/true_positives/count)]]\n```\n\nHow can I resolve this?"
    },
    {
        "role": "assistant",
        "content": "The error you are encountering is due to the fact that TensorFlow metric functions, such as `tensorflow.metrics.precision`, rely on local variables to maintain state (e.g., counts of true positives and false positives). These variables need to be initialized before they are used, which is why you are seeing an error about uninitialized variables.\n\nTo resolve this issue, you can use Keras's custom metric functions, which do not rely on TensorFlow's local variables. Here's how you can modify your code:\n\n1. Define a custom metric function using Keras backend functions.\n2. Ensure that your custom metric function computes the desired metric directly using the predicted and true labels.\n\nHere is an example of how you can modify your code to compute the precision metric:\n\n```python\nimport pandas as pd\nimport numpy as np\nimport tensorflow as tf\nfrom tensorflow.keras import layers, models, backend as K\n\ndef precision(y_true, y_pred):\n    # Round predictions to the nearest integer\n    y_pred = K.round(y_pred)\n    # Calculate true positives\n    true_positives = K.sum(K.round(K.clip(y_true * y_pred, 0, 1)))\n    # Calculate predicted positives\n    predicted_positives = K.sum(K.round(K.clip(y_pred, 0, 1)))\n    # Calculate precision\n    precision_value = true_positives / (predicted_positives + K.epsilon())\n    return precision_value\n\ndef target_function(row):\n    return float(row[0] - row[1] < 0.5)\n\n# Create DataFrame and labels\ndf = pd.DataFrame(np.random.rand(10000, 2))\nlabel = df.apply(target_function, axis=1)\n\n# Define Keras model\ninput_layer = layers.Input(shape=(2,))\nnet = layers.Dense(1, activation='sigmoid')(input_layer)\n\nmodel = models.Model(inputs=[input_layer], outputs=[net])\nmodel.compile(loss='binary_crossentropy', optimizer='adam', metrics=[precision])\n\n# Train model\nmodel.fit(df.to_numpy(), label.to_numpy(), epochs=10, validation_split=0.2, batch_size=100)\n```\n\n### Key Points:\n- The custom `precision` function uses Keras backend functions to compute the precision metric.\n- We use `K.round` and `K.clip` to ensure that the predictions and labels are binary (0 or 1).\n- `K.epsilon()` is used to avoid division by zero.\n\nThis approach should work without requiring manual initialization of TensorFlow local variables. Adjust the metric function as needed for other metrics like recall or AUC."
    }
]