[
    {
        "role": "user",
        "content": "I am working with a legacy database table that has a composite primary key. I checked that Django does not support tables without a primary key (non-composite). Due to some existing code that uses this table, I am unable to change the structure to include a surrogate key. My question is, do Django models support composite primary keys? If not, is there any workaround for this problem without changing the structure of the table? Just to note, I am using PostgreSQL."
    },
    {
        "role": "assistant",
        "content": "Django, by default, does not provide built-in support for composite primary keys. However, there are workarounds you can consider to handle this situation without altering the existing table structure:\n\n1. **Manual Primary Key Management**: You can define a Django model without specifying a primary key, and Django will allow you to manage the primary key manually. You can use the `unique_together` option in the model's `Meta` class to enforce the uniqueness constraint that the composite key represents.\n\n    Here's an example:\n\n    ```python\n    from django.db import models\n\n    class LegacyTable(models.Model):\n        key_part1 = models.IntegerField()\n        key_part2 = models.IntegerField()\n        other_field = models.CharField(max_length=100)\n\n        class Meta:\n            managed = False  # Prevents Django from trying to manage the table's schema\n            db_table = 'legacy_table'\n            unique_together = (('key_part1', 'key_part2'),)\n    ```\n\n2. **Using a Third-Party Library**: There are third-party libraries like `django-compositekey` that provide support for composite primary keys. You can use these libraries to help manage models with composite keys.\n\n    You can install the library and then modify your model as follows:\n\n    ```bash\n    pip install django-compositekey\n    ```\n\n    ```python\n    from compositekey import CompositeKey\n    from django.db import models\n\n    class LegacyTable(models.Model):\n        key_part1 = models.IntegerField()\n        key_part2 = models.IntegerField()\n        other_field = models.CharField(max_length=100)\n\n        class Meta:\n            managed = False\n            db_table = 'legacy_table'\n            unique_together = (('key_part1', 'key_part2'),)\n            primary_key = CompositeKey('key_part1', 'key_part2')\n    ```\n\n3. **Custom QuerySet or Manager**: You can create custom QuerySets or Managers to handle operations that involve the composite key. This approach requires more manual handling in your queries but allows you to abstract the complexity of composite keys.\n\n4. **Raw SQL Queries**: If the above solutions are not viable, you can always resort to using raw SQL queries for complex operations that involve the composite key. This way, you can fully control the SQL being executed.\n\nUsing these approaches, you should be able to work with your legacy table in Django without needing to alter its structure."
    }
]