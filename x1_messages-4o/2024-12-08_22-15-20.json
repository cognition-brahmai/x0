[
    {
        "role": "user",
        "content": "Write an algorithm to find all prime numbers less than or equal to a given integer n."
    },
    {
        "role": "assistant",
        "content": "To find all prime numbers less than or equal to a given integer \\( n \\), you can use the Sieve of Eratosthenes algorithm, which is an efficient way to identify prime numbers. Here's a step-by-step explanation of the algorithm:\n\n### Sieve of Eratosthenes Algorithm\n\n1. **Create a List:**\n   - Create a list of boolean values, `isPrime`, where the index represents the number. Initialize all values to `true`, except for indices 0 and 1, which should be set to `false` since 0 and 1 are not primes.\n\n2. **Iterate Through the List:**\n   - Start with the first prime number, which is 2.\n   - For each number `p` starting from 2, do the following:\n     - If `isPrime[p]` is `true`, then `p` is a prime number.\n     - Mark all multiples of `p` as `false` (i.e., not prime) starting from \\( p^2 \\). You can increment by `p` (i.e., `p^2, p^2 + p, p^2 + 2p, \\ldots`) since any smaller multiple of `p` will have already been marked by smaller primes.\n   - Continue this process until \\( p^2 \\) is greater than \\( n \\).\n\n3. **Collect Prime Numbers:**\n   - The indices of the `isPrime` list that remain `true` are the prime numbers less than or equal to \\( n \\).\n\n### Python Implementation\n\nHere's how you can implement this in Python:\n\n```python\ndef sieve_of_eratosthenes(n):\n    if n < 2:\n        return []\n    \n    # Initialize a list of boolean values\n    isPrime = [True] * (n + 1)\n    isPrime[0] = isPrime[1] = False  # 0 and 1 are not primes\n    \n    p = 2\n    while (p * p <= n):\n        # If isPrime[p] is still true, then it is a prime\n        if isPrime[p]:\n            # Marking multiples of p as false (not prime)\n            for i in range(p * p, n + 1, p):\n                isPrime[i] = False\n        p += 1\n    \n    # Collecting all prime numbers\n    prime_numbers = [p for p in range(n + 1) if isPrime[p]]\n    return prime_numbers\n\n# Example usage:\nn = 30\nprimes = sieve_of_eratosthenes(n)\nprint(f\"Prime numbers less than or equal to {n}: {primes}\")\n```\n\n### Explanation\n\n- The algorithm uses a list of boolean values to keep track of prime candidates.\n- By systematically marking the multiples of each prime number starting from 2, it efficiently reduces the number of candidates to check.\n- The result is a list of indices that are marked `true`, representing the prime numbers up to \\( n \\).\n\nThis algorithm is efficient with a time complexity of \\( O(n \\log \\log n) \\), making it suitable for finding all primes up to a reasonably large number."
    }
]