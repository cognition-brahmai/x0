[
    {
        "role": "user",
        "content": "In Python, I'm attempting to create a proxy object where method calls can be passed from an object (a wrapper) to a member variable of an object (a wrappee). I anticipate many methods may need to be externalized, and I'm looking for a method that doesn't require altering the interface of the wrapper when a new method is added to the wrappee. For example, I have the following classes:\n\n```python\nclass Wrapper(object):\n  def __init__(self, wrappee):\n    self.wrappee = wrappee\n\n  def foo(self):\n    return 42\n\nclass Wrappee(object):\n  def bar(self):\n    return 12\n\no2 = Wrappee()\no1 = Wrapper(o2)\n\no1.foo() # -> 42\no1.bar() # -> 12\no1.<any new function in Wrappee>() # call directed to this new function \n```\n\nI would like the call redirection to be relatively \"fast\" and not introduce too much overhead compared to a direct call. How can I achieve this?"
    },
    {
        "role": "assistant",
        "content": "To achieve dynamic method delegation in your `Wrapper` class without needing to modify its interface each time a new method is added to the `Wrappee`, you can use Python's `__getattr__` magic method. This method is called when an attribute is not found in the usual places (i.e., it is not an attribute of the object itself). By overriding `__getattr__`, you can intercept calls to methods that are not present in the `Wrapper` and delegate them to the `Wrappee`.\n\nHere's how you can implement this:\n\n```python\nclass Wrapper(object):\n    def __init__(self, wrappee):\n        self.wrappee = wrappee\n\n    def foo(self):\n        return 42\n\n    def __getattr__(self, name):\n        # Delegate the attribute access to the wrappee.\n        return getattr(self.wrappee, name)\n\nclass Wrappee(object):\n    def bar(self):\n        return 12\n\n# Example usage:\no2 = Wrappee()\no1 = Wrapper(o2)\n\nprint(o1.foo())  # -> 42\nprint(o1.bar())  # -> 12\n\n# If Wrappee has more methods added dynamically, they will be accessible through Wrapper:\ndef new_method(self):\n    return \"dynamic method\"\n\n# Adding a new method to Wrappee\nsetattr(Wrappee, \"new_method\", new_method)\n\nprint(o1.new_method())  # -> \"dynamic method\"\n```\n\n### Explanation:\n- **`__getattr__`**: This method is only called if the attribute wasn't found the usual ways. If you attempt to access an attribute that doesn't exist on the `Wrapper` object, `__getattr__` will be invoked.\n- **Delegation**: Inside `__getattr__`, the attempt to retrieve the attribute from `self.wrappee` using `getattr` effectively delegates the method call to the `Wrappee` object.\n- **Dynamic behavior**: Any method added to the `Wrappee` class after the creation of the `Wrapper` will automatically be accessible through the `Wrapper` due to this delegation mechanism.\n\nThis approach efficiently forwards the method calls with minimal overhead, maintaining a similar performance to direct calls on the `Wrappee`."
    }
]