[
    {
        "role": "user",
        "content": "In the given prompt, how can we expand the functionality of the Ruby code to support multiple promotions? Specifically, in addition to discounts, how can we offer customers the option to choose between free gifts or a chance to win a prize? It is required that the solution maintains the accuracy of the promotions, and does not adversely affect the overall campaign. Can you provide a concise example of Ruby code that can accomplish this task?"
    },
    {
        "role": "assistant",
        "content": "To expand the functionality of your Ruby code to support multiple promotions, including options for discounts, free gifts, or a chance to win a prize, you can use a strategy pattern. This allows you to define a family of algorithms or behaviors encapsulated in separate classes and make them interchangeable.\n\nHere's a concise example of how you might implement this in Ruby:\n\n```ruby\nclass Promotion\n  def apply(cart)\n    raise NotImplementedError, \"This #{self.class} cannot respond to:\"\n  end\nend\n\nclass DiscountPromotion < Promotion\n  def initialize(discount_rate)\n    @discount_rate = discount_rate\n  end\n\n  def apply(cart)\n    cart.total_price *= (1 - @discount_rate)\n  end\nend\n\nclass FreeGiftPromotion < Promotion\n  def initialize(gift)\n    @gift = gift\n  end\n\n  def apply(cart)\n    cart.add_free_gift(@gift)\n  end\nend\n\nclass PrizeChancePromotion < Promotion\n  def apply(cart)\n    if rand < 0.1 # 10% chance to win\n      cart.add_prize(\"Congratulations! You've won a prize!\")\n    end\n  end\nend\n\nclass Cart\n  attr_accessor :total_price, :items\n\n  def initialize(total_price, items = [])\n    @total_price = total_price\n    @items = items\n    @free_gifts = []\n    @prizes = []\n  end\n\n  def add_free_gift(gift)\n    @free_gifts << gift\n  end\n\n  def add_prize(prize)\n    @prizes << prize\n  end\n\n  def apply_promotions(promotions)\n    promotions.each { |promotion| promotion.apply(self) }\n  end\n\n  def summary\n    {\n      total_price: @total_price,\n      items: @items,\n      free_gifts: @free_gifts,\n      prizes: @prizes\n    }\n  end\nend\n\n# Example usage\ncart = Cart.new(100.0)\npromotions = [\n  DiscountPromotion.new(0.2),       # 20% discount\n  FreeGiftPromotion.new('Mug'),     # Free Mug gift\n  PrizeChancePromotion.new          # Chance to win a prize\n]\n\ncart.apply_promotions(promotions)\nputs cart.summary\n```\n\n### Explanation:\n- **Promotion Base Class**: This defines a generic interface for promotions.\n- **DiscountPromotion**: Subclass that applies a discount to the cart's total price.\n- **FreeGiftPromotion**: Subclass that adds a free gift to the cart.\n- **PrizeChancePromotion**: Subclass that gives a chance to win a prize.\n- **Cart**: Contains methods to apply promotions and store results like free gifts and prizes.\n\nWith this design, you can easily add more types of promotions by creating new subclasses of `Promotion`. This approach maintains the accuracy and integrity of the promotions applied to the cart."
    }
]