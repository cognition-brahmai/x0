[
    {
        "role": "user",
        "content": "Is there a standard Python data structure that maintains its elements in sorted order and allows me to find the element before or after a given element? I have a set of ranges like [(0, 100), (150, 220), (500, 1000)] and I want to add a range, say (250, 400) but I want to validate that the new range does not overlap with any existing range in the list. I am aware of the `bisect` module but I am wondering if there is a better solution or a data structure available in Python that can help me solve this problem."
    },
    {
        "role": "assistant",
        "content": "In Python, while the `bisect` module is useful for maintaining a sorted list and performing binary search, it doesn't directly provide a data structure for maintaining sorted intervals or ranges with non-overlapping constraints. However, you can use a combination of data structures and libraries to achieve your goal.\n\nOne approach is to use the `sortedcontainers` module, which provides a `SortedList` class. This class maintains its elements in sorted order and supports efficient search and insertion operations. You can store the ranges as tuples and use custom logic to check for overlaps before inserting new ranges.\n\nHere's a step-by-step guide on how you might implement this:\n\n1. **Install `sortedcontainers`**: If you don't have it already, you can install it via pip:\n   ```bash\n   pip install sortedcontainers\n   ```\n\n2. **Use `SortedList` to manage the ranges**:\n   ```python\n   from sortedcontainers import SortedList\n\n   # Function to check for overlap\n   def has_overlap(existing_ranges, new_range):\n       start, end = new_range\n       index = existing_ranges.bisect_left((start, end))\n       \n       # Check previous range if it exists\n       if index > 0 and existing_ranges[index - 1][1] > start:\n           return True\n       \n       # Check next range if it exists\n       if index < len(existing_ranges) and existing_ranges[index][0] < end:\n           return True\n       \n       return False\n\n   # Initialize a sorted list of ranges\n   ranges = SortedList([(0, 100), (150, 220), (500, 1000)])\n\n   # Define the new range\n   new_range = (250, 400)\n\n   # Check for overlap\n   if not has_overlap(ranges, new_range):\n       ranges.add(new_range)\n       print(f\"Added range {new_range}\")\n   else:\n       print(f\"Range {new_range} overlaps with existing ranges\")\n   ```\n\nIn this approach, you maintain a sorted list of your ranges. When adding a new range, you use the `bisect_left` method to find the position where the new range would fit. You then check the adjacent ranges for overlaps before adding the new range.\n\nThis method efficiently handles the sorted order and overlap checking in logarithmic time relative to the number of ranges. The `SortedList` from `sortedcontainers` is well-suited for this task as it automatically maintains the order and allows you to perform binary searches and insertions efficiently."
    }
]