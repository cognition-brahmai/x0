[
    {
        "role": "user",
        "content": "How can I trigger a function in Python whenever a specific value changes? More specifically, I have a class named `Person` and a method `m()`, and I want `m()` to be triggered whenever the value `v` is changed. Here's an example for context:\n\n```python\nglobal_wealth = 0\n\nclass Person()\n    def __init__(self):\n        self.wealth = 0\n        global global_wealth\n        # here is where attribute should be\n        # bound to changes in 'global_wealth'\n        self.happiness = bind_to(global_wealth, how_happy)\n\n    def how_happy(self, global_wealth):\n        return self.wealth / global_wealth\n```\n\nIn this case, whenever the `global_wealth` value is changed, all instances of the class `Person` should update their `happiness` value accordingly. I've read about Python's event-handling and dispatchers but I'm not sure how to apply it here."
    },
    {
        "role": "assistant",
        "content": "To achieve the desired behavior where a function is triggered whenever a specific value changes, you can use a pattern known as the Observer pattern. This pattern allows objects (observers) to be notified whenever a particular subject changes. In your case, all instances of the `Person` class would be observers of the `global_wealth` variable.\n\nHere's a way you can implement this in Python:\n\n1. Use a property to manage access to `global_wealth`.\n2. Notify observers when `global_wealth` changes.\n3. Each `Person` instance subscribes to changes in `global_wealth`.\n\nYou can implement this as follows:\n\n```python\nclass GlobalWealth:\n    def __init__(self, value=0):\n        self._value = value\n        self._observers = []\n\n    @property\n    def value(self):\n        return self._value\n\n    @value.setter\n    def value(self, new_value):\n        self._value = new_value\n        self._notify_observers()\n\n    def add_observer(self, observer):\n        self._observers.append(observer)\n\n    def remove_observer(self, observer):\n        self._observers.remove(observer)\n\n    def _notify_observers(self):\n        for observer in self._observers:\n            observer()\n\nglobal_wealth = GlobalWealth()\n\nclass Person:\n    def __init__(self, wealth=0):\n        self.wealth = wealth\n        self.happiness = 0\n        global_wealth.add_observer(self.update_happiness)\n        self.update_happiness()\n\n    def update_happiness(self):\n        if global_wealth.value != 0:\n            self.happiness = self.wealth / global_wealth.value\n        else:\n            self.happiness = 0\n\n    def __del__(self):\n        global_wealth.remove_observer(self.update_happiness)\n\n# Example usage:\nperson1 = Person(wealth=100)\nperson2 = Person(wealth=200)\n\nprint(f\"Person 1 happiness: {person1.happiness}\")\nprint(f\"Person 2 happiness: {person2.happiness}\")\n\nglobal_wealth.value = 1000\n\nprint(f\"Person 1 happiness after wealth change: {person1.happiness}\")\nprint(f\"Person 2 happiness after wealth change: {person2.happiness}\")\n```\n\n### Explanation:\n\n- **GlobalWealth Class**: This class manages the `global_wealth` value and maintains a list of observers.\n  - `value`: A property that notifies observers whenever it changes.\n  - `add_observer` and `remove_observer`: Methods to manage the list of observers.\n  - `_notify_observers`: Calls each observer function.\n\n- **Person Class**: Each instance represents a person with a `wealth` and `happiness`.\n  - `update_happiness`: This method calculates the happiness based on the current `global_wealth`.\n  - The person instance subscribes to changes in `global_wealth` by calling `add_observer`.\n\n- **Usage**: You create instances of `Person`, and whenever you change `global_wealth.value`, each person's happiness is updated automatically."
    }
]