[
    {
        "role": "user",
        "content": "How can I express multiple inheritance in Python type hinting? In languages like Java and C#, a generic method can have a type parameter with a constraint to define the interfaces that must be implemented. For example:\n\n```java\nstatic &lt;T extends Iterable&lt;Integer&gt; &amp; Comparable&lt;Integer&gt;&gt; void test(T p) {\n\n}\n```\n\nHowever, in Python, I want to use type hinting to specify that a variable must inherit from classes A and B. How can I achieve this? I've checked the typing module, it only has a Union which means the type of the variable can be any of the hint, not all of the hint. Creating a new class C which inherits A and B seems a solution, but looks cumbersome."
    },
    {
        "role": "assistant",
        "content": "In Python, you can achieve a similar effect to multiple inheritance constraints in type hinting by using the `Protocol` class from the `typing` module. This allows you to define a protocol that specifies the required methods and properties, and any class that implements this protocol will be considered a subclass of it for type-checking purposes.\n\nHere's how you can express a requirement for a type that must inherit from both `A` and `B` by using protocols:\n\n```python\nfrom typing import Protocol, TypeVar\n\nclass A(Protocol):\n    def method_from_a(self) -> None:\n        ...\n\nclass B(Protocol):\n    def method_from_b(self) -> None:\n        ...\n\nT = TypeVar('T', bound='AB')\n\nclass AB(A, B, Protocol):\n    pass\n\ndef test(p: T) -> None:\n    p.method_from_a()\n    p.method_from_b()\n\n# Example usage\nclass MyClass:\n    def method_from_a(self) -> None:\n        print(\"Method from A\")\n\n    def method_from_b(self) -> None:\n        print(\"Method from B\")\n\n# This will pass type checking\ntest(MyClass())\n\n# This would raise a type error if MyClass didn't implement both methods\n```\n\nIn this example:\n\n1. We define two protocols, `A` and `B`, which specify the methods that must be implemented.\n2. We create a new protocol `AB` that inherits from both `A` and `B`.\n3. We use a `TypeVar` with a bound of `AB` to specify that a variable must implement both protocols.\n4. The `test` function can then enforce that its argument implements both `A` and `B`.\n\nThis approach enables you to specify complex type relationships without needing to create an actual class that inherits from both `A` and `B`, maintaining flexibility and cleanliness in your code."
    }
]