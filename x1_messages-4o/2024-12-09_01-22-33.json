[
    {
        "role": "user",
        "content": "What is the correct way to annotate a function argument in Python that expects a class object instead of an instance of that class? In the following example, the 'some_class' argument is expected to be a type instance (which is a class), but the problem I'm encountering is that 'type' is too broad:\n\n```python\ndef construct(some_class: type, related_data:Dict[str, Any]) -> Any:\n    ...\n```\n\nI'm looking for a solution where 'some_class' expects a specific set of types objects, for example:\n\n```python\ndef construct(some_class: Class[Union[Foo, Bar, Baz]], related_data:Dict[str, Any]) -> Union[Foo, Bar, Baz]:\n    ...\n```\n\nIn this case, 'some_class' is the 'Foo', 'Bar' or 'Faz' class, not an instance of it. The position of these classes in the class tree doesn't matter because 'some_class: Class[Foo]' should also be a valid case. How can this be achieved with the current implementation (Python 3.6 or earlier)?"
    },
    {
        "role": "assistant",
        "content": "In Python 3.6 or earlier, the typing module does not directly provide a way to specify that a function argument should be a class itself rather than an instance of that class. However, you can achieve this by using a combination of `Type` and `Union` from the `typing` module.\n\nThe `Type` generic is used to specify that a parameter should be a class, and you can combine it with `Union` to restrict it to a specific set of classes. Here\u2019s how you can do it:\n\n```python\nfrom typing import Type, Union, Dict, Any\n\nclass Foo:\n    pass\n\nclass Bar:\n    pass\n\nclass Baz:\n    pass\n\ndef construct(some_class: Type[Union[Foo, Bar, Baz]], related_data: Dict[str, Any]) -> Union[Foo, Bar, Baz]:\n    # Implementation here\n    ...\n```\n\nIn this example, `some_class` is expected to be a class that is either `Foo`, `Bar`, or `Baz`. This way, you can ensure that the function is called with one of the specified class types rather than an instance. \n\nNote: This approach works starting from Python 3.5, but for Python 3.6 or earlier, ensure you have the `typing` module available, as it was introduced in Python 3.5."
    }
]