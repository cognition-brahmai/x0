[
    {
        "role": "user",
        "content": "How can I do relative imports in Python, specifically importing from `mod2` in the `sub2` directory into `mod1` in the `sub1` directory? I have tried using `from ..sub2 import mod2` but I'm getting an \"Attempted relative import in non-package\" error. I would like to avoid using \"sys.path manipulation\" hacks. Is there a clean way to do this? My directory structure is as follows:\n\n```\napp/\n   __init__.py\n   sub1/\n      __init__.py\n      mod1.py\n   sub2/\n      __init__.py\n      mod2.py\n```\n\nAll my `__init__.py` files are currently empty. I am trying to do this because `sub2` contains classes that are shared across sub packages (`sub1`, `subX`, etc.). I am looking for behavior similar to what is described in [PEP 366](http://www.python.org/dev/peps/pep-0366/)."
    },
    {
        "role": "assistant",
        "content": "To perform relative imports correctly in a Python package, you need to ensure that the parent directory of your package is in the Python path and that you are running the script in a way that recognizes the package structure. Here\u2019s how you can achieve this without using `sys.path` manipulation:\n\n1. **Ensure the Package Structure is Correct:**  \n   Your directory structure seems correct, and having `__init__.py` files in each directory is essential for Python to recognize them as packages.\n\n2. **Run the Script as a Module:**  \n   When running a script that requires relative imports, you should execute it as a module. This means you should navigate to the directory containing `app` and run the script using the `-m` flag. For example:\n\n   ```bash\n   cd /path/to/your/project\n   python -m app.sub1.mod1\n   ```\n\n   This way, Python knows to treat `app` as a package, and relative imports will work as expected.\n\n3. **Use Correct Relative Import Syntax:**  \n   In your `mod1.py`, you can perform a relative import like this:\n\n   ```python\n   from ..sub2 import mod2\n   ```\n\n   This assumes that `mod1.py` is intended to be part of the `app` package, and you are running it in a way that respects the package structure.\n\n4. **Ensure the `__main__` Guard is Used:**  \n   If `mod1.py` is being executed directly (not via `-m`), ensure it has the `if __name__ == \"__main__\":` guard to prevent the code from executing when it is imported as a module. However, for relative imports to work, avoid running `mod1.py` directly; instead, use the module approach as described above.\n\nBy following these guidelines, you should be able to perform relative imports cleanly without resorting to path manipulation."
    }
]