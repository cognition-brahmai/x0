[
    {
        "role": "user",
        "content": "How can I implement a singleton design pattern in Python in a way that is most pythonic and follows the 'principle of least astonishment'? I have multiple classes which would become singletons, for example a logger. I want to avoid cluttering several classes with added unnecessary complexity when I can simply inherit or decorate."
    },
    {
        "role": "assistant",
        "content": "Implementing the Singleton design pattern in a Pythonic way while adhering to the 'principle of least astonishment' can be achieved using metaclasses or decorators. Below are two approaches that allow you to create singleton classes in a clean and maintainable way.\n\n### Using a Metaclass\n\nA metaclass is a class of a class that defines how a class behaves. Using a metaclass to implement a singleton can be a very clean solution:\n\n```python\nclass SingletonMeta(type):\n    _instances = {}\n\n    def __call__(cls, *args, **kwargs):\n        if cls not in cls._instances:\n            cls._instances[cls] = super().__call__(*args, **kwargs)\n        return cls._instances[cls]\n\n# Example class using SingletonMeta\nclass Logger(metaclass=SingletonMeta):\n    def __init__(self):\n        self.logs = []\n\n    def log(self, message):\n        self.logs.append(message)\n\n    def show_logs(self):\n        return self.logs\n\n# Usage\nlogger1 = Logger()\nlogger2 = Logger()\n\nlogger1.log(\"This is a log message.\")\nprint(logger2.show_logs())  # Output: ['This is a log message.']\nprint(logger1 is logger2)   # Output: True\n```\n\n### Using a Decorator\n\nA decorator can also be used to achieve a singleton. This approach can be more intuitive for those familiar with decorators.\n\n```python\ndef singleton(cls):\n    instances = {}\n    \n    def get_instance(*args, **kwargs):\n        if cls not in instances:\n            instances[cls] = cls(*args, **kwargs)\n        return instances[cls]\n    \n    return get_instance\n\n# Example class using the singleton decorator\n@singleton\nclass Logger:\n    def __init__(self):\n        self.logs = []\n\n    def log(self, message):\n        self.logs.append(message)\n\n    def show_logs(self):\n        return self.logs\n\n# Usage\nlogger1 = Logger()\nlogger2 = Logger()\n\nlogger1.log(\"This is a log message.\")\nprint(logger2.show_logs())  # Output: ['This is a log message.']\nprint(logger1 is logger2)   # Output: True\n```\n\n### Why These Approaches Are Pythonic\n\n1. **Readability**: Both approaches are easy to read and understand. They don't require the user of the class to understand convoluted code to create a singleton.\n\n2. **Reusability**: By using a metaclass or a decorator, you can easily apply the Singleton pattern to multiple classes without duplicating code.\n\n3. **Encapsulation**: These methods encapsulate the logic of ensuring only one instance is created, which aligns with the principle of least astonishment. Users of the classes don't need to handle the singleton logic themselves.\n\nChoose the approach that best fits your project's style and your personal preference. Both are considered Pythonic and adhere to best practices."
    }
]