[
    {
        "role": "user",
        "content": "In Python, is there a clean way to patch an object so that I can get the `assert_call*` helpers in my test case, without actually removing the action? Specifically, can I modify the `@patch` line in the following test to get it to pass? \n\nHere is the provided code:\n\n```python\nfrom unittest import TestCase\nfrom mock import patch\n\nclass Potato(object):\n    def foo(self, n):\n        return self.bar(n)\n\n    def bar(self, n):\n        return n + 2\n\n\nclass PotatoTest(TestCase):\n\n    @patch.object(Potato, 'foo')\n    def test_something(self, mock):\n        spud = Potato()\n        forty_two = spud.foo(n=40)\n        mock.assert_called_once_with(n=40)\n        self.assertEqual(forty_two, 42)\n```\n\nI could possibly use `side_effect` to hack this together, but is there a more elegant solution that would work the same way on all types of methods, such as functions, classmethods, staticmethods, and unbound methods?"
    },
    {
        "role": "assistant",
        "content": "To achieve the desired behavior where you can use the `assert_called_*` helpers but still preserve the original functionality of the method under test, you can use the `wraps` argument in the `patch` decorator. This allows you to wrap the original method with the mock object, effectively letting the method execute while still allowing you to assert calls to it.\n\nHere's how you can modify your test to achieve this:\n\n```python\nfrom unittest import TestCase\nfrom unittest.mock import patch\n\nclass Potato(object):\n    def foo(self, n):\n        return self.bar(n)\n\n    def bar(self, n):\n        return n + 2\n\n\nclass PotatoTest(TestCase):\n\n    @patch.object(Potato, 'foo', wraps=Potato.foo)\n    def test_something(self, mock):\n        spud = Potato()\n        forty_two = spud.foo(n=40)\n        mock.assert_called_once_with(spud, n=40)\n        self.assertEqual(forty_two, 42)\n```\n\n### Explanation:\n\n- **`wraps` Argument**: By setting `wraps=Potato.foo`, you're telling the mock to wrap the original `foo` method. This means that calls to `foo` will pass through to the original method, allowing it to execute its original logic.\n- **Preserving Functionality**: The original functionality of `foo` is preserved because the mock object delegates the call to the real method.\n- **Assertions**: You can still use `mock.assert_called_once_with` to verify that `foo` was called with the correct arguments. Note that when using `wraps`, the actual instance (`spud`) is the first argument, so you need to include it in the `assert_called_once_with` call.\n\nThis approach is elegant and works for various types of methods, as it relies on the `wraps` mechanism to maintain the original behavior while adding the ability to assert calls."
    }
]