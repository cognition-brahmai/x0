[
    {
        "role": "user",
        "content": "How do I mock a function that is imported inside another function for testing purposes?\n\nI am trying to avoid a circular import, so I have defined a function that looks like this:\n\n```python\n# do_something.py\ndef do_it():\n    from .helpers import do_it_helper\n    # do stuff\n```\n\nNow I'd like to test this function, with `do_it_helper` patched over. If the import were a top level import, this would work fine:\n\n```python\nclass Test_do_it(unittest.TestCase):\n    def test_do_it(self):\n        with patch('do_something.do_it_helper') as helper_mock:\n            helper_mock.return_value = 12\n            # test things\n```\n\nHowever, the code above gives me this error:\n\n```python\nAttributeError: <module 'do_something'> does not have the attribute 'do_it_helper'\n```\n\nOn a whim, I also tried changing the patch statement to:\n\n```python\nwith patch('do_something.do_it.do_it_helper') as helper_mock:\n```\n\nBut that produced a similar error. Is there any way to mock this function, given the fact that I'm forced into importing it within the function where it's used?"
    },
    {
        "role": "assistant",
        "content": "When you import a module or function inside another function, patching it can be a bit tricky because the import happens at runtime, and the usual top-level module path used in `patch` won't work directly. However, you can still use `unittest.mock.patch` to mock the function by targeting the specific location where it is being imported.\n\nHere's how you can approach this:\n\n1. **Patch the exact location**: Since `do_it_helper` is imported inside `do_it`, you need to patch the location where it will be present during the execution of `do_it`. This means patching the path as it appears inside the function, not as it is defined in the module.\n\n2. **Patch the helper inside the function**: You need to specify the path where the function `do_it_helper` will be when `do_it` is executed. This is typically `do_something.do_it.<module>.do_it_helper`, where `<module>` is the name of the current module.\n\nHere's how you can do it:\n\n```python\nimport unittest\nfrom unittest.mock import patch\n\n# Assuming do_something.py is in the same directory and has a do_it function.\nclass TestDoIt(unittest.TestCase):\n    def test_do_it(self):\n        with patch('do_something.helpers.do_it_helper') as helper_mock:\n            helper_mock.return_value = 12\n            from do_something import do_it\n            # Call the function to test\n            result = do_it()\n            # Add your assertions here\n            # For example, assert that the mock was called\n            helper_mock.assert_called_once()\n            # If do_it returns something, you can assert the result\n            # self.assertEqual(result, expected_value)\n\n# Run the test\nif __name__ == \"__main__\":\n    unittest.main()\n```\n\n### Key Points:\n- **Patch Path**: The path you provide to `patch` should reflect the actual import path within the function, which is `do_something.helpers.do_it_helper`.\n- **Import Inside Test**: Ensure you import `do_it` inside the test or after the patching to ensure the patch is applied before the function is evaluated.\n- **Mock Return Value**: Set the return value for the mock if the function being mocked returns a value that affects your test.\n\nThis approach should help you test the function with the dependency mocked correctly. Adjust the import paths based on your project\u2019s actual structure."
    }
]