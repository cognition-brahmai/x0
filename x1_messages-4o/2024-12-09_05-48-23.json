[
    {
        "role": "user",
        "content": "In Python, I'm having trouble understanding the behavior of mutable default arguments. I defined a function as follows:\n\n```python\ndef foo(a=[]):\n    a.append(5)\n    return a\n```\n\nWhen I call this function without any arguments, it doesn't always return a list with one element (`[5]`), as I would expect. Instead, it returns a list with an increasing number of `5`s for each subsequent call:\n\n```python\n>>> foo()\n[5]\n>>> foo()\n[5, 5]\n>>> foo()\n[5, 5, 5]\n>>> foo()\n[5, 5, 5, 5]\n```\n\nCan someone explain why this is happening? Also, why does Python bind the default argument at function definition, and not at function execution?"
    },
    {
        "role": "assistant",
        "content": "The behavior you're observing is due to how Python handles default arguments, specifically mutable default arguments like lists. When you define a function with a default argument, Python evaluates the default argument when the function is defined, not each time the function is called. This means that if you use a mutable object (like a list or dictionary) as a default argument, the same object is used across all calls to the function that don't provide their own argument.\n\nHere's what's happening in your code:\n\n1. When you first call `foo()` without any arguments, the default list `a` is created and `5` is appended to it. The list now contains `[5]`.\n\n2. When you call `foo()` again without any arguments, the same list `a` is used, and another `5` is appended. The list now contains `[5, 5]`.\n\n3. This process continues for each subsequent call, resulting in the list growing by one `5` each time you call the function without arguments.\n\nTo avoid this behavior, you can use `None` as the default value and then create a new list inside the function if needed. Here's how you can modify your function:\n\n```python\ndef foo(a=None):\n    if a is None:\n        a = []\n    a.append(5)\n    return a\n```\n\nWith this change, a new list is created each time `foo()` is called without an argument, and you'll get the expected `[5]` every time you call it.\n\nRegarding why Python binds default arguments at function definition rather than at execution, this is because it is generally more efficient. Evaluating the default argument once at definition time saves the overhead of evaluating it each time the function is called. However, this can lead to unexpected behavior with mutable objects, as you've experienced. Understanding this detail of Python's function definition can help avoid such pitfalls."
    }
]