[
    {
        "role": "user",
        "content": "How can I run only a specific part of a test file in Python unittest? Currently, I am using `unittest.main()` to start the tests. These tests take a lot of time as they are sending calculations to a cluster and waiting for the results. All of these tests are in a specific TestCase class. I would like to have the ability to choose whether this subset of tests does or doesn't run, preferably with a command-line argument like `./tests.py --offline`. This way, I can run most of the tests frequently and quickly, and the whole set only occasionally when I have more time. What would be the best way to achieve this?"
    },
    {
        "role": "assistant",
        "content": "To achieve selective test execution with `unittest` based on a command-line argument, you can modify the test discovery and execution process. Here's a step-by-step guide on how you can implement a solution using `unittest` and command-line arguments:\n\n1. **Define Command-Line Arguments:**\n   Use Python's built-in `argparse` module to define and parse command-line arguments.\n\n2. **Filter Tests Based on Arguments:**\n   Implement a mechanism to filter which tests should be run based on the parsed arguments.\n\n3. **Modify Test Runner:**\n   Customize the test runner to execute only the selected tests.\n\nHere's an example implementation:\n\n```python\nimport unittest\nimport argparse\nimport sys\n\nclass MyTestCase(unittest.TestCase):\n    def test_fast_1(self):\n        print(\"Running fast test 1\")\n        # Your test logic here\n\n    def test_fast_2(self):\n        print(\"Running fast test 2\")\n        # Your test logic here\n\n    def test_slow_1(self):\n        print(\"Running slow test 1\")\n        # Your test logic here\n\n    def test_slow_2(self):\n        print(\"Running slow test 2\")\n        # Your test logic here\n\ndef load_tests(loader, tests, pattern):\n    # This will be the default test suite\n    suite = unittest.TestSuite()\n    # Discover all tests from the current module\n    all_tests = loader.loadTestsFromModule(sys.modules[__name__])\n    # Add all tests to the suite\n    suite.addTests(all_tests)\n    return suite\n\ndef run_tests(offline):\n    # Load all tests\n    loader = unittest.TestLoader()\n    suite = load_tests(loader, None, None)\n    \n    # Filter tests based on the 'offline' flag\n    filtered_tests = unittest.TestSuite()\n    for test in suite:\n        for t in test:\n            if offline:\n                # Add only non-slow tests if --offline is specified\n                if 'slow' not in t._testMethodName:\n                    filtered_tests.addTest(t)\n            else:\n                # Add all tests\n                filtered_tests.addTest(t)\n    \n    # Run the filtered test suite\n    runner = unittest.TextTestRunner()\n    runner.run(filtered_tests)\n\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser(description='Run unit tests.')\n    parser.add_argument('--offline', action='store_true', help='Run only offline tests (exclude slow tests).')\n    args = parser.parse_args()\n    run_tests(args.offline)\n```\n\n### Key Points:\n- **Argparse** is used to capture the `--offline` flag from the command line.\n- **Filtering Tests**: The tests are filtered based on whether the `offline` flag is set. In this example, it assumes that \"slow\" tests have \"slow\" in their method names, but you can implement your own criteria.\n- **Custom Test Suite**: A custom test suite is created and populated based on the filtering logic.\n- **Execution**: Only the filtered tests are executed using the `unittest.TextTestRunner`.\n\n### Usage:\n- Run all tests: `python tests.py`\n- Run only fast tests: `python tests.py --offline`\n\nThis setup provides flexibility in running specific subsets of tests, allowing you to quickly execute frequent tests and reserve comprehensive test runs for less frequent occasions. Adjust the filtering logic to suit your exact needs."
    }
]