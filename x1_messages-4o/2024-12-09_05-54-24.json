[
    {
        "role": "user",
        "content": "How can I apply a decorator to all the methods in a class without manually adding the decorator to each method? I have many methods within the class and I would like the decorator to be automatically applied to any new method that I add in future. I am considering using `__call__` but am unsure if this is the correct approach."
    },
    {
        "role": "assistant",
        "content": "To apply a decorator to all methods in a class automatically, you can use a metaclass or a class decorator. A class decorator is often simpler and more flexible for this purpose. Here's how you can do it:\n\n1. **Define your decorator:** First, define the function that will act as your method decorator. This is the function that will be applied to each method in your class.\n\n2. **Create a class decorator:** This decorator will iterate over all the attributes of a class, and if any attribute is a method, it will apply the method decorator to it.\n\nHere's an example to demonstrate this approach:\n\n```python\ndef method_decorator(func):\n    def wrapper(*args, **kwargs):\n        print(f\"Calling method {func.__name__}\")\n        result = func(*args, **kwargs)\n        print(f\"Method {func.__name__} completed\")\n        return result\n    return wrapper\n\ndef class_decorator(cls):\n    for attr_name, attr_value in cls.__dict__.items():\n        if callable(attr_value) and not attr_name.startswith(\"__\"):\n            setattr(cls, attr_name, method_decorator(attr_value))\n    return cls\n\n@class_decorator\nclass MyClass:\n    def method1(self):\n        print(\"Executing method1\")\n\n    def method2(self):\n        print(\"Executing method2\")\n\n# Usage\nobj = MyClass()\nobj.method1()\nobj.method2()\n```\n\n### Explanation:\n\n- **`method_decorator`:** This function wraps each method to add additional behavior. In this example, it prints messages before and after the method execution.\n\n- **`class_decorator`:** This function takes a class as input, iterates over its dictionary (`cls.__dict__`), and applies the `method_decorator` to each method. We skip any attributes that are not callable (like class variables) or special methods (those starting with `__`).\n\n- **Applying the class decorator:** The `@class_decorator` is used above the class definition. This ensures that when the class is defined, all methods are automatically wrapped with the `method_decorator`.\n\nThis approach will also automatically apply the decorator to any new methods you add to the class in the future, as long as you keep the `@class_decorator` above your class definition."
    }
]