[
    {
        "role": "user",
        "content": "I'm using OpenCV and Python to count cars as they cross a line in a video. The program works, but the issue is that it sometimes counts the same car multiple times. The code I've written is as follows:\n\n```python\nimport cv2\nimport numpy as np\n\nbgsMOG = cv2.BackgroundSubtractorMOG()\ncap    = cv2.VideoCapture(\"traffic.avi\")\ncounter = 0\n\nif cap:\n    while True:\n        ret, frame = cap.read()\n\n        if ret:\n            fgmask = bgsMOG.apply(frame, None, 0.01)\n            cv2.line(frame, (0,60), (160,60), (255,255,0), 1)\n            # To find the countours of the Cars\n            contours, hierarchy = cv2.findContours(fgmask,\n                                    cv2.RETR_EXTERNAL,cv2.CHAIN_APPROX_SIMPLE)\n\n            try:\n                hierarchy = hierarchy[0]\n\n            except:\n                hierarchy = []\n\n            for contour, hier in zip(contours, hierarchy):\n                (x, y, w, h) = cv2.boundingRect(contour)\n\n                if w > 20 and h > 20:\n                    cv2.rectangle(frame, (x,y), (x+w,y+h), (255, 0, 0), 1)\n\n                    # To find the centroid of the car\n                    x1 = w/2\n                    y1 = h/2\n\n                    cx = x+x1\n                    cy = y+y1\n                    centroid = (cx,cy)\n                    # Draw the circle of Centroid\n                    cv2.circle(frame,(int(cx),int(cy)),2,(0,0,255),-1)\n\n                    if centroid > (27, 38) and centroid < (134, 108):\n                        counter +=1\n                    cv2.putText(frame, str(counter), (x,y-5),\n                                        cv2.FONT_HERSHEY_SIMPLEX,\n                                        0.5, (255, 0, 255), 2)\n            cv2.imshow('Output', frame)\n\n            key = cv2.waitKey(60)\n            if key == 27:\n                break\n\ncap.release()\ncv2.destroyAllWindows()\n```\nThe video I'm using is available on my GitHub page at https://github.com/Tes3awy/MATLAB-Tutorials/blob/f24b680f2215c1b1bb96c76f5ba81df533552983/traffic.avi. How can I modify the code so that each car is only counted once?"
    },
    {
        "role": "assistant",
        "content": "To ensure each car is counted only once, you'll need to implement a mechanism to track cars over multiple frames and ensure that they are only counted when they cross the line for the first time. One common approach to achieve this is by using a tracking mechanism, such as centroid tracking. Here's a modified version of your code that includes a simple version of centroid tracking:\n\n```python\nimport cv2\nimport numpy as np\n\n# Initialize background subtractor\nbgsMOG = cv2.createBackgroundSubtractorMOG2(history=100, varThreshold=40)\n\ncap = cv2.VideoCapture(\"traffic.avi\")\n\n# Initialize variables\ncounter = 0\ntrackers = []\nline_y = 60  # Y-coordinate of the line\n\n# Function to calculate the Euclidean distance\ndef euclidean_distance(pt1, pt2):\n    return np.sqrt((pt1[0] - pt2[0]) ** 2 + (pt1[1] - pt2[1]) ** 2)\n\nif cap.isOpened():\n    while True:\n        ret, frame = cap.read()\n        \n        if not ret:\n            break\n        \n        fgmask = bgsMOG.apply(frame)\n        cv2.line(frame, (0, line_y), (frame.shape[1], line_y), (255, 255, 0), 2)\n        \n        # Find contours\n        contours, _ = cv2.findContours(fgmask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)\n        \n        new_trackers = []\n        for contour in contours:\n            if cv2.contourArea(contour) < 500:  # Filter out small contours\n                continue\n            \n            x, y, w, h = cv2.boundingRect(contour)\n            if w > 20 and h > 20:\n                # Calculate centroid\n                cx, cy = x + w // 2, y + h // 2\n\n                # Check if the centroid is near any tracked points\n                matched = False\n                for tracker in trackers:\n                    prev_cx, prev_cy = tracker\n                    if euclidean_distance((cx, cy), (prev_cx, prev_cy)) < 50:\n                        matched = True\n                        new_trackers.append((cx, cy))\n                        break\n                \n                if not matched:\n                    new_trackers.append((cx, cy))\n                    if y < line_y <= y + h:\n                        counter += 1\n\n                # Draw rectangle and centroid\n                cv2.rectangle(frame, (x, y), (x + w, y + h), (255, 0, 0), 2)\n                cv2.circle(frame, (cx, cy), 5, (0, 0, 255), -1)\n\n        trackers = new_trackers\n        \n        # Display counter\n        cv2.putText(frame, f'Count: {counter}', (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 0, 255), 2)\n        \n        cv2.imshow('Output', frame)\n        \n        if cv2.waitKey(30) & 0xFF == 27:  # Escape key\n            break\n\ncap.release()\ncv2.destroyAllWindows()\n```\n\n### Key Points:\n- **Background Subtraction**: Updated to use `cv2.createBackgroundSubtractorMOG2()`, which is more modern and can handle shadows.\n- **Tracking Mechanism**: Implemented a simple centroid tracking by maintaining a list of centroid coordinates from the previous frame and matching them with current frame centroids based on Euclidean distance.\n- **Counting Logic**: Only increment the count when a new centroid crosses the line from above to below.\n\nThis implementation is basic and might need further tuning depending on the specific conditions of your video, such as lighting changes and overlapping cars. For more robust tracking, consider using more advanced techniques such as Kalman filters, optical flow, or deep learning-based object trackers like SORT or Deep SORT."
    }
]