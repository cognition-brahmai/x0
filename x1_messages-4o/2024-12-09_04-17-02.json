[
    {
        "role": "user",
        "content": "I am developing a Python script that requires reading files from a directory passed on the command line. I have defined a readable_dir type to be used with argparse for validating that the directory passed on the command line exists and is readable. I have also specified a default value (/tmp/non_existent_dir). However, argparse invokes readable_dir() on the default value even when a directory argument is explicitly passed on the command line. This causes the script to fail as the default path /tmp/non_existent_dir does not exist when a directory is explicitly passed in on the command line. Is there a more elegant solution to this issue without having to make the argument mandatory or deferring the validation until later in the script?\n\nMy current code is as follows:\n\n```python\n#!/usr/bin/python\nimport argparse\nimport os\n\ndef readable_dir(prospective_dir):\n  if not os.path.isdir(prospective_dir):\n    raise Exception(\"readable_dir:{0} is not a valid path\".format(prospective_dir))\n  if os.access(prospective_dir, os.R_OK):\n    return prospective_dir\n  else:\n    raise Exception(\"readable_dir:{0} is not a readable dir\".format(prospective_dir))\n\nparser = argparse.ArgumentParser(description='test', fromfile_prefix_chars=\"@\")\nparser.add_argument('-l', '--launch_directory', type=readable_dir, default='/tmp/non_existent_dir')\nargs = parser.parse_args()\n```"
    },
    {
        "role": "assistant",
        "content": "The issue you're facing arises because `argparse` will always validate the default value, even if a command-line argument is provided. To handle this more elegantly, you can use a custom action class that performs validation only if the argument is actually supplied. Here's how you can modify your code:\n\n```python\n#!/usr/bin/python\nimport argparse\nimport os\n\nclass ReadableDirAction(argparse.Action):\n    def __call__(self, parser, namespace, values, option_string=None):\n        prospective_dir = values\n        if not os.path.isdir(prospective_dir):\n            raise argparse.ArgumentTypeError(f\"{prospective_dir} is not a valid path\")\n        if not os.access(prospective_dir, os.R_OK):\n            raise argparse.ArgumentTypeError(f\"{prospective_dir} is not a readable dir\")\n        setattr(namespace, self.dest, prospective_dir)\n\nparser = argparse.ArgumentParser(description='test', fromfile_prefix_chars=\"@\")\nparser.add_argument('-l', '--launch_directory',\n                    action=ReadableDirAction,\n                    default='/tmp/non_existent_dir')\nargs = parser.parse_args()\n\nprint(f\"Launch directory: {args.launch_directory}\")\n```\n\n### Explanation:\n1. **Custom Action Class**: The `ReadableDirAction` class extends `argparse.Action`. It overrides the `__call__` method to perform the checks only when the argument is explicitly provided.\n\n2. **Validation Only When Needed**: The `__call__` method is invoked only when the `--launch_directory` argument is present in the command line. This prevents the default value from being validated unnecessarily.\n\n3. **Error Handling**: Instead of raising a generic exception, it is better to raise `argparse.ArgumentTypeError`, which is specifically designed for argument parsing errors.\n\nThis approach allows you to maintain a default value without forcing the argument to be mandatory, and you avoid the issue of validating the default path when it is not needed."
    }
]