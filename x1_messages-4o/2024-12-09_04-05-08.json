[
    {
        "role": "user",
        "content": "In Django REST Framework, how can I accomplish simple foreign key assignment with nested serializers? I noticed that a standard ModelSerializer allows ForeignKey model relationships to be assigned or changed by POSTing an ID as an Integer. However, I am not clear on how to accomplish this with a nested serializer. I am only interested in assigning existing database objects, and not in nested creation. I have previously worked around this issue by using additional 'id' fields in the serializer and with custom `create` and `update` methods. Is there a simpler approach to this? Here is the code I am working with:\n\n```python\nclass Child(models.Model):\n    name = CharField(max_length=20)\n\nclass Parent(models.Model):\n    name = CharField(max_length=20)\n    phone_number = models.ForeignKey(PhoneNumber)\n    child = models.ForeignKey(Child)\n\nclass ChildSerializer(ModelSerializer):\n    class Meta:\n        model = Child\n\nclass ParentSerializer(ModelSerializer):\n    # phone_number relation is automatic and will accept ID integers\n    children = ChildSerializer() # this one will not\n\n    class Meta:\n        model = Parent\n```"
    },
    {
        "role": "assistant",
        "content": "To handle foreign key assignments using nested serializers in Django REST Framework, you can leverage the `PrimaryKeyRelatedField`. This field allows you to use primary keys for the relationship, which is exactly what you need if you want to pass an ID for an existing object without creating nested objects. Here's how you can modify your `ParentSerializer` to accomplish this:\n\n```python\nfrom rest_framework import serializers\nfrom .models import Parent, Child, PhoneNumber\n\nclass ChildSerializer(serializers.ModelSerializer):\n    class Meta:\n        model = Child\n        fields = ['id', 'name']\n\nclass ParentSerializer(serializers.ModelSerializer):\n    # Use a PrimaryKeyRelatedField for the child relationship\n    child = serializers.PrimaryKeyRelatedField(queryset=Child.objects.all())\n\n    class Meta:\n        model = Parent\n        fields = ['id', 'name', 'phone_number', 'child']\n```\n\n### Explanation:\n\n1. **PrimaryKeyRelatedField**: By using `PrimaryKeyRelatedField`, you can accept an integer (the ID of the related object) directly in your requests. This field will look up the `Child` instance based on the provided ID and assign it to the `child` foreign key field in the `Parent` model.\n\n2. **Queryset Parameter**: The `queryset` parameter is required for `PrimaryKeyRelatedField`, as it defines the set of objects that can be assigned. In this case, it's set to `Child.objects.all()` to allow any `Child` instance to be assigned.\n\n3. **Fields in Meta**: Ensure that you list all fields you want to serialize, including the foreign key fields like `phone_number` and `child`.\n\nWith these changes, you can assign an existing `Child` object to a `Parent` by including the child's ID in your POST or PUT requests, like so:\n\n```json\n{\n    \"name\": \"Parent Name\",\n    \"phone_number\": 1,  // Assuming you're also using ID for phone_number\n    \"child\": 2  // ID of the existing Child object\n}\n```\n\nThis approach simplifies the process by avoiding the need for custom `create` and `update` methods, as the `PrimaryKeyRelatedField` handles the lookup and assignment for you."
    }
]