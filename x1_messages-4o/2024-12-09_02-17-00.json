[
    {
        "role": "user",
        "content": "What is the best way to open a file for exclusive access in Python? I want to open a file for reading only if it is not already opened for writing. Also, I want to open a file for writing only if it is not already opened for reading or writing. For instance, when using the built-in functions, I have this example:\n```python\npath = r\"c:\\scr.txt\"\nfile1 = open(path, \"w\")\nprint file1\n# <open file 'c:\\scr.txt', mode 'w' at 0x019F88D8>\nfile2 = open(path, \"w\")\nprint file2\n# <open file 'c:\\scr.txt', mode 'w' at 0x02332188>\nfile1.write(\"111\")\nfile2.write(\"222\")\nfile1.close()\nfile2.close()\n```\nIn this case, 'scr.txt' was overwritten and now contains '222'. How can I prevent this from happening? The solution should work within the same process and when another process has opened the file. It is preferred if a crashing program will not keep the lock open."
    },
    {
        "role": "assistant",
        "content": "To ensure exclusive access to a file in Python, where you want to open a file for reading only if it is not already opened for writing, and for writing only if it is not already opened for reading or writing, you can use file locking mechanisms. The `fcntl` module on Unix-like systems and `msvcrt` module on Windows can be used for this purpose. However, file-locking behavior is platform-dependent.\n\nHere is how you can achieve this on both Unix-like systems and Windows:\n\n### Unix-like Systems\n\nOn Unix-like systems, you can use the `fcntl` module to apply locks:\n\n```python\nimport os\nimport fcntl\n\ndef open_file_exclusively(path, mode):\n    flag = os.O_RDWR if 'w' in mode else os.O_RDONLY\n    fd = os.open(path, flag)\n    \n    try:\n        if 'w' in mode:\n            fcntl.flock(fd, fcntl.LOCK_EX | fcntl.LOCK_NB)  # Exclusive lock\n        else:\n            fcntl.flock(fd, fcntl.LOCK_SH | fcntl.LOCK_NB)  # Shared lock\n        \n        return os.fdopen(fd, mode)\n    \n    except IOError:\n        os.close(fd)\n        raise RuntimeError(\"File is already locked\")\n\n# Example usage\ntry:\n    file1 = open_file_exclusively(\"c:\\\\scr.txt\", \"w\")\n    file1.write(\"111\")\n    file1.close()\nexcept RuntimeError as e:\n    print(e)\n```\n\n### Windows\n\nOn Windows, you can use the `msvcrt` module:\n\n```python\nimport os\nimport msvcrt\n\ndef open_file_exclusively(path, mode):\n    flag = os.O_RDWR if 'w' in mode else os.O_RDONLY\n    fd = os.open(path, flag)\n    \n    try:\n        if 'w' in mode:\n            msvcrt.locking(fd, msvcrt.LK_NBLCK, os.path.getsize(path))  # Exclusive lock\n        else:\n            msvcrt.locking(fd, msvcrt.LK_NBRLCK, os.path.getsize(path))  # Shared lock\n        \n        return os.fdopen(fd, mode)\n    \n    except IOError:\n        os.close(fd)\n        raise RuntimeError(\"File is already locked\")\n\n# Example usage\ntry:\n    file1 = open_file_exclusively(\"c:\\\\scr.txt\", \"w\")\n    file1.write(\"111\")\n    file1.close()\nexcept RuntimeError as e:\n    print(e)\n```\n\n### Notes:\n1. **Non-blocking Locks**: The `LOCK_NB` option ensures that the call returns immediately if the lock cannot be acquired, instead of waiting until the lock is available.\n2. **Error Handling**: Handle `IOError` or `RuntimeError` to manage the situation when a file is already locked.\n3. **Cross-Platform**: The provided solutions are platform-specific, so choose the appropriate one based on your operating system.\n4. **Crash Handling**: File locks are usually released when a process terminates, so a crashing program typically won't keep a lock open indefinitely.\n\nBy using these file-locking mechanisms, you ensure that your file access is exclusive as per your requirements."
    }
]