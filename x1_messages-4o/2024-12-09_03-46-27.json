[
    {
        "role": "user",
        "content": "I am currently working with Python 2.7 and using the json module to encode a data structure. I'm pretty printing everything with an indent of 2, and while it works fine, I have a problem with how it handles the content in \"layer3_1\". This is a large dictionary listing coordinates and having a single value set on each one results in a pretty printed file with thousands of lines. Is there a way to extend the json module to turn off indenting only when inside the \"layer3_1\" object? Here's the code I'm using: \n\n```python\n'layer1': {\n    'layer2': {\n        'layer3_1': [ long_list_of_stuff ],\n        'layer3_2': 'string'\n    }\n}\n\njson.dumps(data_structure, indent=2)\n```\n\nAnd the current output:\n\n```python\n{\n  \"layer1\": {\n    \"layer2\": {\n      \"layer3_1\": [\n        {\n          \"x\": 1,\n          \"y\": 7\n        },\n        {\n          \"x\": 0,\n          \"y\": 4\n        },\n        {\n          \"x\": 5,\n          \"y\": 3\n        },\n        {\n          \"x\": 6,\n          \"y\": 9\n        }\n      ],\n      \"layer3_2\": \"string\"\n    }\n  }\n}\n```\n\nWhat I'm aiming for is an output similar to this:\n\n```python\n{\n  \"layer1\": {\n    \"layer2\": {\n      \"layer3_1\": [{\"x\":1,\"y\":7},{\"x\":0,\"y\":4},{\"x\":5,\"y\":3},{\"x\":6,\"y\":9}],\n      \"layer3_2\": \"string\"\n    }\n  }\n}\n```"
    },
    {
        "role": "assistant",
        "content": "To achieve the desired output where the specific section of your JSON is compact while the rest is pretty-printed, you can use a custom JSON encoder. The idea is to override the default behavior of the JSON encoder when handling the specific part of the data structure that you want to format differently.\n\nHere's an approach to solve your problem:\n\n1. Create a custom JSON encoder class that extends `json.JSONEncoder`.\n2. Override the `default()` method to handle the specific case where you want to format `\"layer3_1\"` differently.\n\nHere's how you can implement this:\n\n```python\nimport json\n\nclass CustomJSONEncoder(json.JSONEncoder):\n    def default(self, obj):\n        # Convert the list in 'layer3_1' to a compact string\n        if isinstance(obj, list) and all(isinstance(i, dict) for i in obj):\n            return '[' + ','.join(json.dumps(i, separators=(',', ':')) for i in obj) + ']'\n        return super(CustomJSONEncoder, self).default(obj)\n\ndef custom_dumps(obj, *args, **kwargs):\n    # Convert the whole object to a JSON string\n    json_str = json.dumps(obj, *args, **kwargs)\n    \n    # Locate \"layer3_1\" in the JSON string and replace it with the compact version\n    layer3_1_key = '\"layer3_1\": '\n    start = json_str.find(layer3_1_key) + len(layer3_1_key)\n    end = json_str.find(']', start) + 1\n    compact_layer3_1 = json.dumps(obj['layer1']['layer2']['layer3_1'], cls=CustomJSONEncoder)\n    \n    # Rebuild the JSON string with the compact \"layer3_1\"\n    return json_str[:start] + compact_layer3_1 + json_str[end:]\n\n# Your data structure\ndata_structure = {\n    'layer1': {\n        'layer2': {\n            'layer3_1': [\n                {'x': 1, 'y': 7},\n                {'x': 0, 'y': 4},\n                {'x': 5, 'y': 3},\n                {'x': 6, 'y': 9}\n            ],\n            'layer3_2': 'string'\n        }\n    }\n}\n\n# Pretty print with custom compacting\npretty_json = custom_dumps(data_structure, indent=2)\nprint(pretty_json)\n```\n\n### Explanation:\n- **CustomJSONEncoder**: We define a custom encoder to handle lists of dictionaries compactly.\n- **custom_dumps**: We use this function to locate `\"layer3_1\"` in the serialized JSON string and replace its content with a compact version.\n- **separators**: We use `separators=(',', ':')` in `json.dumps` to remove spaces around separators for compact output.\n\nThis approach provides you with the flexibility to format specific parts of your JSON differently while maintaining pretty-printing for the rest of the structure."
    }
]