[
    {
        "role": "user",
        "content": "What causes a user-defined class to be unhashable in Python? According to the Python documentation, a class is considered hashable as long as it defines both the `__hash__` and `__eq__` methods. However, when I define a class `X` as a subclass of list and reuse the `tuple.__hash__` method for `__hash__`, I get a TypeError saying \"unhashable type: 'X'\". What is making the class `X` unhashable? Note that I don't modify the instances of `X` after creation, and I need the identical lists to be hashed to the same value to fulfill the hash function's requirement that objects which compare equal have the same hash value. Here is the code I'm using:\n\n```python\nclass X(list):\n  # read-only interface of `tuple` and `list` should be the same, so reuse tuple.__hash__\n  __hash__ = tuple.__hash__\n\nx1 = X()\ns = {x1} # TypeError: unhashable type: 'X'\n```"
    },
    {
        "role": "assistant",
        "content": "In Python, a class is considered hashable if it implements both the `__hash__` and `__eq__` methods in a way that the hash value remains consistent with the equality comparison. However, the issue you're encountering with the subclass of `list` stems from the fact that `list` itself is inherently mutable, and mutable objects are typically not hashable.\n\nWhen you subclass `list`, your class `X` inherits the mutability of `list`. Even though you intend not to modify instances of `X` after creation, Python does not automatically infer immutability from this intention. The `tuple.__hash__` method expects the object to be immutable, as `tuple` objects are immutable by nature. Since `X` is a subclass of `list`, it remains mutable and thus unhashable.\n\nTo make your class `X` hashable, you need to ensure that its instances are truly immutable. One way to achieve this is by overriding methods that allow modification of the list, or better yet, not inheriting from `list`. However, if you still need to subclass a sequence type and want hashability, you might consider subclassing `tuple` instead or implementing your own immutable sequence class.\n\nHere's an example of how you could create an immutable list-like class that is hashable:\n\n```python\nclass X(tuple):  # Subclassing tuple instead of list\n    def __new__(cls, *args):\n        return tuple.__new__(cls, args)\n\n# Usage\nx1 = X(1, 2, 3)\ns = {x1}  # Now this works, because X is immutable and hashable\n```\n\nIn this example, `X` is a subclass of `tuple`, which is immutable, thus making `X` hashable. By using `tuple.__new__`, you ensure that instances of `X` are initialized with the immutability properties of a tuple. Now, instances of `X` can be used as keys in dictionaries or added to sets."
    }
]