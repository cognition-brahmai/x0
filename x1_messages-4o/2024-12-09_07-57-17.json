[
    {
        "role": "user",
        "content": "In Python, we have the concept of a frozen set and a frozen list (which could be represented as a tuple). I'm wondering what would be the equivalent of a \"frozen dict\"? By \"frozen dict\", I mean an immutable, hashable dictionary that supports operations like `keys`, `values`, `get`, and also supports `in` and `for` like a regular dictionary. I thought of `collections.namedtuple`, but it seems to work like a frozen-keys dictionary (a half-frozen dict). Is there an equivalent construct for a fully frozen dictionary in Python?"
    },
    {
        "role": "assistant",
        "content": "In Python, there is no built-in \"frozen dict\" equivalent directly, but you can achieve the functionality of an immutable, hashable dictionary using `types.MappingProxyType` from the `types` module. A `MappingProxyType` is a read-only view of a dictionary, meaning you cannot modify it directly, but you can still access its data using methods like `.keys()`, `.values()`, `.get()`, and support for `in` and iteration.\n\nHere's an example of how you can use `MappingProxyType`:\n\n```python\nfrom types import MappingProxyType\n\n# Original dictionary\noriginal_dict = {'a': 1, 'b': 2, 'c': 3}\n\n# Create a read-only version of the dictionary\nfrozen_dict = MappingProxyType(original_dict)\n\n# Accessing elements\nprint(frozen_dict['a'])  # Output: 1\n\n# Methods like keys(), values(), and get()\nprint(frozen_dict.keys())    # Output: dict_keys(['a', 'b', 'c'])\nprint(frozen_dict.values())  # Output: dict_values([1, 2, 3])\nprint(frozen_dict.get('b'))  # Output: 2\n\n# Iteration\nfor key in frozen_dict:\n    print(key, frozen_dict[key])\n\n# Checking membership\nprint('a' in frozen_dict)  # Output: True\n\n# Trying to modify the dictionary will raise an error\n# frozen_dict['d'] = 4  # This will raise a TypeError\n\n# However, if you modify the original dictionary, the changes will reflect in the frozen_dict\noriginal_dict['d'] = 4\nprint(frozen_dict['d'])  # Output: 4\n```\n\nThe `MappingProxyType` provides immutability from the perspective of the user of the proxy, but keep in mind that if someone has access to the original dictionary, they can still modify it, and those changes will be reflected in the `MappingProxyType`. If you need a truly immutable dictionary, you would have to create a custom class that ensures no modifications can be made to the original data once it's encapsulated."
    }
]