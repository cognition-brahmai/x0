[
    {
        "role": "user",
        "content": "How can I convert a dynamic Python object into JSON? My object can have multiple levels of child objects. I am currently using Python 2.6, and when I try to convert my object into JSON using `json.dumps(c.__dict__)`, I get a TypeError saying that my object is not JSON serializable. How can I create a solution that automatically detects if an attribute is an object and parses its `__dict__`?\n\nHere is the code I am working with:\n\n```python\nclass C(): pass\nclass D(): pass\n\nc = C()\nc.dynProperty1 = \"something\"\nc.dynProperty2 = { 1, 3, 5, 7, 9 }\nc.d = D()\nc.d.dynProperty3 = \"d.something\"\n\n# ... convert c to json ...\n\nimport json\n\nc = C()\nc.what = \"now?\"\nc.now = \"what?\"\nc.d = D()\nc.d.what = \"d.what\"\n\njson.dumps(c.__dict__)\n```\n\nAnd here is the error message I get:\n\n```\nTypeError: <__main__.D instance at 0x99237ec> is not JSON serializable\n```"
    },
    {
        "role": "assistant",
        "content": "To convert a dynamic Python object into JSON, especially when you have nested objects, you need to create a custom serialization function. This function should walk through your object's attributes and recursively convert them into a JSON-serializable format. In Python, this usually involves converting objects to dictionaries that can be serialized by the `json` module.\n\nHere's a solution tailored for your case in Python 2.6 (note that Python 2.6 is quite old, and it's recommended to upgrade to a more recent version if possible):\n\n```python\nimport json\n\nclass C(): pass\nclass D(): pass\n\ndef serialize(obj):\n    \"\"\"Recursively serialize a Python object to a JSON-compatible format.\"\"\"\n    if isinstance(obj, (int, float, str, bool, type(None))):\n        return obj\n    elif isinstance(obj, list):\n        return [serialize(item) for item in obj]\n    elif isinstance(obj, dict):\n        return {key: serialize(value) for key, value in obj.items()}\n    elif isinstance(obj, set):\n        return list(obj)  # Convert set to list for JSON serialization\n    elif hasattr(obj, '__dict__'):\n        return {key: serialize(value) for key, value in obj.__dict__.items()}\n    else:\n        raise TypeError(f\"Type {type(obj)} not serializable\")\n\n# Test the solution with your classes\nc = C()\nc.dynProperty1 = \"something\"\nc.dynProperty2 = {1, 3, 5, 7, 9}\nc.d = D()\nc.d.dynProperty3 = \"d.something\"\n\nserialized_data = serialize(c)\njson_data = json.dumps(serialized_data, indent=2)\nprint(json_data)\n```\n\n### Explanation:\n\n1. **Basic Types**: The function `serialize()` checks if the object is a basic type (int, float, str, bool, or None) and returns it directly as these are already JSON serializable.\n\n2. **Lists and Sets**: For lists, it recursively serializes each item. For sets, it converts them to lists first since JSON doesn't support sets.\n\n3. **Dictionaries**: Recursively serializes each key-value pair.\n\n4. **Custom Objects**: If an object has a `__dict__` attribute (which most user-defined classes do), it serializes the `__dict__`.\n\n5. **Unsupported Types**: Raises a `TypeError` if it encounters a type that can't be serialized.\n\nThis setup allows you to handle nested objects and collections, making it flexible for dynamic and complex objects."
    }
]