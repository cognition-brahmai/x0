[
    {
        "role": "user",
        "content": "How can I create an immutable object in Python? I've attempted to overwrite the __setattr__ method but this prevents me from setting attributes in the __init__ method. I've also tried subclassing a tuple, which works, but allows access to the variables a and b through self[0] and self[1], which I find inconvenient. Is there a way to do this in pure Python? If not, are there any solutions involving a C extension? I am open to solutions that work only in Python 3.\n\nHere is the code I've tried for subclassing a tuple:\n\n```python\nclass Immutable(tuple):\n    def __new__(cls, a, b):\n        return tuple.__new__(cls, (a, b))\n\n    @property\n    def a(self):\n        return self[0]\n        \n    @property\n    def b(self):\n        return self[1]\n\n    def __str__(self):\n        return \"<Immutable {0}, {1}>\".format(self.a, self.b)\n    \n    def __setattr__(self, *ignored):\n        raise NotImplementedError\n\n    def __delattr__(self, *ignored):\n        raise NotImplementedError\n```\n\nAs an additional piece of information to consider, as of Python 3.7, the @dataclass decorator seems to be the recommended approach."
    },
    {
        "role": "assistant",
        "content": "To create an immutable object in Python, especially if you want to avoid using tuples directly, you can use several approaches. One of the most elegant solutions in Python 3.7 and later is to use the `@dataclass` decorator with the `frozen=True` parameter, which effectively makes the object immutable. Here's how you can achieve this:\n\n### Using `@dataclass` with `frozen=True`\n\n```python\nfrom dataclasses import dataclass\n\n@dataclass(frozen=True)\nclass Immutable:\n    a: int\n    b: int\n\n    def __str__(self):\n        return f\"<Immutable {self.a}, {self.b}>\"\n```\n\n### Explanation:\n\n- The `@dataclass` decorator simplifies the creation of classes that are primarily used to store data.\n- The `frozen=True` parameter makes the instance immutable by preventing any modification to the fields after the object is created.\n- You can still access the attributes `a` and `b` directly, which makes the syntax clean and readable.\n\n### Alternative Approach: Custom Class with `__setattr__` Control\n\nIf you want to implement immutability manually, you can indeed use a custom class and control attribute setting within `__setattr__`. Here\u2019s an example:\n\n```python\nclass Immutable:\n    def __init__(self, a, b):\n        object.__setattr__(self, '_initialized', False)\n        object.__setattr__(self, 'a', a)\n        object.__setattr__(self, 'b', b)\n        object.__setattr__(self, '_initialized', True)\n\n    def __setattr__(self, key, value):\n        if getattr(self, '_initialized', False):\n            raise AttributeError(\"Cannot modify immutable instance\")\n        object.__setattr__(self, key, value)\n\n    def __delattr__(self, item):\n        raise AttributeError(\"Cannot delete attribute from immutable instance\")\n\n    def __str__(self):\n        return f\"<Immutable {self.a}, {self.b}>\"\n```\n\n### Key Points:\n\n- We use `object.__setattr__` directly during initialization to bypass the restriction and set initial values.\n- The `_initialized` flag ensures that attributes can only be set during initialization.\n- After initialization, any attempt to modify or delete attributes raises an `AttributeError`.\n\nBoth approaches provide a way to create immutable objects in Python, with the dataclass method being more Pythonic and concise, especially with Python 3.7 and later."
    }
]