[
    {
        "role": "user",
        "content": "How can I annotate a function in Python that accepts any type of number, such as `int`, `float` or `numpy` dtypes? I have tried using `Type` from the `typing` module and performing a runtime check to ensure the passed argument is a subclass of `Number`. However, I am looking for a clean solution without runtime checks. Is there a way to substitute `Type` with something like `NumberType`, to indicate that all number types are subclasses of `Number`? This is my current approach:\n\n```python\nfrom typing import Type\n\ndef foo(bar: Type):\n    assert issubclass(bar, Number)\n    print(bar)\n```\n\nI also tried this:\n\n```python\nfrom numbers import Number\nimport numpy as np\n\nassert issubclass(int, Number)\nassert issubclass(np.uint8, Number)\n```\n\nBut it seems there is no such thing as a generic `NumberType` in Python (3.9):\n\n```python\n>>> type(Number)\nabc.ABCMeta\n```"
    },
    {
        "role": "assistant",
        "content": "In Python, the `numbers` module provides an abstract base class `Number` that can be used to check if a type is a numeric type. However, not all numeric types in Python, especially those in third-party libraries like `numpy`, are direct subclasses of `Number`. This is why `issubclass(np.uint8, Number)` will raise a `TypeError`, as `np.uint8` does not directly inherit from `Number`.\n\nFor type annotations, you can use the `Union` type from the `typing` module to specify that a function can accept various numeric types. However, this won't include `numpy` numeric types directly. A more flexible approach involves using the `TypeVar` feature combined with `isinstance` checks to allow for a broader range of numeric types:\n\n```python\nfrom typing import TypeVar, Union\nfrom numbers import Number\nimport numpy as np\n\n# Create a TypeVar that accepts any numeric type\nNumeric = TypeVar('Numeric', int, float, complex, np.integer, np.floating)\n\ndef foo(bar: Numeric) -> None:\n    print(bar)\n\n# Example usage\nfoo(10)           # int\nfoo(10.5)         # float\nfoo(np.int32(10)) # numpy integer\nfoo(np.float64(10.5)) # numpy floating point\n```\n\nIn this code:\n- We define a `TypeVar` named `Numeric` that accepts `int`, `float`, `complex`, `numpy.integer`, and `numpy.floating`.\n- This allows the `foo` function to accept any of these types without requiring runtime checks.\n\nKeep in mind that type annotations are primarily for the benefit of tools like linters and IDEs, and they don't enforce type checking at runtime. If you need to ensure type safety at runtime, you will still need to perform explicit checks, especially when dealing with `numpy` types that don't directly subclass `Number`.\n\nHowever, if your goal is to simply document the expected usage and benefit from static analysis, the `TypeVar` approach combined with `Union` works effectively in most scenarios."
    }
]