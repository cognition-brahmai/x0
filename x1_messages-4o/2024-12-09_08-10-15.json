[
    {
        "role": "user",
        "content": "How can I set environment variables in my Django application for running unittest tests? My views depend on several API keys and I don't want them defined in settings.py for security reasons. Currently, I'm trying to set these environment variables in my setup function but this approach doesn't seem to propagate the values to the Django application. When I test locally, I use an .env file with the command `foreman start -e .env web` which provides values for `os.environ`. However, Django's `unittest.TestCase` doesn't seem to have a way to set this. How can I achieve this?\n\n```python\nclass MyTests(TestCase):\n    def setUp(self):\n        os.environ['TEST'] = '123'  # doesn't propogate to app\n```"
    },
    {
        "role": "assistant",
        "content": "To manage environment variables in your Django application during unit tests, you can use a few different approaches to ensure that these variables are available to your application without hardcoding them in your `settings.py`. Here are a few methods you could consider:\n\n### 1. Use `python-decouple` or `django-environ`\n\nThese libraries allow you to manage your environment variables more effectively, similar to how you might be using an `.env` file. Here's how you can configure it for testing:\n\n1. **Install the package**:\n\n   ```bash\n   pip install python-decouple\n   ```\n\n   or\n\n   ```bash\n   pip install django-environ\n   ```\n\n2. **Create a `.env.test` file** for your test environment variables.\n\n3. **Load the `.env.test` file** in your test settings or setup code:\n\n   - Using `python-decouple`:\n\n     ```python\n     from decouple import config\n\n     class MyTests(TestCase):\n         def setUp(self):\n             os.environ['TEST'] = config('TEST', default='default_value')\n     ```\n\n   - Using `django-environ`:\n\n     ```python\n     import environ\n\n     env = environ.Env()\n     environ.Env.read_env('.env.test')\n\n     class MyTests(TestCase):\n         def setUp(self):\n             os.environ['TEST'] = env('TEST', default='default_value')\n     ```\n\n### 2. Override Settings for Tests\n\nIf you want these variables to be used specifically during tests, you can override settings directly in your test cases using Django's `override_settings` decorator or context manager. Here's how you can use it:\n\n```python\nfrom django.test import TestCase, override_settings\n\n@override_settings(TEST='123')\nclass MyTests(TestCase):\n    def setUp(self):\n        pass\n\n    def test_something(self):\n        # Your test logic here\n```\n\n### 3. Use `setUpClass` or `setUpTestData`\n\nIf you want to ensure that environment variables are set before any tests are run, you can use `setUpClass` or `setUpTestData`:\n\n```python\nimport os\nfrom django.test import TestCase\n\nclass MyTests(TestCase):\n    @classmethod\n    def setUpClass(cls):\n        super().setUpClass()\n        os.environ['TEST'] = '123'\n\n    def test_something(self):\n        # Your test logic here\n```\n\n### 4. Use a Custom Test Runner\n\nIf you have multiple tests and want a centralized place to set environment variables, you can create a custom test runner that sets these variables before executing tests.\n\n1. **Create a custom test runner**:\n\n   ```python\n   # myapp/testrunner.py\n   from django.test.runner import DiscoverRunner\n   import os\n\n   class CustomTestRunner(DiscoverRunner):\n       def setup_test_environment(self, **kwargs):\n           os.environ['TEST'] = '123'\n           super().setup_test_environment(**kwargs)\n   ```\n\n2. **Specify the test runner** in your `settings.py`:\n\n   ```python\n   TEST_RUNNER = 'myapp.testrunner.CustomTestRunner'\n   ```\n\nThis approach allows you to set environment variables centrally and ensures they're available throughout your tests.\n\nBy using one of these methods, you should be able to set environment variables for your Django application during unit testing without exposing them in your production settings."
    }
]