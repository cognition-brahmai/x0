[
    {
        "role": "user",
        "content": "How can I implement a binary search tree in Java? Please provide a sample code using [Java code] data format."
    },
    {
        "role": "assistant",
        "content": "Certainly! Below is a simple implementation of a Binary Search Tree (BST) in Java. This example includes the basic operations such as insertion, searching, and in-order traversal.\n\n```java\n// Node class representing each node in the Binary Search Tree\nclass Node {\n    int key;\n    Node left, right;\n\n    public Node(int item) {\n        key = item;\n        left = right = null;\n    }\n}\n\n// Binary Search Tree class\nclass BinarySearchTree {\n    // Root node of the tree\n    Node root;\n\n    // Constructor to initialize the BST\n    BinarySearchTree() {\n        root = null;\n    }\n\n    // Method to insert a new key in the BST\n    void insert(int key) {\n        root = insertRec(root, key);\n    }\n\n    // Recursive function to insert a new key in the BST\n    Node insertRec(Node root, int key) {\n        // If the tree is empty, return a new node\n        if (root == null) {\n            root = new Node(key);\n            return root;\n        }\n\n        // Otherwise, recur down the tree\n        if (key < root.key)\n            root.left = insertRec(root.left, key);\n        else if (key > root.key)\n            root.right = insertRec(root.right, key);\n\n        // Return the unchanged node pointer\n        return root;\n    }\n\n    // Method to perform in-order traversal of the BST\n    void inorder() {\n        inorderRec(root);\n    }\n\n    // Recursive function to perform in-order traversal\n    void inorderRec(Node root) {\n        if (root != null) {\n            inorderRec(root.left);\n            System.out.print(root.key + \" \");\n            inorderRec(root.right);\n        }\n    }\n\n    // Method to search for a key in the BST\n    boolean search(int key) {\n        return searchRec(root, key);\n    }\n\n    // Recursive function to search for a key in the BST\n    boolean searchRec(Node root, int key) {\n        // Base case: root is null or key is present at root\n        if (root == null || root.key == key)\n            return root != null;\n\n        // Key is greater than root's key\n        if (root.key < key)\n            return searchRec(root.right, key);\n\n        // Key is smaller than root's key\n        return searchRec(root.left, key);\n    }\n\n    public static void main(String[] args) {\n        BinarySearchTree bst = new BinarySearchTree();\n\n        // Inserting keys into the BST\n        bst.insert(50);\n        bst.insert(30);\n        bst.insert(20);\n        bst.insert(40);\n        bst.insert(70);\n        bst.insert(60);\n        bst.insert(80);\n\n        // Performing in-order traversal\n        System.out.println(\"In-order traversal:\");\n        bst.inorder();\n\n        // Searching for a key\n        int keyToSearch = 40;\n        if (bst.search(keyToSearch))\n            System.out.println(\"\\nKey \" + keyToSearch + \" found in the BST.\");\n        else\n            System.out.println(\"\\nKey \" + keyToSearch + \" not found in the BST.\");\n    }\n}\n```\n\n### Explanation:\n\n- **Node class**: Represents each node in the BST, containing a key and pointers to the left and right children.\n- **BinarySearchTree class**: Contains methods for inserting a node, performing in-order traversal, and searching for a key.\n- **insertRec()**: Recursively finds the correct location for the new key and inserts it.\n- **inorderRec()**: Recursively performs in-order traversal (left-root-right) and prints the keys.\n- **searchRec()**: Recursively searches for a key in the BST and returns true if found, false otherwise.\n\nYou can modify this basic structure to add more functionalities like deletion, balancing, etc."
    }
]