[
    {
        "role": "user",
        "content": "How can I implement an efficient infinite generator for prime numbers in Python? I want to use it like this: `for p in primes()`. I am aware of techniques like the Sieve, but I am unsure how many consecutive primes will be consumed and I prefer a non-concurrent approach."
    },
    {
        "role": "assistant",
        "content": "To implement an efficient infinite generator for prime numbers in Python, you can use a method known as the \"Sieve of Eratosthenes,\" but adapted for an infinite sequence. This technique will allow you to generate primes on-demand without knowing beforehand how many will be consumed.\n\nHere's a Python generator function that implements this idea:\n\n```python\ndef primes():\n    \"\"\"Generate an infinite sequence of prime numbers.\"\"\"\n    # Dictionary to hold the composite numbers and their smallest factor\n    composites = {}\n    candidate = 2\n\n    while True:\n        if candidate not in composites:\n            # Candidate is a prime number\n            yield candidate\n            # Mark the square of the prime number as composite\n            composites[candidate * candidate] = [candidate]\n        else:\n            # Candidate is a composite number\n            for prime in composites[candidate]:\n                composites.setdefault(prime + candidate, []).append(prime)\n            # Remove the candidate from the dictionary\n            del composites[candidate]\n        \n        candidate += 1\n\n# Example usage:\nfor p in primes():\n    if p > 100:  # Stop after the first prime greater than 100\n        break\n    print(p)\n```\n\n### Explanation:\n\n1. **Composites Dictionary:** This dictionary is used to keep track of the \"next\" composite numbers and their factors. The keys are the composite numbers, and the values are lists of prime factors.\n\n2. **Candidate:** This is the current number being tested for primality. It starts at 2, the first prime number.\n\n3. **Prime Check:** If the candidate is not in the `composites` dictionary, it is a prime number, and we yield it.\n\n4. **Marking Composites:** When a prime is found, its square is marked as a composite with the prime itself as a factor. For composite numbers in the dictionary, we update the next composite number by adding the candidate to each of its prime factors.\n\n5. **Efficient Memory Use:** The dictionary only stores numbers that are necessary for the iteration, allowing this approach to manage memory efficiently even for very large numbers.\n\nThis method is efficient in both time and space, allowing you to generate prime numbers indefinitely without preallocating a large data structure."
    }
]