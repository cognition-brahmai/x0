[
    {
        "role": "user",
        "content": "How can I create a duplicate of an object in Python, such that the new object has all properties of the original one, but they are independent of each other? In other words, if I make changes to the new object, these changes should not affect the original object."
    },
    {
        "role": "assistant",
        "content": "To create a duplicate or a \"deep copy\" of an object in Python, such that the new object is independent of the original, you can use the `copy` module, specifically the `deepcopy` function. This function creates a new object that is a deep copy of the original, meaning that all levels of nested objects are duplicated, and the new object is completely independent of the original.\n\nHere\u2019s how you can use it:\n\n```python\nimport copy\n\n# Assume `original_object` is the object you want to duplicate\noriginal_object = {\n    'key1': [1, 2, 3],\n    'key2': {'nested_key': 'value'}\n}\n\n# Create a deep copy of the original object\nduplicate_object = copy.deepcopy(original_object)\n\n# Now, you can modify `duplicate_object` without affecting `original_object`\nduplicate_object['key1'].append(4)\nduplicate_object['key2']['nested_key'] = 'new_value'\n\n# Print to see the difference\nprint(\"Original Object:\", original_object)\nprint(\"Duplicate Object:\", duplicate_object)\n```\n\nIn this example:\n- `original_object` is a dictionary containing a list and another dictionary.\n- `copy.deepcopy(original_object)` creates a new object that is a deep copy of `original_object`.\n- Modifications to `duplicate_object` do not affect `original_object`, demonstrating their independence. \n\nUsing `deepcopy` is particularly useful when your object contains other objects (like lists or dictionaries) and you want to ensure that all references are copied rather than shared."
    }
]