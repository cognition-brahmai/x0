[
    {
        "role": "user",
        "content": "Can someone explain how Python resolves references to variables? Specifically, I'm trying to understand how Python resolves variable references within different scopes such as local, global, and builtin as well as within different types of code blocks like modules, class definitions, function definitions, etc. Also, I'm curious to know how Python deals with attribute lookup in these scopes. I have several examples illustrating my confusion, including an example that I don't understand the outcome of."
    },
    {
        "role": "assistant",
        "content": "In Python, variable resolution and scope handling are governed by the LEGB rule, which stands for Local, Enclosing, Global, and Built-in. This rule dictates the order in which Python resolves variable names and is key to understanding how Python handles variable references across different scopes and blocks of code.\n\n### LEGB Rule\n\n1. **Local (L):** The innermost scope, this includes variables defined within a function. When you reference a variable within a function, Python first looks here.\n\n2. **Enclosing (E):** This applies to nested functions. If a variable is not found in the local scope, Python looks in the scope of any enclosing functions from inner to outer.\n\n3. **Global (G):** If the variable is not found in either the local or enclosing scopes, Python checks the global scope, which is the module-level scope.\n\n4. **Built-in (B):** Finally, if the variable is not found in any of the above scopes, Python checks the built-in scope, which contains Python's built-in functions and exceptions.\n\n### Code Blocks and Scopes\n\n- **Modules:** At the module level, variables are in the global scope. When you import a module, its global scope is separate from the global scope of the module doing the importing.\n\n- **Functions:** Each function has its own local scope. Variables defined inside a function are not accessible outside of it unless they are returned.\n\n- **Classes:** Variables within class definitions are treated as attributes. Attribute lookup is done by first checking the instance, then the class, and then the parent classes (if any).\n\n### Attribute Lookup\n\nAttribute lookup in Python follows a different path:\n\n1. **Instance Level:** When you access an attribute on an instance, Python first checks if the attribute is defined in the instance's `__dict__`.\n\n2. **Class Level:** If the attribute is not found in the instance, Python checks if it is defined in the class of the instance.\n\n3. **Inheritance Hierarchy:** If the attribute is not found in the instance or class, Python traverses up the inheritance hierarchy to search parent classes.\n\n### Example Illustration\n\nLet's consider an example to illustrate these concepts:\n\n```python\nx = \"global\"\n\ndef outer():\n    x = \"enclosing\"\n    \n    def inner():\n        x = \"local\"\n        print(x)  # Should print \"local\"\n    \n    inner()\n    print(x)  # Should print \"enclosing\"\n\nouter()\nprint(x)  # Should print \"global\"\n```\n\nIn this example:\n- The `inner()` function prints `x` from its local scope.\n- The `outer()` function prints `x` from its enclosing scope.\n- The global scope `x` is printed outside the `outer()` function.\n\n### Attribute Lookup Example\n\nHere's an example demonstrating attribute lookup:\n\n```python\nclass MyClass:\n    class_var = \"class attribute\"\n\n    def __init__(self, instance_var):\n        self.instance_var = instance_var\n\nobj = MyClass(\"instance attribute\")\nprint(obj.instance_var)  # Prints \"instance attribute\"\nprint(obj.class_var)     # Prints \"class attribute\"\n```\n\nIn this example:\n- `obj.instance_var` is found in the instance's `__dict__`.\n- `obj.class_var` is not in the instance, so Python checks the class and finds it there.\n\nUnderstanding these rules can greatly help in debugging and writing more efficient Python code. If you have specific examples that you're confused about, feel free to share, and I can further clarify!"
    }
]