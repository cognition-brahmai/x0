[
    {
        "role": "user",
        "content": "I frequently need to split a sequence into two subsequences based on a given predicate, while preserving the original relative ordering. Is there a standard or built-in way to do this in Python? For example, I have a sequence of numbers from a range and I want to divide them into two groups: one that satisfies a condition (being divisible by 3) and one that does not. Here's a hypothetical function I have in mind:\n\n```python\ndata = map(str, range(14))\npred = lambda i: int(i) % 3 == 2\nsplitter(data, pred)\n[('2', '5', '8', '11'), ('0', '1', '3', '4', '6', '7', '9', '10', '12', '13')]\n```\n\nI've found a solution using `itertools.groupby`, but it necessitates calling the predicate function twice for each list member, which seems redundant. Here's what I have so far:\n\n```python\nimport itertools as it\n[tuple(v[1]) for v in it.groupby(sorted(data, key=pred), key=pred)]\n[('0', '1', '3', '4', '6', '7', '9', '10', '12', '13'), ('2', '5', '8', '11')]\n```\n\nIs there a simpler or more efficient way to achieve this?"
    },
    {
        "role": "assistant",
        "content": "Certainly! You can achieve this by iterating over the sequence just once and appending elements to two different lists based on whether they satisfy the predicate or not. This approach does not require sorting or using `itertools.groupby`, and it avoids calling the predicate multiple times for the same element. Here's a simple implementation using list comprehensions:\n\n```python\ndef splitter(sequence, predicate):\n    true_group = []\n    false_group = []\n    \n    for item in sequence:\n        if predicate(item):\n            true_group.append(item)\n        else:\n            false_group.append(item)\n    \n    return (tuple(true_group), tuple(false_group))\n\ndata = map(str, range(14))\npred = lambda i: int(i) % 3 == 2\n\nresult = splitter(data, pred)\nprint(result)\n```\n\nThis will give you the desired output:\n\n```\n(('2', '5', '8', '11'), ('0', '1', '3', '4', '6', '7', '9', '10', '12', '13'))\n```\n\nBy using a single loop, this method efficiently separates the elements into two groups based on the predicate, preserving their original order."
    }
]