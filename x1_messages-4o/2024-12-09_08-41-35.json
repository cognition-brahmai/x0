[
    {
        "role": "user",
        "content": "What is the correct method for properly cleaning up after an event loop is interrupted in Python? I have an event loop that runs some co-routines as part of a command line tool. However, when the user interrupts the tool with the usual Ctrl + C, I want to clean up properly. I attempted the following code, but it does not seem to work as expected:\n\n```python\nimport asyncio\n\n@asyncio.coroutine\ndef shleepy_time(seconds):\n    print(\"Shleeping for {s} seconds...\".format(s=seconds))\n    yield from asyncio.sleep(seconds)\n\nif __name__ == '__main__':\n    loop = asyncio.get_event_loop()\n\n    tasks = [\n        asyncio.async(shleepy_time(seconds=5)),\n        asyncio.async(shleepy_time(seconds=10))\n    ]\n\n    try:\n        loop.run_until_complete(asyncio.gather(*tasks))\n    except KeyboardInterrupt as e:\n        print(\"Caught keyboard interrupt. Canceling tasks...\")\n\n        for t in tasks:\n            t.cancel()\n    finally:\n        loop.close()\n```\n\nWhen I run this and hit Ctrl + C, I get the following output:\n\n```shell\n$ python3 asyncio-keyboardinterrupt-example.py \nShleeping for 5 seconds...\nShleeping for 10 seconds...\n^CCaught keyboard interrupt. Canceling tasks...\nTask was destroyed but it is pending!\ntask: <Task pending coro=<shleepy_time() running at asyncio-keyboardinterrupt-example.py:7> wait_for=<Future cancelled> cb=[gather.<locals>._done_callback(1)() at /usr/local/Cellar/python3/3.4.3/Frameworks/Python.framework/Versions/3.4/lib/python3.4/asyncio/tasks.py:587]>\nTask was destroyed but it is pending!\ntask: <Task pending coro=<shleepy_time() running at asyncio-keyboardinterrupt-example.py:7> wait_for=<Future cancelled> cb=[gather.<locals>._done_callback(0)() at /usr/local/Cellar/python3/3.4.3/Frameworks/Python.framework/Versions/3.4/lib/python3.4/asyncio/tasks.py:587]>\n```\n\nClearly, I didn't clean up correctly. I thought perhaps calling cancel() on the tasks would be the way to do it. What's the correct way to clean up after an interrupted event loop?"
    },
    {
        "role": "assistant",
        "content": "To properly handle a `KeyboardInterrupt` in an asyncio event loop and clean up tasks, you need to ensure that you await the cancellation of the tasks and handle any exceptions that might arise from it. Here's an updated version of your code that accomplishes this:\n\n```python\nimport asyncio\n\nasync def shleepy_time(seconds):\n    print(f\"Shleeping for {seconds} seconds...\")\n    try:\n        await asyncio.sleep(seconds)\n    except asyncio.CancelledError:\n        print(f\"Shleepy time cancelled after {seconds} seconds.\")\n        raise\n\nif __name__ == '__main__':\n    loop = asyncio.get_event_loop()\n\n    tasks = [\n        loop.create_task(shleepy_time(seconds=5)),\n        loop.create_task(shleepy_time(seconds=10))\n    ]\n\n    try:\n        loop.run_until_complete(asyncio.gather(*tasks))\n    except KeyboardInterrupt:\n        print(\"Caught keyboard interrupt. Canceling tasks...\")\n\n        for task in tasks:\n            task.cancel()\n        \n        # Wait for the cancellation to complete\n        loop.run_until_complete(asyncio.gather(*tasks, return_exceptions=True))\n    finally:\n        loop.close()\n```\n\n### Key Changes and Improvements:\n\n1. **Use `async` and `await`:** Modern asyncio code uses `async` and `await` instead of `@asyncio.coroutine` and `yield from`.\n\n2. **Handle `CancelledError`:** When a task is cancelled, it raises a `CancelledError`. You need to catch this exception within your coroutine to properly handle task cancellation and perform any necessary cleanup within the coroutine itself.\n\n3. **Await Task Cancellation:** After calling `cancel()` on the tasks, use `asyncio.gather` with `return_exceptions=True` to ensure all tasks are properly awaited and any exceptions (including `CancelledError`) are suppressed.\n\nBy awaiting the tasks after cancellation and handling the `CancelledError`, you ensure that your tasks are properly cleaned up and that the event loop can close gracefully without leaving pending tasks."
    }
]