[
    {
        "role": "user",
        "content": "Why am I not able to assign mutable defaults to class attributes in Python dataclasses? For example, when I try to assign a list as a class attribute default in the following code, I encounter a ValueError:\n\n```python\n@dataclass\nclass Foo:\n    bar: list = []\n\n# ValueError: mutable default <class 'list'> for field a is not allowed: use default_factory\n```\n\nBased on the error message, it appears I should use the following code instead:\n\n```python\n@dataclass\nclass Foo:\n    bar: list = field(default_factory=list)\n```\n\nWhat is the reason for not allowing mutable defaults in dataclasses? Is it to avoid the problem of mutable default argument?"
    },
    {
        "role": "assistant",
        "content": "Yes, the restriction on using mutable default values in Python's `dataclasses` is indeed to avoid common pitfalls associated with mutable default arguments. This is a well-known issue in Python, primarily encountered with function definitions, and the same principle applies to dataclasses.\n\n### Explanation:\n\n1. **Shared State Across Instances**: When you use a mutable object (like a list, dictionary, or set) as a default value, that object is shared across all instances of the class. This means that if one instance modifies the object, it will affect the object for all other instances, leading to unexpected behavior.\n\n2. **Common Pitfall in Functions**: This is similar to how default mutable arguments work in Python functions. If a mutable object is used as a default parameter, it persists across function calls, potentially leading to bugs that are hard to trace.\n\n3. **Dataclasses Design**: To prevent this issue, `dataclasses` enforce the use of `default_factory` for mutable default values. `default_factory` ensures that a new object is created each time a new instance of the dataclass is instantiated, thus avoiding shared state across instances.\n\n### Example:\n\nConsider the following scenario without `default_factory`:\n\n```python\n@dataclass\nclass Foo:\n    bar: list = []\n\nfoo1 = Foo()\nfoo2 = Foo()\n\nfoo1.bar.append(1)\nprint(foo2.bar)  # This would print [1], which is usually not the intended behavior.\n```\n\nTo avoid this, use `default_factory`:\n\n```python\nfrom dataclasses import dataclass, field\n\n@dataclass\nclass Foo:\n    bar: list = field(default_factory=list)\n\nfoo1 = Foo()\nfoo2 = Foo()\n\nfoo1.bar.append(1)\nprint(foo2.bar)  # This will correctly print [], as foo2.bar is a different list.\n```\n\nBy using `default_factory`, each instance gets its own independent list, thus preventing unintended side effects and making the code safer and more predictable."
    }
]