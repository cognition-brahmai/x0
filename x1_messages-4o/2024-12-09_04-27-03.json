[
    {
        "role": "user",
        "content": "I am trying to understand the use of Python's 3.5 async/await feature. I have read several articles and tutorials on this, but I am still confused with the use of get_event_loop() and run_until_complete(), ensure_future(), asyncio.wait(), and call_soon(). I also noticed that all examples use asyncio.sleep() as a simulation of slow operation which returns an awaitable object. However, when I try to replace this with real code, it doesn't work. Specifically, I am using the Quandl library to fetch some stock data, but I am unsure how to make it async/await ready. Here is my code:\n\n```\nimport asyncio\nimport quandl\n\nasync def slow_operation(n):\n    # await asyncio.sleep(1) # Works because it's await ready.\n    await quandl.Dataset(n) # Doesn't work because it's not await ready.\n\n\nasync def main():\n    await asyncio.wait([\n        slow_operation(\"SIX/US9884981013EUR4\"),\n        slow_operation(\"SIX/US88160R1014EUR4\"),\n    ])\n\n# You don't have to use any code for 50 requests/day.\nquandl.ApiConfig.api_key = \"MY_SECRET_CODE\"\n\nloop = asyncio.get_event_loop()\nloop.run_until_complete(main())\n```\nWhat is the difference between the approaches mentioned above and how do I run a third-party library which is not ready for async/await?"
    },
    {
        "role": "assistant",
        "content": "The confusion you're experiencing is common when starting with asynchronous programming in Python, especially when working with libraries that don't natively support async/await. Let me break down the various components and approaches you mentioned, and then address how you can work with non-async libraries like Quandl.\n\n### Key Components\n\n1. **`get_event_loop()` and `run_until_complete()`**: These are used to run asynchronous tasks. `get_event_loop()` retrieves the current event loop, and `run_until_complete()` runs the event loop until the specified awaitable (usually a coroutine) completes.\n\n2. **`ensure_future()`**: This function is used to wrap coroutines and other awaitables into a `Future`, which can be used in conjunction with other asyncio functions like `asyncio.wait()`.\n\n3. **`asyncio.wait()`**: This is used to wait for multiple awaitables to complete. It takes a list of awaitables and waits for them to complete, returning two sets of tasks, those that are done and those that are pending.\n\n4. **`call_soon()`**: This schedules a callback to be run on the next iteration of the event loop. It's typically used for non-blocking calls that need to be executed soon.\n\n### Making Non-Async Libraries Async-Ready\n\nThe Quandl library, like many other third-party libraries, is not designed to be used with async/await. In such cases, you can use a thread or a process pool to run the blocking code without blocking the event loop. Here\u2019s how you can achieve that using `asyncio.to_thread()` (introduced in Python 3.9) or `concurrent.futures.ThreadPoolExecutor` for earlier versions:\n\n#### Using `asyncio.to_thread()` (Python 3.9+)\n\n```python\nimport asyncio\nimport quandl\n\nasync def slow_operation(n):\n    # Run the blocking IO operation in a separate thread\n    data = await asyncio.to_thread(quandl.get, n)\n    return data\n\nasync def main():\n    results = await asyncio.gather(\n        slow_operation(\"SIX/US9884981013EUR4\"),\n        slow_operation(\"SIX/US88160R1014EUR4\"),\n    )\n    for result in results:\n        print(result)\n\n# You don't have to use any code for 50 requests/day.\nquandl.ApiConfig.api_key = \"MY_SECRET_CODE\"\n\nloop = asyncio.get_event_loop()\nloop.run_until_complete(main())\n```\n\n#### Using `ThreadPoolExecutor` (Python 3.5+)\n\n```python\nimport asyncio\nimport quandl\nfrom concurrent.futures import ThreadPoolExecutor\n\nexecutor = ThreadPoolExecutor()\n\nasync def slow_operation(n):\n    # Run the blocking IO operation in a separate thread\n    loop = asyncio.get_event_loop()\n    data = await loop.run_in_executor(executor, quandl.get, n)\n    return data\n\nasync def main():\n    results = await asyncio.gather(\n        slow_operation(\"SIX/US9884981013EUR4\"),\n        slow_operation(\"SIX/US88160R1014EUR4\"),\n    )\n    for result in results:\n        print(result)\n\n# You don't have to use any code for 50 requests/day.\nquandl.ApiConfig.api_key = \"MY_SECRET_CODE\"\n\nloop = asyncio.get_event_loop()\nloop.run_until_complete(main())\n```\n\n### Explanation\n\n- **`asyncio.to_thread()`**: This function is a convenient way to run blocking IO-bound functions in a separate thread in Python 3.9 and later.\n- **`ThreadPoolExecutor`**: This allows you to run blocking operations in separate threads, preventing them from blocking the main event loop.\n\nBy using one of these methods, you can efficiently handle blocking IO operations within an async/await framework, allowing your program to remain responsive."
    }
]