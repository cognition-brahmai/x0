[
    {
        "role": "user",
        "content": "How can I generate a method at runtime in Python? I've created a solution using `exec` and `setattr` to allow the running of arbitrary code and inclusion of a docstring. However, I am unsure if this is the best, safest, or most idiomatic approach to achieve this. Here's an example of my current implementation:\n\n```python\nclass Viking(object):\n    def __init__(self):\n        code = '''\n            def dynamo(self, arg):\n                \"\"\" dynamo's a dynamic method!\n                \"\"\"\n                self.weight += 1\n                return arg * self.weight\n            '''\n        self.weight = 50\n\n        d = {}\n        exec code.strip() in d\n        setattr(self.__class__, 'dynamo', d['dynamo'])\n\n\nif __name__ == \"__main__\":\n    v = Viking()\n    print v.dynamo(10)\n    print v.dynamo(10)\n    print v.dynamo.__doc__\n```\n\nIs there a better / safer / more idiomatic way of achieving the same result?"
    },
    {
        "role": "assistant",
        "content": "Your current approach using `exec` and `setattr` indeed works, but using `exec` can be risky and is generally discouraged because it can execute arbitrary code, potentially leading to security vulnerabilities.\n\nA more idiomatic and safer way to achieve this functionality is by using closures or defining functions dynamically using `types.MethodType`. Here\u2019s an example of how you can implement this without using `exec`:\n\n```python\nfrom types import MethodType\n\nclass Viking(object):\n    def __init__(self):\n        self.weight = 50\n        self.add_dynamic_method()\n\n    def add_dynamic_method(self):\n        # Define a function that will become the dynamic method\n        def dynamo(self, arg):\n            \"\"\" dynamo's a dynamic method! \"\"\"\n            self.weight += 1\n            return arg * self.weight\n\n        # Bind the function as a method to the instance\n        self.dynamo = MethodType(dynamo, self)\n\nif __name__ == \"__main__\":\n    v = Viking()\n    print(v.dynamo(10))\n    print(v.dynamo(10))\n    print(v.dynamo.__doc__)\n```\n\n### Explanation:\n\n1. **`MethodType`**: This is used to bind a function to an instance, effectively turning it into a method. This avoids the need for `exec` and allows you to dynamically add methods in a safer manner.\n\n2. **Closure**: By defining the function inside another function (`add_dynamic_method`), we can control the scope and encapsulation of the dynamically added method.\n\nThis approach maintains clarity and safety by avoiding executing arbitrary code with `exec` while achieving the desired dynamic behavior."
    }
]