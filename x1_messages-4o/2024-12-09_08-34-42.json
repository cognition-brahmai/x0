[
    {
        "role": "user",
        "content": "How can I change the JSON encoding behavior for serializable Python objects? I am working on debugging and want to modify the way some custom objects, which are extended from base ones like dict and list, get serialized in JSON format. I have tried using a default handler but it does not seem to work for serializable objects. Is there a way to override this without adding toJSON methods to the extended classes? I have also tried using a version of JSON encoder which does not work. If there is a workaround with pickle, __getstate__, __setstate__, and then using json.dumps over pickle.loads object, I am open to that as well. \n\nHere is the code I am working with:\n\n```\nimport datetime\nimport json\n\ndef json_debug_handler(obj):\n    print(\"object received:\")\n    print type(obj)\n    print(\"\\n\\n\")\n    if  isinstance(obj, datetime.datetime):\n        return obj.isoformat()\n    elif isinstance(obj,mDict):\n        return {'orig':obj , 'attrs': vars(obj)}\n    elif isinstance(obj,mList):\n        return {'orig':obj, 'attrs': vars(obj)}\n    else:\n        return None\n\n\nclass mDict(dict):\n    pass\n\n\nclass mList(list):\n    pass\n\n\ndef test_debug_json():\n    games = mList(['mario','contra','tetris'])\n    games.src = 'console'\n    scores = mDict({'dp':10,'pk':45})\n    scores.processed = \"unprocessed\"\n    test_json = { 'games' : games , 'scores' : scores , 'date': datetime.datetime.now() }\n    print(json.dumps(test_json,default=json_debug_handler))\n\nif __name__ == '__main__':\n    test_debug_json()\n```\n\nAnd the JSON encoder that does not work:\n\n```\nclass JsonDebugEncoder(json.JSONEncoder):\n    def default(self,obj):\n        if  isinstance(obj, datetime.datetime):\n            return obj.isoformat()\n        elif isinstance(obj,mDict):\n            return {'orig':obj , 'attrs': vars(obj)}\n        elif isinstance(obj,mList):\n            return {'orig':obj, 'attrs': vars(obj)}\n        else:\n            return json.JSONEncoder.default(self, obj)\n```\n\nMy current output is:\n\n```\n{\"date\": \"2013-05-07T01:03:13.098727\", \"games\": [\"mario\", \"contra\", \"tetris\"], \"scores\": {\"pk\": 45, \"dp\": 10}}\n```\n\nBut my desired output is:\n\n```\n{\"date\": \"2013-05-07T01:03:13.098727\", \"games\": { \"orig\": [\"mario\", \"contra\", \"tetris\"] ,\"attrs\" : { \"src\":\"console\"}}  , \"scores\": { \"orig\": {\"pk\": 45, \"dp\": 10},\"attrs\": \"processed\":\"unprocessed }}\n```"
    },
    {
        "role": "assistant",
        "content": "To achieve the desired JSON serialization behavior for your custom `mDict` and `mList` objects, you can make use of a custom JSON encoder that overrides the `default` method. The key issue here is that when JSON encoding, Python's built-in types (`dict`, `list`, etc.) are directly serialized without invoking the `default` method for custom handling. However, you can modify this behavior by explicitly handling these custom types.\n\nHere's an updated version of your code using a custom JSON encoder to achieve the desired output:\n\n```python\nimport datetime\nimport json\n\nclass CustomJSONEncoder(json.JSONEncoder):\n    def default(self, obj):\n        if isinstance(obj, datetime.datetime):\n            return obj.isoformat()\n        elif isinstance(obj, mDict):\n            # Handle serialization for mDict\n            return {'orig': dict(obj), 'attrs': vars(obj)}\n        elif isinstance(obj, mList):\n            # Handle serialization for mList\n            return {'orig': list(obj), 'attrs': vars(obj)}\n        else:\n            # Fallback to default serialization for unknown types\n            return super().default(obj)\n\nclass mDict(dict):\n    pass\n\nclass mList(list):\n    pass\n\ndef test_debug_json():\n    games = mList(['mario', 'contra', 'tetris'])\n    games.src = 'console'\n    scores = mDict({'dp': 10, 'pk': 45})\n    scores.processed = \"unprocessed\"\n    test_json = {'games': games, 'scores': scores, 'date': datetime.datetime.now()}\n    print(json.dumps(test_json, cls=CustomJSONEncoder, indent=2))\n\nif __name__ == '__main__':\n    test_debug_json()\n```\n\n### Explanation:\n1. **CustomJSONEncoder**: This class extends `json.JSONEncoder` and overrides the `default` method to provide custom serialization logic for `mDict` and `mList`.\n   \n2. **Handling Custom Types**: When encountering `mDict` and `mList`, the encoder converts them into a dictionary format with `orig` and `attrs` keys, where `orig` contains the original list or dictionary, and `attrs` contains additional attributes.\n\n3. **Fallback to Default**: For other object types, the encoder falls back to the default serialization provided by `json.JSONEncoder` using `super().default(obj)`.\n\n4. **Using the Custom Encoder**: The `json.dumps` function is called with the `cls` parameter set to `CustomJSONEncoder`, ensuring it uses the custom serialization logic.\n\nThis should produce the desired JSON output with the additional attributes for your custom `mDict` and `mList` objects."
    }
]