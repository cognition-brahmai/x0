[
    {
        "role": "user",
        "content": "Build a Node.js web application that allows users to upload images, resizes them to a specified width and height using the Sharp library, and stores the resized images on disk or in a cloud storage service like Amazon S3."
    },
    {
        "role": "assistant",
        "content": "Alright, I'm going to build a Node.js web application that lets users upload images, resizes them using the Sharp library, and then stores those resized images either on the local disk or in a cloud storage service like Amazon S3. Sounds like a fun project!\n\nFirst, I need to set up a basic Node.js web server. I think I'll use Express.js for that, as it's lightweight and very flexible. So, I'll start by initializing a new Node.js project and installing the necessary dependencies.\n\nLet me list out the steps I need to follow:\n\n1. Set up a new Node.js project.\n2. Install required dependencies: Express, Sharp, Multer (for handling file uploads), and AWS SDK (if using S3).\n3. Create routes for uploading images.\n4. Implement image resizing using Sharp.\n5. Save the resized images either locally or to S3.\n6. Handle any errors that might occur during the process.\n\nAlright, let's start with step 1: setting up a new Node.js project.\n\nI'll create a new directory for my project and initialize it with npm.\n\n```\nmkdir image-resizer\ncd image-resizer\nnpm init -y\n```\n\nThis will create a `package.json` file with default values.\n\nNext, step 2: installing dependencies.\n\nI need Express for the server, Sharp for image resizing, and Multer for handling file uploads. If I decide to use S3, I'll also need the AWS SDK.\n\nLet me install these packages:\n\n```\nnpm install express sharp multer aws-sdk\n```\n\nOkay, now that I have all the dependencies installed, I can move on to step 3: creating routes for uploading images.\n\nI'll set up an Express server and define a route that accepts POST requests with image files.\n\nI should also configure Multer to handle the file uploads. Multer provides options for storing files on disk, and I can customize that to save the files to a specific directory.\n\nBut before saving the files, I need to resize them using Sharp. So, I'll integrate Sharp into the upload process to resize the images on the fly.\n\nLet me think about the flow:\n\n- User sends a POST request to `/upload` with an image file.\n- Multer handles the file upload and passes the file to Sharp for resizing.\n- Sharp resizes the image to the specified width and height.\n- The resized image is then saved either locally or to S3.\n\nI need to decide on the dimensions to resize the images to. Maybe I can accept width and height as query parameters or in the request body.\n\nAlso, I should validate the uploaded file to ensure it's an image and not something else to prevent security issues.\n\nLet me sketch a basic structure of the application.\n\nFirst, I'll set up the Express server:\n\n```javascript\nconst express = require('express');\nconst app = express();\nconst port = 3000;\n\napp.listen(port, () => {\n  console.log(`Server is running on port ${port}`);\n});\n```\n\nNext, set up Multer for handling file uploads. I need to specify storage options for where to store the uploaded files temporarily before resizing.\n\n```javascript\nconst multer = require('multer');\nconst upload = multer({ dest: 'uploads/' });\n```\n\nNow, create the `/upload` route that accepts POST requests with files.\n\n```javascript\napp.post('/upload', upload.single('image'), (req, res) => {\n  // Handle the uploaded file\n});\n```\n\nInside the route handler, I need to use Sharp to resize the image.\n\nFirst, import Sharp:\n\n```javascript\nconst sharp = require('sharp');\n```\n\nThen, read the uploaded file and resize it:\n\n```javascript\nsharp(req.file.path)\n  .resize({ width: 800, height: 600 })\n  .toFile('resized.jpg', (err, info) => {\n    if (err) {\n      console.error(err);\n      res.status(500).send('Error resizing image');\n    } else {\n      res.send('Image resized and saved as resized.jpg');\n    }\n  });\n```\n\nThis is a basic example. I hard-coded the width and height to 800 and 600, but I should make them dynamic based on user input.\n\nLet me modify the route to accept width and height as query parameters.\n\n```javascript\napp.post('/upload', upload.single('image'), (req, res) => {\n  const { width, height } = req.query;\n  \n  sharp(req.file.path)\n    .resize({ width: parseInt(width), height: parseInt(height) })\n    .toFile('resized.jpg', (err, info) => {\n      if (err) {\n        console.error(err);\n        res.status(500).send('Error resizing image');\n      } else {\n        res.send('Image resized and saved as resized.jpg');\n      }\n    });\n});\n```\n\nBut I need to handle cases where width and height are not provided or are invalid. I should add validation for these parameters.\n\nAlso, after resizing, I might want to save the image to a specific directory or to S3, depending on the configuration.\n\nLet me think about configuring the storage destination. Maybe I can have an environment variable that decides whether to save locally or to S3.\n\nI'll introduce an environment variable called ` STORAGE_DEST` which can be set to `local` or `s3`.\n\nFirst, I need to load environment variables. I can use the `dotenv` package for that.\n\nLet me install `dotenv`:\n\n```\nnpm install dotenv\n```\n\nThen, at the top of my server file, I'll add:\n\n```javascript\nrequire('dotenv').config();\n```\n\nNow, I can set `STORAGE_DEST` in a `.env` file.\n\nNext, based on the value of `STORAGE_DEST`, I'll decide where to save the resized image.\n\nIf `STORAGE_DEST` is `local`, I'll save it to a specific directory on the server.\n\nIf it's `s3`, I'll upload it to an S3 bucket using the AWS SDK.\n\nFirst, let's handle the local storage.\n\nI'll define a path where to save the resized images, say `./resized-images/`.\n\nI need to make sure that this directory exists. I can use the `fs` module to check and create it if necessary.\n\nSimilarly, for S3 storage, I'll need to configure the AWS SDK with my S3 credentials and bucket name.\n\nLet me plan this step by step.\n\nFirst, install the AWS SDK if not already installed:\n\n```\nnpm install aws-sdk\n```\n\nThen, require it in my server file:\n\n```javascript\nconst AWS = require('aws-sdk');\n```\n\nI need to configure the S3 client with my AWS credentials and the region where my bucket is located.\n\nI should store my AWS access key, secret access key, and bucket name in the `.env` file for security.\n\nSo, in `.env`, I'll have:\n\n```\nSTORAGE_DEST=local  # or s3\nAWS_ACCESS_KEY=your_access_key\nAWS_SECRET_KEY=your_secret_key\nAWS_REGION=your_region\nS3_BUCKET_NAME=your_bucket_name\n```\n\nThen, in my server file, I'll configure the S3 client:\n\n```javascript\nif (process.env.STORAGE_DEST === 's3') {\n  AWS.config.update({\n    accessKeyId: process.env.AWS_ACCESS_KEY,\n    secretAccessKey: process.env.AWS_SECRET_KEY,\n    region: process.env.AWS_REGION\n  });\n\n  const s3 = new AWS.S3();\n}\n```\n\nNow, after resizing the image, I need to save it accordingly.\n\nFor local storage, I can use Sharp's `toFile` method as I did before, specifying the path in the `resized-images` directory.\n\nFor S3, I need to read the resized image buffer and upload it to S3.\n\nLet me adjust the route handler to handle both cases.\n\nFirst, I'll make sure that the `resized-images` directory exists.\n\nI'll use the `fs` module for that:\n\n```javascript\nconst fs = require('fs');\nconst path = require('path');\n\nconst resizedDir = path.join(__dirname, 'resized-images');\n\nif (!fs.existsSync(resizedDir)) {\n  fs.mkdirSync(resizedDir);\n}\n```\n\nNow, in the route handler, after resizing the image, I'll check `STORAGE_DEST` and save the image accordingly.\n\nFor local storage:\n\n```javascript\nsharp(req.file.path)\n  .resize({ width: parseInt(width), height: parseInt(height) })\n  .toFile(path.join(resizedDir, 'resized.jpg'), (err, info) => {\n    if (err) {\n      console.error(err);\n      res.status(500).send('Error resizing image');\n    } else {\n      res.send('Image resized and saved locally');\n    }\n  });\n```\n\nFor S3 storage:\n\n```javascript\nsharp(req.file.path)\n  .resize({ width: parseInt(width), height: parseInt(height) })\n  .toBuffer()\n  .then(buffer => {\n    const params = {\n      Bucket: process.env.S3_BUCKET_NAME,\n      Key: 'resized.jpg',\n      Body: buffer,\n      ContentType: 'image/jpeg'\n    };\n    s3.upload(params, (err, data) => {\n      if (err) {\n        console.error(err);\n        res.status(500).send('Error uploading to S3');\n      } else {\n        res.send('Image resized and uploaded to S3');\n      }\n    });\n  })\n  .catch(err => {\n    console.error(err);\n    res.status(500).send('Error resizing image');\n  });\n```\n\nSo, I need to conditionally choose between `toFile` for local storage and `toBuffer` followed by S3 upload.\n\nI can abstract this into a function to keep the code clean.\n\nLet me define a function `saveResizedImage` that takes the resized buffer and saves it based on the storage destination.\n\nFirst, install any missing dependencies, like `fs` and `path` are built-in, so no need to install them.\n\nNow, implement the `saveResizedImage` function.\n\nBut perhaps it's simpler to keep it inline for now, especially since the logic is not too complex.\n\nLet me refactor the route handler to check `STORAGE_DEST` and perform the appropriate action.\n\nHere's how it might look:\n\n```javascript\napp.post('/upload', upload.single('image'), (req, res) => {\n  const { width, height } = req.query;\n\n  if (!width || !height) {\n    return res.status(400).send('Width and height are required');\n  }\n\n  sharp(req.file.path)\n    .resize({ width: parseInt(width), height: parseInt(height) })\n    .toBuffer()\n    .then(buffer => {\n      if (process.env.STORAGE_DEST === 'local') {\n        const filePath = path.join(resizedDir, 'resized.jpg');\n        fs.writeFileSync(filePath, buffer);\n        res.send('Image resized and saved locally');\n      } else if (process.env.STORAGE_DEST === 's3') {\n        const params = {\n          Bucket: process.env.S3_BUCKET_NAME,\n          Key: 'resized.jpg',\n          Body: buffer,\n          ContentType: 'image/jpeg'\n        };\n        s3.upload(params, (err, data) => {\n          if (err) {\n            console.error(err);\n            res.status(500).send('Error uploading to S3');\n          } else {\n            res.send('Image resized and uploaded to S3');\n          }\n        });\n      } else {\n        res.status(500).send('Invalid storage destination');\n      }\n    })\n    .catch(err => {\n      console.error(err);\n      res.status(500).send('Error resizing image');\n    });\n});\n```\n\nThis seems better. I'm using `toBuffer` to get the resized image buffer, then saving it locally or uploading to S3 based on the `STORAGE_DEST` environment variable.\n\nI should also handle cases where the storage destination is invalid, which I've partially done by sending a 500 error.\n\nAdditionally, I should validate that the uploaded file is actually an image. Multer has options for file type validation.\n\nLet me configure Multer to only accept image files.\n\nI can define an array of allowed MIME types:\n\n```javascript\nconst upload = multer({\n  dest: 'uploads/',\n  fileFilter: (req, file, cb) => {\n    const allowedTypes = /image\\/(jpeg|jpg|png|gif)/;\n    if (!allowedTypes.test(file.mimetype)) {\n      cb(new Error('Only image files are allowed'), false);\n    }\n    cb(null, true);\n  }\n});\n```\n\nThis will ensure that only image files are accepted for upload.\n\nIf an invalid file type is uploaded, Multer will throw an error, which I need to handle.\n\nI should add error handling for Multer in the route.\n\nHere's how I can do it:\n\n```javascript\napp.post('/upload', upload.single('image'), (req, res) => {\n  // resizing and saving logic here\n}, (err, req, res, next) => {\n  if (err instanceof multer.MulterError) {\n    // A Multer error occurred when uploading.\n    res.status(400).send(err.message);\n  } else if (err) {\n    // An unknown error occurred.\n    res.status(500).send('An error occurred');\n  }\n});\n```\n\nThis way, any errors thrown by Multer, such as invalid file types, will be caught and handled appropriately.\n\nAlso, I should consider cleaning up the temporary uploaded files after processing, to avoid filling up disk space.\n\nSharp reads the file from disk, so I can safely delete the temporary file after resizing.\n\nI can use `fs.unlink` to delete the file.\n\nHere's how I can incorporate that:\n\n```javascript\napp.post('/upload', upload.single('image'), (req, res) => {\n  const { width, height } = req.query;\n\n  if (!width || !height) {\n    return res.status(400).send('Width and height are required');\n  }\n\n  sharp(req.file.path)\n    .resize({ width: parseInt(width), height: parseInt(height) })\n    .toBuffer()\n    .then(buffer => {\n      let savePromise;\n\n      if (process.env.STORAGE_DEST === 'local') {\n        const filePath = path.join(resizedDir, 'resized.jpg');\n        savePromise = new Promise((resolve, reject) => {\n          fs.writeFile(filePath, buffer, err => {\n            if (err) {\n              reject(err);\n            } else {\n              resolve();\n            }\n          });\n        });\n      } else if (process.env.STORAGE_DEST === 's3') {\n        const params = {\n          Bucket: process.env.S3_BUCKET_NAME,\n          Key: 'resized.jpg',\n          Body: buffer,\n          ContentType: 'image/jpeg'\n        };\n        savePromise = new Promise((resolve, reject) => {\n          s3.upload(params, (err, data) => {\n            if (err) {\n              reject(err);\n            } else {\n              resolve();\n            }\n          });\n        });\n      } else {\n        return Promise.reject(new Error('Invalid storage destination'));\n      }\n\n      return savePromise;\n    })\n    .then(() => {\n      // Delete the temporary uploaded file\n      fs.unlinkSync(req.file.path);\n      res.send('Image resized and saved');\n    })\n    .catch(err => {\n      console.error(err);\n      res.status(500).send('Error processing image');\n    });\n}, (err, req, res, next) => {\n  if (err instanceof multer.MulterError) {\n    res.status(400).send(err.message);\n  } else if (err) {\n    res.status(500).send('An error occurred');\n  }\n});\n```\n\nThis is getting better. I'm handling the file upload, resizing, saving, and cleanup in a more structured way.\n\nI should also think about error handling for file operations, like writing to disk or uploading to S3.\n\nI've already included error callbacks for those operations, but I can make the code even cleaner by using async/await syntax, which can make error handling clearer.\n\nLet me refactor the route handler to use async/await.\n\nFirst, I need to make the route handler an async function.\n\nHere's how it would look:\n\n```javascript\napp.post('/upload', upload.single('image'), async (req, res, next) => {\n  try {\n    const { width, height } = req.query;\n\n    if (!width || !height) {\n      throw new Error('Width and height are required');\n    }\n\n    const buffer = await sharp(req.file.path)\n      .resize({ width: parseInt(width), height: parseInt(height) })\n      .toBuffer();\n\n    let savePromise;\n\n    if (process.env.STORAGE_DEST === 'local') {\n      const filePath = path.join(resizedDir, 'resized.jpg');\n      await new Promise((resolve, reject) => {\n        fs.writeFile(filePath, buffer, err => {\n          if (err) {\n            reject(err);\n          } else {\n            resolve();\n          }\n        });\n      });\n    } else if (process.env.STORAGE_DEST === 's3') {\n      const params = {\n        Bucket: process.env.S3_BUCKET_NAME,\n        Key: 'resized.jpg',\n        Body: buffer,\n        ContentType: 'image/jpeg'\n      };\n      await new Promise((resolve, reject) => {\n        s3.upload(params, (err, data) => {\n          if (err) {\n            reject(err);\n          } else {\n            resolve();\n          }\n        });\n      });\n    } else {\n      throw new Error('Invalid storage destination');\n    }\n\n    // Delete the temporary uploaded file\n    fs.unlinkSync(req.file.path);\n\n    res.send('Image resized and saved');\n  } catch (err) {\n    next(err);\n  }\n}, (err, req, res, next) => {\n  if (err instanceof multer.MulterError) {\n    res.status(400).send(err.message);\n  } else {\n    res.status(500).send('An error occurred');\n  }\n});\n```\n\nThis looks much cleaner. Using async/await makes the code easier to read and handle errors properly.\n\nI should also consider adding more robust error messages and possibly logging errors for debugging purposes.\n\nAdditionally, for S3 uploads, I might want to set ACL permissions or other options depending on my requirements.\n\nAlso, for local storage, I might want to generate a unique filename for each uploaded image to avoid overwriting existing files.\n\nLet me address that. Instead of always saving the file as 'resized.jpg', I can generate a unique filename based on a timestamp or using a UUID.\n\nI'll need to install a package to generate UUIDs, such as `uuid`.\n\nFirst, install it:\n\n```\nnpm install uuid\n```\n\nThen, require it in the server file:\n\n```javascript\nconst { v4: uuidv4 } = require('uuid');\n```\n\nNow, generate a unique filename for each resized image:\n\n```javascript\nconst uniqueFilename = `${uuidv4()}.jpg`;\nconst filePath = path.join(resizedDir, uniqueFilename);\n```\n\nSimilarly, for S3 uploads, use the unique filename as the S3 key.\n\nHere's how I can adjust the code:\n\n```javascript\nconst uniqueFilename = `${uuidv4()}.jpg`;\n\nif (process.env.STORAGE_DEST === 'local') {\n  const filePath = path.join(resizedDir, uniqueFilename);\n  await new Promise((resolve, reject) => {\n    fs.writeFile(filePath, buffer, err => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve();\n      }\n    });\n  });\n} else if (process.env.STORAGE_DEST === 's3') {\n  const params = {\n    Bucket: process.env.S3_BUCKET_NAME,\n    Key: uniqueFilename,\n    Body: buffer,\n    ContentType: 'image/jpeg'\n  };\n  await new Promise((resolve, reject) => {\n    s3.upload(params, (err, data) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve();\n      }\n    });\n  });\n} else {\n  throw new Error('Invalid storage destination');\n}\n```\n\nThis way, each resized image will have a unique filename, preventing overwrite issues.\n\nAnother consideration is handling different image formats. Currently, I'm always saving as JPEG. But the original image could be PNG, GIF, etc.\n\nI can use Sharp's `withMetadata` option to preserve the original format.\n\nHere's how to do it:\n\n```javascript\nconst metadata = await sharp(req.file.path).metadata();\nconst format = metadata.format;\n\nconst buffer = await sharp(req.file.path)\n  .resize({ width: parseInt(width), height: parseInt(height) })\n  .toFormat(format)\n  .toBuffer();\n```\n\nThis way, if the original image is a PNG, the resized image will also be in PNG format, and similarly for other formats.\n\nI should adjust the filename extension accordingly based on the format.\n\nTo do that, I can map the format to an extension.\n\nHere's an example:\n\n```javascript\nconst formatToExtension = {\n  jpeg: 'jpg',\n  png: 'png',\n  gif: 'gif',\n  // add more formats if needed\n};\n\nconst extension = formatToExtension[format] || 'jpg';\nconst uniqueFilename = `${uuidv4()}.${extension}`;\n```\n\nThis ensures that the filename has the correct extension based on the image format.\n\nLet me incorporate this into the code.\n\nFirst, define the `formatToExtension` object:\n\n```javascript\nconst formatToExtension = {\n  jpeg: 'jpg',\n  png: 'png',\n  gif: 'gif',\n  // add more formats if needed\n};\n```\n\nThen, after getting the metadata:\n\n```javascript\nconst metadata = await sharp(req.file.path).metadata();\nconst format = metadata.format;\nconst extension = formatToExtension[format] || 'jpg';\nconst uniqueFilename = `${uuidv4()}.${extension}`;\n```\n\nAnd use this `uniqueFilename` when saving locally or uploading to S3.\n\nAlso, set the `ContentType` in the S3 upload parameters based on the format.\n\nHere's how:\n\n```javascript\nconst contentType = `image/${format}`;\n\nif (process.env.STORAGE_DEST === 'local') {\n  const filePath = path.join(resizedDir, uniqueFilename);\n  await new Promise((resolve, reject) => {\n    fs.writeFile(filePath, buffer, err => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve();\n      }\n    });\n  });\n} else if (process.env.STORAGE_DEST === 's3') {\n  const params = {\n    Bucket: process.env.S3_BUCKET_NAME,\n    Key: uniqueFilename,\n    Body: buffer,\n    ContentType: contentType\n  };\n  await new Promise((resolve, reject) => {\n    s3.upload(params, (err, data) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve();\n      }\n    });\n  });\n} else {\n  throw new Error('Invalid storage destination');\n}\n```\n\nThis makes the application more flexible and ensures that image formats are handled correctly.\n\nAnother improvement could be to allow users to specify the output format separately from the input format.\n\nFor example, a user might upload a PNG but want it resized to JPEG.\n\nI can add an additional query parameter, say `format`, which specifies the desired output format.\n\nSharp supports various formats, so I can map the provided format to Sharp's format options.\n\nFirst, define an object mapping allowed formats to Sharp's format names.\n\n```javascript\nconst allowedFormats = {\n  jpg: 'jpeg',\n  jpeg: 'jpeg',\n  png: 'png',\n  gif: 'gif',\n  // add more formats if needed\n};\n```\n\nThen, in the route handler, check if the `format` query parameter is provided and valid.\n\n```javascript\nconst { width, height, format } = req.query;\n\nif (!width || !height) {\n  throw new Error('Width and height are required');\n}\n\nlet outputFormat = format ? allowedFormats[format.toLowerCase()] : format;\n\nif (outputFormat && !allowedFormats[outputFormat]) {\n  throw new Error('Invalid output format');\n}\n```\n\nThen, when resizing the image, use the specified output format if provided, otherwise use the original format.\n\n```javascript\nconst buffer = await sharp(req.file.path)\n  .resize({ width: parseInt(width), height: parseInt(height) })\n  .toFormat(outputFormat || format)\n  .toBuffer();\n```\n\nAlso, adjust the `uniqueFilename` extension based on `outputFormat` or original format.\n\n```javascript\nconst extension = outputFormat ? formatToExtension[outputFormat] : extension;\nconst uniqueFilename = `${uuidv4()}.${extension}`;\n```\n\nAnd set the `ContentType` accordingly.\n\nThis adds more flexibility to the application.\n\nI should also make sure that the `format` query parameter is case-insensitive by converting it to lowercase.\n\nAlright, let's summarize the current state of the application.\n\n- It's a Node.js application using Express for the server.\n- Multer is used to handle file uploads, with validation to accept only image files.\n- Sharp is used to resize the images to the specified width and height.\n- The resized images can be saved locally in a specified directory or uploaded to an S3 bucket, based on an environment variable.\n- Unique filenames are generated using UUIDs to avoid overwrite issues.\n- The image format is preserved from the original or can be converted to a specified format if provided.\n\nNext steps:\n\n- Set up environment variables in a `.env` file.\n- Ensure that the `uploads` and `resized-images` directories exist.\n- Test the application thoroughly, including edge cases like invalid dimensions, non-image files, etc.\n- Consider adding more features, such as retrieving a list of uploaded images or providing download links.\n- Implement authentication if necessary to restrict access to the upload functionality.\n\nFor now, I think this covers the basic requirements. I'll proceed to implement this code and test it.\n\n**Final Solution**\n\nTo solve this problem, we will build a Node.js web application that allows users to upload images, resizes them to a specified width and height using the Sharp library, and stores the resized images either on the local disk or in an Amazon S3 bucket.\n\n### Approach\n\n1. **Set Up the Project:**\n   - Initialize a new Node.js project.\n   - Install necessary dependencies: Express, Sharp, Multer, AWS SDK, and Dotenv.\n\n2. **Configure the Server:**\n   - Set up an Express server.\n   - Configure Multer for handling file uploads.\n   - Use Sharp for resizing images.\n\n3. **Environment Configuration:**\n   - Use Dotenv to manage environment variables.\n   - Configure storage destination (local or S3) and S3 credentials.\n\n4. **Image Upload and Resize:**\n   - Create an endpoint to handle image uploads.\n   - Resize the uploaded image using Sharp.\n   - Save the resized image locally or upload it to S3 based on the configuration.\n\n5. **Error Handling:**\n   - Handle errors during file upload, image processing, and storage operations.\n\n### Solution Code\n\n```javascript\nrequire('dotenv').config();\nconst express = require('express');\nconst sharp = require('sharp');\nconst multer = require('multer');\nconst fs = require('fs');\nconst path = require('path');\nconst AWS = require('aws-sdk');\nconst { v4: uuidv4 } = require('uuid');\n\nconst app = express();\nconst port = 3000;\n\n// Multer setup for handling file uploads\nconst upload = multer({\n  dest: 'uploads/',\n  fileFilter: (req, file, cb) => {\n    const allowedTypes = /image\\/(jpeg|jpg|png|gif)/;\n    if (!allowedTypes.test(file.mimetype)) {\n      cb(new Error('Only image files are allowed'), false);\n    }\n    cb(null, true);\n  }\n});\n\n// Configure S3 if storage destination is S3\nif (process.env.STORAGE_DEST === 's3') {\n  AWS.config.update({\n    accessKeyId: process.env.AWS_ACCESS_KEY,\n    secretAccessKey: process.env.AWS_SECRET_KEY,\n    region: process.env.AWS_REGION\n  });\n  const s3 = new AWS.S3();\n}\n\n// Ensure resized-images directory exists\nconst resizedDir = path.join(__dirname, 'resized-images');\nif (!fs.existsSync(resizedDir)) {\n  fs.mkdirSync(resizedDir);\n}\n\n// Allowed output formats\nconst allowedFormats = {\n  jpg: 'jpeg',\n  jpeg: 'jpeg',\n  png: 'png',\n  gif: 'gif',\n};\n\nconst formatToExtension = {\n  jpeg: 'jpg',\n  png: 'png',\n  gif: 'gif',\n};\n\napp.post('/upload', upload.single('image'), async (req, res, next) => {\n  try {\n    const { width, height, format } = req.query;\n\n    if (!width || !height) {\n      throw new Error('Width and height are required');\n    }\n\n    // Get image metadata\n    const metadata = await sharp(req.file.path).metadata();\n    const inputFormat = metadata.format;\n\n    // Determine output format\n    let outputFormat = format ? allowedFormats[format.toLowerCase()] : null;\n    if (outputFormat && !allowedFormats[outputFormat]) {\n      throw new Error('Invalid output format');\n    }\n    outputFormat = outputFormat || inputFormat;\n\n    // Resize the image\n    const buffer = await sharp(req.file.path)\n      .resize({ width: parseInt(width), height: parseInt(height) })\n      .toFormat(outputFormat)\n      .toBuffer();\n\n    // Generate unique filename\n    const extension = formatToExtension[outputFormat] || 'jpg';\n    const uniqueFilename = `${uuidv4()}.${extension}`;\n\n    // Save or upload the resized image\n    if (process.env.STORAGE_DEST === 'local') {\n      const filePath = path.join(resizedDir, uniqueFilename);\n      await new Promise((resolve, reject) => {\n        fs.writeFile(filePath, buffer, err => {\n          if (err) {\n            reject(err);\n          } else {\n            resolve();\n          }\n        });\n      });\n    } else if (process.env.STORAGE_DEST === 's3') {\n      const params = {\n        Bucket: process.env.S3_BUCKET_NAME,\n        Key: uniqueFilename,\n        Body: buffer,\n        ContentType: `image/${outputFormat}`,\n      };\n      await new Promise((resolve, reject) => {\n        s3.upload(params, (err, data) => {\n          if (err) {\n            reject(err);\n          } else {\n            resolve();\n          }\n        });\n      });\n    } else {\n      throw new Error('Invalid storage destination');\n    }\n\n    // Clean up temporary uploaded file\n    fs.unlinkSync(req.file.path);\n\n    res.send('Image resized and saved');\n  } catch (err) {\n    next(err);\n  }\n}, (err, req, res, next) => {\n  if (err instanceof multer.MulterError) {\n    res.status(400).send(err.message);\n  } else {\n    res.status(500).send('An error occurred');\n  }\n});\n\napp.listen(port, () => {\n  console.log(`Server is running on port ${port}`);\n});\n```\n\n### Explanation\n\n1. **Project Setup:**\n   - Initialize a new Node.js project and install required dependencies.\n\n2. **Server Configuration:**\n   - Set up an Express server and configure Multer for handling image uploads.\n   - Use Sharp for resizing images.\n\n3. **Environment Configuration:**\n   - Use Dotenv to manage environment variables for storage destination and AWS credentials.\n\n4. **Image Upload and Resize:**\n   - Create an endpoint to handle image uploads.\n   - Resize the image using Sharp and save it locally or upload to S3 based on the configuration.\n\n5. **Error Handling:**\n   - Handle errors during file upload, image processing, and storage operations to ensure robustness.\n\nThis approach ensures that the application is flexible, handles different image formats appropriately, and provides clear error messages for better user experience."
    }
]