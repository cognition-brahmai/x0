[
    {
        "role": "user",
        "content": "Develop a C# console application that implements a simple chat server using TCP/IP sockets. The server should accept multiple clients and broadcast messages received from one client to all other connected clients. PLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Alright, I'm going to try to create a simple chat server using C# and TCP/IP sockets. The goal is to have a server that can handle multiple clients and broadcast messages from one client to all others. I'm not too experienced with sockets in C#, so this might be a bit challenging, but I'll do my best.\n\nFirst, I need to set up a basic C# console application. I'll use Visual Studio for this, but I think I can also do it with the command line using dotnet CLI. I'll go with Visual Studio for now.\n\nI start by creating a new Console App project in C#. Once that's set up, I need to focus on the socket programming part.\n\nFrom what I remember, in TCP, we have a server that listens on a specific port, and clients connect to that server by knowing the IP address and port number. The server needs to accept incoming connections and handle them appropriately.\n\nSince I need to handle multiple clients, I'll probably have to use some form of threading or asynchronous programming to manage multiple client connections simultaneously.\n\nLet me recall the basic steps for a TCP server:\n\n1. Create a TcpListener object bound to a specific IP address and port.\n\n2. Start listening for incoming connections.\n\n3. Accept incoming connections, which gives me a TcpClient object for each client.\n\n4. Handle communication with each client by reading from and writing to their NetworkStream.\n\n5. For broadcasting messages, when a message is received from one client, I need to send that message to all other connected clients.\n\nI think I need to keep a list of all connected clients so that I can iterate through them when broadcasting messages.\n\nLet me think about the structure of the program.\n\nI'll need:\n\n- A class to represent the server.\n\n- A list to keep track of all connected clients.\n\n- A method to start the server and begin listening for connections.\n\n- A method to handle each client connection, which will run in its own thread or asynchronously.\n\n- A method to broadcast messages to all connected clients except the sender.\n\nPotential challenges:\n\n- Managing multiple client threads or asynchronous operations.\n\n- Ensuring thread safety when accessing the list of clients.\n\n- Handling exceptions and disconnects properly.\n\n- Efficiently broadcasting messages to all clients.\n\nI should also consider how clients will connect and communicate. Probably, clients will send messages as strings, and the server will forward them to other clients.\n\nI need to decide on a protocol for messages. For simplicity, I'll assume that messages are null-terminated strings.\n\nWait, in TCP, data is streamed, so I need a way to delimit messages. Using null-terminated strings might work, but I need to make sure that the receiver can correctly identify message boundaries.\n\nAlternatively, I could send the message length before the message itself, so the receiver knows how many bytes to read for the message.\n\nLet's go with sending the message length first, as a fixed-size integer, followed by the message bytes.\n\nFor example, I can send a 4-byte integer (network byte order) representing the message length, followed by that number of bytes containing the message.\n\nThis way, the receiver can first read the 4-byte length, then read exactly that number of bytes for the message.\n\nThis seems more reliable for message boundaries.\n\nNow, let's think about the server architecture.\n\nI'll have a Server class with the following members:\n\n- A TcpListener to listen for incoming connections.\n\n- A List<TcpClient> to keep track of connected clients.\n\n- A method to start the server, which will call TcpListener.Start().\n\n- An infinite loop that accepts incoming connections and spawns a new thread or uses async methods to handle each client.\n\n- A method to handle each client connection, which will read messages from the client and broadcast them to other clients.\n\n- A method to broadcast messages to all clients except the sender.\n\nI need to make sure that the list of clients is accessed in a thread-safe manner, perhaps by using locks.\n\nAlso, I should handle cases where clients disconnect unexpectedly.\n\nLet me sketch a rough outline of the Server class.\n\n```csharp\n\nusing System;\n\nusing System.Net;\n\nusing System.Net.Sockets;\n\nusing System.Collections.Generic;\n\nusing System.Threading;\n\npublic class Server\n\n{\n\n    private TcpListener listener;\n\n    private List<TcpClient> clients;\n\n    public Server(int port)\n\n    {\n\n        listener = new TcpListener(IPAddress.Any, port);\n\n        clients = new List<TcpClient>();\n\n    }\n\n    public void Start()\n\n    {\n\n        listener.Start();\n\n        while (true)\n\n        {\n\n            TcpClient client = listener.AcceptTcpClient();\n\n            clients.Add(client);\n\n            // Start a new thread or use async to handle the client\n\n        }\n\n    }\n\n    // Other methods...\n\n}\n\n```\n\nThis is a very basic outline. I need to expand it.\n\nFirst, I need a method to handle each client connection. This method will read messages from the client and broadcast them to other clients.\n\nI'll call this method HandleClient.\n\nI need to decide whether to use threads or async methods for handling multiple clients.\n\nUsing threads for each client is straightforward but might not be the most efficient for a large number of clients.\n\nAsync methods with async/await are more scalable and are recommended for I/O-bound operations like networking.\n\nI think I'll go with async methods for better performance and scalability.\n\nSo, I'll make HandleClient an async method that reads from the client's NetworkStream and broadcasts messages.\n\nI'll also need to read messages correctly, considering the message length prefix I mentioned earlier.\n\nLet me define a constant for the length prefix size, say 4 bytes.\n\nI'll need to read exactly 4 bytes for the length, then read exactly the number of bytes specified by the length.\n\nI need to handle cases where the read operations are not completed in a single go, especially for network streams which might not provide all requested bytes at once.\n\nI should also consider encoding for strings, probably using UTF8.\n\nLet me define some constants:\n\n```csharp\n\nprivate const int MessageLengthSize = 4;\n\nprivate readonly Encoding encoding = Encoding.UTF8;\n\n```\n\nNow, in the HandleClient method, I'll need to repeatedly read message length and then message data from the client's stream.\n\nOnce a message is received, I'll broadcast it to all other clients.\n\nI need to make sure that broadcasting is done without interfering with the list of clients, so I should lock the list when iterating through it.\n\nAlso, I need to handle exceptions and remove clients from the list when they disconnect.\n\nLet me try writing the HandleClient method.\n\n```csharp\n\nprivate async Task HandleClient(TcpClient client)\n\n{\n\n    try\n\n    {\n\n        NetworkStream stream = client.GetStream();\n\n        while (true)\n\n        {\n\n            byte[] lengthBytes = new byte[MessageLengthSize];\n\n            int totalBytesRead = 0;\n\n            while (totalBytesRead < MessageLengthSize)\n\n            {\n\n                int bytesRead = await stream.ReadAsync(lengthBytes, totalBytesRead, MessageLengthSize - totalBytesRead);\n\n                if (bytesRead == 0)\n\n                {\n\n                    // Client disconnected\n\n                    RemoveClient(client);\n\n                    return;\n\n                }\n\n                totalBytesRead += bytesRead;\n\n            }\n\n            int messageLength = BitConverter.ToInt32(lengthBytes, 0);\n\n            byte[] messageBytes = new byte[messageLength];\n\n            int totalMessageBytesRead = 0;\n\n            while (totalMessageBytesRead < messageLength)\n\n            {\n\n                int bytesRead = await stream.ReadAsync(messageBytes, totalMessageBytesRead, messageLength - totalMessageBytesRead);\n\n                if (bytesRead == 0)\n\n                {\n\n                    // Client disconnected\n\n                    RemoveClient(client);\n\n                    return;\n\n                }\n\n                totalMessageBytesRead += bytesRead;\n\n            }\n\n            string message = encoding.GetString(messageBytes);\n\n            Broadcast(message, client);\n\n        }\n\n    }\n\n    catch (Exception ex)\n\n    {\n\n        // Log the exception\n\n        RemoveClient(client);\n\n    }\n\n}\n\n```\n\nThis seems like a good start. I need to implement the RemoveClient method, which removes the client from the list and closes its resources.\n\nI should also make sure to start the HandleClient method asynchronously without blocking the server's accept loop.\n\nIn the Start method, instead of spawning a new thread for each client, I'll use Task.Run to handle each client asynchronously.\n\nHere's an updated Start method:\n\n```csharp\n\npublic async void Start()\n\n{\n\n    listener.Start();\n\n    while (true)\n\n    {\n\n        TcpClient client = await listener.AcceptTcpClientAsync();\n\n        lock (clients)\n\n        {\n\n            clients.Add(client);\n\n        }\n\n        _ = HandleClient(client);\n\n    }\n\n}\n\n```\n\nI'm using await listener.AcceptTcpClientAsync() to asynchronously accept clients, which is better than blocking in a loop.\n\nAlso, I'm using lock (clients) when adding a client to the list to ensure thread safety.\n\nIn the Broadcast method, I need to iterate through the list of clients and send the message to each one except the sender.\n\nI need to be careful here to avoid modifying the list while iterating through it, so I'll lock the list and create a copy of it to iterate through.\n\nAlso, I need to send the message in the same format: first the message length as 4 bytes, then the message bytes.\n\nHere's a possible implementation of Broadcast:\n\n```csharp\n\nprivate async void Broadcast(string message, TcpClient sender)\n\n{\n\n    lock (clients)\n\n    {\n\n        foreach (TcpClient client in clients)\n\n        {\n\n            if (client != sender)\n\n            {\n\n                _ = Send_message_async(client, message);\n\n            }\n\n        }\n\n    }\n\n}\n\n```\n\nWait, but I need to ensure that sending messages doesn't block the broadcast method, so I'll make Send_message_async return a Task and await it appropriately.\n\nActually, to make Broadcast await all send operations, I should collect all the send tasks and await them together.\n\nHere's a better version:\n\n```csharp\n\nprivate async Task Broadcast(string message, TcpClient sender)\n\n{\n\n    List<Task> sendTasks = new List<Task>();\n\n    lock (clients)\n\n    {\n\n        foreach (TcpClient client in clients)\n\n        {\n\n            if (client != sender)\n\n            {\n\n                sendTasks.Add(Send_message_async(client, message));\n\n            }\n\n        }\n\n    }\n\n    await Task.WhenAll(sendTasks);\n\n}\n\n```\n\nAnd the Send_message_async method would look like this:\n\n```csharp\n\nprivate async Task Send_message_async(TcpClient client, string message)\n\n{\n\n    try\n\n    {\n\n        NetworkStream stream = client.GetStream();\n\n        byte[] messageBytes = encoding.GetBytes(message);\n\n        byte[] lengthBytes = BitConverter.GetBytes(messageBytes.Length);\n\n        await stream.WriteAsync(lengthBytes, 0, MessageLengthSize);\n\n        await stream.WriteAsync(messageBytes, 0, messageBytes.Length);\n\n    }\n\n    catch (Exception ex)\n\n    {\n\n        // Log the exception\n\n        RemoveClient(client);\n\n    }\n\n}\n\n```\n\nThis method sends the message length followed by the message bytes asynchronously.\n\nI also need to implement the RemoveClient method:\n\n```csharp\n\nprivate void RemoveClient(TcpClient client)\n\n{\n\n    lock (clients)\n\n    {\n\n        clients.Remove(client);\n\n    }\n\n    client.Close();\n\n}\n\n```\n\nAlright, now I need to consider how clients will connect and use the chat.\n\nClients need to connect to the server's IP address and port, then they can send messages which will be broadcast to other clients.\n\nI should probably have a simple client program to test the server.\n\nBut for now, I'll focus on the server.\n\nI need to make sure that the server can handle multiple clients connecting and disconnecting gracefully.\n\nAlso, I need to handle cases where clients send empty messages or disconnect unexpectedly without notifying the server.\n\nI should also think about implementing a way to identify clients, maybe by assigning them unique IDs or using their socket information.\n\nFor simplicity, I'll use the socket's remote endpoint (IP address and port) as the client's identifier.\n\nI can store a dictionary of TcpClient objects mapped to their endpoints.\n\nWait, but TcpClient already has a property called Client which is a Socket, and Socket has a RemoteEndPoint property.\n\nSo, I can use that to identify clients.\n\nAlternatively, I can store the client's display name, but for now, I'll stick with their endpoint information.\n\nLet me adjust the Server class to use a dictionary for clients.\n\n```csharp\n\nprivate readonly Dictionary<EndPoint, TcpClient> clients = new Dictionary<EndPoint, TcpClient>();\n\n```\n\nThen, in HandleClient, after accepting a client, I can get their endpoint and add it to the dictionary.\n\nSimilarly, in RemoveClient, I can remove the client based on their endpoint.\n\nThis might be more efficient and easier to manage than using a list.\n\nHere's an updated HandleClient method:\n\n```csharp\n\nprivate async Task HandleClient(TcpClient client)\n\n{\n\n    try\n\n    {\n\n        EndPoint clientEndPoint = client.Client.RemoteEndPoint;\n\n        lock (clients)\n\n        {\n\n            clients[clientEndPoint] = client;\n\n        }\n\n        NetworkStream stream = client.GetStream();\n\n        while (true)\n\n        {\n\n            byte[] lengthBytes = new byte[MessageLengthSize];\n\n            int totalBytesRead = 0;\n\n            while (totalBytesRead < MessageLengthSize)\n\n            {\n\n                int bytesRead = await stream.ReadAsync(lengthBytes, totalBytesRead, MessageLengthSize - totalBytesRead);\n\n                if (bytesRead == 0)\n\n                {\n\n                    // Client disconnected\n\n                    RemoveClient(clientEndPoint);\n\n                    return;\n\n                }\n\n                totalBytesRead += bytesRead;\n\n            }\n\n            int messageLength = BitConverter.ToInt32(lengthBytes, 0);\n\n            byte[] messageBytes = new byte[messageLength];\n\n            int totalMessageBytesRead = 0;\n\n            while (totalMessageBytesRead < messageLength)\n\n            {\n\n                int bytesRead = await stream.ReadAsync(messageBytes, totalMessageBytesRead, messageLength - totalMessageBytesRead);\n\n                if (bytesRead == 0)\n\n                {\n\n                    // Client disconnected\n\n                    RemoveClient(clientEndPoint);\n\n                    return;\n\n                }\n\n                totalMessageBytesRead += bytesRead;\n\n            }\n\n            string message = encoding.GetString(messageBytes);\n\n            await Broadcast(message, clientEndPoint);\n\n        }\n\n    }\n\n    catch (Exception ex)\n\n    {\n\n        // Log the exception\n\n        RemoveClient(client.Client.RemoteEndPoint);\n\n    }\n\n}\n\n```\n\nAnd the RemoveClient method:\n\n```csharp\n\nprivate void RemoveClient(EndPoint endpoint)\n\n{\n\n    lock (clients)\n\n    {\n\n        if (clients.ContainsKey(endpoint))\n\n        {\n\n            TcpClient client = clients[endpoint];\n\n            clients.Remove(endpoint);\n\n            client.Close();\n\n        }\n\n    }\n\n}\n\n```\n\nAnd the Broadcast method:\n\n```csharp\n\nprivate async Task Broadcast(string message, EndPoint sender)\n\n{\n\n    List<Task> sendTasks = new List<Task>();\n\n    lock (clients)\n\n    {\n\n        foreach (var client in clients)\n\n        {\n\n            if (client.Key != sender)\n\n            {\n\n                sendTasks.Add(Send_message_async(client.Value, message));\n\n            }\n\n        }\n\n    }\n\n    await Task.WhenAll(sendTasks);\n\n}\n\n```\n\nThis seems better. Using a dictionary allows for faster lookups and deletions.\n\nI should also consider what happens when multiple clients try to send messages at the same time.\n\nSince each client is handled in its own async method, their operations should be independent.\n\nHowever, I need to ensure that the broadcast operation doesn't interfere with clients sending messages simultaneously.\n\nBy using locks when accessing the clients dictionary, I can prevent race conditions.\n\nI should also think about how to handle large messages or messages that exceed a certain size.\n\nMaybe I should impose a maximum message size to prevent abuse.\n\nFor now, I'll assume that messages are reasonably sized.\n\nAnother consideration is performance. Since broadcasting involves sending the same message to multiple clients, I need to make sure that this is efficient.\n\nUsing async methods should help here, as each send operation can be executed concurrently.\n\nI might also look into using SocketAsyncEventArgs for even better performance, but that seems more complex.\n\nFor this simple chat server, async methods should suffice.\n\nI should also think about how to close the server gracefully, perhaps by listening for a console input or a specific command.\n\nBut for now, I'll just have the server run indefinitely until manually stopped.\n\nLet me try to write the main method to start the server on a specified port.\n\nI'll accept the port number as a command-line argument.\n\nHere's the Main method:\n\n```csharp\n\nstatic void Main(string[] args)\n\n{\n\n    if (args.Length != 1)\n\n    {\n\n        Console.WriteLine(\"Usage: ChatServer port\");\n\n        return;\n\n    }\n\n    int port;\n\n    if (!int.TryParse(args[0], out port))\n\n    {\n\n        Console.WriteLine(\"Please enter a valid port number.\");\n\n        return;\n\n    }\n\n    Server server = new Server(port);\n\n    server.Start();\n\n    Console.WriteLine(\"Press any key to exit...\");\n\n    Console.ReadKey();\n\n}\n\n```\n\nI need to make sure that the Server.Start method is async and uses await properly.\n\nWait, in the Start method, I have an infinite loop with await AcceptTcpClientAsync(), but async void methods can be tricky because they don't return a Task, making it hard to wait for them to complete.\n\nMaybe I should make Start an async Task method and wait for it in the Main method.\n\nBut since C# 7.1, we can have async Main method, which is convenient.\n\nLet me adjust the code accordingly.\n\nFirst, change the Main method to be async and return a Task:\n\n```csharp\n\nstatic async Task Main(string[] args)\n\n{\n\n    if (args.Length != 1)\n\n    {\n\n        Console.WriteLine(\"Usage: ChatServer port\");\n\n        return;\n\n    }\n\n    int port;\n\n    if (!int.TryParse(args[0], out port))\n\n    {\n\n        Console.WriteLine(\"Please enter a valid port number.\");\n\n        return;\n\n    }\n\n    Server server = new Server(port);\n\n    await server.Start();\n\n    Console.WriteLine(\"Press any key to exit...\");\n\n    Console.ReadKey();\n\n}\n\n```\n\nAnd change the Server.Start method to be async Task:\n\n```csharp\n\npublic async Task Start()\n\n{\n\n    listener.Start();\n\n    while (true)\n\n    {\n\n        TcpClient client = await listener.AcceptTcpClientAsync();\n\n        EndPoint clientEndPoint = client.Client.RemoteEndPoint;\n\n        lock (clients)\n\n        {\n\n            clients[clientEndPoint] = client;\n\n        }\n\n        _ = HandleClient(client);\n\n    }\n\n}\n\n```\n\nThis should work better.\n\nNow, when the Main method awaits server.Start(), it will wait for the server to complete, which in this case is never, since it's an infinite loop.\n\nBut when the program is about to exit, it should stop the server properly.\n\nI should also add a way to stop the server, perhaps by setting a cancellation token.\n\nLet me introduce a CancellationToken to handle graceful shutdown.\n\nFirst, add a CancellationTokenSource in the Server class:\n\n```csharp\n\nprivate CancellationTokenSource cancellationTokenSource;\n\n```\n\nThen, in the Start method, accept a CancellationToken and pass it down:\n\n```csharp\n\npublic async Task Start(CancellationToken cancellationToken)\n\n{\n\n    listener.Start();\n\n    cancellationTokenSource = new CancellationTokenSource();\n\n    while (!cancellationToken.IsCancellationRequested)\n\n    {\n\n        try\n\n        {\n\n            TcpClient client = await listener.AcceptTcpClientAsync();\n\n            EndPoint clientEndPoint = client.Client.RemoteEndPoint;\n\n            lock (clients)\n\n            {\n\n                clients[clientEndPoint] = client;\n\n            }\n\n            _ = HandleClient(client, cancellationToken);\n\n        }\n\n        catch (OperationCanceledException)\n\n        {\n\n            // Shutdown requested\n\n            break;\n\n        }\n\n    }\n\n    // Clean up clients\n\n    lock (clients)\n\n    {\n\n        foreach (var client in clients.Values)\n\n        {\n\n            client.Close();\n\n        }\n\n        clients.Clear();\n\n    }\n\n}\n\n```\n\nI also need to modify the HandleClient method to accept the CancellationToken and monitor it.\n\nHere's an updated HandleClient method:\n\n```csharp\n\nprivate async Task HandleClient(TcpClient client, CancellationToken cancellationToken)\n\n{\n\n    try\n\n    {\n\n        NetworkStream stream = client.GetStream();\n\n        while (!cancellationToken.IsCancellationRequested)\n\n        {\n\n            byte[] lengthBytes = new byte[MessageLengthSize];\n\n            int totalBytesRead = 0;\n\n            while (totalBytesRead < MessageLengthSize)\n\n            {\n\n                int bytesRead = await stream.ReadAsync(lengthBytes, totalBytesRead, MessageLengthSize - totalBytesRead, cancellationToken);\n\n                if (bytesRead == 0)\n\n                {\n\n                    // Client disconnected\n\n                    RemoveClient(client.Client.RemoteEndPoint);\n\n                    return;\n\n                }\n\n                totalBytesRead += bytesRead;\n\n            }\n\n            int messageLength = BitConverter.ToInt32(lengthBytes, 0);\n\n            byte[] messageBytes = new byte[messageLength];\n\n            int totalMessageBytesRead = 0;\n\n            while (totalMessageBytesRead < messageLength)\n\n            {\n\n                int bytesRead = await stream.ReadAsync(messageBytes, totalMessageBytesRead, messageLength - totalMessageBytesRead, cancellationToken);\n\n                if (bytesRead == 0)\n\n                {\n\n                    // Client disconnected\n\n                    RemoveClient(client.Client.RemoteEndPoint);\n\n                    return;\n\n                }\n\n                totalMessageBytesRead += bytesRead;\n\n            }\n\n            string message = encoding.GetString(messageBytes);\n\n            await Broadcast(message, client.Client.RemoteEndPoint, cancellationToken);\n\n        }\n\n    }\n\n    catch (OperationCanceledException)\n\n    {\n\n        // Shutdown requested\n\n        RemoveClient(client.Client.RemoteEndPoint);\n\n    }\n\n    catch (Exception ex)\n\n    {\n\n        // Log the exception\n\n        RemoveClient(client.Client.RemoteEndPoint);\n\n    }\n\n}\n\n```\n\nAnd the Broadcast method should also accept the CancellationToken:\n\n```csharp\n\nprivate async Task Broadcast(string message, EndPoint sender, CancellationToken cancellationToken)\n\n{\n\n    List<Task> sendTasks = new List<Task>();\n\n    lock (clients)\n\n    {\n\n        foreach (var client in clients)\n\n        {\n\n            if (client.Key != sender)\n\n            {\n\n                sendTasks.Add(Send_message_async(client.Value, message, cancellationToken));\n\n            }\n\n        }\n\n    }\n\n    await Task.WhenAll(sendTasks);\n\n}\n\n```\n\nAnd the Send_message_async method:\n\n```csharp\n\nprivate async Task Send_message_async(TcpClient client, string message, CancellationToken cancellationToken)\n\n{\n\n    try\n\n    {\n\n        NetworkStream stream = client.GetStream();\n\n        byte[] messageBytes = encoding.GetBytes(message);\n\n        byte[] lengthBytes = BitConverter.GetBytes(messageBytes.Length);\n\n        await stream.WriteAsync(lengthBytes, 0, MessageLengthSize, cancellationToken);\n\n        await stream.WriteAsync(messageBytes, 0, messageBytes.Length, cancellationToken);\n\n    }\n\n    catch (Exception ex)\n\n    {\n\n        // Log the exception\n\n        RemoveClient(client.Client.RemoteEndPoint);\n\n    }\n\n}\n\n```\n\nIn the Main method, I'll create a CancellationTokenSource and pass its token to the Server.Start method.\n\nAlso, I'll wait for a console key press and then cancel the token to shutdown the server.\n\nHere's the updated Main method:\n\n```csharp\n\nstatic async Task Main(string[] args)\n\n{\n\n    if (args.Length != 1)\n\n    {\n\n        Console.WriteLine(\"Usage: ChatServer port\");\n\n        return;\n\n    }\n\n    int port;\n\n    if (!int.TryParse(args[0], out port))\n\n    {\n\n        Console.WriteLine(\"Please enter a valid port number.\");\n\n        return;\n\n    }\n\n    using CancellationTokenSource cancellationTokenSource = new CancellationTokenSource();\n\n    Server server = new Server(port);\n\n    _ = server.Start(cancellationTokenSource.Token);\n\n    Console.WriteLine(\"Press any key to exit...\");\n\n    Console.ReadKey();\n\n    cancellationTokenSource.Cancel();\n\n}\n\n```\n\nThis should allow for a graceful shutdown of the server when the user presses a key.\n\nI need to make sure that all ongoing operations respect the cancellation token and exit cleanly.\n\nNow, I should test the server to see if it works as expected.\n\nI'll need at least two client instances connected to the server to test broadcasting.\n\nI can write a simple client console application that connects to the server, sends messages, and receives messages from other clients.\n\nBut for now, I'll assume that the server code is correct and proceed accordingly.\n\nI should also consider edge cases, such as:\n\n- Multiple clients connecting and disconnecting concurrently.\n\n- Clients sending messages simultaneously.\n\n- Clients sending very large messages.\n\n- Clients disconnecting abruptly without notifying the server.\n\nTo handle these scenarios, I need to ensure that the server is robust and doesn't crash or leak resources.\n\nI should also implement proper error handling and logging.\n\nFor logging, I can use Console.WriteLine for simplicity, but in a production environment, I'd use a logging framework like NLog or Serilog.\n\nAdditionally, I might want to add some identification for clients, like assigning them unique IDs or using their usernames.\n\nBut for this basic implementation, using their endpoint information should suffice.\n\nI should also think about how to display messages to clients, perhaps prefixing the message with the client's endpoint or username.\n\nIn the Broadcast method, I can include the sender's information in the message before sending it to other clients.\n\nFor example, the message could be formatted as \"Client [endpoint]: [message]\".\n\nThis way, clients can see who sent each message.\n\nI'll need to adjust the Broadcast method accordingly.\n\nFirst, modify the Broadcast method to include the sender's endpoint in the message.\n\nHere's an updated Broadcast method:\n\n```csharp\n\nprivate async Task Broadcast(string message, EndPoint sender, CancellationToken cancellationToken)\n\n{\n\n    string formattedMessage = $\"{sender}: {message}\";\n\n    List<Task> sendTasks = new List<Task>();\n\n    lock (clients)\n\n    {\n\n        foreach (var client in clients)\n\n        {\n\n            if (client.Key != sender)\n\n            {\n\n                sendTasks.Add(Send_message_async(client.Value, formattedMessage, cancellationToken));\n\n            }\n\n        }\n\n    }\n\n    await Task.WhenAll(sendTasks);\n\n}\n\n```\n\nThis way, each message broadcast to clients will include the sender's endpoint.\n\nClients can then display the message with the sender's information.\n\nAlternatively, I can send the sender's information separately, but for simplicity, I'll include it in the message string.\n\nI should also consider escaping or sanitizing the message to prevent any injection attacks, but for this simple chat server, it's probably unnecessary.\n\nAnother consideration is handling the server across multiple threads.\n\nSince I'm using locks to access the clients dictionary, it should be thread-safe.\n\nHowever, I need to ensure that no two threads modify the dictionary simultaneously, which the lock should prevent.\n\nI should also be careful with the cancellationToken to ensure that all operations respect it and exit cleanly when requested.\n\nI might want to set a timeout for read operations to handle slow or unresponsive clients.\n\nIn the HandleClient method, I can use the ReadAsync method with a cancellation token to handle timeouts.\n\nBut for now, I'll assume that read operations complete in a reasonable time.\n\nI should also think about how to handle exceptions in the Send_message_async method.\n\nIf sending a message fails, I should remove the client from the list to clean up resources.\n\nAdditionally, I might want to log the exception for debugging purposes.\n\nFor logging, I'll just use Console.WriteLine for now.\n\nHere's an updated Send_message_async method with logging:\n\n```csharp\n\nprivate async Task Send_message_async(TcpClient client, string message, CancellationToken cancellationToken)\n\n{\n\n    try\n\n    {\n\n        NetworkStream stream = client.GetStream();\n\n        byte[] messageBytes = encoding.GetBytes(message);\n\n        byte[] lengthBytes = BitConverter.GetBytes(messageBytes.Length);\n\n        await stream.WriteAsync(lengthBytes, 0, MessageLengthSize, cancellationToken);\n\n        await stream.WriteAsync(messageBytes, 0, messageBytes.Length, cancellationToken);\n\n    }\n\n    catch (Exception ex)\n\n    {\n\n        Console.WriteLine($\"Error sending message to {client.Client.RemoteEndPoint}: {ex.Message}\");\n\n        RemoveClient(client.Client.RemoteEndPoint);\n\n    }\n\n}\n\n```\n\nThis should help in identifying any issues that occur during message sending.\n\nNow, I need to make sure that the server can handle a reasonable number of clients simultaneously.\n\nI should test it with at least a few clients connecting and sending messages.\n\nI can write a simple client console application that connects to the server, reads user input for messages, and displays incoming messages from the server.\n\nBut for now, I'll assume that the server logic is correct and move forward.\n\nI should also consider the network byte order for the message length.\n\nIn BitConverter, I need to ensure that the byte order is consistent across different systems.\n\nI can use BitConverter.IsLittleEndian to handle endianess properly.\n\nHere's how I can adjust the lengthBytes assignment:\n\n```csharp\n\nbyte[] lengthBytes = BitConverter.GetBytes(messageBytes.Length);\n\nif (BitConverter.IsLittleEndian)\n\n{\n\n    Array.Reverse(lengthBytes);\n\n}\n\n```\n\nAnd when reading the length from the stream:\n\n```csharp\n\nint messageLength = BitConverter.ToInt32(lengthBytes, 0);\n\nif (BitConverter.IsLittleEndian)\n\n{\n\n    messageLength = BitConverter.ToInt32(lengthBytes, 0);\n\n}\n\nelse\n\n{\n\n    Array.Reverse(lengthBytes);\n\n    messageLength = BitConverter.ToInt32(lengthBytes, 0);\n\n}\n\n```\n\nWait, actually, in the reading part, I think I need to reverse the bytes only if the system is little-endian, to match network byte order (big-endian).\n\nLet me verify this.\n\nIn network programming, integers are typically sent in big-endian (network byte order).\n\nIn C#, BitConverter.ToInt32 uses the system's byte order by default.\n\nSo, to convert to network byte order, I need to reverse the bytes if the system is little-endian.\n\nTherefore, when sending the length:\n\n```csharp\n\nbyte[] lengthBytes = BitConverter.GetBytes(messageBytes.Length);\n\nif (BitConverter.IsLittleEndian)\n\n{\n\n    Array.Reverse(lengthBytes);\n\n}\n\nawait stream.WriteAsync(lengthBytes, 0, MessageLengthSize, cancellationToken);\n\n```\n\nAnd when receiving the length:\n\n```csharp\n\nint messageLength = BitConverter.ToInt32(lengthBytes, 0);\n\nif (BitConverter.IsLittleEndian)\n\n{\n\n    Array.Reverse(lengthBytes);\n\n    messageLength = BitConverter.ToInt32(lengthBytes, 0);\n\n}\n\n```\n\nThis ensures that the message length is correctly interpreted regardless of the system's endianess.\n\nI need to make sure to apply this consistent handling in both sending and receiving parts.\n\nNow, I should review the entire Server class to ensure all parts are correctly implemented.\n\nHere's the complete Server class so far:\n\n```csharp\n\nusing System;\n\nusing System.Net;\n\nusing System.Net.Sockets;\n\nusing System.Collections.Generic;\n\nusing System.Threading;\n\nusing System.Threading.Tasks;\n\nusing System.Text;\n\npublic class Server\n\n{\n\n    private TcpListener listener;\n\n    private readonly Dictionary<EndPoint, TcpClient> clients;\n\n    private readonly Encoding encoding;\n\n    private const int MessageLengthSize = 4;\n\n    private CancellationTokenSource cancellationTokenSource;\n\n    public Server(int port)\n\n    {\n\n        listener = new TcpListener(IPAddress.Any, port);\n\n        clients = new Dictionary<EndPoint, TcpClient>();\n\n        encoding = Encoding.UTF8;\n\n    }\n\n    public async Task Start(CancellationToken cancellationToken)\n\n    {\n\n        listener.Start();\n\n        cancellationTokenSource = new CancellationTokenSource();\n\n        while (!cancellationToken.IsCancellationRequested)\n\n        {\n\n            try\n\n            {\n\n                TcpClient client = await listener.AcceptTcpClientAsync();\n\n                EndPoint clientEndPoint = client.Client.RemoteEndPoint;\n\n                lock (clients)\n\n                {\n\n                    clients[clientEndPoint] = client;\n\n                }\n\n                _ = HandleClient(client, cancellationToken);\n\n            }\n\n            catch (OperationCanceledException)\n\n            {\n\n                // Shutdown requested\n\n                break;\n\n            }\n\n        }\n\n        // Clean up clients\n\n        lock (clients)\n\n        {\n\n            foreach (var client in clients.Values)\n\n            {\n\n                client.Close();\n\n            }\n\n            clients.Clear();\n\n        }\n\n    }\n\n    private async Task HandleClient(TcpClient client, CancellationToken cancellationToken)\n\n    {\n\n        try\n\n        {\n\n            NetworkStream stream = client.GetStream();\n\n            while (!cancellationToken.IsCancellationRequested)\n\n            {\n\n                byte[] lengthBytes = new byte[MessageLengthSize];\n\n                int totalBytesRead = 0;\n\n                while (totalBytesRead < MessageLengthSize)\n\n                {\n\n                    int bytesRead = await stream.ReadAsync(lengthBytes, totalBytesRead, MessageLengthSize - totalBytesRead, cancellationToken);\n\n                    if (bytesRead == 0)\n\n                    {\n\n                        // Client disconnected\n\n                        RemoveClient(client.Client.RemoteEndPoint);\n\n                        return;\n\n                    }\n\n                    totalBytesRead += bytesRead;\n\n                }\n\n                int messageLength = BitConverter.ToInt32(lengthBytes, 0);\n\n                if (BitConverter.IsLittleEndian)\n\n                {\n\n                    Array.Reverse(lengthBytes);\n\n                    messageLength = BitConverter.ToInt32(lengthBytes, 0);\n\n                }\n\n                byte[] messageBytes = new byte[messageLength];\n\n                int totalMessageBytesRead = 0;\n\n                while (totalMessageBytesRead < messageLength)\n\n                {\n\n                    int bytesRead = await stream.ReadAsync(messageBytes, totalMessageBytesRead, messageLength - totalMessageBytesRead, cancellationToken);\n\n                    if (bytesRead == 0)\n\n                    {\n\n                        // Client disconnected\n\n                        RemoveClient(client.Client.RemoteEndPoint);\n\n                        return;\n\n                    }\n\n                    totalMessageBytesRead += bytesRead;\n\n                }\n\n                string message = encoding.GetString(messageBytes);\n\n                await Broadcast(message, client.Client.RemoteEndPoint, cancellationToken);\n\n            }\n\n        }\n\n        catch (OperationCanceledException)\n\n        {\n\n            // Shutdown requested\n\n            RemoveClient(client.Client.RemoteEndPoint);\n\n        }\n\n        catch (Exception ex)\n\n        {\n\n            // Log the exception\n\n            RemoveClient(client.Client.RemoteEndPoint);\n\n        }\n\n    }\n\n    private async Task Broadcast(string message, EndPoint sender, CancellationToken cancellationToken)\n\n    {\n\n        string formattedMessage = $\"{sender}: {message}\";\n\n        List<Task> sendTasks = new List<Task>();\n\n        lock (clients)\n\n        {\n\n            foreach (var client in clients)\n\n            {\n\n                if (client.Key != sender)\n\n                {\n\n                    sendTasks.Add(Send_message_async(client.Value, formattedMessage, cancellationToken));\n\n                }\n\n            }\n\n        }\n\n        await Task.WhenAll(sendTasks);\n\n    }\n\n    private async Task Send_message_async(TcpClient client, string message, CancellationToken cancellationToken)\n\n    {\n\n        try\n\n        {\n\n            NetworkStream stream = client.GetStream();\n\n            byte[] messageBytes = encoding.GetBytes(message);\n\n            byte[] lengthBytes = BitConverter.GetBytes(messageBytes.Length);\n\n            if (BitConverter.IsLittleEndian)\n\n            {\n\n                Array.Reverse(lengthBytes);\n\n            }\n\n            await stream.WriteAsync(lengthBytes, 0, MessageLengthSize, cancellationToken);\n\n            await stream.WriteAsync(messageBytes, 0, messageBytes.Length, cancellationToken);\n\n        }\n\n        catch (Exception ex)\n\n        {\n\n            Console.WriteLine($\"Error sending message to {client.Client.RemoteEndPoint}: {ex.Message}\");\n\n            RemoveClient(client.Client.RemoteEndPoint);\n\n        }\n\n    }\n\n    private void RemoveClient(EndPoint endpoint)\n\n    {\n\n        lock (clients)\n\n        {\n\n            if (clients.ContainsKey(endpoint))\n\n            {\n\n                TcpClient client = clients[endpoint];\n\n                clients.Remove(endpoint);\n\n                client.Close();\n\n            }\n\n        }\n\n    }\n\n}\n\n```\n\nThis seems comprehensive. I need to make sure that all async methods are properly awaited and that exceptions are handled gracefully.\n\nI should also consider adding some configuration options, such as the maximum message size or the IP address to listen on, but for now, hardcoding these values is acceptable.\n\nNow, I'll proceed to write a simple client console application to test the server.\n\nThe client should be able to connect to the server, send messages, and receive messages from other clients.\n\nI'll create another C# console application for the client.\n\nIn the client application, I'll need to:\n\n1. Connect to the server's IP address and port.\n\n2. Read user input for messages and send them to the server.\n\n3. Receive messages from the server and display them to the user.\n\n4. Handle disconnection gracefully.\n\nAgain, I'll use async methods for handling network operations.\n\nLet me start by creating a new Console App project for the client.\n\nIn the client's Program class, I'll write an async Main method to handle the connection and messaging.\n\nFirst, I need to accept the server's IP address and port from the user or via command-line arguments.\n\nFor simplicity, I'll hardcode the server's IP and port in this example, but in a real application, I'd make them configurable.\n\nHere's a rough outline of the client's Main method:\n\n```csharp\n\nstatic async Task Main(string[] args)\n\n{\n\n    string serverIp = \"127.0.0.1\";\n\n    int serverPort = 5000;\n\n    TcpClient client = new TcpClient();\n\n    await client.ConnectAsync(serverIp, serverPort);\n\n    Console.WriteLine(\"Connected to server.\");\n\n    NetworkStream stream = client.GetStream();\n\n    // Start a task to read messages from the server\n\n    _ = ReadMessagesAsync(stream);\n\n    // Read user input and send messages to the server\n\n    while (true)\n\n    {\n\n        string message = Console.ReadLine();\n\n        if (string.IsNullOrEmpty(message))\n\n        {\n\n            continue;\n\n        }\n\n        await SendMessageAsync(stream, message);\n\n    }\n\n}\n\n```\n\nIn this outline, I have two main parts:\n\n- A background task that reads messages from the server and displays them to the user.\n\n- A loop that reads user input and sends messages to the server.\n\nI need to implement the ReadMessagesAsync and SendMessageAsync methods.\n\nFirst, the SendMessageAsync method should send the message in the same format as the server expects: a 4-byte length followed by the message bytes.\n\nHere's how I can implement it:\n\n```csharp\n\nprivate static async Task SendMessageAsync(NetworkStream stream, string message)\n\n{\n\n    byte[] messageBytes = Encoding.UTF8.GetBytes(message);\n\n    byte[] lengthBytes = BitConverter.GetBytes(messageBytes.Length);\n\n    if (BitConverter.IsLittleEndian)\n\n    {\n\n        Array.Reverse(lengthBytes);\n\n    }\n\n    await stream.WriteAsync(lengthBytes, 0, 4);\n\n    await stream.WriteAsync(messageBytes, 0, messageBytes.Length);\n\n}\n\n```\n\nSimilarly, the ReadMessagesAsync method needs to read the message length and then the message bytes from the stream.\n\nHere's a possible implementation:\n\n```csharp\n\nprivate static async Task ReadMessagesAsync(NetworkStream stream)\n\n{\n\n    byte[] lengthBuffer = new byte[4];\n\n    while (true)\n\n    {\n\n        int totalBytesRead = 0;\n\n        while (totalBytesRead < 4)\n\n        {\n\n            int bytesRead = await stream.ReadAsync(lengthBuffer, totalBytesRead, 4 - totalBytesRead);\n\n            if (bytesRead == 0)\n\n            {\n\n                // Server disconnected\n\n                Console.WriteLine(\"Server disconnected.\");\n\n                return;\n\n            }\n\n            totalBytesRead += bytesRead;\n\n        }\n\n        int messageLength = BitConverter.ToInt32(lengthBuffer, 0);\n\n        if (BitConverter.IsLittleEndian)\n\n        {\n\n            Array.Reverse(lengthBuffer);\n\n            messageLength = BitConverter.ToInt32(lengthBuffer, 0);\n\n        }\n\n        byte[] messageBuffer = new byte[messageLength];\n\n        int totalMessageBytesRead = 0;\n\n        while (totalMessageBytesRead < messageLength)\n\n        {\n\n            int bytesRead = await stream.ReadAsync(messageBuffer, totalMessageBytesRead, messageLength - totalMessageBytesRead);\n\n            if (bytesRead == 0)\n\n            {\n\n                // Server disconnected\n\n                Console.WriteLine(\"Server disconnected.\");\n\n                return;\n\n            }\n\n            totalMessageBytesRead += bytesRead;\n\n        }\n\n        string message = Encoding.UTF8.GetString(messageBuffer);\n\n        Console.WriteLine(message);\n\n    }\n\n}\n\n```\n\nThis should handle receiving messages correctly.\n\nI need to make sure that the client can handle multiple messages sequentially and that there are no issues with overlapping reads.\n\nBy reading the exact number of bytes specified by the message length, I should avoid such issues.\n\nNow, I'll test the client and server together.\n\nFirst, run the server application, specifying the port, for example, 5000.\n\nThen, open multiple client instances and connect to the server.\n\nEach client should be able to send messages that are broadcast to all other connected clients.\n\nI should see messages from other clients displayed in each client's console.\n\nIf everything works as expected, then the chat server is functioning correctly.\n\nPotential improvements:\n\n- Implement user authentication or naming to identify clients better.\n\n- Add commands for clients to join different chat rooms or perform other actions.\n\n- Improve error handling and add more logging.\n\n- Optimize performance for a larger number of clients.\n\n- Implement SSL/TLS for encrypted communication.\n\nBut for a simple chat server, this should suffice.\n\nI think I've covered the basic requirements for this task.\n\n**Final Solution**\n\nTo create a simple chat server using C# and TCP/IP sockets that accepts multiple clients and broadcasts messages from one client to all others, follow these steps:\n\n### Server Code\n\n1. **Create a new C# Console Application project.**\n2. **Implement the Server Class:**\n\n```csharp\nusing System;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Collections.Generic;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing System.Text;\n\npublic class Server\n{\n    private TcpListener listener;\n    private readonly Dictionary<EndPoint, TcpClient> clients;\n    private readonly Encoding encoding;\n    private const int MessageLengthSize = 4;\n    private CancellationTokenSource cancellationTokenSource;\n\n    public Server(int port)\n    {\n        listener = new TcpListener(IPAddress.Any, port);\n        clients = new Dictionary<EndPoint, TcpClient>();\n        encoding = Encoding.UTF8;\n    }\n\n    public async Task Start(CancellationToken cancellationToken)\n    {\n        listener.Start();\n        cancellationTokenSource = new CancellationTokenSource();\n        while (!cancellationToken.IsCancellationRequested)\n        {\n            try\n            {\n                TcpClient client = await listener.AcceptTcpClientAsync();\n                EndPoint clientEndPoint = client.Client.RemoteEndPoint;\n                lock (clients)\n                {\n                    clients[clientEndPoint] = client;\n                }\n                _ = HandleClient(client, cancellationToken);\n            }\n            catch (OperationCanceledException)\n            {\n                // Shutdown requested\n                break;\n            }\n        }\n        // Clean up clients\n        lock (clients)\n        {\n            foreach (var client in clients.Values)\n            {\n                client.Close();\n            }\n            clients.Clear();\n        }\n    }\n\n    private async Task HandleClient(TcpClient client, CancellationToken cancellationToken)\n    {\n        try\n        {\n            NetworkStream stream = client.GetStream();\n            while (!cancellationToken.IsCancellationRequested)\n            {\n                byte[] lengthBytes = new byte[MessageLengthSize];\n                int totalBytesRead = 0;\n                while (totalBytesRead < MessageLengthSize)\n                {\n                    int bytesRead = await stream.ReadAsync(lengthBytes, totalBytesRead, MessageLengthSize - totalBytesRead, cancellationToken);\n                    if (bytesRead == 0)\n                    {\n                        // Client disconnected\n                        RemoveClient(client.Client.RemoteEndPoint);\n                        return;\n                    }\n                    totalBytesRead += bytesRead;\n                }\n                int messageLength = BitConverter.ToInt32(lengthBytes, 0);\n                if (BitConverter.IsLittleEndian)\n                {\n                    Array.Reverse(lengthBytes);\n                    messageLength = BitConverter.ToInt32(lengthBytes, 0);\n                }\n                byte[] messageBytes = new byte[messageLength];\n                int totalMessageBytesRead = 0;\n                while (totalMessageBytesRead < messageLength)\n                {\n                    int bytesRead = await stream.ReadAsync(messageBytes, totalMessageBytesRead, messageLength - totalMessageBytesRead, cancellationToken);\n                    if (bytesRead == 0)\n                    {\n                        // Client disconnected\n                        RemoveClient(client.Client.RemoteEndPoint);\n                        return;\n                    }\n                    totalMessageBytesRead += bytesRead;\n                }\n                string message = encoding.GetString(messageBytes);\n                await Broadcast(message, client.Client.RemoteEndPoint, cancellationToken);\n            }\n        }\n        catch (OperationCanceledException)\n        {\n            // Shutdown requested\n            RemoveClient(client.Client.RemoteEndPoint);\n        }\n        catch (Exception ex)\n        {\n            // Log the exception\n            RemoveClient(client.Client.RemoteEndPoint);\n        }\n    }\n\n    private async Task Broadcast(string message, EndPoint sender, CancellationToken cancellationToken)\n    {\n        string formattedMessage = $\"{sender}: {message}\";\n        List<Task> sendTasks = new List<Task>();\n        lock (clients)\n        {\n            foreach (var client in clients)\n            {\n                if (client.Key != sender)\n                {\n                    sendTasks.Add(Send_message_async(client.Value, formattedMessage, cancellationToken));\n                }\n            }\n        }\n        await Task.WhenAll(sendTasks);\n    }\n\n    private async Task Send_message_async(TcpClient client, string message, CancellationToken cancellationToken)\n    {\n        try\n        {\n            NetworkStream stream = client.GetStream();\n            byte[] messageBytes = encoding.GetBytes(message);\n            byte[] lengthBytes = BitConverter.GetBytes(messageBytes.Length);\n            if (BitConverter.IsLittleEndian)\n            {\n                Array.Reverse(lengthBytes);\n            }\n            await stream.WriteAsync(lengthBytes, 0, MessageLengthSize, cancellationToken);\n            await stream.WriteAsync(messageBytes, 0, messageBytes.Length, cancellationToken);\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine($\"Error sending message to {client.Client.RemoteEndPoint}: {ex.Message}\");\n            RemoveClient(client.Client.RemoteEndPoint);\n        }\n    }\n\n    private void RemoveClient(EndPoint endpoint)\n    {\n        lock (clients)\n        {\n            if (clients.ContainsKey(endpoint))\n            {\n                TcpClient client = clients[endpoint];\n                clients.Remove(endpoint);\n                client.Close();\n            }\n        }\n    }\n}\n```\n\n3. **Implement the Main Method:**\n\n```csharp\nstatic async Task Main(string[] args)\n{\n    if (args.Length != 1)\n    {\n        Console.WriteLine(\"Usage: ChatServer port\");\n        return;\n    }\n\n    int port;\n    if (!int.TryParse(args[0], out port))\n    {\n        Console.WriteLine(\"Please enter a valid port number.\");\n        return;\n    }\n\n    using CancellationTokenSource cancellationTokenSource = new CancellationTokenSource();\n    Server server = new Server(port);\n    _ = server.Start(cancellationTokenSource.Token);\n    Console.WriteLine(\"Press any key to exit...\");\n    Console.ReadKey();\n    cancellationTokenSource.Cancel();\n}\n```\n\n### Client Code\n\n1. **Create another C# Console Application project for the client.**\n2. **Implement the Client Program:**\n\n```csharp\nusing System;\nusing System.Net;\nusing System.Net.Sockets;\nusing System.Text;\nusing System.Threading.Tasks;\n\nclass Program\n{\n    static async Task Main(string[] args)\n    {\n        string serverIp = \"127.0.0.1\";\n        int serverPort = 5000;\n        TcpClient client = new TcpClient();\n        await client.ConnectAsync(serverIp, serverPort);\n        Console.WriteLine(\"Connected to server.\");\n        NetworkStream stream = client.GetStream();\n        // Start a task to read messages from the server\n        _ = ReadMessagesAsync(stream);\n        // Read user input and send messages to the server\n        while (true)\n        {\n            string message = Console.ReadLine();\n            if (string.IsNullOrEmpty(message))\n            {\n                continue;\n            }\n            await SendMessageAsync(stream, message);\n        }\n    }\n\n    private static async Task SendMessageAsync(NetworkStream stream, string message)\n    {\n        byte[] messageBytes = Encoding.UTF8.GetBytes(message);\n        byte[] lengthBytes = BitConverter.GetBytes(messageBytes.Length);\n        if (BitConverter.IsLittleEndian)\n        {\n            Array.Reverse(lengthBytes);\n        }\n        await stream.WriteAsync(lengthBytes, 0, 4);\n        await stream.WriteAsync(messageBytes, 0, messageBytes.Length);\n    }\n\n    private static async Task ReadMessagesAsync(NetworkStream stream)\n    {\n        byte[] lengthBuffer = new byte[4];\n        while (true)\n        {\n            int totalBytesRead = 0;\n            while (totalBytesRead < 4)\n            {\n                int bytesRead = await stream.ReadAsync(lengthBuffer, totalBytesRead, 4 - totalBytesRead);\n                if (bytesRead == 0)\n                {\n                    // Server disconnected\n                    Console.WriteLine(\"Server disconnected.\");\n                    return;\n                }\n                totalBytesRead += bytesRead;\n            }\n            int messageLength = BitConverter.ToInt32(lengthBuffer, 0);\n            if (BitConverter.IsLittleEndian)\n            {\n                Array.Reverse(lengthBuffer);\n                messageLength = BitConverter.ToInt32(lengthBuffer, 0);\n            }\n            byte[] messageBuffer = new byte[messageLength];\n            int totalMessageBytesRead = 0;\n            while (totalMessageBytesRead < messageLength)\n            {\n                int bytesRead = await stream.ReadAsync(messageBuffer, totalMessageBytesRead, messageLength - totalMessageBytesRead);\n                if (bytesRead == 0)\n                {\n                    // Server disconnected\n                    Console.WriteLine(\"Server disconnected.\");\n                    return;\n                }\n                totalMessageBytesRead += bytesRead;\n            }\n            string message = Encoding.UTF8.GetString(messageBuffer);\n            Console.WriteLine(message);\n        }\n    }\n}\n```\n\n### Explanation\n\n- **Server:**\n  - Listens for incoming connections and manages multiple clients using asynchronous methods.\n  - Broadcasts messages received from one client to all other connected clients.\n  - Uses a dictionary to track connected clients for efficient management.\n\n- **Client:**\n  - Connects to the server and sends messages entered by the user.\n  - Receives and displays messages from the server in real-time.\n\nThis setup ensures that the chat server can handle multiple clients efficiently and broadcast messages effectively using TCP/IP sockets in C#."
    }
]