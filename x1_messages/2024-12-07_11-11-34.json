[
    {
        "role": "user",
        "content": "Implement a C++ class representing a simple stack data structure with push, pop, and peek operations. The stack should have a fixed size specified at instantiation and throw an exception when trying to push onto a full stack or pop from an empty stack. Include unit tests demonstrating correct functionality."
    },
    {
        "role": "assistant",
        "content": "Sure, I can help you with that! Implementing a stack in C++ is a great way to understand both basic data structures and exception handling in C++. A stack is a Last-In-First-Out (LIFO) data structure, and by fixing its size at instantiation, we can manage memory more efficiently.\n\nFirst, let's outline what we need to do:\n\n1. **Define the Stack Class:**\n   - Private member to store the array of elements.\n   - Private members to keep track of the top of the stack and the size of the stack.\n   - Public methods: `push`, `pop`, `peek`, and possibly a `isFull` and `isEmpty` for utility.\n\n2. **Exception Handling:**\n   - Throw an exception when trying to push onto a full stack.\n   - Throw an exception when trying to pop from an empty stack.\n\n3. **Unit Tests:**\n   - Test pushing and popping elements.\n   - Test peeking at the top element.\n   - Test handling of full and empty stack scenarios.\n\nLet's start by defining the Stack class.\n\n### Stack Class Definition\n\n```cpp\n#include <iostream>\n#include <exception>\n\nclass StackFullException : public std::exception {\npublic:\n    const char* what() const throw() {\n        return \"Stack is full\";\n    }\n};\n\nclass StackEmptyException : public std::exception {\npublic:\n    const char* what() const throw() {\n        return \"Stack is empty\";\n    }\n};\n\ntemplate<typename T>\nclass FixedSizeStack {\nprivate:\n    T* stack;\n    int top;\n    int capacity;\n\npublic:\n    FixedSizeStack(int size) {\n        if (size <= 0) {\n            throw std::invalid_argument(\"Size must be positive\");\n        }\n        capacity = size;\n        stack = new T[capacity];\n        top = -1;\n    }\n\n    ~FixedSizeStack() {\n        delete[] stack;\n    }\n\n    void push(const T& value) {\n        if (isFull()) {\n            throw StackFullException();\n        }\n        stack[++top] = value;\n    }\n\n    T pop() {\n        if (isEmpty()) {\n            throw StackEmptyException();\n        }\n        return stack[top--];\n    }\n\n    T peek() const {\n        if (isEmpty()) {\n            throw StackEmptyException();\n        }\n        return stack[top];\n    }\n\n    bool isEmpty() const {\n        return top == -1;\n    }\n\n    bool isFull() const {\n        return top == capacity - 1;\n    }\n};\n```\n\n### Explanation\n\n1. **Exception Classes:**\n   - `StackFullException` and `StackEmptyException` are custom exceptions derived from `std::exception`. They provide messages for when the stack is full or empty.\n\n2. **FixedSizeStack Class:**\n   - Templates are used to make the stack work with any data type.\n   - The constructor initializes the stack with a given size and sets the top to -1 (empty stack).\n   - The destructor frees the allocated memory.\n   - `push` adds an element to the top of the stack, throwing `StackFullException` if the stack is full.\n   - `pop` removes and returns the top element, throwing `StackEmptyException` if the stack is empty.\n   - `peek` returns the top element without removing it, throwing `StackEmptyException` if the stack is empty.\n   - `isEmpty` and `isFull` are utility functions to check the state of the stack.\n\n### Unit Tests\n\nTo test this stack, we can write a simple test function that exercises all the methods and checks for correct behavior, including exception handling.\n\n```cpp\n#include <iostream>\n#include <cassert>\n\nvoid testStack() {\n    FixedSizeStack<int> stack(3);\n\n    // Test push and pop\n    stack.push(1);\n    stack.push(2);\n    assert(stack.peek() == 2);\n    assert(stack.pop() == 2);\n    assert(stack.peek() == 1);\n    assert(stack.pop() == 1);\n    assert(stack.isEmpty());\n\n    // Test pushing beyond capacity\n    stack.push(3);\n    stack.push(4);\n    try {\n        stack.push(5);\n        assert(false); // Should not reach here\n    } catch (const StackFullException&) {\n        std::cout << \"Caught StackFullException as expected\" << std::endl;\n    }\n\n    // Test popping from empty stack\n    try {\n        stack.pop();\n        assert(false); // Should not reach here\n    } catch (const StackEmptyException&) {\n        std::cout << \"Caught StackEmptyException as expected\" << std::endl;\n    }\n}\n\nint main() {\n    testStack();\n    std::cout << \"All tests passed successfully.\" << std::endl;\n    return 0;\n}\n```\n\n### Explanation of Tests\n\n1. **Basic Operations:**\n   - Push two elements and check peek and pop operations.\n   - Ensure the stack is empty after popping all elements.\n\n2. **Full Stack Scenario:**\n   - Push elements until the stack is full.\n   - Attempt to push an additional element and catch the `StackFullException`.\n\n3. **Empty Stack Scenario:**\n   - Pop from an empty stack and catch the `StackEmptyException`.\n\nThis setup ensures that all critical parts of the stack implementation are tested, and exceptions are handled correctly."
    }
]