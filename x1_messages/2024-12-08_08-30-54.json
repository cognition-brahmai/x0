[
    {
        "role": "user",
        "content": "Create a C++ program that compresses and decompresses files using the LZ77 algorithm. The program should accept command line arguments for input file, output file, and operation mode (compress or decompress).\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Alright, I've got this task to create a C++ program that can compress and decompress files using the LZ77 algorithm. It needs to take command-line arguments for the input file, output file, and specify whether to compress or decompress. Okay, let's break this down.\n\nFirst, I need to understand what LZ77 is. LZ77 is an algorithm for lossless data compression published by Abraham Lempel and Jacob Ziv in 1977. It's a dictionary-based compression algorithm where the dictionary is built dynamically as the data is processed. The basic idea is to replace phrases in the data with pointers to previous occurrences of that phrase.\n\nSo, for compression, I need to read the input file, process it using LZ77 to create compressed data, and then write that to the output file. For decompression, it's the reverse: read the compressed data from the input file, decompress it using LZ77, and write the original data to the output file.\n\nLet me think about how to structure the program. I should have a main function that parses the command-line arguments to determine the input file, output file, and the operation mode (compress or decompress). Then, based on the mode, it should call the appropriate function to perform the operation.\n\nI need to handle file I/O carefully, making sure to read and write binary data correctly. In C++, I can use ifstream and ofstream for this purpose, and set them to binary mode.\n\nNow, for the LZ77 implementation itself. I need to decide on the parameters for the algorithm, such as the size of the sliding window and the lookahead buffer. These parameters will affect the compression ratio and the performance.\n\nLet's consider the sliding window. LZ77 uses a sliding window to keep track of previously seen data. The window has a certain size, and the algorithm searches within this window for matching phrases. The size of the window can be fixed or variable, but for simplicity, I'll go with a fixed-size window.\n\nSimilarly, the lookahead buffer determines how far ahead the algorithm looks for matching phrases. Again, for simplicity, I'll use a fixed-size lookahead buffer.\n\nI need to implement the compression function. It should read the input data, search for the longest match in the sliding window, and output a triple (offset, length, next character) for each match found. The offset indicates the position in the window where the match starts, the length indicates how many characters match, and the next character is the first character after the match.\n\nFor decompression, I need to read these triples from the compressed data and reconstruct the original data by copying phrases from the sliding window and adding the next character.\n\nI should also think about how to handle the end of the file. When there are no more matches or the remaining data is too short, I need to handle that appropriately.\n\nLet me sketch a rough outline of the compression function:\n\n1. Initialize an empty sliding window.\n\n2. Read the input data into a buffer.\n\n3. Start from the beginning of the buffer.\n\n4. For each position in the buffer:\n\na. Search backwards in the sliding window for the longest match with the current substring.\n\nb. If a match is found, output the (offset, length, next character) triple.\n\nc. If no match is found, output a triple with offset=0, length=0, and the current character.\n\nd. Move the window forward by the length of the match plus one (for the next character).\n\n5. Repeat until the end of the buffer is reached.\n\nSimilarly, for decompression:\n\n1. Initialize an empty sliding window.\n\n2. Read the compressed triples from the input file.\n\n3. For each triple (offset, length, next character):\n\na. Copy 'length' characters from the position 'offset' in the sliding window.\n\nb. Add the 'next character' after the copied characters.\n\nc. Add the copied characters and the next character to the sliding window.\n\n4. Repeat until all triples have been processed.\n\n5. Write the reconstructed data to the output file.\n\nI need to decide on the data structures to use for the sliding window. Since the window can be large, I should use an efficient way to store and search it. One common approach is to use a buffer array and keep track of the window boundaries.\n\nFor matching phrases, I need an efficient string matching algorithm. Naive string matching would be too slow for large files, so I should consider using more efficient algorithms like the Rabin-Karp algorithm or the Knuth-Morris-Pratt (KMP) algorithm.\n\nHowever, implementing these algorithms from scratch might be time-consuming and error-prone. Maybe there are existing libraries or functions in C++ that can help with string matching.\n\nWait, perhaps I can use the std::search function from the <algorithm> header, which can find a subsequence in a sequence. That might be useful for finding matches in the sliding window.\n\nBut I need to consider the performance, especially for large files. std::search has a worst-case time complexity of O(n*m), where n is the size of the window and m is the length of the substring being searched. That could be slow for large windows.\n\nMaybe I should consider building an index or a data structure that allows faster lookups, like a hash table or a trie. But that might complicate the implementation.\n\nAlternatively, I can limit the size of the sliding window to make the search efficient. For example, I can set the window size to a reasonable value like 4096 bytes, which should provide a good balance between compression ratio and performance.\n\nI also need to think about how to represent the triples in the compressed data. Each triple consists of an offset, a length, and a next character. I need to decide on the number of bytes to use for each component.\n\nFor example, I can use 2 bytes for the offset, 1 byte for the length, and 1 byte for the next character. That would make each triple 4 bytes long.\n\nBut I need to consider the range of values for each component. The offset can be up to the size of the window, so if the window size is 4096, 2 bytes for the offset should be sufficient (since 2 bytes can hold up to 65535).\n\nThe length can vary, but in practice, phrase lengths are often short, so 1 byte for the length can represent lengths up to 255. That should be adequate.\n\nThe next character is a single byte, assuming we're dealing with ASCII or binary data.\n\nSo, each triple would be 4 bytes: 2 for offset, 1 for length, and 1 for the next character.\n\nI need to ensure that when writing the compressed data to the file, I write these triples in binary format, and when reading them during decompression, I read them as binary data and interpret them correctly.\n\nNow, let's think about the file I/O. In C++, I can open files in binary mode using the std::ios::binary flag with ifstream and ofstream.\n\nFor example:\n\nstd::ifstream infile(input_file, std::ios::binary);\n\nstd::ofstream outfile(output_file, std::ios::binary);\n\nThat should take care of reading and writing binary data correctly.\n\nI also need to handle errors gracefully, such as file not found, permission issues, or invalid command-line arguments.\n\nLet me consider how to parse the command-line arguments. The program should accept three arguments: input file, output file, and operation mode (compress or decompress).\n\nFor example:\n\nmyprogram compress input.txt output.lz77\n\nor\n\nmyprogram decompress input.lz77 output.txt\n\nI need to check if the correct number of arguments is provided, and if the operation mode is either \"compress\" or \"decompress\".\n\nIf any of these conditions are not met, I should display an error message and exit.\n\nAdditionally, I should check if the input file exists and is readable, and if the output file can be created or overwritten.\n\nIn C++, I can use functions from <iostream> and <fstream> for file operations, and from <cstring> for string operations.\n\nI should also include <cstdlib> for exit functions and <cstdio> for file existence checks.\n\nWait, for file existence checks, I can use std::ifstream to try opening the file and check if it succeeds.\n\nSimilarly, for checking if the output file can be created, I can attempt to open it for writing and handle any exceptions or errors that occur.\n\nNow, let's think about the implementation in more detail.\n\nFirst, the main function:\n\nint main(int argc, char* argv[]) {\n\nif (argc != 4) {\n\nstd::cerr << \"Usage: \" << argv[0] << \" <compress|decompress> <input_file> <output_file>\" << std::endl;\n\nreturn 1;\n\n}\n\nstd::string mode = argv[1];\n\nstd::string input_file = argv[2];\n\nstd::string output_file = argv[3];\n\nif (mode != \"compress\" && mode != \"decompress\") {\n\nstd::cerr << \"Error: Invalid mode. Use 'compress' or 'decompress'.\" << std::endl;\n\nreturn 1;\n\n}\n\n// Further processing based on mode\n\n}\n\nThat seems straightforward. Now, for the compression function.\n\nI need to read the input file into a buffer. Since files can be large, I should consider reading them in chunks rather than loading the entire file into memory at once. However, for simplicity, I'll assume that the input file fits into memory.\n\nSo, I'll read the entire input file into a std::vector<char> buffer.\n\nThen, I'll initialize a sliding window, which can also be a std::vector<char>, with a fixed size, say 4096 bytes.\n\nI'll need to keep track of the current position in the buffer and the contents of the sliding window.\n\nAs I process the buffer, I'll search backwards in the sliding window for the longest match with the current substring.\n\nTo do this, I'll need a loop that, for each position in the buffer, looks back into the window for matches.\n\nI can use a function to find the longest match.\n\nSomething like:\n\nstd::pair<int, int> find_longest_match(const std::vector<char>& window, size_t start, const std::vector<char>& buffer, size_t pos, size_t max_length) {\n\nint best_offset = -1;\n\nint best_length = 0;\n\nfor (size_t offset = 1; offset <= window.size(); ++offset) {\n\nsize_t match_pos = start - offset;\n\nif (match_pos + max_length > window.size()) {\n\ncontinue;\n\n}\n\nsize_t current_length = 0;\n\nwhile (match_pos + current_length < window.size() &&\n\npos + current_length < buffer.size() &&\n\nwindow[match_pos + current_length] == buffer[pos + current_length]) {\n\n++current_length;\n\nif (current_length >= max_length) {\n\nbreak;\n\n}\n\n}\n\nif (current_length > best_length) {\n\nbest_length = current_length;\n\nbest_offset = offset;\n\n}\n\n}\n\nreturn {best_offset, best_length};\n\n}\n\nThis function searches the window for the longest matching substring starting from position 'start' in the window, compared to position 'pos' in the buffer.\n\nI need to call this function for each position in the buffer, and based on the result, output the appropriate triple.\n\nWait, but in LZ77, the sliding window contains the previously processed data, so I need to manage the window as I process the buffer, shifting it forward as I move along.\n\nI think a better approach is to maintain a circular buffer for the sliding window to efficiently handle the shifting.\n\nIn C++, I can use std::deque<char> for the sliding window, which allows efficient insertion and removal from both ends.\n\nSo, I'll initialize a std::deque<char> with a maximum size equal to the window size.\n\nAs I process each character in the buffer, I'll add it to the end of the deque and remove characters from the front if the deque exceeds the window size.\n\nFor each position, I'll search the deque for the longest match starting from that position.\n\nOnce I find the match, I'll output the triple (offset, length, next character), where offset is the distance from the current position to the start of the match in the deque, and length is the match length.\n\nThen, I'll move the window forward by length + 1 positions.\n\nWait, but in LZ77, the sliding window looks back at previously processed data, not ahead. So, the window contains data that has already been processed.\n\nTherefore, as I process the buffer, I need to keep adding processed data to the window, and search within the window for matches with the upcoming data.\n\nSo, perhaps I need to maintain a window that contains the last 'N' characters processed, where 'N' is the window size.\n\nThen, for each position in the buffer, I look back into the window to find the longest match with the substring starting at the current position.\n\nOnce I find the match, I output the triple and move forward by length + 1 characters.\n\nI need to ensure that the window is updated correctly after each match.\n\nLet me try to outline the steps again:\n\n1. Initialize an empty sliding window with a maximum size of 'N' bytes.\n\n2. Read the entire input file into a buffer (std::vector<char>).\n\n3. Initialize position pos = 0.\n\n4. While pos < buffer.size():\n\na. Search backwards in the window for the longest match with the substring starting at pos.\n\nb. If a match is found:\n\ni. Let match_offset be the distance from pos to the start of the match in the window.\n\nii. Let match_length be the length of the match.\n\niii. Output the triple (match_offset, match_length, buffer[pos + match_length]).\n\niv. Move pos forward by match_length + 1.\n\nb. If no match is found:\n\ni. Output the triple (0, 0, buffer[pos]).\n\nii. Move pos forward by 1.\n\n5. After processing all data, write the triples to the output file in binary format.\n\nFor the decompression function, it's the reverse process:\n\n1. Read the compressed triples from the input file in binary format.\n\n2. Initialize an empty sliding window with a maximum size of 'N' bytes.\n\n3. For each triple (offset, length, next_char):\n\na. If offset > 0 and length > 0:\n\ni. Copy 'length' bytes from the position 'offset' bytes before the current end of the window.\n\nii. Add 'next_char' after the copied bytes.\n\nb. Else:\n\ni. Add 'next_char' to the window.\n\n4. Write the reconstructed data from the window to the output file.\n\nI need to ensure that the window is managed correctly during decompression, adding new data and maintaining the window size.\n\nNow, let's think about implementing the find_longest_match function efficiently.\n\nGiven that the window can be up to 4096 bytes, and the buffer can be large, I need an efficient way to search for the longest match.\n\nOne way is to iterate through the window from the end to the beginning, checking for matches with the buffer starting at pos.\n\nI can keep track of the longest match found and its offset.\n\nHowever, this approach could be slow for large windows and large files.\n\nTo optimize, I can limit the search to a certain length, say 255 bytes, since I'm using 1 byte for the length in the triple.\n\nAlternatively, I can use hashing to speed up the search.\n\nFor example, I can compute a hash of the current substring in the buffer and look for matching hashes in the window.\n\nThis can reduce the search time significantly.\n\nBut implementing a hash-based search might complicate the code, and given time constraints, I might opt for a simpler approach.\n\nPerhaps I can use the Rabin-Karp algorithm for string matching, which uses hashing to find any one of a set of pattern strings in a text.\n\nBut again, that might be too involved for this task.\n\nAlternatively, I can use the Z algorithm or the Knuth-Morris-Pratt (KMP) algorithm to find the longest prefix that matches the substring in the window.\n\nBut these algorithms are designed for exact matches, not necessarily for the longest match.\n\nWait, perhaps I can precompute a Z-array for the window and use it to find the longest match efficiently.\n\nThe Z algorithm can compute, for each position in a string, the length of the longest substring starting from that position that matches a prefix of the string.\n\nIf I concatenate the window and the buffer starting at pos with a separator, I can compute the Z-array for the combined string and find the longest match.\n\nThis sounds promising.\n\nLet me recall how the Z algorithm works.\n\nGiven a string S, the Z-array Z[i] is the length of the longest substring starting from S[i] that matches the prefix of S.\n\nTo use this for finding the longest match, I can:\n\n1. Concatenate the window W and the buffer starting at pos with a separator that doesn't appear in the data, say '\\0'.\n\n2. Compute the Z-array for the concatenated string.\n\n3. The maximum Z[i] for i from 1 to len(W) will give the length of the longest match, and the corresponding i will give the offset.\n\nHowever, in binary data, '\\0' might appear, so I need to choose a separator that doesn't appear in the data. But in binary data, any byte could appear, so this approach might not be reliable.\n\nAlternatively, I can avoid using a separator and handle the matching logic accordingly.\n\nBut this might complicate things.\n\nGiven time constraints, perhaps I should stick with a simpler, albeit less efficient, approach.\n\nI can iterate through the window from the end to the beginning, checking for matches with the buffer starting at pos.\n\nI'll limit the maximum length to 255 bytes, since I'm using 1 byte for the length in the triple.\n\nThis should be manageable for reasonably sized windows.\n\nNow, let's think about the implementation of the compression function.\n\nI'll need to:\n\n- Read the entire input file into a buffer.\n\n- Initialize an empty sliding window.\n\n- Process the buffer from start to end, finding matches in the window and outputting triples.\n\n- Write the triples to the output file in binary format.\n\nFor reading the input file into a buffer, I can use std::ifstream to read the entire file into a std::vector<char>.\n\nSimilarly, for writing the compressed data, I can use std::ofstream in binary mode.\n\nNow, for the sliding window, I'll use a std::deque<char> with a maximum size equal to the window size.\n\nAs I process each position in the buffer, I'll add the processed characters to the window, and remove old characters if the window exceeds the maximum size.\n\nWait, but in LZ77, the window looks back at previously processed data, so I need to maintain a window that contains the last 'N' bytes processed.\n\nTherefore, I can keep adding new characters to the window and remove old ones if the window exceeds the maximum size.\n\nWhen searching for matches, I need to search within the current window for the longest match with the substring starting at the current position in the buffer.\n\nOnce I find the match, I output the triple and move the position forward by match_length + 1.\n\nIf no match is found, I output a triple with offset=0, length=0, and the current character, then move the position forward by 1.\n\nI need to ensure that the window is updated correctly after each step.\n\nLet me try to write some pseudocode for the compression function:\n\nvoid compress(const std::string& input_file, const std::string& output_file, size_t window_size) {\n\nstd::vector<char> buffer = read_file(input_file);\n\nstd::deque<char> window;\n\nsize_t pos = 0;\n\nstd::vector<Triple> triples;\n\nwhile (pos < buffer.size()) {\n\nsize_t start = window.size() - std::min(window.size(), window_size);\n\nauto [offset, length] = find_longest_match(window, start, buffer, pos, 255);\n\nif (length > 0) {\n\ntriples.push_back({offset, length, buffer[pos + length]});\n\npos += length + 1;\n\n} else {\n\ntriples.push_back({0, 0, buffer[pos]});\n\npos += 1;\n\n}\n\n// Add the processed characters to the window\n\nsize_t end = pos;\n\nfor (size_t i = pos - length - 1; i < end; ++i) {\n\nwindow.push_back(buffer[i]);\n\nif (window.size() > window_size) {\n\nwindow.pop_front();\n\n}\n\n}\n\n}\n\nwrite_triples_to_file(output_file, triples);\n\n}\n\nHere, Triple is a struct containing offset, length, and next_char.\n\nI need to define it accordingly.\n\nWait, in the above pseudocode, there's a mistake in updating the window.\n\nI need to add the characters that have been processed to the window.\n\nIn the else clause, I've processed a single character, so I should add that character to the window.\n\nIn the match found clause, I've processed 'length + 1' characters, so I should add those to the window.\n\nAlso, I need to ensure that the window doesn't exceed the window_size.\n\nLet me correct that:\n\nvoid compress(const std::string& input_file, const std::string& output_file, size_t window_size) {\n\nstd::vector<char> buffer = read_file(input_file);\n\nstd::deque<char> window;\n\nsize_t pos = 0;\n\nstd::vector<Triple> triples;\n\nwhile (pos < buffer.size()) {\n\nsize_t start = window.size() - std::min(window.size(), window_size);\n\nauto [offset, length] = find_longest_match(window, start, buffer, pos, 255);\n\nif (length > 0) {\n\ntriples.push_back({offset, length, buffer[pos + length]});\n\npos += length + 1;\n\n// Add the matched characters and the next character to the window\n\nfor (size_t i = pos - length - 1; i < pos; ++i) {\n\nwindow.push_back(buffer[i]);\n\nif (window.size() > window_size) {\n\nwindow.pop_front();\n\n}\n\n}\n\n} else {\n\ntriples.push_back({0, 0, buffer[pos]});\n\npos += 1;\n\n// Add the current character to the window\n\nwindow.push_back(buffer[pos - 1]);\n\nif (window.size() > window_size) {\n\nwindow.pop_front();\n\n}\n\n}\n\n}\n\nwrite_triples_to_file(output_file, triples);\n\n}\n\nThis should be better.\n\nNow, I need to implement the find_longest_match function.\n\nHere's a possible implementation:\n\nstd::pair<int, int> find_longest_match(const std::deque<char>& window, size_t start, const std::vector<char>& buffer, size_t pos, size_t max_length) {\n\nint best_offset = -1;\n\nint best_length = 0;\n\nfor (size_t offset = 1; offset <= window.size(); ++offset) {\n\nsize_t match_pos = start - offset;\n\nif (match_pos + max_length > window.size()) {\n\ncontinue;\n\n}\n\nsize_t current_length = 0;\n\nwhile (match_pos + current_length < window.size() &&\n\npos + current_length < buffer.size() &&\n\nwindow[match_pos + current_length] == buffer[pos + current_length]) {\n\n++current_length;\n\nif (current_length >= max_length) {\n\nbreak;\n\n}\n\n}\n\nif (current_length > best_length) {\n\nbest_length = current_length;\n\nbest_offset = offset;\n\n}\n\n}\n\nreturn {best_offset, best_length};\n\n}\n\nThis function searches the window for the longest match starting from 'start' in the window, compared to 'pos' in the buffer.\n\nI need to ensure that 'start' is correctly calculated as the position in the window corresponding to the start of the searchable area.\n\nNow, for the decompression function, I need to read the triples from the compressed file, reconstruct the original data using the sliding window, and write it to the output file.\n\nHere's a rough outline:\n\nvoid decompress(const std::string& input_file, const std::string& output_file, size_t window_size) {\n\nstd::vector<Triple> triples = read_triples_from_file(input_file);\n\nstd::deque<char> window;\n\nfor (const auto& triple : triples) {\n\nif (triple.offset > 0 && triple.length > 0) {\n\nfor (size_t i = 0; i < triple.length; ++i) {\n\nchar ch = window[window.size() - triple.offset + i];\n\nwindow.push_back(ch);\n\n}\n\n}\n\nwindow.push_back(triple.next_char);\n\nif (window.size() > window_size) {\n\nwindow.pop_front();\n\n}\n\n}\n\nstd::vector<char> original_data(window.begin(), window.end());\n\nwrite_file(output_file, original_data);\n\n}\n\nWait, but this isn't quite right.\n\nIn decompression, for each triple:\n\n- If offset > 0 and length > 0, copy 'length' bytes from the position 'offset' bytes before the current end of the window, and then add 'next_char'.\n\n- Else, just add 'next_char' to the window.\n\nThen, write the entire window content to the output file.\n\nBut actually, in LZ77 decompression, the reconstructed data is the content of the window at the end of the process.\n\nWait, no. As we process each triple, we add the reconstructed data to the output, not just keeping it in the window.\n\nSo, I need to accumulate the reconstructed data in a separate buffer and write it to the output file at the end.\n\nLet me correct that.\n\nHere's a better approach:\n\nvoid decompress(const std::string& input_file, const std::string& output_file, size_t window_size) {\n\nstd::vector<Triple> triples = read_triples_from_file(input_file);\n\nstd::deque<char> window;\n\nstd::vector<char> original_data;\n\nfor (const auto& triple : triples) {\n\nif (triple.offset > 0 && triple.length > 0) {\n\nfor (size_t i = 0; i < triple.length; ++i) {\n\nchar ch = window[window.size() - triple.offset + i];\n\noriginal_data.push_back(ch);\n\nwindow.push_back(ch);\n\n}\n\n}\n\noriginal_data.push_back(triple.next_char);\n\nwindow.push_back(triple.next_char);\n\nif (window.size() > window_size) {\n\nwindow.pop_front();\n\n}\n\n}\n\nwrite_file(output_file, original_data);\n\n}\n\nThis should correctly reconstruct the original data.\n\nNow, I need to implement the read_file and write_file functions to read and write binary files.\n\nHere's how I can do it:\n\nstd::vector<char> read_file(const std::string& filename) {\n\nstd::ifstream infile(filename, std::ios::binary | std::ios::ate);\n\nif (!infile.is_open()) {\n\nthrow std::runtime_error(\"Failed to open input file: \" + filename);\n\n}\n\nsize_t size = infile.tellg();\n\nstd::vector<char> buffer(size);\n\ninfile.seekg(0);\n\ninfile.read(buffer.data(), size);\n\nreturn buffer;\n\n}\n\nvoid write_file(const std::string& filename, const std::vector<char>& data) {\n\nstd::ofstream outfile(filename, std::ios::binary);\n\nif (!outfile.is_open()) {\n\nthrow std::runtime_error(\"Failed to open output file: \" + filename);\n\n}\n\noutfile.write(data.data(), data.size());\n\n}\n\nSimilarly, I need to implement read_triples_from_file and write_triples_to_file.\n\nAssuming that each triple consists of 2 bytes for offset, 1 byte for length, and 1 byte for next_char, I can represent it in C++ as:\n\nstruct Triple {\n\nuint16_t offset;\n\nuint8_t length;\n\nuint8_t next_char;\n\n};\n\nThen, read_triples_from_file can read the binary data and parse it into a vector of Triples.\n\nHere's how I can implement it:\n\nstd::vector<Triple> read_triples_from_file(const std::string& filename) {\n\nstd::ifstream infile(filename, std::ios::binary);\n\nif (!infile.is_open()) {\n\nthrow std::runtime_error(\"Failed to open input file: \" + filename);\n\n}\n\ninfile.seekg(0, std::ios::end);\n\nsize_t size = infile.tellg();\n\nif (size % sizeof(Triple) != 0) {\n\nthrow std::runtime_error(\"Invalid file size for triples\");\n\n}\n\ninfile.seekg(0);\n\nsize_t num_triples = size / sizeof(Triple);\n\nstd::vector<Triple> triples(num_triples);\n\ninfile.read(reinterpret_cast<char*>(triples.data()), size);\n\nreturn triples;\n\n}\n\nSimilarly, write_triples_to_file can write a vector of Triples to the output file in binary format.\n\nvoid write_triples_to_file(const std::string& filename, const std::vector<Triple>& triples) {\n\nstd::ofstream outfile(filename, std::ios::binary);\n\nif (!outfile.is_open()) {\n\nthrow std::runtime_error(\"Failed to open output file: \" + filename);\n\n}\n\noutfile.write(reinterpret_cast<const char*>(triples.data()), triples.size() * sizeof(Triple));\n\n}\n\nNow, I need to make sure that the endianness is handled correctly when reading and writing the triples.\n\nSince I'm assuming that the program will be used on a single machine, I can assume that the endianness is consistent.\n\nBut if the program needs to be portable across different architectures, I might need to handle endianness conversions.\n\nFor now, I'll assume that endianness is not an issue.\n\nFinally, I need to set the window size parameter.\n\nI can define it as a constant in the program, or make it configurable via command-line arguments.\n\nFor simplicity, I'll set it to a fixed value, say 4096 bytes.\n\nNow, putting it all together, here's a rough sketch of the program structure:\n\n#include <iostream>\n\n#include <fstream>\n\n#include <vector>\n\n#include <deque>\n\n#include <cstdint>\n\n#include <stdexcept>\n\nstruct Triple {\n\nuint16_t offset;\n\nuint8_t length;\n\nuint8_t next_char;\n\n};\n\nstd::vector<char> read_file(const std::string& filename);\n\nvoid write_file(const std::string& filename, const std::vector<char>& data);\n\nstd::vector<Triple> read_triples_from_file(const std::string& filename);\n\nvoid write_triples_to_file(const std::string& filename, const std::vector<Triple>& triples);\n\nstd::pair<int, int> find_longest_match(const std::deque<char>& window, size_t start, const std::vector<char>& buffer, size_t pos, size_t max_length);\n\nvoid compress(const std::string& input_file, const std::string& output_file, size_t window_size);\n\nvoid decompress(const std::string& input_file, const std::string& output_file, size_t window_size);\n\nint main(int argc, char* argv[]) {\n\n// Parse command-line arguments and call compress or decompress accordingly\n\n}\n\n// Implement the functions defined above\n\nI need to implement all these functions as per the outlines above.\n\nI should also add error handling to handle cases like file not found, invalid arguments, etc.\n\nAdditionally, I can add some debug prints or verbose mode to see what's happening during compression and decompression.\n\nNow, to test the program, I need to create some sample input files and verify that compression and decompression work correctly.\n\nI can create text files with repeating patterns to see if the compression works as expected.\n\nI should also test with binary files to ensure that the program handles binary data correctly.\n\nI need to make sure that the decompressed data matches the original input data bit-for-bit.\n\nTo do this, I can compute hashes of the original and decompressed files and compare them.\n\nAlternatively, I can use tools like 'diff' to compare the files.\n\nFinally, I should consider optimizing the program for performance, especially the match finding function, since it can be a bottleneck for large files.\n\nBut for now, I'll focus on getting a working implementation first and then think about optimizations.\n\n## Final Solution\nTo create a C++ program that compresses and decompresses files using the LZ77 algorithm, follow the steps below. This program accepts command line arguments for input file, output file, and operation mode (compress or decompress).\n\n### Approach\n\n1. **Command Line Parsing**: \n   - The program expects three arguments: operation mode (`compress` or `decompress`), input file, and output file.\n   \n2. **File Operations**:\n   - Read the entire input file into a buffer for processing.\n   - Write the processed data (compressed or decompressed) to the output file.\n\n3. **LZ77 Compression**:\n   - Use a sliding window to find repeated phrases.\n   - Output triples `(offset, length, next character)` for matches found.\n\n4. **LZ77 Decompression**:\n   - Reconstruct the original data from the triples by copying phrases from the sliding window.\n\n### Solution Code\n\n```cpp\n#include <iostream>\n#include <fstream>\n#include <vector>\n#include <deque>\n#include <cstdint>\n#include <stdexcept>\n\nstruct Triple {\n    uint16_t offset;\n    uint8_t length;\n    uint8_t next_char;\n};\n\nstd::vector<char> read_file(const std::string& filename) {\n    std::ifstream infile(filename, std::ios::binary | std::ios::ate);\n    if (!infile.is_open()) {\n        throw std::runtime_error(\"Failed to open input file: \" + filename);\n    }\n    size_t size = infile.tellg();\n    std::vector<char> buffer(size);\n    infile.seekg(0);\n    infile.read(buffer.data(), size);\n    return buffer;\n}\n\nvoid write_file(const std::string& filename, const std::vector<char>& data) {\n    std::ofstream outfile(filename, std::ios::binary);\n    if (!outfile.is_open()) {\n        throw std::runtime_error(\"Failed to open output file: \" + filename);\n    }\n    outfile.write(data.data(), data.size());\n}\n\nstd::vector<Triple> read_triples_from_file(const std::string& filename) {\n    std::ifstream infile(filename, std::ios::binary);\n    if (!infile.is_open()) {\n        throw std::runtime_error(\"Failed to open input file: \" + filename);\n    }\n    infile.seekg(0, std::ios::end);\n    size_t size = infile.tellg();\n    if (size % sizeof(Triple) != 0) {\n        throw std::runtime_error(\"Invalid file size for triples\");\n    }\n    infile.seekg(0);\n    size_t num_triples = size / sizeof(Triple);\n    std::vector<Triple> triples(num_triples);\n    infile.read(reinterpret_cast<char*>(triples.data()), size);\n    return triples;\n}\n\nvoid write_triples_to_file(const std::string& filename, const std::vector<Triple>& triples) {\n    std::ofstream outfile(filename, std::ios::binary);\n    if (!outfile.is_open()) {\n        throw std::runtime_error(\"Failed to open output file: \" + filename);\n    }\n    outfile.write(reinterpret_cast<const char*>(triples.data()), triples.size() * sizeof(Triple));\n}\n\nstd::pair<int, int> find_longest_match(const std::deque<char>& window, size_t start, const std::vector<char>& buffer, size_t pos, size_t max_length) {\n    int best_offset = -1;\n    int best_length = 0;\n    for (size_t offset = 1; offset <= window.size(); ++offset) {\n        size_t match_pos = start - offset;\n        if (match_pos + max_length > window.size()) {\n            continue;\n        }\n        size_t current_length = 0;\n        while (match_pos + current_length < window.size() &&\n               pos + current_length < buffer.size() &&\n               window[match_pos + current_length] == buffer[pos + current_length]) {\n            ++current_length;\n            if (current_length >= max_length) {\n                break;\n            }\n        }\n        if (current_length > best_length) {\n            best_length = current_length;\n            best_offset = offset;\n        }\n    }\n    return {best_offset, best_length};\n}\n\nvoid compress(const std::string& input_file, const std::string& output_file, size_t window_size) {\n    std::vector<char> buffer = read_file(input_file);\n    std::deque<char> window;\n    size_t pos = 0;\n    std::vector<Triple> triples;\n    while (pos < buffer.size()) {\n        size_t start = window.size() - std::min(window.size(), window_size);\n        auto [offset, length] = find_longest_match(window, start, buffer, pos, 255);\n        if (length > 0) {\n            triples.push_back({static_cast<uint16_t>(offset), static_cast<uint8_t>(length), buffer[pos + length]});\n            pos += length + 1;\n            for (size_t i = pos - length - 1; i < pos; ++i) {\n                window.push_back(buffer[i]);\n                if (window.size() > window_size) {\n                    window.pop_front();\n                }\n            }\n        } else {\n            triples.push_back({0, 0, buffer[pos]});\n            pos += 1;\n            window.push_back(buffer[pos - 1]);\n            if (window.size() > window_size) {\n                window.pop_front();\n            }\n        }\n    }\n    write_triples_to_file(output_file, triples);\n}\n\nvoid decompress(const std::string& input_file, const std::string& output_file, size_t window_size) {\n    std::vector<Triple> triples = read_triples_from_file(input_file);\n    std::deque<char> window;\n    std::vector<char> original_data;\n    for (const auto& triple : triples) {\n        if (triple.offset > 0 && triple.length > 0) {\n            for (size_t i = 0; i < triple.length; ++i) {\n                char ch = window[window.size() - triple.offset + i];\n                original_data.push_back(ch);\n                window.push_back(ch);\n            }\n        }\n        original_data.push_back(triple.next_char);\n        window.push_back(triple.next_char);\n        if (window.size() > window_size) {\n            window.pop_front();\n        }\n    }\n    write_file(output_file, original_data);\n}\n\nint main(int argc, char* argv[]) {\n    if (argc != 4) {\n        std::cerr << \"Usage: \" << argv[0] << \" <compress|decompress> <input_file> <output_file>\" << std::endl;\n        return 1;\n    }\n    std::string mode = argv[1];\n    std::string input_file = argv[2];\n    std::string output_file = argv[3];\n    if (mode != \"compress\" && mode != \"decompress\") {\n        std::cerr << \"Error: Invalid mode. Use 'compress' or 'decompress'.\" << std::endl;\n        return 1;\n    }\n    size_t window_size = 4096; // Define window size\n    try {\n        if (mode == \"compress\") {\n            compress(input_file, output_file, window_size);\n        } else {\n            decompress(input_file, output_file, window_size);\n        }\n    } catch (const std::exception& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n        return 1;\n    }\n    return 0;\n}\n```\n\n### Explanation\n\n- **Command Line Parsing**: The program checks for exactly three arguments: operation mode, input file, and output file. It validates the operation mode.\n  \n- **File Operations**: It reads the entire input file into a buffer and writes processed data to the output file in binary mode.\n\n- **LZ77 Compression**:\n  - Uses a sliding window to identify repeated phrases.\n  - Outputs triples representing matches and non-matches.\n\n- **LZ77 Decompression**:\n  - Reconstructs the original data from the triples by referencing phrases in the sliding window.\n\nThis implementation provides a basic but functional LZ77 compressor and decompressor suitable for educational and testing purposes. For production use, further optimizations and error handling may be necessary."
    }
]