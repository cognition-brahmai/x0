[
    {
        "role": "user",
        "content": "Write a python script to implement a Binary Search Tree data structure, including methods for insertion, deletion, and searching for a specific value. PLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Sure! Below is a Python script that implements a Binary Search Tree (BST) with methods for insertion, deletion, and searching for a specific value.\n\n```python\nclass TreeNode:\n    def __init__(self, key):\n        self.left = None\n        self.right = None\n        self.val = key\n\nclass BST:\n    def __init__(self):\n        self.root = None\n\n    def insert(self, key):\n        if self.root is None:\n            self.root = TreeNode(key)\n        else:\n            self._insert_recursive(self.root, key)\n\n    def _insert_recursive(self, current, key):\n        if key < current.val:\n            if current.left is None:\n                current.left = TreeNode(key)\n            else:\n                self._insert_recursive(current.left, key)\n        else:\n            if current.right is None:\n                current.right = TreeNode(key)\n            else:\n                self._insert_recursive(current.right, key)\n\n    def delete(self, key):\n        self.root = self._delete_recursive(self.root, key)\n\n    def _delete_recursive(self, root, key):\n        if root is None:\n            return root\n\n        if key < root.val:\n            root.left = self._delete_recursive(root.left, key)\n        elif key > root.val:\n            root.right = self._delete_recursive(root.right, key)\n        else:\n            # Node with only one child or no child\n            if root.left is None:\n                return root.right\n            elif root.right is None:\n                return root.left\n\n            # Node with two children: Get the inorder successor (smallest in the right subtree)\n            root.val = self._min_value_node(root.right).val\n            # Delete the inorder successor\n            root.right = self._delete_recursive(root.right, root.val)\n\n        return root\n\n    def _min_value_node(self, node):\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current\n\n    def search(self, key):\n        return self._search_recursive(self.root, key)\n\n    def _search_recursive(self, current, key):\n        if current is None or current.val == key:\n            return current\n\n        if key < current.val:\n            return self._search_recursive(current.left, key)\n        else:\n            return self._search_recursive(current.right, key)\n\n    def inorderTraversal(self, root):\n        res = []\n        if root:\n            res = self.inorderTraversal(root.left)\n            res.append(root.val)\n            res = res + self.inorderTraversal(root.right)\n        return res\n\n# Example usage:\nbst = BST()\nbst.insert(50)\nbst.insert(30)\nbst.insert(20)\nbst.insert(40)\nbst.insert(70)\nbst.insert(60)\nbst.insert(80)\n\nprint(\"Inorder traversal:\", bst.inorderTraversal(bst.root))\n\n# Search for a key\nif bst.search(40):\n    print(\"40 is found\")\nelse:\n    print(\"40 is not found\")\n\n# Delete a key\nbst.delete(20)\nprint(\"Inorder traversal after deleting 20:\", bst.inorderTraversal(bst.root))\n\nbst.delete(30)\nprint(\"Inorder traversal after deleting 30:\", bst.inorderTraversal(bst.root))\n\nbst.delete(50)\nprint(\"Inorder traversal after deleting 50:\", bst.inorderTraversal(bst.root))\n```\n\n### Explanation\n\n1. **TreeNode Class**:\n   - Represents each node in the BST.\n   - Each node has a value (`val`), and pointers to left and right children.\n\n2. **BST Class**:\n   - Manages the BST operations.\n   - **insert(key)**: Inserts a new node with the given key.\n   - **delete(key)**: Deletes the node with the given key.\n   - **search(key)**: Searches for a node with the given key.\n   - **inorderTraversal(root)**: Performs an inorder traversal of the tree and returns the list of values.\n\n3. **Insertion**:\n   - If the tree is empty, set the root to the new node.\n   - Otherwise, recursively find the correct position based on the key's value and insert the new node.\n\n4. **Deletion**:\n   - If the node to be deleted is found:\n     - Node with no child or one child: Directly remove it.\n     - Node with two children: Replace the node's value with the smallest value from the right subtree, then delete that smallest node.\n   - Recursively adjust the tree to maintain BST properties.\n\n5. **Searching**:\n   - Recursively traverse the tree based on the key's value until the key is found or the subtree ends.\n\n6. **Inorder Traversal**:\n   - Recursively traverse the left subtree, visit the root, and then traverse the right subtree.\n   - This provides a sorted list of the tree's values.\n\n### Example Usage\n\n- **Insertion**: Insert several keys to build the BST.\n- **Search**: Check if a specific key exists in the BST.\n- **Deletion**: Remove specific keys and observe the tree's structure after deletion.\n\nThis implementation ensures that the BST properties are maintained after insertion and deletion operations."
    }
]