[
    {
        "role": "user",
        "content": "Create a C++ implementation of a stack data structure using dynamic arrays, including push, pop, and peek operations.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Certainly! Below is a C++ implementation of a stack data structure using dynamic arrays. This implementation includes the `push`, `pop`, and `peek` operations, along with some additional functionality to handle the dynamic resizing of the array.\n\n```cpp\n#include <iostream>\n\nclass Stack {\nprivate:\n    int* arr;\n    int capacity;\n    int top;\n\npublic:\n    Stack(int cap = 10) : capacity(cap), top(-1) {\n        arr = new int[capacity];\n    }\n\n    ~Stack() {\n        delete[] arr;\n    }\n\n    void push(int value);\n    void pop();\n    int peek();\n    bool isEmpty();\n    bool isFull();\n    void display();\n};\n\nvoid Stack::push(int value) {\n    if (isFull()) {\n        int* temp = new int[2 * capacity];\n        for (int i = 0; i < capacity; ++i) {\n            temp[i] = arr[i];\n        }\n        delete[] arr;\n        arr = temp;\n        capacity *= 2;\n    }\n    arr[++top] = value;\n}\n\nvoid Stack::pop() {\n    if (isEmpty()) {\n        std::cout << \"Stack is empty. Cannot pop.\" << std::endl;\n        return;\n    }\n    --top;\n}\n\nint Stack::peek() {\n    if (isEmpty()) {\n        std::cout << \"Stack is empty. Cannot peek.\" << std::endl;\n        return -1; // Assuming -1 is not a valid value in the stack\n    }\n    return arr[top];\n}\n\nbool Stack::isEmpty() {\n    return top == -1;\n}\n\nbool Stack::isFull() {\n    return top == capacity - 1;\n}\n\nvoid Stack::display() {\n    if (isEmpty()) {\n        std::cout << \"Stack is empty.\" << std::endl;\n        return;\n    }\n    std::cout << \"Stack elements: \";\n    for (int i = 0; i <= top; ++i) {\n        std::cout << arr[i] << \" \";\n    }\n    std::cout << std::endl;\n}\n\nint main() {\n    Stack s(5); // Initialize stack with capacity 5\n\n    s.push(1);\n    s.push(2);\n    s.push(3);\n    s.push(4);\n    s.push(5);\n\n    s.display(); // Should display 1 2 3 4 5\n\n    s.push(6); // Should resize the array to capacity 10\n\n    s.display(); // Should display 1 2 3 4 5 6\n\n    std::cout << \"Peek: \" << s.peek() << std::endl; // Should display 6\n\n    s.pop();\n    s.pop();\n\n    s.display(); // Should display 1 2 3 4\n\n    return 0;\n}\n```\n\n### Explanation:\n\n1. **Constructor**: Initializes the stack with a given capacity (default is 10). It allocates memory for the array.\n   \n2. **Destructor**: Frees the allocated memory.\n\n3. **push(int value)**: Adds an element to the top of the stack. If the stack is full, it doubles the capacity by creating a new array and copying the elements.\n\n4. **pop()**: Removes the top element from the stack. If the stack is empty, it prints an error message.\n\n5. **peek()**: Returns the top element of the stack without removing it. If the stack is empty, it prints an error message and returns -1.\n\n6. **isEmpty()**: Checks if the stack is empty.\n\n7. **isFull()**: Checks if the stack is full.\n\n8. **display()**: Prints all elements of the stack from bottom to top.\n\nThis implementation ensures that the stack can dynamically resize itself when it reaches its capacity, allowing it to handle an arbitrary number of elements."
    }
]