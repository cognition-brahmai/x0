[
    {
        "role": "user",
        "content": "Create a RESTful API server using GoLang that interacts with a PostgreSQL database. The server should provide endpoints to perform CRUD operations on a 'users' table in the database."
    },
    {
        "role": "assistant",
        "content": "Alright, I'm going to create a RESTful API server using GoLang that interacts with a PostgreSQL database. The server will have endpoints to perform CRUD operations on a 'users' table. Let's break this down step by step.\n\nFirst, I need to set up my Go environment. I should make sure that I have Go installed on my machine. I can check this by running `go version` in my terminal. If it's not installed, I'll need to download and install it from golang.org.\n\nNext, I need to set up a new Go module for this project. I'll create a new directory for my project, say `user-api`, and then run `go mod init user-api` inside that directory. This will initialize a new Go module.\n\nNow, I need to set up my database. I'll be using PostgreSQL, so I need to make sure that PostgreSQL is installed and running on my machine. I can download and install it from postgresql.org. Once installed, I'll create a new database, let's call it `userdb`.\n\nI need to define the structure of the 'users' table. For simplicity, let's assume the 'users' table has the following columns:\n\n- id (integer, primary key, auto-increment)\n\n- name (text, not null)\n\n- email (text, not null, unique)\n\nI'll use PostgreSQL's `serial` type for the id, which is an auto-incrementing integer.\n\nSo, the SQL to create the table would be:\n\n```sql\n\nCREATE TABLE users (\n\n    id serial PRIMARY KEY,\n\n    name TEXT NOT NULL,\n\n    email TEXT NOT NULL UNIQUE\n\n);\n\n```\n\nI can run this SQL command in psql or any other PostgreSQL client to create the table.\n\nNow, I need to set up my Go project to connect to this PostgreSQL database. I'll need to use a database driver for PostgreSQL. In Go, the most commonly used driver for PostgreSQL is `lib/pq`, which is part of the standard library.\n\nBut actually, the standard library's database driver for PostgreSQL is `github.com/lib/pq`. I need to make sure that this package is available in my Go module. I can add it as a dependency by running `go get github.com/lib/pq`.\n\nNow, I need to set up the database connection in my Go code. I'll need to import the `database/sql` package and the `github.com/lib/pq` driver.\n\nI should also consider using environment variables to store database connection parameters, such as host, port, user, password, and database name. This is a good practice for security and flexibility.\n\nI can use the `os` package to read environment variables.\n\nSo, in my main Go file, I'll set up the database connection like this:\n\n```go\n\npackage main\n\nimport (\n\n    \"database/sql\"\n\n    \"log\"\n\n    \"os\"\n\n    _ \"github.com/lib/pq\"\n\n)\n\nconst (\n\n    DBDriver = \"postgres\"\n\n)\n\nfunc main() {\n\n    dbInfo := fmt.Sprintf(\"host=%s port=%s user=%s password=%s dbname=%s sslmode=disable\",\n\n        os.Getenv(\"DB_HOST\"),\n\n        os.Getenv(\"DB_PORT\"),\n\n        os.Getenv(\"DB_USER\"),\n\n        os.Getenv(\"DB_PASSWORD\"),\n\n        os.Getenv(\"DB_NAME\"),\n\n    )\n\n    db, err := sql.Open(DBDriver, dbInfo)\n\n    if err != nil {\n\n        log.Fatal(err)\n\n    }\n\n    if err = db.Ping(); err != nil {\n\n        log.Fatal(err)\n\n    }\n\n    log.Println(\"Database connection established\")\n\n    // Rest of the server setup\n\n}\n\n```\n\nI need to make sure that I have set the environment variables `DB_HOST`, `DB_PORT`, `DB_USER`, `DB_PASSWORD`, and `DB_NAME` before running the server.\n\nNow, I need to set up a web server using Go's `net/http` package. I'll create a new HTTP server and define routes for the CRUD operations.\n\nLet's define the endpoints:\n\n- GET /users: Get all users\n\n- POST /users: Create a new user\n\n- GET /users/{id}: Get a user by ID\n\n- PUT /users/{id}: Update a user by ID\n\n- DELETE /users/{id}: Delete a user by ID\n\nI'll need to define handlers for each of these endpoints.\n\nFirst, I need to define a `User` struct that maps to the 'users' table.\n\n```go\n\ntype User struct {\n\n    ID    int    `json:\"id\"`\n\n    Name  string `json:\"name\"`\n\n    Email string `json:\"email\"`\n\n}\n\n```\n\nI'll also need to handle JSON serialization and deserialization, so I'll import the `encoding/json` package.\n\nNow, let's implement the handler for GET /users to retrieve all users.\n\n```go\n\nfunc getUsers(w http.ResponseWriter, r *http.Request) {\n\n    rows, err := db.Query(\"SELECT id, name, email FROM users\")\n\n    if err != nil {\n\n        log.Println(err)\n\n        http.Error(w, \"Internal server error\", http.StatusInternalServerError)\n\n        return\n\n    }\n\n    defer rows.Close()\n\n    var users []User\n\n    for rows.Next() {\n\n        var user User\n\n        err := rows.Scan(&user.ID, &user.Name, &user.Email)\n\n        if err != nil {\n\n            log.Println(err)\n\n            http.Error(w, \"Internal server error\", http.StatusInternalServerError)\n\n            return\n\n        }\n\n        users = append(users, user)\n\n    }\n\n    err = rows.Err()\n\n    if err != nil {\n\n        log.Println(err)\n\n        http.Error(w, \"Internal server error\", http.StatusInternalServerError)\n\n        return\n\n    }\n\n    json.NewEncoder(w).Encode(users)\n\n}\n\n```\n\nSimilarly, I'll implement the handler for POST /users to create a new user.\n\n```go\n\nfunc createUser(w http.ResponseWriter, r *http.Request) {\n\n    var user User\n\n    err := json.NewDecoder(r.Body).Decode(&user)\n\n    if err != nil {\n\n        log.Println(err)\n\n        http.Error(w, \"Bad request\", http.StatusBadRequest)\n\n        return\n\n    }\n\n    stmt, err := db.Prepare(\"INSERT INTO users(name, email) VALUES($1, $2)\")\n\n    if err != nil {\n\n        log.Println(err)\n\n        http.Error(w, \"Internal server error\", http.StatusInternalServerError)\n\n        return\n\n    }\n\n    res, err := stmt.Exec(user.Name, user.Email)\n\n    if err != nil {\n\n        log.Println(err)\n\n        http.Error(w, \"Internal server error\", http.StatusInternalServerError)\n\n        return\n\n    }\n\n    id, err := res.LastInsertId()\n\n    if err != nil {\n\n        log.Println(err)\n\n        http.Error(w, \"Internal server error\", http.StatusInternalServerError)\n\n        return\n\n    }\n\n    user.ID = int(id)\n\n    json.NewEncoder(w).Encode(user)\n\n}\n\n```\n\nNext, the handler for GET /users/{id} to get a user by ID.\n\n```go\n\nfunc getUser(w http.ResponseWriter, r *http.Request) {\n\n    vars := mux.Vars(r)\n\n    idStr := vars[\"id\"]\n\n    id, err := strconv.Atoi(idStr)\n\n    if err != nil {\n\n        log.Println(err)\n\n        http.Error(w, \"Bad request\", http.StatusBadRequest)\n\n        return\n\n    }\n\n    row := db.QueryRow(\"SELECT id, name, email FROM users WHERE id=$1\", id)\n\n    var user User\n\n    err = row.Scan(&user.ID, &user.Name, &user.Email)\n\n    if err == sql.ErrNoRows {\n\n        http.Error(w, \"Not found\", http.StatusNotFound)\n\n        return\n\n    } else if err != nil {\n\n        log.Println(err)\n\n        http.Error(w, \"Internal server error\", http.StatusInternalServerError)\n\n        return\n\n    }\n\n    json.NewEncoder(w).Encode(user)\n\n}\n\n```\n\nFor PUT /users/{id} to update a user by ID.\n\n```go\n\nfunc updateUser(w http.ResponseWriter, r *http.Request) {\n\n    vars := mux.Vars(r)\n\n    idStr := vars[\"id\"]\n\n    id, err := strconv.Atoi(idStr)\n\n    if err != nil {\n\n        log.Println(err)\n\n        http.Error(w, \"Bad request\", http.StatusBadRequest)\n\n        return\n\n    }\n\n    var user User\n\n    err = json.NewDecoder(r.Body).Decode(&user)\n\n    if err != nil {\n\n        log.Println(err)\n\n        http.Error(w, \"Bad request\", http.StatusBadRequest)\n\n        return\n\n    }\n\n    stmt, err := db.Prepare(\"UPDATE users SET name=$1, email=$2 WHERE id=$3\")\n\n    if err != nil {\n\n        log.Println(err)\n\n        http.Error(w, \"Internal server error\", http.StatusInternalServerError)\n\n        return\n\n    }\n\n    res, err := stmt.Exec(user.Name, user.Email, id)\n\n    if err != nil {\n\n        log.Println(err)\n\n        http.Error(w, \"Internal server error\", http.StatusInternalServerError)\n\n        return\n\n    }\n\n    rowsAffected, err := res.RowsAffected()\n\n    if err != nil {\n\n        log.Println(err)\n\n        http.Error(w, \"Internal server error\", http.StatusInternalServerError)\n\n        return\n\n    }\n\n    if rowsAffected == 0 {\n\n        http.Error(w, \"Not found\", http.StatusNotFound)\n\n        return\n\n    }\n\n    user.ID = id\n\n    json.NewEncoder(w).Encode(user)\n\n}\n\n```\n\nAnd finally, the handler for DELETE /users/{id} to delete a user by ID.\n\n```go\n\nfunc deleteUser(w http.ResponseWriter, r *http.Request) {\n\n    vars := mux.Vars(r)\n\n    idStr := vars[\"id\"]\n\n    id, err := strconv.Atoi(idStr)\n\n    if err != nil {\n\n        log.Println(err)\n\n        http.Error(w, \"Bad request\", http.StatusBadRequest)\n\n        return\n\n    }\n\n    res, err := db.Exec(\"DELETE FROM users WHERE id=$1\", id)\n\n    if err != nil {\n\n        log.Println(err)\n\n        http.Error(w, \"Internal server error\", http.StatusInternalServerError)\n\n        return\n\n    }\n\n    rowsAffected, err := res.RowsAffected()\n\n    if err != nil {\n\n        log.Println(err)\n\n        http.Error(w, \"Internal server error\", http.StatusInternalServerError)\n\n        return\n\n    }\n\n    if rowsAffected == 0 {\n\n        http.Error(w, \"Not found\", http.StatusNotFound)\n\n        return\n\n    }\n\n    w.WriteHeader(http.StatusNoContent)\n\n}\n\n```\n\nI need to set up routing for these endpoints. For routing, I can use the `github.com/gorilla/mux` package, which is a popular choice for routing in Go.\n\nFirst, I need to add it as a dependency by running `go get github.com/gorilla/mux`.\n\nThen, in my main function, I'll create a new router and define the routes.\n\n```go\n\nrouter := mux.NewRouter()\n\nrouter.HandleFunc(\"/users\", getUsers).Methods(\"GET\")\n\nrouter.HandleFunc(\"/users\", createUser).Methods(\"POST\")\n\nrouter.HandleFunc(\"/users/{id}\", getUser).Methods(\"GET\")\n\nrouter.HandleFunc(\"/users/{id}\", updateUser).Methods(\"PUT\")\n\nrouter.HandleFunc(\"/users/{id}\", deleteUser).Methods(\"DELETE\")\n\nlog.Println(\"Starting server at port 8000\")\n\nlog.Fatal(http.ListenAndServe(\":8000\", router))\n\n```\n\nI should also make sure to handle any panics and close the database connection when the server is shut down.\n\nTo handle panics, I can use `defer` with a recovery function.\n\nTo close the database connection, I can use a shutdown hook.\n\nBut for simplicity, I'll just make sure to close the database connection when the server is shut down.\n\nNow, I need to make sure that all the necessary packages are imported.\n\nHere's the list of imports I'll need:\n\n- `database/sql`\n\n- `encoding/json`\n\n- `log`\n\n- `net/http`\n\n- `os`\n\n- `strconv`\n\n- `github.com/gorilla/mux`\n\n- `github.com/lib/pq`\n\nI should also set up a `main` function to tie everything together.\n\nPutting it all together, here's what the main Go file might look like:\n\n```go\n\npackage main\n\nimport (\n\n    \"database/sql\"\n\n    \"encoding/json\"\n\n    \"fmt\"\n\n    \"log\"\n\n    \"net/http\"\n\n    \"os\"\n\n    \"strconv\"\n\n    \"github.com/gorilla/mux\"\n\n    _ \"github.com/lib/pq\"\n\n)\n\nconst (\n\n    DBDriver = \"postgres\"\n\n)\n\ntype User struct {\n\n    ID    int    `json:\"id\"`\n\n    Name  string `json:\"name\"`\n\n    Email string `json:\"email\"`\n\n}\n\nfunc main() {\n\n    dbInfo := fmt.Sprintf(\"host=%s port=%s user=%s password=%s dbname=%s sslmode=disable\",\n\n        os.Getenv(\"DB_HOST\"),\n\n        os.Getenv(\"DB_PORT\"),\n\n        os.Getenv(\"DB_USER\"),\n\n        os.Getenv(\"DB_PASSWORD\"),\n\n        os.Getenv(\"DB_NAME\"),\n\n    )\n\n    db, err := sql.Open(DBDriver, dbInfo)\n\n    if err != nil {\n\n        log.Fatal(err)\n\n    }\n\n    if err = db.Ping(); err != nil {\n\n        log.Fatal(err)\n\n    }\n\n    log.Println(\"Database connection established\")\n\n    router := mux.NewRouter()\n\n    router.HandleFunc(\"/users\", getUsers).Methods(\"GET\")\n\n    router.HandleFunc(\"/users\", createUser).Methods(\"POST\")\n\n    router.HandleFunc(\"/users/{id}\", getUser).Methods(\"GET\")\n\n    router.HandleFunc(\"/users/{id}\", updateUser).Methods(\"PUT\")\n\n    router.HandleFunc(\"/users/{id}\", deleteUser).Methods(\"DELETE\")\n\n    log.Println(\"Starting server at port 8000\")\n\n    log.Fatal(http.ListenAndServe(\":8000\", router))\n\n}\n\nfunc getUsers(w http.ResponseWriter, r *http.Request) {\n\n    rows, err := db.Query(\"SELECT id, name, email FROM users\")\n\n    if err != nil {\n\n        log.Println(err)\n\n        http.Error(w, \"Internal server error\", http.StatusInternalServerError)\n\n        return\n\n    }\n\n    defer rows.Close()\n\n    var users []User\n\n    for rows.Next() {\n\n        var user User\n\n        err := rows.Scan(&user.ID, &user.Name, &user.Email)\n\n        if err != nil {\n\n            log.Println(err)\n\n            http.Error(w, \"Internal server error\", http.StatusInternalServerError)\n\n            return\n\n        }\n\n        users = append(users, user)\n\n    }\n\n    err = rows.Err()\n\n    if err != nil {\n\n        log.Println(err)\n\n        http.Error(w, \"Internal server error\", http.StatusInternalServerError)\n\n        return\n\n    }\n\n    json.NewEncoder(w).Encode(users)\n\n}\n\nfunc createUser(w http.ResponseWriter, r *http.Request) {\n\n    var user User\n\n    err := json.NewDecoder(r.Body).Decode(&user)\n\n    if err != nil {\n\n        log.Println(err)\n\n        http.Error(w, \"Bad request\", http.StatusBadRequest)\n\n        return\n\n    }\n\n    stmt, err := db.Prepare(\"INSERT INTO users(name, email) VALUES($1, $2)\")\n\n    if err != nil {\n\n        log.Println(err)\n\n        http.Error(w, \"Internal server error\", http.StatusInternalServerError)\n\n        return\n\n    }\n\n    res, err := stmt.Exec(user.Name, user.Email)\n\n    if err != nil {\n\n        log.Println(err)\n\n        http.Error(w, \"Internal server error\", http.StatusInternalServerError)\n\n        return\n\n    }\n\n    id, err := res.LastInsertId()\n\n    if err != nil {\n\n        log.Println(err)\n\n        http.Error(w, \"Internal server error\", http.StatusInternalServerError)\n\n        return\n\n    }\n\n    user.ID = int(id)\n\n    json.NewEncoder(w).Encode(user)\n\n}\n\nfunc getUser(w http.ResponseWriter, r *http.Request) {\n\n    vars := mux.Vars(r)\n\n    idStr := vars[\"id\"]\n\n    id, err := strconv.Atoi(idStr)\n\n    if err != nil {\n\n        log.Println(err)\n\n        http.Error(w, \"Bad request\", http.StatusBadRequest)\n\n        return\n\n    }\n\n    row := db.QueryRow(\"SELECT id, name, email FROM users WHERE id=$1\", id)\n\n    var user User\n\n    err = row.Scan(&user.ID, &user.Name, &user.Email)\n\n    if err == sql.ErrNoRows {\n\n        http.Error(w, \"Not found\", http.StatusNotFound)\n\n        return\n\n    } else if err != nil {\n\n        log.Println(err)\n\n        http.Error(w, \"Internal server error\", http.StatusInternalServerError)\n\n        return\n\n    }\n\n    json.NewEncoder(w).Encode(user)\n\n}\n\nfunc updateUser(w http.ResponseWriter, r *http.Request) {\n\n    vars := mux.Vars(r)\n\n    idStr := vars[\"id\"]\n\n    id, err := strconv.Atoi(idStr)\n\n    if err != nil {\n\n        log.Println(err)\n\n        http.Error(w, \"Bad request\", http.StatusBadRequest)\n\n        return\n\n    }\n\n    var user User\n\n    err = json.NewDecoder(r.Body).Decode(&user)\n\n    if err != nil {\n\n        log.Println(err)\n\n        http.Error(w, \"Bad request\", http.StatusBadRequest)\n\n        return\n\n    }\n\n    stmt, err := db.Prepare(\"UPDATE users SET name=$1, email=$2 WHERE id=$3\")\n\n    if err != nil {\n\n        log.Println(err)\n\n        http.Error(w, \"Internal server error\", http.StatusInternalServerError)\n\n        return\n\n    }\n\n    res, err := stmt.Exec(user.Name, user.Email, id)\n\n    if err != nil {\n\n        log.Println(err)\n\n        http.Error(w, \"Internal server error\", http.StatusInternalServerError)\n\n        return\n\n    }\n\n    rowsAffected, err := res.RowsAffected()\n\n    if err != nil {\n\n        log.Println(err)\n\n        http.Error(w, \"Internal server error\", http.StatusInternalServerError)\n\n        return\n\n    }\n\n    if rowsAffected == 0 {\n\n        http.Error(w, \"Not found\", http.StatusNotFound)\n\n        return\n\n    }\n\n    user.ID = id\n\n    json.NewEncoder(w).Encode(user)\n\n}\n\nfunc deleteUser(w http.ResponseWriter, r *http.Request) {\n\n    vars := mux.Vars(r)\n\n    idStr := vars[\"id\"]\n\n    id, err := strconv.Atoi(idStr)\n\n    if err != nil {\n\n        log.Println(err)\n\n        http.Error(w, \"Bad request\", http.StatusBadRequest)\n\n        return\n\n    }\n\n    res, err := db.Exec(\"DELETE FROM users WHERE id=$1\", id)\n\n    if err != nil {\n\n        log.Println(err)\n\n        http.Error(w, \"Internal server error\", http.StatusInternalServerError)\n\n        return\n\n    }\n\n    rowsAffected, err := res.RowsAffected()\n\n    if err != nil {\n\n        log.Println(err)\n\n        http.Error(w, \"Internal server error\", http.StatusInternalServerError)\n\n        return\n\n    }\n\n    if rowsAffected == 0 {\n\n        http.Error(w, \"Not found\", http.StatusNotFound)\n\n        return\n\n    }\n\n    w.WriteHeader(http.StatusNoContent)\n\n}\n\n```\n\nI need to make sure that the `db` variable is accessible in all the handler functions. In this example, I've declared `db` in the global scope, which makes it accessible everywhere. However, using global variables isn't always the best practice, especially in larger applications. An alternative approach is to use a context or a closure to pass the database connection to the handler functions.\n\nBut for this simple example, using a global variable should be fine.\n\nNow, I need to test this API to make sure it works as expected.\n\nI can use tools like Postman or curl to send HTTP requests to the server and verify the responses.\n\nFirst, I'll start the server by running `go run main.go` in the project directory, making sure that the database environment variables are set.\n\nThen, I can send a POST request to `http://localhost:8000/users` with a JSON body containing the user's name and email to create a new user.\n\nFor example:\n\n```json\n\n{\n\n    \"name\": \"John Doe\",\n\n    \"email\": \"john.doe@example.com\"\n\n}\n\n```\n\nI should receive a response with the newly created user, including the auto-generated ID.\n\nNext, I can send a GET request to `http://localhost:8000/users` to retrieve all users and verify that the newly created user is listed.\n\nThen, I can send a GET request to `http://localhost:8000/users/{id}` to retrieve a specific user by ID.\n\nI can also send a PUT request to `http://localhost:8000/users/{id}` with an updated user JSON to update the user's information.\n\nFinally, I can send a DELETE request to `http://localhost:8000/users/{id}` to delete the user.\n\nI need to make sure to handle error cases, such as trying to create a user with an existing email, updating a non-existent user, or deleting a non-existent user.\n\nI should also consider adding validation for the user input, such as ensuring that the name and email are not empty and that the email is in a valid format.\n\nAdditionally, I might want to add middleware for logging, error handling, or authentication, but that's beyond the scope of this simple CRUD API.\n\nOverall, this should give me a basic RESTful API server in Go that interacts with a PostgreSQL database to perform CRUD operations on a 'users' table.\n\n**Final Solution**\n\nTo create a RESTful API server in Go that interacts with a PostgreSQL database to perform CRUD operations on a 'users' table, follow these steps:\n\n1. **Set up your Go environment:**\n   - Ensure Go is installed by running `go version`.\n   - Initialize a new Go module with `go mod init user-api`.\n\n2. **Set up the PostgreSQL database:**\n   - Install PostgreSQL and create a new database named `userdb`.\n   - Create a table named `users` with columns: `id` (serial primary key), `name` (text not null), and `email` (text not null unique).\n\n3. **Define the Go structure:**\n   - Define a `User` struct to map to the 'users' table.\n   - Set up database connection using environment variables for host, port, user, password, and dbname.\n\n4. **Implement CRUD operations:**\n   - Implement handlers for GET, POST, PUT, and DELETE methods using Gorilla Mux for routing.\n\n5. **Run the server:**\n   - Start the server and test the API using tools like Postman or curl.\n\n### Solution Code\n\n```go\npackage main\n\nimport (\n    \"database/sql\"\n    \"encoding/json\"\n    \"fmt\"\n    \"log\"\n    \"net/http\"\n    \"os\"\n    \"strconv\"\n\n    \"github.com/gorilla/mux\"\n    _ \"github.com/lib/pq\"\n)\n\nconst (\n    DBDriver = \"postgres\"\n)\n\ntype User struct {\n    ID    int    `json:\"id\"`\n    Name  string `json:\"name\"`\n    Email string `json:\"email\"`\n}\n\nfunc main() {\n    dbInfo := fmt.Sprintf(\"host=%s port=%s user=%s password=%s dbname=%s sslmode=disable\",\n        os.Getenv(\"DB_HOST\"),\n        os.Getenv(\"DB_PORT\"),\n        os.Getenv(\"DB_USER\"),\n        os.Getenv(\"DB_PASSWORD\"),\n        os.Getenv(\"DB_NAME\"),\n    )\n\n    db, err := sql.Open(DBDriver, dbInfo)\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer db.Close()\n\n    if err = db.Ping(); err != nil {\n        log.Fatal(err)\n    }\n\n    log.Println(\"Database connection established\")\n\n    router := mux.NewRouter()\n    router.HandleFunc(\"/users\", getUsers).Methods(\"GET\")\n    router.HandleFunc(\"/users\", createUser).Methods(\"POST\")\n    router.HandleFunc(\"/users/{id}\", getUser).Methods(\"GET\")\n    router.HandleFunc(\"/users/{id}\", updateUser).Methods(\"PUT\")\n    router.HandleFunc(\"/users/{id}\", deleteUser).Methods(\"DELETE\")\n\n    log.Println(\"Starting server at port 8000\")\n    log.Fatal(http.ListenAndServe(\":8000\", router))\n}\n\nfunc getUsers(w http.ResponseWriter, r *http.Request) {\n    rows, err := db.Query(\"SELECT id, name, email FROM users\")\n    if err != nil {\n        log.Println(err)\n        http.Error(w, \"Internal server error\", http.StatusInternalServerError)\n        return\n    }\n    defer rows.Close()\n\n    var users []User\n    for rows.Next() {\n        var user User\n        err := rows.Scan(&user.ID, &user.Name, &user.Email)\n        if err != nil {\n            log.Println(err)\n            http.Error(w, \"Internal server error\", http.StatusInternalServerError)\n            return\n        }\n        users = append(users, user)\n    }\n\n    err = rows.Err()\n    if err != nil {\n        log.Println(err)\n        http.Error(w, \"Internal server error\", http.StatusInternalServerError)\n        return\n    }\n\n    json.NewEncoder(w).Encode(users)\n}\n\nfunc createUser(w http.ResponseWriter, r *http.Request) {\n    var user User\n    err := json.NewDecoder(r.Body).Decode(&user)\n    if err != nil {\n        log.Println(err)\n        http.Error(w, \"Bad request\", http.StatusBadRequest)\n        return\n    }\n\n    stmt, err := db.Prepare(\"INSERT INTO users(name, email) VALUES($1, $2) RETURNING id\")\n    if err != nil {\n        log.Println(err)\n        http.Error(w, \"Internal server error\", http.StatusInternalServerError)\n        return\n    }\n    defer stmt.Close()\n\n    var id int\n    err = stmt.QueryRow(user.Name, user.Email).Scan(&id)\n    if err != nil {\n        log.Println(err)\n        http.Error(w, \"Internal server error\", http.StatusInternalServerError)\n        return\n    }\n\n    user.ID = id\n    json.NewEncoder(w).Encode(user)\n}\n\nfunc getUser(w http.ResponseWriter, r *http.Request) {\n    vars := mux.Vars(r)\n    idStr := vars[\"id\"]\n    id, err := strconv.Atoi(idStr)\n    if err != nil {\n        log.Println(err)\n        http.Error(w, \"Bad request\", http.StatusBadRequest)\n        return\n    }\n\n    row := db.QueryRow(\"SELECT id, name, email FROM users WHERE id=$1\", id)\n\n    var user User\n    err = row.Scan(&user.ID, &user.Name, &user.Email)\n    if err == sql.ErrNoRows {\n        http.Error(w, \"Not found\", http.StatusNotFound)\n        return\n    } else if err != nil {\n        log.Println(err)\n        http.Error(w, \"Internal server error\", http.StatusInternalServerError)\n        return\n    }\n\n    json.NewEncoder(w).Encode(user)\n}\n\nfunc updateUser(w http.ResponseWriter, r *http.Request) {\n    vars := mux.Vars(r)\n    idStr := vars[\"id\"]\n    id, err := strconv.Atoi(idStr)\n    if err != nil {\n        log.Println(err)\n        http.Error(w, \"Bad request\", http.StatusBadRequest)\n        return\n    }\n\n    var user User\n    err = json.NewDecoder(r.Body).Decode(&user)\n    if err != nil {\n        log.Println(err)\n        http.Error(w, \"Bad request\", http.StatusBadRequest)\n        return\n    }\n\n    res, err := db.Exec(\"UPDATE users SET name=$1, email=$2 WHERE id=$3\", user.Name, user.Email, id)\n    if err != nil {\n        log.Println(err)\n        http.Error(w, \"Internal server error\", http.StatusInternalServerError)\n        return\n    }\n\n    rowsAffected, err := res.RowsAffected()\n    if err != nil {\n        log.Println(err)\n        http.Error(w, \"Internal server error\", http.StatusInternalServerError)\n        return\n    }\n\n    if rowsAffected == 0 {\n        http.Error(w, \"Not found\", http.StatusNotFound)\n        return\n    }\n\n    user.ID = id\n    json.NewEncoder(w).Encode(user)\n}\n\nfunc deleteUser(w http.ResponseWriter, r *http.Request) {\n    vars := mux.Vars(r)\n    idStr := vars[\"id\"]\n    id, err := strconv.Atoi(idStr)\n    if err != nil {\n        log.Println(err)\n        http.Error(w, \"Bad request\", http.StatusBadRequest)\n        return\n    }\n\n    res, err := db.Exec(\"DELETE FROM users WHERE id=$1\", id)\n    if err != nil {\n        log.Println(err)\n        http.Error(w, \"Internal server error\", http.StatusInternalServerError)\n        return\n    }\n\n    rowsAffected, err := res.RowsAffected()\n    if err != nil {\n        log.Println(err)\n        http.Error(w, \"Internal server error\", http.StatusInternalServerError)\n        return\n    }\n\n    if rowsAffected == 0 {\n        http.Error(w, \"Not found\", http.StatusNotFound)\n        return\n    }\n\n    w.WriteHeader(http.StatusNoContent)\n}\n```\n\n### Explanation\n\n- **Database Setup:** Connect to PostgreSQL using environment variables for database credentials.\n- **User Struct:** Maps to the 'users' table in the database.\n- **Routing:** Use Gorilla Mux for handling different HTTP methods and routes.\n- **CRUD Operations:**\n  - **GET /users:** Retrieve all users.\n  - **POST /users:** Create a new user.\n  - **GET /users/{id}:** Retrieve a specific user by ID.\n  - **PUT /users/{id}:** Update a user by ID.\n  - **DELETE /users/{id}:** Delete a user by ID.\n  \nThis setup provides a basic RESTful API for managing users in a PostgreSQL database using Go."
    }
]