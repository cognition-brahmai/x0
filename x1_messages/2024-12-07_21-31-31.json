[
    {
        "role": "user",
        "content": "Create a C++ implementation of the Merge Sort algorithm. The program should take an array of integers as input and sort them in ascending order using the merge sort technique.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Sure! I'd be happy to help you with that. Merge sort is a popular sorting algorithm that uses the divide-and-conquer approach. It divides the input array into two halves, sorts them separately, and then merges them back together in the correct order.\n\nHere's a step-by-step explanation of how merge sort works:\n\n1. **Divide**: Split the array into two halves.\n2. **Conquer**: Recursively sort the two halves.\n3. **Combine**: Merge the two sorted halves back into a single sorted array.\n\nNow, let's dive into the C++ implementation. I'll provide you with a complete program that takes an array of integers as input and sorts it using merge sort.\n\n### C++ Implementation of Merge Sort\n\n```cpp\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to merge two subarrays of arr[].\n// First subarray is arr[l..m]\n// Second subarray is arr[m+1..r]\nvoid merge(vector<int>& arr, int l, int m, int r) {\n    int n1 = m - l + 1;\n    int n2 = r - m;\n\n    // Create temporary arrays\n    vector<int> L(n1), R(n2);\n\n    // Copy data to temporary arrays L[] and R[]\n    for (int i = 0; i < n1; i++)\n        L[i] = arr[l + i];\n    for (int j = 0; j < n2; j++)\n        R[j] = arr[m + 1 + j];\n\n    // Merge the temporary arrays back into arr[l..r]\n    int i = 0, j = 0, k = l;\n    while (i < n1 && j < n2) {\n        if (L[i] <= R[j]) {\n            arr[k] = L[i];\n            i++;\n        } else {\n            arr[k] = R[j];\n            j++;\n        }\n        k++;\n    }\n\n    // Copy the remaining elements of L[], if there are any\n    while (i < n1) {\n        arr[k] = L[i];\n        i++;\n        k++;\n    }\n\n    // Copy the remaining elements of R[], if there are any\n    while (j < n2) {\n        arr[k] = R[j];\n        j++;\n        k++;\n    }\n}\n\n// l is for the left index and r is the right index of the sub-array of arr to be sorted\nvoid mergeSort(vector<int>& arr, int l, int r) {\n    if (l >= r) {\n        return; // Returns recursively\n    }\n    int m = l + (r - l) / 2;\n    mergeSort(arr, l, m);\n    mergeSort(arr, m + 1, r);\n    merge(arr, l, m, r);\n}\n\n// Function to print an array\nvoid printArray(const vector<int>& arr) {\n    for (int num : arr) {\n        cout << num << \" \";\n    }\n    cout << endl;\n}\n\n// Driver code\nint main() {\n    vector<int> arr = {12, 11, 13, 5, 6, 7};\n    cout << \"Given array is \\n\";\n    printArray(arr);\n    mergeSort(arr, 0, arr.size() - 1);\n    cout << \"\\nSorted array is \\n\";\n    printArray(arr);\n    return 0;\n}\n```\n\n### Explanation of the Code\n\n1. **merge Function**: This function merges two halves of the array. It takes the original array and the indices indicating the start, middle, and end of the subarray to be merged.\n   - It creates temporary arrays for the left and right halves.\n   - It copies data to these temporary arrays.\n   - It merges the two halves back into the original array in sorted order.\n\n2. **mergeSort Function**: This is a recursive function that divides the array into halves until the base case is reached (when the subarray has only one element).\n   - It finds the middle point to divide the array into two halves.\n   - It recursively calls itself for the left and right halves.\n   - It calls the merge function to merge the two halves.\n\n3. **printArray Function**: A utility function to print the elements of the array.\n\n4. **main Function**: The driver code that initializes the array, prints the original array, sorts it using merge sort, and then prints the sorted array.\n\nThis implementation should help you understand how merge sort works in C++. If you have any questions or need further clarification, feel free to ask!"
    }
]