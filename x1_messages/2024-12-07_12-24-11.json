[
    {
        "role": "user",
        "content": "Develop a Golang REST API server that supports CRUD operations for managing a list of tasks. Each task should have a unique ID, title, description, and status (completed or not). Use a SQLite database for storing the tasks."
    },
    {
        "role": "assistant",
        "content": "I'm going to develop a REST API server in Golang that manages a list of tasks with CRUD operations, using a SQLite database. Let's break this down step by step.\n\nFirst, I need to set up a new Go project. I'll create a new directory for my project and initialize it with `go mod init`. Let's call the project \"taskmanager\".\n\nNext, I need to set up the SQLite database. I'll use the `github.com/mattn/go-sqlite3` package to interact with SQLite from Go. I should install this package using `go get`.\n\nNow, I need to define the structure of a task. Each task should have a unique ID, a title, a description, and a status indicating whether it's completed or not. I'll create a struct in Go to represent this.\n\n```go\ntype Task struct {\n    ID          int    `json:\"id\"`\n    Title       string `json:\"title\"`\n    Description string `json:\"description\"`\n    Completed   bool   `json:\"completed\"`\n}\n```\n\nI'll also need a slice to hold all tasks in memory, but since I'm using a database, I'll handle data persistence through SQL queries.\n\nLet's set up the database connection and create the tasks table if it doesn't exist.\n\n```go\nimport (\n    \"database/sql\"\n    _ \"github.com/mattn/go-sqlite3\"\n)\n\nfunc initDB() (*sql.DB, error) {\n    db, err := sql.Open(\"sqlite3\", \"./tasks.db\")\n    if err != nil {\n        return nil, err\n    }\n    // Create tasks table\n    createTableSQL := `\n    CREATE TABLE IF NOT EXISTS tasks (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        title TEXT NOT NULL,\n        description TEXT,\n        completed INTEGER NOT NULL\n    );\n    `\n    _, err = db.Exec(createTableSQL)\n    if err != nil {\n        return nil, err\n    }\n    return db, nil\n}\n```\n\nWith the database set up, I can proceed to implement the CRUD operations.\n\n**Create Operation:**\n\nI need an endpoint to create a new task. This will be a POST request to `/tasks`.\n\n```go\nfunc createTask(w http.ResponseWriter, r *http.Request) {\n    var task Task\n    if err := json.NewDecoder(r.Body).Decode(&task); err != nil {\n        http.Error(w, err.Error(), http.StatusBadRequest)\n        return\n    }\n    stmt, err := db.Prepare(\"INSERT INTO tasks(title, description, completed) VALUES(?,?,?)\")\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n        return\n    }\n    res, err := stmt.Exec(task.Title, task.Description, task.Completed)\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n        return\n    }\n    taskId, _ := res.LastInsertId()\n    task.ID = int(taskId)\n    w.Header().Set(\"Location\", \"/tasks/\"+strconv.Itoa(task.ID))\n    w.WriteHeader(http.StatusCreated)\n    json.NewEncoder(w).Encode(task)\n}\n```\n\n**Read Operations:**\n\n1. Get all tasks: GET `/tasks`\n\n```go\nfunc getTasks(w http.ResponseWriter, r *http.Request) {\n    rows, err := db.Query(\"SELECT id, title, description, completed FROM tasks\")\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n        return\n    }\n    defer rows.Close()\n    var tasks []Task\n    for rows.Next() {\n        var task Task\n        if err := rows.Scan(&task.ID, &task.Title, &task.Description, &task.Completed); err != nil {\n            http.Error(w, err.Error(), http.StatusInternalServerError)\n            return\n        }\n        tasks = append(tasks, task)\n    }\n    json.NewEncoder(w).Encode(tasks)\n}\n```\n\n2. Get a single task: GET `/tasks/{id}`\n\n```go\nfunc getTask(w http.ResponseWriter, r *http.Request) {\n    vars := mux.Vars(r)\n    idStr := vars[\"id\"]\n    id, err := strconv.Atoi(idStr)\n    if err != nil {\n        http.Error(w, \"Invalid ID\", http.StatusBadRequest)\n        return\n    }\n    row := db.QueryRow(\"SELECT id, title, description, completed FROM tasks WHERE id=?\", id)\n    var task Task\n    if err := row.Scan(&task.ID, &task.Title, &task.Description, &task.Completed); err != nil {\n        if err == sql.ErrNoRows {\n            http.Error(w, \"Task not found\", http.StatusNotFound)\n        } else {\n            http.Error(w, err.Error(), http.StatusInternalServerError)\n        }\n        return\n    }\n    json.NewEncoder(w).Encode(task)\n}\n```\n\n**Update Operation:**\n\nUpdate a task: PUT `/tasks/{id}`\n\n```go\nfunc updateTask(w http.ResponseWriter, r *http.Request) {\n    vars := mux.Vars(r)\n    idStr := vars[\"id\"]\n    id, err := strconv.Atoi(idStr)\n    if err != nil {\n        http.Error(w, \"Invalid ID\", http.StatusBadRequest)\n        return\n    }\n    var task Task\n    if err := json.NewDecoder(r.Body).Decode(&task); err != nil {\n        http.Error(w, err.Error(), http.StatusBadRequest)\n        return\n    }\n    task.ID = id\n    stmt, err := db.Prepare(\"UPDATE tasks SET title=?, description=?, completed=? WHERE id=?\")\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n        return\n    }\n    _, err = stmt.Exec(task.Title, task.Description, task.Completed, task.ID)\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n        return\n    }\n    json.NewEncoder(w).Encode(task)\n}\n```\n\n**Delete Operation:**\n\nDelete a task: DELETE `/tasks/{id}`\n\n```go\nfunc deleteTask(w http.ResponseWriter, r *http.Request) {\n    vars := mux.Vars(r)\n    idStr := vars[\"id\"]\n    id, err := strconv.Atoi(idStr)\n    if err != nil {\n        http.Error(w, \"Invalid ID\", http.StatusBadRequest)\n        return\n    }\n    res, err := db.Exec(\"DELETE FROM tasks WHERE id=?\", id)\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n        return\n    }\n    rowsAffected, _ := res.RowsAffected()\n    if rowsAffected == 0 {\n        http.Error(w, \"Task not found\", http.StatusNotFound)\n        return\n    }\n    w.WriteHeader(http.StatusNoContent)\n}\n```\n\nNow, I need to set up the HTTP routes using a router like `github.com/gorilla/mux`.\n\n```go\nimport (\n    \"github.com/gorilla/mux\"\n)\n\nfunc main() {\n    db, err := initDB()\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer db.Close()\n    router := mux.NewRouter()\n    router.HandleFunc(\"/tasks\", createTask).Methods(\"POST\")\n    router.HandleFunc(\"/tasks\", getTasks).Methods(\"GET\")\n    router.HandleFunc(\"/tasks/{id}\", getTask).Methods(\"GET\")\n    router.HandleFunc(\"/tasks/{id}\", updateTask).Methods(\"PUT\")\n    router.HandleFunc(\"/tasks/{id}\", deleteTask).Methods(\"DELETE\")\n    log.Fatal(http.ListenAndServe(\":8000\", router))\n}\n```\n\nThat should cover the basic CRUD operations for managing tasks with a SQLite database in a Golang REST API server.\n\n**Summary of Endpoints:**\n\n- POST /tasks: Create a new task\n- GET /tasks: Get all tasks\n- GET /tasks/{id}: Get a single task by ID\n- PUT /tasks/{id}: Update a task by ID\n- DELETE /tasks/{id}: Delete a task by ID\n\nThis setup uses SQLite for data persistence, which is suitable for development and small-scale applications. For production, consider using a more robust database system like PostgreSQL or MySQL.\n\n## Final Solution\nTo create a Golang REST API server that supports CRUD operations for managing a list of tasks with a SQLite database, follow these steps:\n\n1. **Set Up the Project:**\n   - Create a new directory for your project.\n   - Initialize a Go module:\n     ```sh\n     go mod init taskmanager\n     ```\n   - Install the required packages:\n     ```sh\n     go get github.com/gorilla/mux\n     go get github.com/mattn/go-sqlite3\n     ```\n\n2. **Define the Task Structure:**\n   - Create a `task.go` file to define the Task struct.\n     ```go\n     package main\n\n     import (\n         \"database/sql\"\n         \"encoding/json\"\n         \"log\"\n         \"net/http\"\n         \"strconv\"\n\n         _ \"github.com/mattn/go-sqlite3\"\n         \"github.com/gorilla/mux\"\n     )\n\n     type Task struct {\n         ID          int    `json:\"id\"`\n         Title       string `json:\"title\"`\n         Description string `json:\"description\"`\n         Completed   bool   `json:\"completed\"`\n     }\n\n     var db *sql.DB\n\n     func initDB() error {\n         var err error\n         db, err = sql.Open(\"sqlite3\", \"./tasks.db\")\n         if err != nil {\n             return err\n         }\n         createTableSQL := `\n         CREATE TABLE IF NOT EXISTS tasks (\n             id INTEGER PRIMARY KEY AUTOINCREMENT,\n             title TEXT NOT NULL,\n             description TEXT,\n             completed INTEGER NOT NULL\n         );\n         `\n         _, err = db.Exec(createTableSQL)\n         return err\n     }\n     ```\n\n3. **Implement CRUD Operations:**\n   - **Create Task:**\n     ```go\n     func createTask(w http.ResponseWriter, r *http.Request) {\n         var task Task\n         if err := json.NewDecoder(r.Body).Decode(&task); err != nil {\n             http.Error(w, err.Error(), http.StatusBadRequest)\n             return\n         }\n         stmt, err := db.Prepare(\"INSERT INTO tasks(title, description, completed) VALUES(?,?,?)\")\n         if err != nil {\n             http.Error(w, err.Error(), http.StatusInternalServerError)\n             return\n         }\n         res, err := stmt.Exec(task.Title, task.Description, task.Completed)\n         if err != nil {\n             http.Error(w, err.Error(), http.StatusInternalServerError)\n             return\n         }\n         taskId, _ := res.LastInsertId()\n         task.ID = int(taskId)\n         w.Header().Set(\"Location\", \"/tasks/\"+strconv.Itoa(task.ID))\n         w.WriteHeader(http.StatusCreated)\n         json.NewEncoder(w).Encode(task)\n     }\n     ```\n\n   - **Read All Tasks:**\n     ```go\n     func getTasks(w http.ResponseWriter, r *http.Request) {\n         rows, err := db.Query(\"SELECT id, title, description, completed FROM tasks\")\n         if err != nil {\n             http.Error(w, err.Error(), http.StatusInternalServerError)\n             return\n         }\n         defer rows.Close()\n         var tasks []Task\n         for rows.Next() {\n             var task Task\n             if err := rows.Scan(&task.ID, &task.Title, &task.Description, &task.Completed); err != nil {\n                 http.Error(w, err.Error(), http.StatusInternalServerError)\n                 return\n             }\n             tasks = append(tasks, task)\n         }\n         json.NewEncoder(w).Encode(tasks)\n     }\n     ```\n\n   - **Read Single Task:**\n     ```go\n     func getTask(w http.ResponseWriter, r *http.Request) {\n         vars := mux.Vars(r)\n         idStr := vars[\"id\"]\n         id, err := strconv.Atoi(idStr)\n         if err != nil {\n             http.Error(w, \"Invalid ID\", http.StatusBadRequest)\n             return\n         }\n         row := db.QueryRow(\"SELECT id, title, description, completed FROM tasks WHERE id=?\", id)\n         var task Task\n         if err := row.Scan(&task.ID, &task.Title, &task.Description, &task.Completed); err != nil {\n             if err == sql.ErrNoRows {\n                 http.Error(w, \"Task not found\", http.StatusNotFound)\n             } else {\n                 http.Error(w, err.Error(), http.StatusInternalServerError)\n             }\n             return\n         }\n         json.NewEncoder(w).Encode(task)\n     }\n     ```\n\n   - **Update Task:**\n     ```go\n     func updateTask(w http.ResponseWriter, r *http.Request) {\n         vars := mux.Vars(r)\n         idStr := vars[\"id\"]\n         id, err := strconv.Atoi(idStr)\n         if err != nil {\n             http.Error(w, \"Invalid ID\", http.StatusBadRequest)\n             return\n         }\n         var task Task\n         if err := json.NewDecoder(r.Body).Decode(&task); err != nil {\n             http.Error(w, err.Error(), http.StatusBadRequest)\n             return\n         }\n         task.ID = id\n         stmt, err := db.Prepare(\"UPDATE tasks SET title=?, description=?, completed=? WHERE id=?\")\n         if err != nil {\n             http.Error(w, err.Error(), http.StatusInternalServerError)\n             return\n         }\n         _, err = stmt.Exec(task.Title, task.Description, task.Completed, task.ID)\n         if err != nil {\n             http.Error(w, err.Error(), http.StatusInternalServerError)\n             return\n         }\n         json.NewEncoder(w).Encode(task)\n     }\n     ```\n\n   - **Delete Task:**\n     ```go\n     func deleteTask(w http.ResponseWriter, r *http.Request) {\n         vars := mux.Vars(r)\n         idStr := vars[\"id\"]\n         id, err := strconv.Atoi(idStr)\n         if err != nil {\n             http.Error(w, \"Invalid ID\", http.StatusBadRequest)\n             return\n         }\n         res, err := db.Exec(\"DELETE FROM tasks WHERE id=?\", id)\n         if err != nil {\n             http.Error(w, err.Error(), http.StatusInternalServerError)\n             return\n         }\n         rowsAffected, _ := res.RowsAffected()\n         if rowsAffected == 0 {\n             http.Error(w, \"Task not found\", http.StatusNotFound)\n             return\n         }\n         w.WriteHeader(http.StatusNoContent)\n     }\n     ```\n\n4. **Set Up Routes and Start the Server:**\n   - In your `main.go` file, set up the routes and start the server.\n     ```go\n     func main() {\n         if err := initDB(); err != nil {\n             log.Fatal(err)\n         }\n         defer db.Close()\n\n         router := mux.NewRouter()\n         router.HandleFunc(\"/tasks\", createTask).Methods(\"POST\")\n         router.HandleFunc(\"/tasks\", getTasks).Methods(\"GET\")\n         router.HandleFunc(\"/tasks/{id}\", getTask).Methods(\"GET\")\n         router.HandleFunc(\"/tasks/{id}\", updateTask).Methods(\"PUT\")\n         router.HandleFunc(\"/tasks/{id}\", deleteTask).Methods(\"DELETE\")\n\n         log.Fatal(http.ListenAndServe(\":8000\", router))\n     }\n     ```\n\n5. **Run the Server:**\n   - Start the server by running:\n     ```sh\n     go run main.go\n     ```\n\nNow, your REST API server is up and running, supporting CRUD operations for managing tasks with a SQLite database."
    }
]