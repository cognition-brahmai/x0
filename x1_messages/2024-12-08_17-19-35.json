[
    {
        "role": "user",
        "content": "Implement a Python Flask API with endpoints to perform CRUD operations on a \"Task\" model. The Task model should have fields like title, description, due_date, and status. Use SQLAlchemy ORM for database interactions and validate user inputs before performing any operation.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Alright, I'm going to help you set up a Python Flask API with CRUD operations for a \"Task\" model. We'll use SQLAlchemy for database interactions and validate user inputs to ensure data integrity.\n\nFirst, make sure you have Flask and SQLAlchemy installed. You can install them using pip:\n\n```bash\npip install Flask SQLAlchemy\n```\n\nNext, let's set up the basic structure of our Flask app. Create a new directory for your project, and inside it, create a file named `app.py`. This will be our main application file.\n\nIn `app.py`, start by importing the necessary modules:\n\n```python\nfrom flask import Flask, request, jsonify\nfrom flask_sqlalchemy import SQLAlchemy\nfrom flask_marshmallow import Marshmallow\nimport os\n```\n\nNow, initialize your Flask app and set up the database URI. For simplicity, we'll use a SQLite database:\n\n```python\napp = Flask(__name__)\nbasedir = os.path.abspath(os.path.dirname(__file__))\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///' + os.path.join(basedir, 'db.sqlite')\napp.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False\n\ndb = SQLAlchemy(app)\nma = Marshmallow(app)\n```\n\nNext, define the Task model with the specified fields: title, description, due_date, and status.\n\n```python\nclass Task(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    title = db.Column(db.String(100), nullable=False)\n    description = db.Column(db.String(500))\n    due_date = db.Column(db.Date)\n    status = db.Column(db.String(20))\n\n    def __init__(self, title, description, due_date, status):\n        self.title = title\n        self.description = description\n        self.due_date = due_date\n        self.status = status\n```\n\nNow, create a schema for serialization and deserialization using Marshmallow.\n\n```python\nclass TaskSchema(ma.Schema):\n    class Meta:\n        fields = ('id', 'title', 'description', 'due_date', 'status')\n\ntask_schema = TaskSchema()\ntasks_schema = TaskSchema(many=True)\n```\n\nBefore proceeding to create the endpoints, make sure to create the database tables by running:\n\n```python\ndb.create_all()\n```\n\nNow, let's create the CRUD endpoints.\n\n**1. Create a Task (POST)**\n\nFor creating a task, we need to validate the input data. Ensure that the title is provided and that the status is one of the allowed values (e.g., 'pending', 'in progress', 'completed').\n\n```python\n@app.route('/task', methods=['POST'])\ndef add_task():\n    title = request.json.get('title')\n    description = request.json.get('description')\n    due_date = request.json.get('due_date')\n    status = request.json.get('status')\n\n    if not title:\n        return jsonify({'message': 'Title is required'}), 400\n\n    allowed_statuses = ['pending', 'in progress', 'completed']\n    if status not in allowed_statuses:\n        return jsonify({'message': 'Invalid status. Choose from: {}'.format(', '.join(allowed_statuses))}), 400\n\n    new_task = Task(title, description, due_date, status)\n    db.session.add(new_task)\n    db.session.commit()\n\n    return task_schema.jsonify(new_task), 201\n```\n\n**2. Get All Tasks (GET)**\n\nThis endpoint will return a list of all tasks.\n\n```python\n@app.route('/tasks', methods=['GET'])\ndef get_tasks():\n    all_tasks = Task.query.all()\n    result = tasks_schema.dump(all_tasks)\n    return jsonify(result)\n```\n\n**3. Get a Single Task (GET by ID)**\n\nRetrieve a task by its ID.\n\n```python\n@app.route('/task/<int:id>', methods=['GET'])\ndef get_task(id):\n    task = Task.query.get(id)\n    if not task:\n        return jsonify({'message': 'Task not found'}), 404\n    return task_schema.jsonify(task)\n```\n\n**4. Update a Task (PUT)**\n\nAllow updating of task fields. Validate the input similarly to the create endpoint.\n\n```python\n@app.route('/task/<int:id>', methods=['PUT'])\ndef update_task(id):\n    task = Task.query.get(id)\n    if not task:\n        return jsonify({'message': 'Task not found'}), 404\n\n    title = request.json.get('title')\n    description = request.json.get('description')\n    due_date = request.json.get('due_date')\n    status = request.json.get('status')\n\n    if title:\n        task.title = title\n    if description:\n        task.description = description\n    if due_date:\n        task.due_date = due_date\n    if status:\n        allowed_statuses = ['pending', 'in progress', 'completed']\n        if status not in allowed_statuses:\n            return jsonify({'message': 'Invalid status. Choose from: {}'.format(', '.join(allowed_statuses))}), 400\n        task.status = status\n\n    db.session.commit()\n    return task_schema.jsonify(task)\n```\n\n**5. Delete a Task (DELETE)**\n\nProvide an endpoint to delete a task by its ID.\n\n```python\n@app.route('/task/<int:id>', methods=['DELETE'])\ndef delete_task(id):\n    task = Task.query.get(id)\n    if not task:\n        return jsonify({'message': 'Task not found'}), 404\n    db.session.delete(task)\n    db.session.commit()\n    return jsonify({'message': 'Task deleted'})\n```\n\nFinally, add the following lines to run the app:\n\n```python\nif __name__ == '__main__':\n    app.run(debug=True)\n```\n\n### Summary\n\n- **Create Task:** POST `/task`\n- **Get All Tasks:** GET `/tasks`\n- **Get Single Task:** GET `/task/<id>`\n- **Update Task:** PUT `/task/<id>`\n- **Delete Task:** DELETE `/task/<id>`\n\nThis setup provides a basic Flask API with CRUD operations for managing tasks, including input validation to ensure data integrity.\n"
    }
]