[
    {
        "role": "user",
        "content": "Create a C++ application that reads data from a SQLite database and performs basic CRUD operations on the data. The application should support creating new tables, inserting rows, updating existing rows, deleting rows, and querying the data using SQL statements provided as command line arguments.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Alright, I'm going to try to create a C++ application that can interact with a SQLite database and perform basic CRUD operations. I've never done this before, but I'm excited to learn something new.\n\nFirst, I need to understand what SQLite is and how it works with C++. SQLite is a C library that provides a lightweight disk-based database that doesn't require a separate server process. It's perfect for small to medium-sized applications where setting up a full SQL server is overkill.\n\nTo use SQLite in a C++ application, I need to include the SQLite C API. I think I can download the SQLite amalgram source code and include it in my project. Alternatively, I can install it via a package manager if I'm on a Linux system.\n\nLet me start by setting up a new C++ project. I'll create a new directory for my project and initialize it with a main.cpp file.\n\nNow, I need to figure out how to compile my C++ code with SQLite. Since SQLite is a C library, I need to make sure that my C++ code can link against it properly. I might need to use extern \"C\" to prevent name mangling.\n\nLet me look up how to include SQLite in a C++ project. From what I'm reading, I need to include the sqlite3.h header file and link against the sqlite3 library.\n\nAssuming I have SQLite installed on my system, I can include it like this:\n\n#include <sqlite3.h>\n\nAnd then link against -lsqlite3 during compilation.\n\nBut to make sure I have SQLite installed, I can check by running:\n\nsqlite3 --version\n\nin my terminal. If it's not installed, I'll need to install it. On Ubuntu, I can use:\n\nsudo apt-get install libsqlite3-dev\n\nThat should install the development files I need.\n\nOnce I have SQLite set up, I need to think about how my application will work. The application should read data from a SQLite database and perform CRUD operations based on command line arguments.\n\nSo, I need to parse command line arguments to determine what operation to perform: create table, insert row, update row, delete row, or query data.\n\nI should define a set of commands, like:\n\n- create table: To create a new table in the database.\n\n- insert: To insert a new row into a table.\n\n- update: To update an existing row in a table.\n\n- delete: To delete a row from a table.\n\n- select: To query data from the table.\n\nEach of these commands will require different parameters. For example, creating a table will need the table name and column definitions, while inserting a row will need the table name and the values to insert.\n\nI need to design a way to parse these arguments efficiently. Maybe I can use a library like Boost.Program_options or implement a simple parser myself.\n\nFor simplicity, I'll try to implement a simple parser myself.\n\nLet me think about the basic structure of the application:\n\n1. Parse command line arguments to determine the operation to perform.\n\n2. Open the SQLite database specified by the user.\n\n3. Execute the specified operation.\n\n4. Handle any errors that occur during the process.\n\nFirst, I need to handle connecting to the SQLite database. In SQLite, this is done using sqlite3_open function, which takes the database file name and a pointer to a sqlite3* variable.\n\nI need to handle errors properly. SQLite provides error codes and error messages that I can retrieve using sqlite3_errcode and sqlite3_errmsg functions.\n\nLet me sketch out some pseudocode for the connection part:\n\nsqlite3 *db;\n\nint rc = sqlite3_open(\"mydatabase.db\", &db);\n\nif (rc != SQLITE_OK) {\n\n    fprintf(stderr, \"Cannot open database: %s\\n\", sqlite3_errmsg(db));\n\n    sqlite3_close(db);\n\n    return 1;\n\n}\n\nGreat, now that I have the database connection, I can proceed to execute SQL statements based on the user's command.\n\nLet me consider the \"create table\" operation. The user needs to specify the table name and the column definitions. For example:\n\ncreate table users (id INTEGER PRIMARY KEY, name TEXT, age INTEGER)\n\nI need to pass this as a SQL statement to the database.\n\nI can use the sqlite3_exec function to execute SQL statements. This function takes the database connection, the SQL statement, and some callback functions for handling results.\n\nFor create table, since it's a DDL statement, there are no results to handle, so I can pass NULL for the callback.\n\nSimilarly, for insert, update, and delete operations, there are no results to handle, so I can use sqlite3_exec for those as well.\n\nFor select queries, I need to handle the results. I need to provide a callback function that will be called for each row returned by the query.\n\nI need to design a callback function that can handle the results appropriately. Perhaps I can print the results to the console in a formatted way.\n\nLet me think about how to structure the command line interface.\n\nI need to have the first argument specify the operation, and then subsequent arguments provide the necessary parameters for that operation.\n\nFor example:\n\nmyapp create table users (id INTEGER PRIMARY KEY, name TEXT, age INTEGER)\n\nmyapp insert into users values (1, 'John Doe', 30)\n\nmyapp update users set age=31 where id=1\n\nmyapp delete from users where id=1\n\nmyapp select * from users\n\nI need to parse these arguments and construct the corresponding SQL statements.\n\nThis seems a bit tricky because the arguments include parentheses and commas, which are special characters in the shell. Maybe I need to enclose the SQL statement in quotes.\n\nFor example:\n\nmyapp create \"table users (id INTEGER PRIMARY KEY, name TEXT, age INTEGER)\"\n\nmyapp insert \"into users values (1, 'John Doe', 30)\"\n\nmyapp update \"users set age=31 where id=1\"\n\nmyapp delete \"from users where id=1\"\n\nmyapp select \"from users\"\n\nThis way, the shell won't interpret the special characters, and I can pass the SQL statement as a single argument to my application.\n\nIn my application, I can then extract the operation and the SQL statement accordingly.\n\nLet me adjust my earlier pseudocode to include this.\n\nFirst, check the number of arguments. There should be at least two: the operation and the SQL statement.\n\nThen, based on the operation, construct the appropriate SQL command.\n\nWait, perhaps I can simplify it by having the user provide the full SQL statement, and my application just executes it.\n\nFor example:\n\nmyapp \"CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT, age INTEGER)\"\n\nmyapp \"INSERT INTO users VALUES (1, 'John Doe', 30)\"\n\nmyapp \"UPDATE users SET age=31 WHERE id=1\"\n\nmyapp \"DELETE FROM users WHERE id=1\"\n\nmyapp \"SELECT * FROM users\"\n\nThis way, my application just needs to take the SQL statement as a string and execute it using sqlite3_exec.\n\nThis seems much simpler. I don't need to parse the SQL statement myself; I can just pass it to SQLite.\n\nBut I need to handle the results for select statements. For other statements, I can ignore the results.\n\nI can check if the SQL statement starts with \"SELECT\", and if so, provide a callback function to handle the results.\n\nOtherwise, just execute the statement and check for errors.\n\nThis seems feasible.\n\nLet me think about how to implement the callback function for select statements.\n\nSQLite allows me to provide a callback function that is called for each row returned by the query. The function receives the column values as arguments.\n\nI need to print these values in a readable format.\n\nPerhaps I can print each row as a list of values separated by tabs or commas.\n\nAlso, I should print the column names first.\n\nTo get the column names, I can use the sqlite3_column_name function.\n\nSo, in my callback function, I can do something like:\n\nvoid print_result(int argc, char **argv, char **azColName) {\n\n    for(int i = 0; i < argc; i++) {\n\n        printf(\"%s = %s\\n\", azColName[i], argv[i] ? argv[i] : \"NULL\");\n\n    }\n\n    printf(\"\\n\");\n\n}\n\nAnd pass this function to sqlite3_exec.\n\nWait, but sqlite3_exec doesn't take a callback that includes column names. I think I need to use sqlite3_prepare, sqlite3_step, and sqlite3_column_* functions for more control.\n\nPerhaps it's better to switch to using these lower-level functions for executing the SQL statements.\n\nUsing sqlite3_prepare, I can compile the SQL statement into a statement object, then use sqlite3_step to execute it step by step, and retrieve the results using sqlite3_column_* functions.\n\nThis will give me more control over how to handle the results.\n\nSo, in my application, I can do something like:\n\nsqlite3 *db;\n\nchar *zErrMsg = 0;\n\nint rc;\n\nrc = sqlite3_open(\"mydatabase.db\", &db);\n\nif( rc ) {\n\n    fprintf(stderr, \"Can't open database: %s\\n\", sqlite3_errmsg(db));\n\n    return(0);\n\n}\n\nconst char *sql = \"SELECT * FROM users\";\n\nsqlite3_stmt *stmt;\n\nrc = sqlite3_prepare_v2(db, sql, -1, &stmt, 0);\n\nif( rc != SQLITE_OK ) {\n\n    fprintf(stderr, \"Prepare error: %s\\n\", zErrMsg);\n\n    sqlite3_free(zErrMsg);\n\n    sqlite3_close(db);\n\n    return 1;\n\n}\n\nwhile((rc = sqlite3_step(stmt)) == SQLITE_ROW) {\n\n    int id = sqlite3_column_int(stmt, 0);\n\n    const unsigned char *name = sqlite3_column_text(stmt, 1);\n\n    int age = sqlite3_column_int(stmt, 2);\n\n    printf(\"ID: %d, Name: %s, Age: %d\\n\", id, name, age);\n\n}\n\nif( rc != SQLITE_DONE ) {\n\n    fprintf(stderr, \"Step error: %s\\n\", sqlite3_errmsg(db));\n\n}\n\nsqlite3_finalize(stmt);\n\nsqlite3_close(db);\n\nThis seems more flexible. I can handle different types of columns appropriately.\n\nBut for simplicity, perhaps sticking with sqlite3_exec for non-select statements and using sqlite3_prepare for select statements would be okay.\n\nWait, actually, sqlite3_exec can handle select statements with a callback function.\n\nSo maybe I can use sqlite3_exec for select statements and sqlite3_exec for other statements.\n\nLet me check the sqlite3_exec documentation.\n\nsqlite3_exec runs a single SQL statement against the database and returns the result.\n\nFor non-select statements, it's fine to use sqlite3_exec.\n\nFor select statements, I need to provide a callback function that will be called for each row.\n\nSo, in my application, I can check if the SQL statement starts with \"SELECT\", and if so, set the callback function, otherwise pass NULL for the callback.\n\nThis seems workable.\n\nNow, I need to handle command line arguments properly.\n\nIn C++, I can access command line arguments through the main function's argv array.\n\nI need to make sure that the user provides at least one argument, which is the SQL statement.\n\nI should also allow the user to specify the database file name as an argument.\n\nPerhaps the first argument is the database file name, and the second argument is the SQL statement.\n\nFor example:\n\nmyapp mydatabase.db \"SELECT * FROM users\"\n\nAlternatively, I can make the database file name a command line option, like:\n\nmyapp -db mydatabase.db \"SELECT * FROM users\"\n\nThis way, the database file name is optional, and if not specified, the application can use a default database file.\n\nI think using command line options is better, as it makes the interface more flexible.\n\nI can use standard library facilities to parse command line options, like std::stoi, std::string, etc., or use a library like Boost.Program_options for more complex scenarios.\n\nFor simplicity, I'll stick with manual parsing.\n\nLet me define the command line options as follows:\n\nmyapp [options] \"SQL_statement\"\n\nWhere options can include:\n\n- -db or --database followed by the database file name.\n\n- -h or --help to display usage information.\n\nI need to parse these options and handle them accordingly.\n\nFor example, if -h or --help is provided, print usage information and exit.\n\nIf -db or --database is provided, use the specified database file name; otherwise, use a default file name, say \"default.db\".\n\nThen, the last argument should be the SQL statement enclosed in quotes.\n\nI need to make sure that the SQL statement is provided as a single argument, hence the quotes.\n\nIn my main function, I can iterate through the argv array, parse the options, and extract the database file name and the SQL statement.\n\nLet me sketch some pseudocode for this:\n\nint main(int argc, char *argv[]) {\n\n    std::string db_name = \"default.db\";\n\n    std::string sql_statement;\n\n    for (int i = 1; i < argc; i++) {\n\n        if (std::string(argv[i]) == \"-h\" || std::string(argv[i]) == \"--help\") {\n\n            print_help();\n\n            return 0;\n\n        } else if (std::string(argv[i]) == \"-db\" || std::string(argv[i]) == \"--database\") {\n\n            if (i + 1 < argc) {\n\n                db_name = argv[i + 1];\n\n                i++;\n\n            } else {\n\n                std::cerr << \"Database file name not provided.\" << std::endl;\n\n                print_help();\n\n                return 1;\n\n            }\n\n        } else {\n\n            // Assume it's the SQL statement\n\n            sql_statement = argv[i];\n\n        }\n\n    }\n\n    if (sql_statement.empty()) {\n\n        std::cerr << \"SQL statement not provided.\" << std::endl;\n\n        print_help();\n\n        return 1;\n\n    }\n\n    // Proceed to open the database and execute the SQL statement\n\n}\n\nThis seems reasonable.\n\nNow, I need to implement the function to open the database and execute the SQL statement.\n\nI need to check if the SQL statement starts with \"SELECT\" (case-insensitive), and if so, set a callback function for handling the results.\n\nOtherwise, just execute the statement and check for errors.\n\nI can use sqlite3_exec for this purpose.\n\nLet me look up the sqlite3_exec function.\n\nsqlite3_exec(database, sql, callback, data, &zErrMsg)\n\nWhere:\n\n- database: the database connection.\n\n- sql: the SQL statement to execute.\n\n- callback: the callback function for select statements.\n\n- data: user data to pass to the callback.\n\n- zErrMsg: pointer to a char* to hold any error message.\n\nFor non-select statements, I can pass NULL for the callback.\n\nFor select statements, I need to provide a callback function that matches the following prototype:\n\nint callback(void *data, int argc, char **argv, char **azColName)\n\nSo, I need to implement such a function to handle the results.\n\nIn this function, argc is the number of columns, argv is an array of pointers to char* containing the column values, and azColName is an array of pointers to char* containing the column names.\n\nI can print the column names first, and then print each row's values.\n\nLet me write a simple callback function for this:\n\nstatic int print_result(void *data, int argc, char **argv, char **azColName) {\n\n    for(int i = 0; i < argc; i++) {\n\n        printf(\"%s = %s\\n\", azColName[i], argv[i] ? argv[i] : \"NULL\");\n\n    }\n\n    printf(\"\\n\");\n\n    return 0;\n\n}\n\nThen, in my main function, I can check if the SQL statement starts with \"SELECT\", and if so, set the callback to print_result; otherwise, set it to NULL.\n\nI need to make this check case-insensitive, so I should convert the first few characters of the SQL statement to uppercase and compare.\n\nIn C++, I can use std::string to handle this easily.\n\nLet me write a function to check if the SQL statement is a select statement:\n\nbool is_select_statement(const std::string& sql) {\n\n    std::string upper_sql = sql;\n\n    std::transform(upper_sql.begin(), upper_sql.end(), upper_sql.begin(), ::toupper);\n\n    return upper_sql.find(\"SELECT\") == 0;\n\n}\n\nThis function converts the SQL statement to uppercase and checks if it starts with \"SELECT\".\n\nNow, in my main function, I can use this function to decide whether to set the callback or not.\n\nHere's an updated version of the main function:\n\nint main(int argc, char *argv[]) {\n\n    std::string db_name = \"default.db\";\n\n    std::string sql_statement;\n\n    for (int i = 1; i < argc; i++) {\n\n        if (std::string(argv[i]) == \"-h\" || std::string(argv[i]) == \"--help\") {\n\n            print_help();\n\n            return 0;\n\n        } else if (std::string(argv[i]) == \"-db\" || std::string(argv[i]) == \"--database\") {\n\n            if (i + 1 < argc) {\n\n                db_name = argv[i + 1];\n\n                i++;\n\n            } else {\n\n                std::cerr << \"Database file name not provided.\" << std::endl;\n\n                print_help();\n\n                return 1;\n\n            }\n\n        } else {\n\n            // Assume it's the SQL statement\n\n            sql_statement = argv[i];\n\n        }\n\n    }\n\n    if (sql_statement.empty()) {\n\n        std::cerr << \"SQL statement not provided.\" << std::endl;\n\n        print_help();\n\n        return 1;\n\n    }\n\n    sqlite3 *db;\n\n    char *zErrMsg = 0;\n\n    int rc;\n\n    rc = sqlite3_open(db_name.c_str(), &db);\n\n    if( rc ) {\n\n        fprintf(stderr, \"Can't open database: %s\\n\", sqlite3_errmsg(db));\n\n        sqlite3_close(db);\n\n        return 1;\n\n    }\n\n    if (is_select_statement(sql_statement)) {\n\n        rc = sqlite3_exec(db, sql_statement.c_str(), print_result, 0, &zErrMsg);\n\n    } else {\n\n        rc = sqlite3_exec(db, sql_statement.c_str(), NULL, 0, &zErrMsg);\n\n    }\n\n    if( rc != SQLITE_OK ) {\n\n        fprintf(stderr, \"SQL error: %s\\n\", zErrMsg);\n\n        sqlite3_free(zErrMsg);\n\n    } else {\n\n        fprintf(stdout, \"Operation completed successfully.\\n\");\n\n    }\n\n    sqlite3_close(db);\n\n    return 0;\n\n}\n\nThis looks good. Now, I need to implement the print_help function to display usage information.\n\nAlso, I need to declare the print_result function before the main function since it's used in sqlite3_exec.\n\nLet me write the print_result function:\n\nstatic int print_result(void *data, int argc, char **argv, char **azColName) {\n\n    for(int i = 0; i < argc; i++) {\n\n        printf(\"%s = %s\\n\", azColName[i], argv[i] ? argv[i] : \"NULL\");\n\n    }\n\n    printf(\"\\n\");\n\n    return 0;\n\n}\n\nAnd the print_help function:\n\nvoid print_help() {\n\n    std::cout << \"Usage: myapp [options] \\\"SQL_statement\\\"\\n\"\n\n                 \"\\n\"\n\n                 \"Options:\\n\"\n\n                 \"  -h, --help     Display this help message.\\n\"\n\n                 \"  -db, --database <filename>  Specify the database file name.\\n\"\n\n                 \"\\n\"\n\n                 \"Example:\\n\"\n\n                 \"  myapp -db mydatabase.db \\\"SELECT * FROM users\\\"\\n\";\n\n}\n\nNow, I need to make sure that the SQL statement is provided as a single argument, hence the quotes.\n\nI should also handle cases where the SQL statement contains quotes inside it. Maybe I need to allow escaping quotes or use different quoting styles.\n\nBut for simplicity, I'll assume that the user will properly quote the SQL statement.\n\nNext, I need to compile this C++ code with SQLite.\n\nI need to make sure that SQLite is installed on my system and that I can link against it.\n\nOn Ubuntu, I can install the SQLite development files using:\n\nsudo apt-get install libsqlite3-dev\n\nThen, I can compile my C++ code with:\n\ng++ -o myapp main.cpp -lsqlite3\n\nThis should link against the SQLite library and create the executable myapp.\n\nLet me try writing a simple test.\n\nFirst, create a database file:\n\nsqlite3 mydatabase.db\n\nThen, create a table:\n\nCREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT, age INTEGER);\n\nInsert some data:\n\nINSERT INTO users VALUES (1, 'John Doe', 30);\n\nINSERT INTO users VALUES (2, 'Jane Smith', 25);\n\nNow, run my application to select data:\n\n./myapp -db mydatabase.db \"SELECT * FROM users\"\n\nExpected output:\n\nid = 1\n\nname = John Doe\n\nage = 30\n\nid = 2\n\nname = Jane Smith\n\nage = 25\n\nSimilarly, I can run insert, update, and delete statements.\n\nThis seems to be working as expected.\n\nHowever, I need to make sure that the application handles errors properly.\n\nFor example, if the database file doesn't exist, it should display an error message.\n\nSimilarly, if the SQL statement is invalid, it should display the SQL error message.\n\nI should also handle cases where the table doesn't exist or where there are constraint violations.\n\nIn the current implementation, I'm printing error messages to stderr using fprintf.\n\nI can improve the error handling by providing more context or suggestions to the user.\n\nAdditionally, I can consider implementing transaction support, so that multiple SQL statements can be executed within a single transaction.\n\nBut for now, this basic implementation should suffice.\n\nIn summary, I've created a C++ application that connects to a SQLite database and executes SQL statements provided as command line arguments.\n\nIt supports CRUD operations by allowing the user to pass SQL statements for creating tables, inserting rows, updating rows, deleting rows, and querying data.\n\nThe application uses the SQLite C API to handle database operations and provides a simple command line interface for interacting with the database.\n\n## Final Solution\nTo create a C++ application that interacts with a SQLite database and performs basic CRUD operations, follow these steps:\n\n### Prerequisites\n1. **SQLite Installation**: Ensure SQLite is installed on your system. You can install it using:\n   ```sh\n   sudo apt-get install libsqlite3-dev\n   ```\n\n2. **Development Environment**: Set up a C++ development environment with a compiler like `g++`.\n\n### Solution Code\n\n```cpp\n#include <iostream>\n#include <string>\n#include <cstdlib>\n#include <cstdio>\n#include <cctype>\n#include <algorithm>\n\nextern \"C\" {\n    #include <sqlite3.h>\n}\n\nstatic int print_result(void *data, int argc, char **argv, char **azColName) {\n    for(int i = 0; i < argc; i++) {\n        printf(\"%s = %s\\n\", azColName[i], argv[i] ? argv[i] : \"NULL\");\n    }\n    printf(\"\\n\");\n    return 0;\n}\n\nvoid print_help() {\n    std::cout << \"Usage: myapp [options] \\\"SQL_statement\\\"\\n\"\n                 \"\\n\"\n                 \"Options:\\n\"\n                 \"  -h, --help     Display this help message.\\n\"\n                 \"  -db, --database <filename>  Specify the database file name.\\n\"\n                 \"\\n\"\n                 \"Example:\\n\"\n                 \"  myapp -db mydatabase.db \\\"SELECT * FROM users\\\"\\n\";\n}\n\nbool is_select_statement(const std::string& sql) {\n    std::string upper_sql = sql;\n    std::transform(upper_sql.begin(), upper_sql.end(), upper_sql.begin(), ::toupper);\n    return upper_sql.find(\"SELECT\") == 0;\n}\n\nint main(int argc, char *argv[]) {\n    std::string db_name = \"default.db\";\n    std::string sql_statement;\n\n    for (int i = 1; i < argc; i++) {\n        if (std::string(argv[i]) == \"-h\" || std::string(argv[i]) == \"--help\") {\n            print_help();\n            return 0;\n        } else if (std::string(argv[i]) == \"-db\" || std::string(argv[i]) == \"--database\") {\n            if (i + 1 < argc) {\n                db_name = argv[i + 1];\n                i++;\n            } else {\n                std::cerr << \"Database file name not provided.\" << std::endl;\n                print_help();\n                return 1;\n            }\n        } else {\n            // Assume it's the SQL statement\n            sql_statement = argv[i];\n        }\n    }\n\n    if (sql_statement.empty()) {\n        std::cerr << \"SQL statement not provided.\" << std::endl;\n        print_help();\n        return 1;\n    }\n\n    sqlite3 *db;\n    char *zErrMsg = 0;\n    int rc;\n\n    rc = sqlite3_open(db_name.c_str(), &db);\n    if( rc ) {\n        fprintf(stderr, \"Can't open database: %s\\n\", sqlite3_errmsg(db));\n        sqlite3_close(db);\n        return 1;\n    }\n\n    if (is_select_statement(sql_statement)) {\n        rc = sqlite3_exec(db, sql_statement.c_str(), print_result, 0, &zErrMsg);\n    } else {\n        rc = sqlite3_exec(db, sql_statement.c_str(), NULL, 0, &zErrMsg);\n    }\n\n    if( rc != SQLITE_OK ) {\n        fprintf(stderr, \"SQL error: %s\\n\", zErrMsg);\n        sqlite3_free(zErrMsg);\n    } else {\n        fprintf(stdout, \"Operation completed successfully.\\n\");\n    }\n\n    sqlite3_close(db);\n    return 0;\n}\n```\n\n### Compilation\nTo compile the application, use the following command:\n```sh\ng++ -o myapp main.cpp -lsqlite3\n```\n\n### Usage\n1. **Run the Application with a SQL Statement**:\n   ```sh\n   ./myapp -db mydatabase.db \"SELECT * FROM users\"\n   ```\n\n2. **Other Operations**:\n   - **Create Table**:\n     ```sh\n     ./myapp -db mydatabase.db \"CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT, age INTEGER)\"\n     ```\n   - **Insert Data**:\n     ```sh\n     ./myapp -db mydatabase.db \"INSERT INTO users VALUES (1, 'John Doe', 30)\"\n     ```\n   - **Update Data**:\n     ```sh\n     ./myapp -db mydatabase.db \"UPDATE users SET age=31 WHERE id=1\"\n     ```\n   - **Delete Data**:\n     ```sh\n     ./myapp -db mydatabase.db \"DELETE FROM users WHERE id=1\"\n     ```\n\nThis application provides a straightforward way to perform CRUD operations on a SQLite database using SQL statements passed as command-line arguments."
    }
]