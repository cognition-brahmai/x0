[
    {
        "role": "user",
        "content": "Write a C++ program that simulates a simple banking system with account creation, deposit, withdrawal, and balance checking functionalities. Use object-oriented programming principles and store account data in a SQLite database.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Alright, I've got this task to create a simple banking system using C++ and SQLite. I need to implement account creation, deposit, withdrawal, and balance checking functionalities. Since I'm supposed to use object-oriented programming principles, I'll design classes for the bank and accounts.\n\nFirst, I need to set up the SQLite database to store account data. Each account should have at least an account number, owner's name, and balance. I should probably create a table for accounts with these fields.\n\nLet me think about the class structure. I can have a class called `Account` that holds the account number, owner's name, and balance. Then, I can have a class called `Bank` that manages multiple accounts, handling operations like creating new accounts, depositing, withdrawing, and checking balances.\n\nI need to make sure that the database operations are properly handled within the classes. I should use SQLite C API to interact with the database from C++. I need to include the SQLite library in my project.\n\nLet me sketch a rough outline of the classes:\n\nClass: Account\n\n- Private members:\n\n- accountNumber (int)\n\n- ownerName (string)\n\n- balance (double)\n\n- Public methods:\n\n- Constructor to initialize account\n\n- Methods to deposit, withdraw, and check balance\n\nClass: Bank\n\n- Private members:\n\n- Database connection\n\n- Public methods:\n\n- Constructor to set up the database\n\n- Method to create a new account\n\n- Method to get an account by account number\n\n- Methods to deposit, withdraw, and check balance by account number\n\nI need to ensure that the database is properly initialized and that tables are created if they don't exist. I should also handle cases where accounts don't exist or invalid operations are attempted, like withdrawing more than the balance.\n\nLet me consider how to handle the account number. Maybe I can auto-increment it in the database to ensure uniqueness.\n\nI should also think about how to map the database rows to Account objects. Perhaps I can retrieve account data from the database and create Account objects on the fly when needed.\n\nLet me consider the flow of the program. It should probably have a simple text-based interface where the user can choose options like create account, deposit, withdraw, check balance, and exit.\n\nI need to handle user inputs carefully to prevent errors and ensure data integrity.\n\nAlso, I should think about how to handle multiple transactions. Maybe I can commit the transactions after each operation to keep the database up to date.\n\nLet me start by setting up the SQLite database. I need to create a table for accounts with columns for account number, owner name, and balance.\n\nThe SQL statement for creating the table would look like:\n\nCREATE TABLE accounts (\n\naccount_number INTEGER PRIMARY KEY AUTOINCREMENT,\n\nowner_name TEXT NOT NULL,\n\nbalance REAL NOT NULL\n\n);\n\nNow, in the Bank class, I need to establish a connection to the SQLite database and create this table if it doesn't exist.\n\nI should write a method in the Bank class to create a new account, which inserts a new row into the accounts table with the owner's name and initial balance.\n\nFor deposit and withdrawal, I need to update the balance in the database accordingly.\n\nFor checking the balance, I need to retrieve the balance from the database based on the account number.\n\nI should also handle cases where the account doesn't exist. Maybe by checking if the account number exists in the database before performing operations.\n\nLet me think about the Account class. Since the account data is stored in the database, maybe the Account class can have methods that interact with the database to get and update the account data.\n\nAlternatively, I can fetch the account data from the database when an Account object is created and keep the data in memory, then update the database when changes are made.\n\nBut to keep it simple, maybe I can have the Bank class handle all database interactions, and the Account class just handles the business logic.\n\nWait, maybe it's better to have the Account class handle its own database interactions, so each account object can manage its own data.\n\nThat way, the Bank class can manage multiple accounts, but each account handles its own database operations.\n\nLet me try that approach.\n\nSo, the Account class would have methods like deposit, withdraw, and check_balance, which would update and retrieve data from the database.\n\nBut then, how to handle the database connection? Should each Account object have its own database connection, or should there be a single connection shared by all Account objects?\n\nTo avoid multiple connections, maybe the Bank class can manage the database connection and pass it to Account objects as needed.\n\nAlternatively, since SQLite allows multiple connections, but for simplicity, maybe the Bank class manages the database connection, and Account objects operate on the database through the Bank class.\n\nWait, perhaps the Bank class should handle all database operations, and Account objects hold temporary data in memory.\n\nBut that might not be efficient if there are many accounts.\n\nI need to find a balance between simplicity and efficiency.\n\nLet me try this:\n\n- The Bank class manages the database connection.\n\n- When an account is needed, the Bank class retrieves the account data from the database and creates an Account object.\n\n- The Account object holds the account data in memory.\n\n- When operations like deposit or withdrawal are performed, the Account object updates its in-memory data and also updates the database.\n\n- When the Account object is destroyed, any changes are already saved to the database.\n\nThis way, the database is kept up to date, and the Account objects don't need to worry about keeping their data in sync with the database.\n\nWait, but if I update the database immediately after each operation, it might be inefficient if there are many operations.\n\nAlternatively, I could use database transactions to group multiple operations together and commit them at once.\n\nBut for simplicity, maybe I can stick with committing each operation individually.\n\nNow, let's think about the implementation.\n\nFirst, I need to include the SQLite C library in my C++ code.\n\nI can include \"sqlite3.h\" and link against the SQLite library.\n\nThen, in the Bank class, I can have a sqlite3* pointer to manage the database connection.\n\nIn the constructor of the Bank class, I can open the database file and create the accounts table if it doesn't exist.\n\nFor the Account class, I can have it hold the account number, owner name, and balance as member variables.\n\nWhen creating an Account object, I can retrieve the data from the database based on the account number.\n\nThen, methods like deposit and withdraw can update the in-memory balance and also update the database.\n\nI need to ensure that the database is updated even if the program crashes, so I should use transactions with immediate commits.\n\nLet me outline the classes again:\n\nClass: Bank\n\n- Private members:\n\n- sqlite3* db\n\n- Public methods:\n\n- Constructor: opens the database and creates the accounts table if needed\n\n- createAccount(ownerName, initialBalance): inserts a new account into the database and returns the account number\n\n- getAccount(accountNumber): retrieves account data from the database and returns an Account object\n\nClass: Account\n\n- Private members:\n\n- int accountNumber\n\n- string ownerName\n\n- double balance\n\n- Public methods:\n\n- Constructor(accountNumber, ownerName, balance)\n\n- deposit(amount): updates balance and database\n\n- withdraw(amount): updates balance and database\n\n- getBalance(): returns balance\n\nIn the Bank class, the getAccount method would query the database for the account data and create an Account object with that data.\n\nThen, the user can perform operations on the Account object, which would update the database accordingly.\n\nI need to make sure that the Account object cannot be created without a valid account number that exists in the database.\n\nAlternatively, maybe the Account class should handle both creating new accounts and managing existing ones.\n\nWait, perhaps I should have the Account class handle its own creation in the database.\n\nSo, the Account class would have a constructor that either loads an existing account from the database or creates a new one if it doesn't exist.\n\nBut to keep it simple, maybe I should have the Bank class handle the creation of new accounts, and the Account class only manages existing accounts.\n\nThis way, the Bank class can ensure that accounts are properly created in the database before Account objects are instantiated.\n\nLet me try that.\n\nSo, in the Bank class, the createAccount method would insert a new row into the accounts table and return the account number.\n\nThen, the getAccount method would retrieve the account data based on the account number and create an Account object.\n\nThe Account class would then have methods to deposit, withdraw, and check balance, which update and retrieve data from the database.\n\nNow, I need to think about how to handle the database connection in the Account class.\n\nSince multiple Account objects might be created, and each might need to access the database, I need to ensure that the database connection is properly managed.\n\nOne way is to pass the sqlite3* pointer from the Bank class to the Account class when creating an Account object.\n\nThis way, all Account objects share the same database connection.\n\nAlternatively, each Account object can have its own database connection, but that might be inefficient.\n\nI think sharing the database connection is better.\n\nSo, the Account class would have a sqlite3* member that is initialized with the connection from the Bank class.\n\nBut then, I need to ensure that the database connection remains open as long as there are Account objects using it.\n\nAlternatively, I can make the Bank class responsible for all database operations, and have the Account class call methods in the Bank class to perform database operations.\n\nThis way, the Account class doesn't need to hold a reference to the database connection.\n\nLet me try that.\n\nSo, the Bank class has methods like deposit(accountNumber, amount), withdraw(accountNumber, amount), and getBalance(accountNumber), which perform the respective operations on the database.\n\nThen, the Account class can call these methods on the Bank object to perform operations.\n\nThis way, the Bank class acts as a mediator between the Account objects and the database.\n\nI need to decide whether to have the Account class hold the bank object as a member, or to pass the bank object to the Account methods as needed.\n\nTo reduce coupling, maybe it's better to pass the bank object to the Account methods when needed.\n\nBut that might not be straightforward.\n\nAlternatively, I can make the Bank class a singleton, so it's accessible from anywhere in the code.\n\nBut singletons can be considered an anti-pattern, so I'd rather avoid that.\n\nPerhaps the best approach is to have the Bank class manage all account operations, including creation, deposit, withdrawal, and balance checking.\n\nThen, the Account class can be a simple data structure that holds account data, but all database interactions are handled by the Bank class.\n\nThis way, the Bank class is responsible for interacting with the database, and the Account class is just a container for account data.\n\nLet me adjust the class outline accordingly:\n\nClass: Account\n\n- Private members:\n\n- int accountNumber\n\n- string ownerName\n\n- double balance\n\n- Public methods:\n\n- Constructor(accountNumber, ownerName, balance)\n\n- getters for accountNumber, ownerName, and balance\n\nClass: Bank\n\n- Private members:\n\n- sqlite3* db\n\n- Public methods:\n\n- Constructor: opens the database and creates the accounts table if needed\n\n- createAccount(ownerName, initialBalance): inserts a new account into the database and returns the account number\n\n- getAccount(accountNumber): retrieves account data from the database and returns an Account object\n\n- deposit(accountNumber, amount): updates the balance in the database\n\n- withdraw(accountNumber, amount): updates the balance in the database\n\n- getBalance(accountNumber): retrieves the balance from the database\n\nThis way, the Bank class handles all interactions with the database, and the Account class is just used to hold account data retrieved from the database.\n\nThis seems cleaner and easier to manage.\n\nNow, I need to implement these classes in C++.\n\nFirst, I need to set up the SQLite database connection in the Bank class.\n\nI can use the sqlite3_open function to open the database file.\n\nIf the database file doesn't exist, it will be created.\n\nThen, I need to create the accounts table if it doesn't already exist.\n\nI can execute a CREATE TABLE statement in the constructor of the Bank class.\n\nFor the Account class, I can keep it simple with just the account number, owner name, and balance as member variables.\n\nI need to make sure that the account number is unique and auto-incremented.\n\nIn SQLite, I can define the account_number column as INTEGER PRIMARY KEY AUTOINCREMENT, which will handle the auto-incrementing.\n\nWhen inserting a new account, I can omit the account_number column, and SQLite will automatically assign a unique number.\n\nThen, to retrieve an account, I can select the row from the accounts table based on the account_number.\n\nNow, I need to handle errors, such as attempting to withdraw more than the balance or trying to access an account that doesn't exist.\n\nI should check if an account exists before performing operations on it.\n\nFor example, in the getAccount method, I can query the database for the account number, and if no row is found, return an error or throw an exception.\n\nSimilarly, in the deposit and withdraw methods, I should check if the account exists before performing the operations.\n\nFor the withdraw method, I need to ensure that the withdrawal amount doesn't exceed the balance.\n\nIf it does, I should either deny the withdrawal or allow overdrafts, depending on the requirements.\n\nFor simplicity, I'll assume no overdrafts are allowed.\n\nNow, let's think about the user interface.\n\nI need a simple text-based interface where the user can choose options like create account, deposit, withdraw, check balance, and exit.\n\nI can use a loop that repeatedly prompts the user for input and performs the corresponding operations.\n\nI need to handle user inputs carefully to prevent errors, such as invalid account numbers or non-numeric amounts.\n\nI should also provide feedback to the user after each operation, such as confirming a successful deposit or indicating insufficient funds for a withdrawal.\n\nLet me sketch a rough outline of the main function:\n\n- Create a Bank object\n\n- Display a menu with options: create account, deposit, withdraw, check balance, exit\n\n- Prompt the user to choose an option\n\n- Based on the option, prompt for necessary inputs and call the corresponding methods in the Bank class\n\n- Display the result to the user\n\n- Repeat until the user chooses to exit\n\nI need to ensure that the program can handle invalid inputs gracefully, such as non-numeric account numbers or amounts.\n\nI should use try-catch blocks to handle exceptions and display error messages to the user.\n\nNow, let's think about implementing the classes.\n\nFirst, the Bank class.\n\nI need to include the SQLite header and link against the SQLite library.\n\nIn the constructor, I need to open the database file and create the accounts table if it doesn't exist.\n\nHere's some pseudocode for the Bank constructor:\n\nBank::Bank() {\n\n// Open the database file\n\nif (sqlite3_open(\"bank.db\", &db) != SQLITE_OK) {\n\nthrow runtime_error(\"Can't open database: \" + string(sqlite3_errmsg(db)));\n\n}\n\n// Create the accounts table if it doesn't exist\n\nconst char* createTableSql = R\"(\n\nCREATE TABLE IF NOT EXISTS accounts (\n\naccount_number INTEGER PRIMARY KEY AUTOINCREMENT,\n\nowner_name TEXT NOT NULL,\n\nbalance REAL NOT NULL\n\n);\n\n)\";\n\nchar* errMsg = nullptr;\n\nif (sqlite3_exec(db, createTableSql, nullptr, nullptr, &errMsg) != SQLITE_OK) {\n\nthrow runtime_error(\"SQL error: \" + string(errMsg));\n\nsqlite3_free(errMsg);\n\n}\n\n}\n\nNext, the createAccount method in the Bank class.\n\nIt should insert a new row into the accounts table with the owner's name and initial balance, and return the assigned account number.\n\nHere's some pseudocode for createAccount:\n\nint Bank::createAccount(const string& ownerName, double initialBalance) {\n\nstring sql = \"INSERT INTO accounts (owner_name, balance) VALUES ('\" + ownerName + \"', \" + to_string(initialBalance) + \");\";\n\nchar* errMsg = nullptr;\n\nint result = sqlite3_exec(db, sql.c_str(), nullptr, nullptr, &errMsg);\n\nif (result != SQLITE_OK) {\n\nthrow runtime_error(\"SQL error: \" + string(errMsg));\n\nsqlite3_free(errMsg);\n\n}\n\n// Get the last inserted row id, which is the account number\n\nsqlite3_int64 accountNumber = sqlite3_last_insert_rowid(db);\n\nreturn static_cast<int>(accountNumber);\n\n}\n\nNext, the getAccount method in the Bank class.\n\nIt should retrieve the account data based on the account number and return an Account object.\n\nHere's some pseudocode for getAccount:\n\nAccount Bank::getAccount(int accountNumber) {\n\nstring sql = \"SELECT owner_name, balance FROM accounts WHERE account_number = \" + to_string(accountNumber) + \";\";\n\nsqlite3_stmt* stmt;\n\nif (sqlite3_prepare_v2(db, sql.c_str(), -1, &stmt, nullptr) != SQLITE_OK) {\n\nthrow runtime_error(\"SQL error: \" + string(sqlite3_errmsg(db)));\n\n}\n\nif (sqlite3_step(stmt) != SQLITE_ROW) {\n\nthrow runtime_error(\"Account not found\");\n\n}\n\nstring ownerName = string(reinterpret_cast<const char*>(sqlite3_column_text(stmt, 0)));\n\ndouble balance = sqlite3_column_double(stmt, 1);\n\nsqlite3_finalize(stmt);\n\nreturn Account(accountNumber, ownerName, balance);\n\n}\n\nSimilarly, the deposit, withdraw, and getBalance methods in the Bank class would execute UPDATE and SELECT statements to modify and retrieve the balance in the database.\n\nFor example, the deposit method:\n\nvoid Bank::deposit(int accountNumber, double amount) {\n\nstring sql = \"UPDATE accounts SET balance = balance + \" + to_string(amount) + \" WHERE account_number = \" + to_string(accountNumber) + \";\";\n\nchar* errMsg = nullptr;\n\nint result = sqlite3_exec(db, sql.c_str(), nullptr, nullptr, &errMsg);\n\nif (result != SQLITE_OK) {\n\nthrow runtime_error(\"SQL error: \" + string(errMsg));\n\nsqlite3_free(errMsg);\n\n}\n\n}\n\nSimilarly for withdraw and getBalance.\n\nNow, the Account class is straightforward:\n\nClass: Account\n\n- Private members:\n\n- int accountNumber\n\n- string ownerName\n\n- double balance\n\n- Public methods:\n\n- Constructor(accountNumber, ownerName, balance)\n\n- getters for accountNumber, ownerName, and balance\n\nIn the main function, I can create a Bank object and present a menu to the user.\n\nHere's a rough sketch of the main function:\n\nint main() {\n\nBank bank;\n\nbool exit = false;\n\nwhile (!exit) {\n\ncout << \"Banking System Menu:\" << endl;\n\ncout << \"1. Create Account\" << endl;\n\ncout << \"2. Deposit\" << endl;\n\ncout << \"3. Withdraw\" << endl;\n\ncout << \"4. Check Balance\" << endl;\n\ncout << \"5. Exit\" << endl;\n\ncout << \"Enter your choice: \";\n\nint choice;\n\ncin >> choice;\n\ntry {\n\nswitch (choice) {\n\ncase 1:\n\ncout << \"Enter owner name: \";\n\nstring ownerName;\n\ncin.ignore();\n\ngetline(cin, ownerName);\n\ncout << \"Enter initial balance: \";\n\ndouble initialBalance;\n\ncin >> initialBalance;\n\nint accountNumber = bank.createAccount(ownerName, initialBalance);\n\ncout << \"Account created successfully. Account number: \" << accountNumber << endl;\n\nbreak;\n\ncase 2:\n\ncout << \"Enter account number: \";\n\nint accountNumber;\n\ncin >> accountNumber;\n\ncout << \"Enter deposit amount: \";\n\ndouble amount;\n\ncin >> amount;\n\nbank.deposit(accountNumber, amount);\n\ncout << \"Deposit successful.\" << endl;\n\nbreak;\n\ncase 3:\n\ncout << \"Enter account number: \";\n\nint accountNumber;\n\ncin >> accountNumber;\n\ncout << \"Enter withdrawal amount: \";\n\ndouble amount;\n\ncin >> amount;\n\nbank.withdraw(accountNumber, amount);\n\ncout << \"Withdrawal successful.\" << endl;\n\nbreak;\n\ncase 4:\n\ncout << \"Enter account number: \";\n\nint accountNumber;\n\ncin >> accountNumber;\n\ndouble balance = bank.getBalance(accountNumber);\n\ncout << \"Balance: \" << balance << endl;\n\nbreak;\n\ncase 5:\n\nexit = true;\n\nbreak;\n\ndefault:\n\ncout << \"Invalid choice. Please try again.\" << endl;\n\n}\n\n}\n\ncatch (const exception& e) {\n\ncout << \"Error: \" << e.what() << endl;\n\n}\n\n}\n\nreturn 0;\n\n}\n\nI need to handle cases where the user enters invalid inputs, such as non-numeric account numbers or amounts.\n\nI can add input validation in the main function to ensure that the inputs are valid before calling the Bank methods.\n\nAlso, in the Bank methods, I should handle cases where the account doesn't exist or if there are insufficient funds for withdrawal.\n\nFor example, in the withdraw method, I can check if the withdrawal amount is greater than the balance and throw an exception if it is.\n\nHere's an updated version of the withdraw method:\n\nvoid Bank::withdraw(int accountNumber, double amount) {\n\n// Check if account exists\n\nif (!accountExists(accountNumber)) {\n\nthrow runtime_error(\"Account not found\");\n\n}\n\n// Check if sufficient balance\n\ndouble balance = getBalance(accountNumber);\n\nif (amount > balance) {\n\nthrow runtime_error(\"Insufficient funds\");\n\n}\n\n// Perform withdrawal\n\nstring sql = \"UPDATE accounts SET balance = balance - \" + to_string(amount) + \" WHERE account_number = \" + to_string(accountNumber) + \";\";\n\nchar* errMsg = nullptr;\n\nint result = sqlite3_exec(db, sql.c_str(), nullptr, nullptr, &errMsg);\n\nif (result != SQLITE_OK) {\n\nthrow runtime_error(\"SQL error: \" + string(errMsg));\n\nsqlite3_free(errMsg);\n\n}\n\n}\n\nSimilarly, I can add a helper method accountExists to check if an account exists:\n\nbool Bank::accountExists(int accountNumber) {\n\nstring sql = \"SELECT 1 FROM accounts WHERE account_number = \" + to_string(accountNumber) + \";\";\n\nsqlite3_stmt* stmt;\n\nif (sqlite3_prepare_v2(db, sql.c_str(), -1, &stmt, nullptr) != SQLITE_OK) {\n\nthrow runtime_error(\"SQL error: \" + string(sqlite3_errmsg(db)));\n\n}\n\nint row = sqlite3_step(stmt);\n\nsqlite3_finalize(stmt);\n\nreturn row == SQLITE_ROW;\n\n}\n\nThis way, I can ensure that operations are only performed on existing accounts and that there are sufficient funds for withdrawals.\n\nI should also consider formatting the balance output to show currency properly, but for simplicity, I'll leave it as a double.\n\nNow, I need to make sure to close the database connection when the Bank object is destroyed.\n\nI can add a destructor to the Bank class that calls sqlite3_close.\n\nHere's the destructor:\n\nBank::~Bank() {\n\nsqlite3_close(db);\n\n}\n\nThis ensures that the database connection is properly closed when the program exits.\n\nI should also handle any other potential errors, such as failing to open the database or execute SQL statements.\n\nIn such cases, I should throw exceptions with meaningful error messages, as I've done in the constructor and other methods.\n\nIn the main function, I catch these exceptions and display the error messages to the user.\n\nI need to make sure to include the necessary headers and link against the SQLite library.\n\nHere's a list of headers I'll need to include:\n\n- iostream for input/output\n\n- string for string operations\n\n- sqlite3.h for SQLite functions\n\n- cstdlib for standard library functions\n\n- cstdio for standard input/output functions\n\n- exception for exception handling\n\nI should also link against the SQLite library when compiling the program.\n\nFor example, using g++, I can compile the program with:\n\ng++ -o banking_system banking_system.cpp -lsqlite3\n\nNow, let's think about testing the program.\n\nI need to test various scenarios, such as:\n\n- Creating a new account and checking its balance\n\n- Depositing money into an account and checking the updated balance\n\n- Withdrawing money from an account and checking the updated balance\n\n- Attempting to withdraw more than the balance and receiving an error\n\n- Accessing a non-existent account and receiving an error\n\n- Entering invalid inputs, such as non-numeric account numbers or amounts\n\nI should make sure that the program handles all these cases correctly and provides appropriate feedback to the user.\n\nI should also ensure that the database is updated correctly after each operation.\n\nTo verify database operations, I can check the database file directly using an SQLite browser or by executing SQL queries manually.\n\nAdditionally, I can add logging or debug statements to trace the program's execution and database interactions.\n\nNow, let's proceed to implement the actual code based on this design.\n\n## Final Solution\nTo create a simple banking system using C++ and SQLite, we'll use object-oriented programming principles and interact with a SQLite database to manage account data. This solution includes account creation, deposit, withdrawal, and balance checking functionalities.\n\n### Approach\n\n1. **Classes and Responsibilities:**\n   - **Bank Class:** Manages the SQLite database connection and handles operations like creating accounts, depositing, withdrawing, and checking balances.\n   - **Account Class:** Represents an individual bank account with properties like account number, owner's name, and balance.\n\n2. **Database Setup:**\n   - Use SQLite to store account data in a table named `accounts` with columns for account number, owner's name, and balance.\n\n3. **User Interface:**\n   - A simple text-based menu for users to interact with the banking system.\n\n### Solution Code\n\n```cpp\n#include <iostream>\n#include <string>\n#include <sqlite3.h>\n#include <stdexcept>\n\nclass Account {\nprivate:\n    int accountNumber;\n    std::string ownerName;\n    double balance;\npublic:\n    Account(int accountNumber, const std::string& ownerName, double balance)\n        : accountNumber(accountNumber), ownerName(ownerName), balance(balance) {}\n\n    int getAccountNumber() const { return accountNumber; }\n    std::string getOwnerName() const { return ownerName; }\n    double getBalance() const { return balance; }\n};\n\nclass Bank {\nprivate:\n    sqlite3* db;\n\n    bool accountExists(int accountNumber) {\n        std::string sql = \"SELECT 1 FROM accounts WHERE account_number = \" + std::to_string(accountNumber) + \";\";\n        sqlite3_stmt* stmt;\n        if (sqlite3_prepare_v2(db, sql.c_str(), -1, &stmt, nullptr) != SQLITE_OK) {\n            throw std::runtime_error(\"SQL error: \" + std::string(sqlite3_errmsg(db)));\n        }\n        int row = sqlite3_step(stmt);\n        sqlite3_finalize(stmt);\n        return row == SQLITE_ROW;\n    }\n\npublic:\n    Bank() {\n        if (sqlite3_open(\"bank.db\", &db) != SQLITE_OK) {\n            throw std::runtime_error(\"Can't open database: \" + std::string(sqlite3_errmsg(db)));\n        }\n        const char* createTableSql = R\"(\n            CREATE TABLE IF NOT EXISTS accounts (\n                account_number INTEGER PRIMARY KEY AUTOINCREMENT,\n                owner_name TEXT NOT NULL,\n                balance REAL NOT NULL\n            );\n        )\";\n        char* errMsg = nullptr;\n        if (sqlite3_exec(db, createTableSql, nullptr, nullptr, &errMsg) != SQLITE_OK) {\n            throw std::runtime_error(\"SQL error: \" + std::string(errMsg));\n            sqlite3_free(errMsg);\n        }\n    }\n\n    ~Bank() {\n        sqlite3_close(db);\n    }\n\n    int createAccount(const std::string& ownerName, double initialBalance) {\n        std::string sql = \"INSERT INTO accounts (owner_name, balance) VALUES ('\" + ownerName + \"', \" + std::to_string(initialBalance) + \");\";\n        char* errMsg = nullptr;\n        int result = sqlite3_exec(db, sql.c_str(), nullptr, nullptr, &errMsg);\n        if (result != SQLITE_OK) {\n            throw std::runtime_error(\"SQL error: \" + std::string(errMsg));\n            sqlite3_free(errMsg);\n        }\n        return static_cast<int>(sqlite3_last_insert_rowid(db));\n    }\n\n    Account getAccount(int accountNumber) {\n        if (!accountExists(accountNumber)) {\n            throw std::runtime_error(\"Account not found\");\n        }\n        std::string sql = \"SELECT owner_name, balance FROM accounts WHERE account_number = \" + std::to_string(accountNumber) + \";\";\n        sqlite3_stmt* stmt;\n        if (sqlite3_prepare_v2(db, sql.c_str(), -1, &stmt, nullptr) != SQLITE_OK) {\n            throw std::runtime_error(\"SQL error: \" + std::string(sqlite3_errmsg(db)));\n        }\n        if (sqlite3_step(stmt) != SQLITE_ROW) {\n            throw std::runtime_error(\"Account not found\");\n        }\n        std::string ownerName = std::string(reinterpret_cast<const char*>(sqlite3_column_text(stmt, 0)));\n        double balance = sqlite3_column_double(stmt, 1);\n        sqlite3_finalize(stmt);\n        return Account(accountNumber, ownerName, balance);\n    }\n\n    void deposit(int accountNumber, double amount) {\n        if (!accountExists(accountNumber)) {\n            throw std::runtime_error(\"Account not found\");\n        }\n        std::string sql = \"UPDATE accounts SET balance = balance + \" + std::to_string(amount) + \" WHERE account_number = \" + std::to_string(accountNumber) + \";\";\n        char* errMsg = nullptr;\n        int result = sqlite3_exec(db, sql.c_str(), nullptr, nullptr, &errMsg);\n        if (result != SQLITE_OK) {\n            throw std::runtime_error(\"SQL error: \" + std::string(errMsg));\n            sqlite3_free(errMsg);\n        }\n    }\n\n    void withdraw(int accountNumber, double amount) {\n        if (!accountExists(accountNumber)) {\n            throw std::runtime_error(\"Account not found\");\n        }\n        double balance = getAccount(accountNumber).getBalance();\n        if (amount > balance) {\n            throw std::runtime_error(\"Insufficient funds\");\n        }\n        std::string sql = \"UPDATE accounts SET balance = balance - \" + std::to_string(amount) + \" WHERE account_number = \" + std::to_string(accountNumber) + \";\";\n        char* errMsg = nullptr;\n        int result = sqlite3_exec(db, sql.c_str(), nullptr, nullptr, &errMsg);\n        if (result != SQLITE_OK) {\n            throw std::runtime_error(\"SQL error: \" + std::string(errMsg));\n            sqlite3_free(errMsg);\n        }\n    }\n\n    double getBalance(int accountNumber) {\n        if (!accountExists(accountNumber)) {\n            throw std::runtime_error(\"Account not found\");\n        }\n        std::string sql = \"SELECT balance FROM accounts WHERE account_number = \" + std::to_string(accountNumber) + \";\";\n        sqlite3_stmt* stmt;\n        if (sqlite3_prepare_v2(db, sql.c_str(), -1, &stmt, nullptr) != SQLITE_OK) {\n            throw std::runtime_error(\"SQL error: \" + std::string(sqlite3_errmsg(db)));\n        }\n        if (sqlite3_step(stmt) != SQLITE_ROW) {\n            throw std::runtime_error(\"Account not found\");\n        }\n        double balance = sqlite3_column_double(stmt, 0);\n        sqlite3_finalize(stmt);\n        return balance;\n    }\n};\n\nint main() {\n    Bank bank;\n    bool exit = false;\n    while (!exit) {\n        std::cout << \"Banking System Menu:\" << std::endl;\n        std::cout << \"1. Create Account\" << std::endl;\n        std::cout << \"2. Deposit\" << std::endl;\n        std::cout << \"3. Withdraw\" << std::endl;\n        std::cout << \"4. Check Balance\" << std::endl;\n        std::cout << \"5. Exit\" << std::endl;\n        std::cout << \"Enter your choice: \";\n        int choice;\n        std::cin >> choice;\n        try {\n            switch (choice) {\n                case 1:\n                    std::cout << \"Enter owner name: \";\n                    std::string ownerName;\n                    std::cin.ignore();\n                    std::getline(std::cin, ownerName);\n                    std::cout << \"Enter initial balance: \";\n                    double initialBalance;\n                    std::cin >> initialBalance;\n                    int accountNumber = bank.createAccount(ownerName, initialBalance);\n                    std::cout << \"Account created successfully. Account number: \" << accountNumber << std::endl;\n                    break;\n                case 2:\n                    std::cout << \"Enter account number: \";\n                    int accountNumber;\n                    std::cin >> accountNumber;\n                    std::cout << \"Enter deposit amount: \";\n                    double amount;\n                    std::cin >> amount;\n                    bank.deposit(accountNumber, amount);\n                    std::cout << \"Deposit successful.\" << std::endl;\n                    break;\n                case 3:\n                    std::cout << \"Enter account number: \";\n                    int accountNumber;\n                    std::cin >> accountNumber;\n                    std::cout << \"Enter withdrawal amount: \";\n                    double amount;\n                    std::cin >> amount;\n                    bank.withdraw(accountNumber, amount);\n                    std::cout << \"Withdrawal successful.\" << std::endl;\n                    break;\n                case 4:\n                    std::cout << \"Enter account number: \";\n                    int accountNumber;\n                    std::cin >> accountNumber;\n                    double balance = bank.getBalance(accountNumber);\n                    std::cout << \"Balance: \" << balance << std::endl;\n                    break;\n                case 5:\n                    exit = true;\n                    break;\n                default:\n                    std::cout << \"Invalid choice. Please try again.\" << std::endl;\n            }\n        } catch (const std::exception& e) {\n            std::cout << \"Error: \" << e.what() << std::endl;\n        }\n    }\n    return 0;\n}\n```\n\n### Explanation\n\n1. **Account Class:**\n   - Simple data structure to hold account details.\n\n2. **Bank Class:**\n   - Manages the SQLite database connection.\n   - Provides methods to create accounts, deposit, withdraw, and check balances.\n   - Ensures that database operations are handled correctly and exceptions are thrown for errors.\n\n3. **Main Function:**\n   - Presents a menu-driven interface to interact with the banking system.\n   - Handles user inputs and calls appropriate Bank methods.\n   - Catches and displays exceptions to ensure the program handles errors gracefully."
    }
]