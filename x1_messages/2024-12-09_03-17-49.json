[
    {
        "role": "user",
        "content": "Create a Node.js script that takes in a JSON file of key-value pairs as input, sorts the keys alphabetically, and writes the sorted data to a new JSON file. The script should support command line arguments for specifying the input and output file paths.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Alright, I've got this task to create a Node.js script that sorts the keys of a JSON object alphabetically and saves it to a new file. I need to make sure that it accepts command line arguments for the input and output file paths. Let's break this down step by step.\n\nFirst, I need to set up a basic Node.js script. I should start by creating a new JavaScript file, maybe call it `sort-json-keys.js`. Since I'm dealing with command line arguments, I'll need to use the `process.argv` array to get the input and output file paths.\n\nI know that `process.argv` contains the command line arguments, where the first element is the Node.js executable path, the second is the path to the JavaScript file, and the rest are the arguments passed to the script. So, the input file path would be `process.argv[2]` and the output file path would be `process.argv[3]`.\n\nNext, I need to read the input JSON file. For that, I can use the `fs` module, which is built into Node.js, specifically the `fs.readFileSync` method to read the file synchronously. I should handle any errors that might occur if the file doesn't exist or can't be read.\n\nOnce I have the JSON data as a string, I need to parse it into a JavaScript object. I can use `JSON.parse` for that. After parsing, I'll have an object with keys and values.\n\nNow, the task is to sort the keys alphabetically. To do that, I can get all the keys from the object using `Object.keys()`, sort them using the `sort()` method, and then create a new object with these sorted keys.\n\nWait, but in JavaScript, objects don't maintain order until ECMAScript 2015, and even then, it's not guaranteed in all cases. However, in modern JavaScript, objects do preserve the order of keys, especially when using methods like `Object.assign()` or destructuring. But to be safe, I'll create a new object by iterating over the sorted keys and adding them one by one.\n\nOnce I have the new object with sorted keys, I need to convert it back to a JSON string. I can use `JSON.stringify`, and maybe pretty-print it with spaces for better readability.\n\nFinally, I need to write this JSON string to a new file specified by the output file path. Again, I'll use the `fs` module, specifically `fs.writeFileSync` to write the file synchronously.\n\nI should also handle any errors that might occur during writing the file, like permission issues or invalid paths.\n\nLet me think about edge cases. What if the input file doesn't exist? I should check for that and maybe display an error message. What if the input JSON is invalid? I need to handle parsing errors.\n\nAlso, what if the output file already exists? Should I overwrite it or ask for confirmation? To keep it simple, I'll overwrite it without asking, but I'll make sure to handle any write errors.\n\nAnother thing is that the script should be usable from the command line, so I should provide some usage instructions if the arguments are missing or invalid.\n\nMaybe I can add some validation for the arguments, like checking if two arguments are provided, and that the input file exists and is a JSON file.\n\nWait, but checking if it's a JSON file just by extension might not be reliable. Maybe I should try parsing the content and see if it's valid JSON.\n\nAlright, let's outline the steps again:\n\n1. Check if the correct number of arguments are provided.\n\n2. Read the input file.\n\n3. Parse the JSON data.\n\n4. Sort the keys alphabetically.\n\n5. Create a new sorted JSON object.\n\n6. Convert the sorted object back to a JSON string, pretty-printed.\n\n7. Write the JSON string to the output file.\n\nI should also think about error handling at each step.\n\nLet me start writing some pseudocode to visualize this.\n\nPseudocode:\n\nif number of arguments is less than 4 (node script.js input.json output.json)\n\ndisplay usage: \"Usage: node sort-json-keys.js input.json output.json\"\n\nexit\n\nendif\n\ntry\n\nread input file content\n\nparse JSON from content\n\nsort keys\n\ncreate sorted object\n\nconvert to pretty JSON string\n\nwrite to output file\n\ncatch read error\n\ndisplay error message\n\nexit\n\ncatch parse error\n\ndisplay error message\n\nexit\n\ncatch write error\n\ndisplay error message\n\nexit\n\nendtry\n\ndisplay \"Sorting completed successfully.\"\n\nAlright, that seems like a plan. Now, let's translate this into actual JavaScript code.\n\nFirst, I'll handle the arguments:\n\nif (process.argv.length < 4) {\n\nconsole.log(\"Usage: node sort-json-keys.js input.json output.json\");\n\nprocess.exit(1);\n\n}\n\nThen, I'll read the input file:\n\nconst fs = require('fs');\n\nlet inputContent;\n\ntry {\n\ninputContent = fs.readFileSync(process.argv[2], 'utf8');\n\n} catch (err) {\n\nconsole.error(\"Error reading input file:\", err.message);\n\nprocess.exit(1);\n\n}\n\nNext, parse the JSON:\n\nlet jsonData;\n\ntry {\n\njsonData = JSON.parse(inputContent);\n\n} catch (err) {\n\nconsole.error(\"Error parsing JSON from input file:\", err.message);\n\nprocess.exit(1);\n\n}\n\nNow, sort the keys:\n\nconst sortedKeys = Object.keys(jsonData).sort();\n\nCreate a new object with sorted keys:\n\nconst sortedJson = {};\n\nfor (const key of sortedKeys) {\n\nsortedJson[key] = jsonData[key];\n\n}\n\nConvert to pretty JSON string:\n\nconst outputJson = JSON.stringify(sortedJson, null, 2) + '\\n';\n\nWrite to output file:\n\ntry {\n\nfs.writeFileSync(process.argv[3], outputJson, 'utf8');\n\n} catch (err) {\n\nconsole.error(\"Error writing to output file:\", err.message);\n\nprocess.exit(1);\n\n}\n\nFinally, print a success message:\n\nconsole.log(\"JSON keys sorted and saved to\", process.argv[3]);\n\nThat seems straightforward. But I should consider if the input JSON has nested objects. Would this script handle that correctly?\n\nWait, my current approach only sorts the top-level keys. If there are nested objects, their keys are not sorted. Should I handle nested objects as well?\n\nThe task says to sort the keys alphabetically, but it doesn't specify about nested objects. To keep it simple, I'll stick to sorting only the top-level keys. But if I have time, I can think about how to recursively sort all keys in nested objects.\n\nFor now, I'll proceed with sorting only the top-level keys.\n\nLet me think about how to run this script. I need to make sure that Node.js is installed on the system, and then I can run it from the command line like this:\n\nnode sort-json-keys.js input.json output.json\n\nI should also consider adding some validation to ensure that the input file exists before trying to read it. Although `fs.readFileSync` will throw an error if the file doesn't exist, it's good to have explicit checks.\n\nWait, but `fs.readFileSync` does throw an error if the file doesn't exist, so catching that should be sufficient.\n\nAnother thing is to handle cases where the input file is empty or doesn't contain valid JSON. I've already got a try-catch for parsing, so that should cover invalid JSON.\n\nIf the file is empty, `JSON.parse` will throw an error, which is fine.\n\nI should also think about what happens if the output file already exists. Will `fs.writeFileSync` overwrite it without warning? Yes, it will. I think for this script, overwriting is acceptable, but I should mention it in any documentation or comments.\n\nLet me think about adding some comments to the script for clarity.\n\nAlso, I should consider making the script executable so that it can be run directly from the command line without specifying Node.js explicitly.\n\nTo do that, I can add a shebang line at the top:\n\n#!/usr/bin/env node\n\nAnd then make the file executable using `chmod +x sort-json-keys.js`.\n\nBut since the task is to create a Node.js script, it's likely that it will be run with `node`, so maybe it's not necessary.\n\nAnyway, I'll proceed with the script as is.\n\nLet me write a sample input JSON to test the script.\n\nSample input JSON (input.json):\n\n{\n\n\"banana\": \"yellow\",\n\n\"apple\": \"red\",\n\n\"cherry\": \"red\"\n\n}\n\nAfter running the script, the output JSON should be:\n\n{\n\n\"apple\": \"red\",\n\n\"banana\": \"yellow\",\n\n\"cherry\": \"red\"\n\n}\n\nSaved to the specified output file.\n\nI should also test with a JSON that has nested objects to see if the script handles them correctly.\n\nTest input with nested object:\n\n{\n\n\"banana\": \"yellow\",\n\n\"apple\": {\n\n\"color\": \"red\",\n\n\"taste\": \"sweet\"\n\n},\n\n\"cherry\": \"red\"\n\n}\n\nExpected output with top-level keys sorted:\n\n{\n\n\"apple\": {\n\n\"color\": \"red\",\n\n\"taste\": \"sweet\"\n\n},\n\n\"banana\": \"yellow\",\n\n\"cherry\": \"red\"\n\n}\n\nAs you can see, the nested object within \"apple\" remains unchanged.\n\nIf I want to sort keys in nested objects as well, I would need to write a recursive function to sort all levels of keys.\n\nBut for now, I'll keep it simple and only sort top-level keys.\n\nIf I have time, I can think about implementing recursive key sorting.\n\nBut let's first get the basic version working.\n\nLet me write the script accordingly.\n\n## Final Solution\nTo create a Node.js script that sorts the keys of a JSON object alphabetically and saves it to a new file, you can follow these steps:\n\n1. **Create a JavaScript file**: Name it `sort-json-keys.js`.\n\n2. **Use command line arguments**: Retrieve input and output file paths from `process.argv`.\n\n3. **Read the input JSON file**: Use `fs.readFileSync` to read the file.\n\n4. **Parse the JSON data**: Use `JSON.parse` to convert the string to a JavaScript object.\n\n5. **Sort the keys**: Use `Object.keys().sort()` to get sorted keys.\n\n6. **Create a new object with sorted keys**: Iterate over the sorted keys and build a new object.\n\n7. **Convert to a JSON string**: Use `JSON.stringify` with spaces for readability.\n\n8. **Write the output JSON file**: Use `fs.writeFileSync` to write the sorted JSON to a new file.\n\n### Solution Code\n\n```javascript\n#!/usr/bin/env node\n\nconst fs = require('fs');\n\n// Check for correct number of arguments\nif (process.argv.length < 4) {\n  console.log(\"Usage: node sort-json-keys.js input.json output.json\");\n  process.exit(1);\n}\n\n// Paths for input and output files\nconst inputPath = process.argv[2];\nconst outputPath = process.argv[3];\n\ntry {\n  // Read the input file\n  const inputContent = fs.readFileSync(inputPath, 'utf8');\n\n  // Parse the JSON data\n  const jsonData = JSON.parse(inputContent);\n\n  // Sort the keys alphabetically\n  const sortedKeys = Object.keys(jsonData).sort();\n\n  // Create a new object with sorted keys\n  const sortedJson = {};\n  for (const key of sortedKeys) {\n    sortedJson[key] = jsonData[key];\n  }\n\n  // Convert to a JSON string with indentation\n  const outputJson = JSON.stringify(sortedJson, null, 2) + '\\n';\n\n  // Write to the output file\n  fs.writeFileSync(outputPath, outputJson, 'utf8');\n\n  console.log(\"JSON keys sorted and saved to\", outputPath);\n} catch (err) {\n  if (err.code === 'ENOENT') {\n    console.error(\"Input file does not exist:\", inputPath);\n  } else if (err instanceof SyntaxError) {\n    console.error(\"Error parsing JSON from input file:\", err.message);\n  } else {\n    console.error(\"Error writing to output file:\", err.message);\n  }\n  process.exit(1);\n}\n```\n\n### Explanation\n\n1. **Argument Check**: Ensure the script is called with exactly two arguments: input and output file paths.\n2. **File Reading**: Read the content of the input JSON file.\n3. **JSON Parsing**: Parse the JSON content into a JavaScript object.\n4. **Key Sorting**: Extract and sort the keys of the object.\n5. **New Object Creation**: Create a new object using the sorted keys.\n6. **Stringify JSON**: Convert the sorted object back to a JSON string with indentation for better readability.\n7. **Write to File**: Write the sorted JSON string to the specified output file.\n8. **Error Handling**: Handle errors for file operations and JSON parsing.\n\nThis script will sort only the top-level keys of the JSON object. If you need to sort keys in nested objects as well, you would need to implement a recursive sorting function."
    }
]