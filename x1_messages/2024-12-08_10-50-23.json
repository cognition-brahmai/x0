[
    {
        "role": "user",
        "content": "Design a Java program that implements a simple chat server and client using sockets. The server should support multiple clients, broadcast messages from one client to all others, and allow clients to choose their username upon joining.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Alright, I'm going to design a simple chat server and client using Java sockets. The requirements are:\n\n1. The server should support multiple clients.\n\n2. It should broadcast messages from one client to all others.\n\n3. Clients should be able to choose their username upon joining.\n\nGiven these requirements, I need to think about how to handle multiple clients simultaneously. In Java, the `ServerSocket` class is used for handling multiple client connections, and each client connection can be handled in a separate thread to ensure that the server can handle multiple clients concurrently.\n\nFirst, I'll start by designing the server.\n\n**Server Design:**\n\n- The server will listen on a specific port for incoming client connections.\n\n- For each client that connects, the server will create a new thread to handle that client's messages.\n\n- The server needs to maintain a list of all connected clients so that it can broadcast messages to them.\n\n- When a client sends a message, the server will broadcast that message to all other clients.\n\n- Clients should choose their username upon joining, so the server needs to handle username assignments and ensure that usernames are unique.\n\n**Client Design:**\n\n- The client will connect to the server via a specified IP address and port.\n\n- Upon connecting, the client will choose a username.\n\n- The client will have the ability to send messages to the server, which will then broadcast them to other clients.\n\n- The client should also be able to receive messages from the server.\n\nGiven that, I need to think about the communication protocol between the client and the server. Since this is a text-based chat application, plain text messages should suffice. I need to define how messages are formatted so that the server can interpret them correctly.\n\n**Communication Protocol:**\n\n- When a client connects, it sends its chosen username to the server.\n\n- The server responds with an acknowledgment if the username is accepted or rejects it if it's already in use.\n\n- Once a username is accepted, the client can send messages prefixed with their username.\n\n- The server will broadcast these messages to all other clients.\n\nTo implement this, I need to use Java's `Socket` class for client-server communication and `ServerSocket` for the server to listen for incoming connections.\n\nLet me outline the steps for the server:\n\n1. Create a `ServerSocket` on a specified port.\n\n2. Wait for client connections using `accept()`.\n\n3. For each connection, create a new thread to handle that client.\n\n4. In the client handler thread:\n\na. Read the username from the client.\n\nb. Check if the username is unique; if not, ask the client to choose another one.\n\nc. Once a unique username is chosen, add the client to the list of connected clients.\n\nd. Listen for messages from the client and broadcast them to other clients.\n\n5. Handle client disconnections and remove them from the list.\n\nFor the client:\n\n1. Connect to the server via specified IP and port.\n\n2. Prompt the user to choose a username and send it to the server.\n\n3. If the username is accepted, proceed to send messages.\n\n4. Listen for messages from the server and display them.\n\nI need to ensure that the server can handle multiple clients concurrently, so each client will be handled in its own thread. Also, since multiple threads will be accessing the list of connected clients, I need to synchronize access to this list to prevent concurrency issues.\n\nLet me think about how to implement the broadcasting of messages. I need to iterate through the list of connected clients and send the message to each one except the sender.\n\nI should also consider edge cases, such as a client disconnecting abruptly or sending invalid messages.\n\nAdditionally, to make the chat more user-friendly, I can include some basic commands, like listing connected users or privately messaging another user. But for simplicity, I'll focus on the core requirements first.\n\nNow, let's think about the implementation in code.\n\n**Server Implementation:**\n\n- Create a `ServerSocket` on a specified port.\n\n- Use a `List` to keep track of connected clients. Each client can be represented by an object that holds their username and output stream for sending messages.\n\n- Create a separate class for the client handler thread, say `ClientHandler`, which will handle communication with a single client.\n\n- In the `ClientHandler` class:\n\n- Read the username from the client.\n\n- Check if the username is unique; if not, ask the client to choose another one.\n\n- Once a unique username is chosen, add the client to the list of connected clients.\n\n- Listen for messages from the client and broadcast them to other clients.\n\n- Handle client disconnections and remove them from the list.\n\n**Client Implementation:**\n\n- Create a `Socket` connection to the server.\n\n- Prompt the user to choose a username and send it to the server.\n\n- If the username is accepted, proceed to send messages.\n\n- Listen for messages from the server and display them.\n\nI need to handle I/O streams properly to read and write messages. For simplicity, I'll use `BufferedReader` and `PrintWriter` for reading and writing strings.\n\nLet me sketch some pseudocode for the server:\n\n```\n\nserverSocket = new ServerSocket(port)\n\nwhile (true) {\n\n socket = serverSocket.accept()\n\n clientHandler = new ClientHandler(socket)\n\n clientHandler.start()\n\n}\n\nclass ClientHandler extends Thread {\n\n Socket socket\n\n String username\n\n OutputStream outputStream\n\n // ...\n\n public void run() {\n\n  try {\n\n   BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()))\n\n   PrintWriter out = new PrintWriter(socket.getOutputStream(), true)\n\n   while (true) {\n\n    // read username if not set\n\n    if (username == null) {\n\n     username = in.readLine()\n\n     if (usernameExists(username)) {\n\n      out.println(\"Username already exists. Choose another one.\")\n\n      continue\n\n     } else {\n\n      // add to list of clients\n\n      addClient(this)\n\n      out.println(\"Username accepted.\")\n\n     }\n\n    } else {\n\n     // read message and broadcast\n\n     String message = in.readLine()\n\n     broadcast(message, this)\n\n    }\n\n   }\n\n  } catch (IOException e) {\n\n   // handle exception and remove client\n\n  } finally {\n\n   // clean up resources and remove client\n\n  }\n\n }\n\n}\n\n```\n\nAnd for the client:\n\n```\n\nsocket = new Socket(host, port)\n\nBufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()))\n\nPrintWriter out = new PrintWriter(socket.getOutputStream(), true)\n\n// prompt user for username\n\nString username = getUserInput(\"Choose a username: \")\n\nout.println(username)\n\nString response = in.readLine()\n\nif (response.equals(\"Username accepted.\")) {\n\n // start listening for messages in a separate thread\n\n messageListener = new Thread(() -> {\n\n  BufferedReader messageIn = new BufferedReader(new InputStreamReader(socket.getInputStream()))\n\n  while (true) {\n\n   String message = messageIn.readLine()\n\n   if (message != null) {\n\n    System.out.println(message)\n\n   }\n\n  }\n\n })\n\n messageListener.start()\n\n // main thread for sending messages\n\n while (true) {\n\n  String message = getUserInput(\"\")\n\n  out.println(message)\n\n }\n\n} else {\n\n System.out.println(response)\n\n}\n\n```\n\nThis is a high-level overview. Now, I need to think about implementing this in actual Java code, considering exception handling, thread management, and synchronization.\n\nI should also consider how to handle client disconnections. When a client disconnects, its thread should be terminated, and it should be removed from the list of connected clients. I can do this by catching `IOException` in the client handler thread and performing the necessary cleanup.\n\nAdditionally, I need to ensure that the list of connected clients is thread-safe. I can use a `CopyOnWriteArrayList` for this purpose, as it is designed for concurrent access.\n\nLet me think about the data structure for storing connected clients. Each client has a username and an `OutputStream` for sending messages. I can create a simple class to hold this information.\n\n```\n\nclass Client {\n\n String username\n\n PrintWriter out\n\n // constructor, getters, etc.\n\n}\n\n```\n\nThen, the server can maintain a list of `Client` objects.\n\nI also need to think about how to broadcast messages. I'll need to iterate through the list of clients and send the message to each one except the sender.\n\nGiven that, I need to pass the sender's `Client` object to the broadcast method so that it can be excluded from message reception.\n\nI should also consider how to format the messages. Probably, each message should include the sender's username and the message content, like \"`username: message`\".\n\nFurthermore, I need to handle cases where a client sends multiple messages rapidly or sends invalid data. I should make sure that the server can handle such scenarios without crashing.\n\nLet me also consider implementing a way for clients to see who is currently connected. I can add a command, say `/users`, that lists all connected usernames.\n\nBut for now, I'll focus on the core requirements.\n\nAnother consideration is choosing the port number. I need to decide on a port for the server to listen on and ensure that it's not being used by another application.\n\nI can either hardcode the port number or make it configurable via command-line arguments.\n\nSimilarly, for the client, I need to specify the server's IP address and port number. I can hardcode them or make them configurable.\n\nFor simplicity, I'll hardcode them for now.\n\nLet me start by writing the server code.\n\n**Server Code:**\n\nFirst, I'll create a `Server` class that sets up the `ServerSocket` and handles multiple clients.\n\nI'll also create a `ClientHandler` class that extends `Thread` to handle each client.\n\nI need to maintain a list of connected clients, so I'll use a `CopyOnWriteArrayList`.\n\nI'll also need to synchronize access to the list when adding or removing clients.\n\nWait, `CopyOnWriteArrayList` is thread-safe for concurrent read operations, but it still requires synchronization for add/remove operations if iterators are used.\n\nTo be safe, I'll synchronize access when modifying the list.\n\nLet me define the `Client` class.\n\n```\n\nclass Client {\n\n String username;\n\n PrintWriter out;\n\n public Client(String username, PrintWriter out) {\n\n this.username = username;\n\n this.out = out;\n\n }\n\n public String getUsername() {\n\n return username;\n\n }\n\n public PrintWriter getOut() {\n\n return out;\n\n }\n\n}\n\n```\n\nNow, the `Server` class.\n\n```\n\nimport java.io.*;\n\nimport java.net.*;\n\nimport java.util.*;\n\n\n\npublic class ChatServer {\n\n private int port;\n\n private ServerSocket serverSocket;\n\n private List<Client> clients = new CopyOnWriteArrayList<>();\n\n\n\n public ChatServer(int port) {\n\n this.port = port;\n\n }\n\n\n\n public void start() throws IOException {\n\n serverSocket = new ServerSocket(port);\n\n System.out.println(\"Server started on port \" + port);\n\n\n\n while (true) {\n\n Socket socket = serverSocket.accept();\n\n System.out.println(\"New client connected\");\n\n\n\n ClientHandler handler = new ClientHandler(socket, this);\n\n handler.start();\n\n }\n\n }\n\n\n\n public void addClient(Client client) {\n\n clients.add(client);\n\n }\n\n\n\n public void removeClient(Client client) {\n\n clients.remove(client);\n\n }\n\n\n\n public void broadcast(String message, Client sender) {\n\n for (Client client : clients) {\n\n if (client != sender) {\n\n client.getOut().println(message);\n\n }\n\n }\n\n }\n\n\n\n public static void main(String[] args) {\n\n int port = 1234; // default port\n\n if (args.length > 0) {\n\n try {\n\n port = Integer.parseInt(args[0]);\n\n } catch (NumberFormatException e) {\n\n System.err.println(\"Invalid port number\");\n\n System.exit(1);\n\n }\n\n }\n\n\n\n ChatServer server = new ChatServer(port);\n\n try {\n\n server.start();\n\n } catch (IOException e) {\n\n e.printStackTrace();\n\n }\n\n }\n\n}\n\n```\n\nAnd the `ClientHandler` class.\n\n```\n\nimport java.io.*;\n\nimport java.net.*;\n\nclass ClientHandler extends Thread {\n\n private Socket socket;\n\n private ChatServer server;\n\n private BufferedReader in;\n\n private PrintWriter out;\n\n private String username;\n\n\n\n public ClientHandler(Socket socket, ChatServer server) {\n\n this.socket = socket;\n\n this.server = server;\n\n }\n\n\n\n public void run() {\n\n try {\n\n in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\n out = new PrintWriter(socket.getOutputStream(), true);\n\n\n\n while (true) {\n\n if (username == null) {\n\n username = in.readLine();\n\n if (server.clients.stream().anyMatch(c -> c.getUsername().equals(username))) {\n\n out.println(\"Username already exists. Choose another one.\");\n\n username = null;\n\n continue;\n\n } else {\n\n server.addClient(new Client(username, out));\n\n out.println(\"Username accepted.\");\n\n }\n\n } else {\n\n String message = in.readLine();\n\n if (message != null) {\n\n server.broadcast(username + \": \" + message, server.getClientByUsername(username));\n\n }\n\n }\n\n }\n\n } catch (IOException e) {\n\n e.printStackTrace();\n\n } finally {\n\n try {\n\n socket.close();\n\n } catch (IOException e) {\n\n e.printStackTrace();\n\n }\n\n if (username != null) {\n\n server.removeClient(server.getClientByUsername(username));\n\n }\n\n }\n\n }\n\n}\n\n```\n\nWait a minute, in the `ClientHandler` class, in the broadcast method, I need to get the `Client` object corresponding to the username to exclude the sender. But currently, the `broadcast` method in `ChatServer` takes a `Client` object to exclude. However, in the `ClientHandler`, I'm passing `server.getClientByUsername(username)`, but I don't have such a method in `ChatServer`.\n\nI need to implement a method in `ChatServer` to get a client by username.\n\nLet me add that method.\n\n```\n\npublic Client getClientByUsername(String username) {\n\n for (Client client : clients) {\n\n if (client.getUsername().equals(username)) {\n\n return client;\n\n }\n\n }\n\n return null;\n\n}\n\n```\n\nAlso, in the `broadcast` method, I need to ensure that the sender's message is not sent back to them.\n\nAlternatively, I can pass the sender's `Client` object directly from `ClientHandler`.\n\nLet me adjust the `ClientHandler` class to pass the `Client` object.\n\nFirst, modify the `ClientHandler` constructor to initialize the `Client` object once the username is accepted.\n\nThen, store the `Client` object in an instance variable.\n\nHere's an updated version:\n\n```\n\nclass ClientHandler extends Thread {\n\n private Socket socket;\n\n private ChatServer server;\n\n private BufferedReader in;\n\n private PrintWriter out;\n\n private Client client;\n\n\n\n public ClientHandler(Socket socket, ChatServer server) {\n\n this.socket = socket;\n\n this.server = server;\n\n }\n\n\n\n public void run() {\n\n try {\n\n in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\n out = new PrintWriter(socket.getOutputStream(), true);\n\n\n\n while (true) {\n\n if (client == null) {\n\n String username = in.readLine();\n\n if (server.isUsernameAvailable(username)) {\n\n client = new Client(username, out);\n\n server.addClient(client);\n\n out.println(\"Username accepted.\");\n\n } else {\n\n out.println(\"Username already exists. Choose another one.\");\n\n continue;\n\n }\n\n } else {\n\n String message = in.readLine();\n\n if (message != null) {\n\n server.broadcast(message, client);\n\n }\n\n }\n\n }\n\n } catch (IOException e) {\n\n e.printStackTrace();\n\n } finally {\n\n try {\n\n socket.close();\n\n } catch (IOException e) {\n\n e.printStackTrace();\n\n }\n\n if (client != null) {\n\n server.removeClient(client);\n\n }\n\n }\n\n }\n\n}\n\n```\n\nAnd in `ChatServer`, modify the `broadcast` method to include the sender's username in the message.\n\nWait, actually, the message should include the sender's username, so I need to construct the message in the `broadcast` method.\n\nLet me adjust that.\n\nIn `ChatServer`:\n\n```\n\npublic void broadcast(String message, Client sender) {\n\n String formattedMessage = sender.getUsername() + \": \" + message;\n\n for (Client client : clients) {\n\n if (client != sender) {\n\n client.getOut().println(formattedMessage);\n\n }\n\n }\n\n}\n\n```\n\nAnd in `ClientHandler`, pass the `client` object when broadcasting.\n\nAlso, in `ChatServer`, add a method to check if a username is available.\n\n```\n\npublic boolean isUsernameAvailable(String username) {\n\n return !clients.stream().anyMatch(c -> c.getUsername().equals(username));\n\n}\n\n```\n\nThis should cover the server-side implementation.\n\nNow, let's move on to the client-side.\n\n**Client Code:**\n\nThe client needs to connect to the server, choose a username, and then be able to send and receive messages.\n\nI'll create a `ChatClient` class that handles the connection and communication.\n\nI need to have two threads:\n\n1. One for reading messages from the server and displaying them.\n\n2. One for reading user input and sending messages to the server.\n\nI need to handle the initial username selection and handle cases where the username is already taken.\n\nHere's a sketch of the `ChatClient` class.\n\n```\n\nimport java.io.*;\n\nimport java.net.*;\n\nimport java.util.Scanner;\n\n\n\npublic class ChatClient {\n\n private String host;\n\n private int port;\n\n private Socket socket;\n\n private BufferedReader in;\n\n private PrintWriter out;\n\n\n\n public ChatClient(String host, int port) {\n\n this.host = host;\n\n this.port = port;\n\n }\n\n\n\n public void start() throws IOException {\n\n socket = new Socket(host, port);\n\n in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\n out = new PrintWriter(socket.getOutputStream(), true);\n\n\n\n // Start a thread to listen for messages from the server\n\n Thread messageListener = new Thread(() -> {\n\n try {\n\n String message;\n\n while ((message = in.readLine()) != null) {\n\n System.out.println(message);\n\n }\n\n } catch (IOException e) {\n\n e.printStackTrace();\n\n }\n\n });\n\n messageListener.start();\n\n\n\n // Read username\n\n String username = getUsername();\n\n out.println(username);\n\n String response = in.readLine();\n\n if (response.equals(\"Username accepted.\")) {\n\n // Start reading user input and sending messages\n\n Scanner scanner = new Scanner(System.in);\n\n while (true) {\n\n String message = scanner.nextLine();\n\n out.println(message);\n\n }\n\n } else {\n\n System.out.println(response);\n\n }\n\n }\n\n\n\n private String getUsername() {\n\n Scanner scanner = new Scanner(System.in);\n\n System.out.print(\"Choose a username: \");\n\n return scanner.nextLine();\n\n }\n\n\n\n public static void main(String[] args) {\n\n String host = \"localhost\"; // default host\n\n int port = 1234; // default port\n\n\n\n if (args.length >= 1) {\n\n host = args[0];\n\n }\n\n if (args.length >= 2) {\n\n try {\n\n port = Integer.parseInt(args[1]);\n\n } catch (NumberFormatException e) {\n\n System.err.println(\"Invalid port number\");\n\n System.exit(1);\n\n }\n\n }\n\n\n\n ChatClient client = new ChatClient(host, port);\n\n try {\n\n client.start();\n\n } catch (IOException e) {\n\n e.printStackTrace();\n\n }\n\n }\n\n}\n\n```\n\nThis should cover the basic functionality.\n\nLet me summarize:\n\n- The server listens on a specified port and handles multiple clients using separate threads.\n\n- Each client chooses a unique username upon connecting.\n\n- The server broadcasts messages from one client to all other connected clients, prefixing the message with the sender's username.\n\n- The client can send and receive messages concurrently using separate threads.\n\nI need to test this implementation to ensure that it works as expected.\n\n**Testing:**\n\n1. Start the server by running the `ChatServer` class.\n\n2. Open multiple client terminals and run the `ChatClient` class.\n\n3. Each client should choose a unique username.\n\n4. Clients should be able to see messages sent by other clients.\n\n5. If a client tries to use an already taken username, they should be prompted to choose another one.\n\n6. Check for proper handling of client disconnections.\n\nI should also consider edge cases, such as:\n\n- A client sending multiple messages very quickly.\n\n- A client disconnecting without proper notification.\n\n- Handling of invalid messages or data.\n\n- Ensuring that the server doesn't crash under normal usage.\n\nOverall, this should provide a simple yet functional chat server and client using Java sockets.\n\n## Final Solution\nTo create a simple chat server and client using Java sockets that supports multiple clients, broadcasts messages from one client to all others, and allows clients to choose their username upon joining, follow the steps below.\n\n### Solution Code\n\n#### Server Code\n\n1. **ChatServer.java**\n\n```java\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\n\nclass Client {\n    String username;\n    PrintWriter out;\n\n    public Client(String username, PrintWriter out) {\n        this.username = username;\n        this.out = out;\n    }\n\n    public String getUsername() {\n        return username;\n    }\n\n    public PrintWriter getOut() {\n        return out;\n    }\n}\n\npublic class ChatServer {\n    private int port;\n    private ServerSocket serverSocket;\n    private List<Client> clients = new CopyOnWriteArrayList<>();\n\n    public ChatServer(int port) {\n        this.port = port;\n    }\n\n    public void start() throws IOException {\n        serverSocket = new ServerSocket(port);\n        System.out.println(\"Server started on port \" + port);\n\n        while (true) {\n            Socket socket = serverSocket.accept();\n            System.out.println(\"New client connected\");\n\n            ClientHandler handler = new ClientHandler(socket, this);\n            handler.start();\n        }\n    }\n\n    public void addClient(Client client) {\n        clients.add(client);\n    }\n\n    public void removeClient(Client client) {\n        clients.remove(client);\n    }\n\n    public void broadcast(String message, Client sender) {\n        String formattedMessage = sender.getUsername() + \": \" + message;\n        for (Client client : clients) {\n            if (client != sender) {\n                client.getOut().println(formattedMessage);\n            }\n        }\n    }\n\n    public boolean isUsernameAvailable(String username) {\n        return !clients.stream().anyMatch(c -> c.getUsername().equals(username));\n    }\n\n    public static void main(String[] args) {\n        int port = 1234; // default port\n        if (args.length > 0) {\n            try {\n                port = Integer.parseInt(args[0]);\n            } catch (NumberFormatException e) {\n                System.err.println(\"Invalid port number\");\n                System.exit(1);\n            }\n        }\n\n        ChatServer server = new ChatServer(port);\n        try {\n            server.start();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\nclass ClientHandler extends Thread {\n    private Socket socket;\n    private ChatServer server;\n    private BufferedReader in;\n    private PrintWriter out;\n    private Client client;\n\n    public ClientHandler(Socket socket, ChatServer server) {\n        this.socket = socket;\n        this.server = server;\n    }\n\n    public void run() {\n        try {\n            in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n            out = new PrintWriter(socket.getOutputStream(), true);\n\n            while (true) {\n                if (client == null) {\n                    String username = in.readLine();\n                    if (server.isUsernameAvailable(username)) {\n                        client = new Client(username, out);\n                        server.addClient(client);\n                        out.println(\"Username accepted.\");\n                    } else {\n                        out.println(\"Username already exists. Choose another one.\");\n                        continue;\n                    }\n                } else {\n                    String message = in.readLine();\n                    if (message != null) {\n                        server.broadcast(message, client);\n                    }\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                socket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (client != null) {\n                server.removeClient(client);\n            }\n        }\n    }\n}\n```\n\n#### Client Code\n\n2. **ChatClient.java**\n\n```java\nimport java.io.*;\nimport java.net.*;\nimport java.util.Scanner;\n\npublic class ChatClient {\n    private String host;\n    private int port;\n    private Socket socket;\n    private BufferedReader in;\n    private PrintWriter out;\n\n    public ChatClient(String host, int port) {\n        this.host = host;\n        this.port = port;\n    }\n\n    public void start() throws IOException {\n        socket = new Socket(host, port);\n        in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n        out = new PrintWriter(socket.getOutputStream(), true);\n\n        // Start a thread to listen for messages from the server\n        Thread messageListener = new Thread(() -> {\n            try {\n                String message;\n                while ((message = in.readLine()) != null) {\n                    System.out.println(message);\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        });\n        messageListener.start();\n\n        // Read username\n        String username = getUsername();\n        out.println(username);\n        String response = in.readLine();\n        if (response.equals(\"Username accepted.\")) {\n            // Start reading user input and sending messages\n            Scanner scanner = new Scanner(System.in);\n            while (true) {\n                String message = scanner.nextLine();\n                out.println(message);\n            }\n        } else {\n            System.out.println(response);\n        }\n    }\n\n    private String getUsername() {\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Choose a username: \");\n        return scanner.nextLine();\n    }\n\n    public static void main(String[] args) {\n        String host = \"localhost\"; // default host\n        int port = 1234; // default port\n\n        if (args.length >= 1) {\n            host = args[0];\n        }\n        if (args.length >= 2) {\n            try {\n                port = Integer.parseInt(args[1]);\n            } catch (NumberFormatException e) {\n                System.err.println(\"Invalid port number\");\n                System.exit(1);\n            }\n        }\n\n        ChatClient client = new ChatClient(host, port);\n        try {\n            client.start();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n### Explanation\n\n- **Server (`ChatServer.java`)**:\n  - Listens on a specified port for incoming client connections.\n  - Manages multiple clients using separate threads (`ClientHandler`).\n  - Maintains a list of connected clients to broadcast messages.\n  - Ensures unique usernames for each client.\n\n- **Client (`ChatClient.java`)**:\n  - Connects to the server via specified IP and port.\n  - Allows the user to choose a username.\n  - Sends and receives messages through separate threads.\n\n### Usage\n\n1. **Start the Server**:\n   - Compile `ChatServer.java`.\n   - Run the server with `java ChatServer [port]`.\n\n2. **Start Clients**:\n   - Compile `ChatClient.java`.\n   - Run multiple instances of the client with `java ChatClient [host] [port]`.\n\nEach client can then choose a unique username and communicate with other connected clients."
    }
]