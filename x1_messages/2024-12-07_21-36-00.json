[
    {
        "role": "user",
        "content": "Create a Python script that connects to a Cassandra database and performs basic CRUD operations (Create, Read, Update, Delete) on a table containing user information (name, email, age). The script should support command line arguments for specifying the connection details (host, port, keyspace).\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Alright, I've got this task to create a Python script that connects to a Cassandra database and performs basic CRUD operations on a table with user information: name, email, and age. Also, the script should accept command line arguments for the database connection details like host, port, and keyspace. Okay, let's break this down step by step.\n\nFirst things first, I need to make sure I have the Cassandra driver installed for Python. I think it's called 'cassandra-driver', right? I should check that. Yeah, I can install it using pip if it's not already installed.\n\nNext, I need to parse command line arguments for the connection details. Python has a module called 'argparse' that's great for handling command line arguments. I'll use that to get host, port, and keyspace from the user.\n\nAfter that, I need to connect to the Cassandra database using these details. I'll need to handle any potential connection errors, like if the host is incorrect or the keyspace doesn't exist.\n\nOnce connected, I need to perform CRUD operations on a table containing user information. So, I need to create a table if it doesn't exist, insert new users, read user data, update existing user data, and delete users.\n\nI should probably define functions for each of these operations to keep the code organized. Let's think about the flow of the script:\n\n1. Parse command line arguments for host, port, and keyspace.\n\n2. Connect to the Cassandra database using these parameters.\n\n3. Create a table for users if it doesn't already exist.\n\n4. Provide options for the user to perform CRUD operations.\n\nWait, but since it's a script, I need to decide how the user will interact with it. Maybe I can accept additional command line arguments to specify the operation to perform, like 'create', 'read', 'update', 'delete', and then provide the necessary data for each operation.\n\nFor example:\n\n- To create a new user: script.py --host localhost --port 9042 --keyspace mykeyspace --operation create --name John --email john@example.com --age 30\n\n- To read user data: script.py --host localhost --port 9042 --keyspace mykeyspace --operation read --email john@example.com\n\n- To update user data: script.py --host localhost --port 9042 --keyspace mykeyspace --operation update --email john@example.com --age 31\n\n- To delete a user: script.py --host localhost --port 9042 --keyspace mykeyspace --operation delete --email john@example.com\n\nThat sounds reasonable. So, I need to add arguments for the operation and the corresponding data needed for each operation.\n\nNow, for the table schema. Since the table will contain user information with fields name, email, and age, I need to define the table structure in Cassandra. Cassandra requires a primary key, so I'll need to decide which field should be the primary key. Email seems like a good candidate since it's unique for each user.\n\nSo, the table creation query would look something like:\n\nCREATE TABLE IF NOT EXISTS users (\n\nemail text PRIMARY KEY,\n\nname text,\n\nage int\n\n);\n\nI need to make sure to handle the table creation carefully, maybe checking if the table already exists before trying to create it.\n\nOkay, moving on to the CRUD operations:\n\n- Create: Insert a new user into the table.\n\n- Read: Retrieve user data based on email.\n\n- Update: Update existing user data based on email.\n\n- Delete: Delete a user based on email.\n\nI need to write functions for each of these operations, handling any possible errors, like trying to insert a user that already exists or deleting a user that doesn't exist.\n\nAlso, I should think about how to display the results to the user. For read operations, I can print the user data. For other operations, I can print success or failure messages.\n\nLet me start sketching out the structure of the script.\n\nFirst, import necessary modules:\n\nimport argparse\n\nfrom cassandra.cluster import Cluster\n\nfrom cassandra.query import SimpleStatement\n\nThen, set up argument parsing using argparse. I need to define required arguments for host, port, keyspace, operation, and the corresponding data for each operation.\n\nI can use subparsers for different operations to make it cleaner, but maybe that's overkill for this script. Instead, I can have a single --operation argument and then have optional arguments for name, email, and age depending on the operation.\n\nWait, but some operations require certain arguments. For example, create requires name, email, and age, while delete only requires email. I need to make sure that the required arguments are provided for each operation.\n\nMaybe I can have separate arguments for name, email, and age, and then based on the operation, check if the required arguments are provided.\n\nAlright, moving forward.\n\nNext, connect to the Cassandra cluster using the host and port provided, and set the keyspace.\n\ncluster = Cluster(contact_points=[host], port=port)\n\nsession = cluster.connect(keyspace)\n\nThen, create the users table if it doesn't exist.\n\ncreate_table_query = \"\"\"\n\nCREATE TABLE IF NOT EXISTS users (\n\nemail text PRIMARY KEY,\n\nname text,\n\nage int\n\n)\n\n\"\"\"\n\nsession.execute(create_table_query)\n\nNow, based on the operation specified, call the corresponding function.\n\nIf operation is 'create', get name, email, and age from arguments, and insert into the table.\n\nIf operation is 'read', get email, and select the user data based on email.\n\nIf operation is 'update', get email and the fields to update (name, age), and update the corresponding fields.\n\nIf operation is 'delete', get email, and delete the user record.\n\nI need to handle cases where required arguments are missing. For example, if the operation is 'create' but name, email, or age is not provided, I should display an error message.\n\nAlso, for update, the user might want to update only name or only age, so I need to handle partial updates.\n\nWait, in Cassandra, you can update specific columns without affecting others. So, in the update query, I can specify which columns to update based on the provided arguments.\n\nFor example, if only age is provided, update only age; if both name and age are provided, update both.\n\nI need to build the update query dynamically based on the provided arguments.\n\nAlright, that adds a bit of complexity, but it's manageable.\n\nLet me think about error handling. For example, if the connection to the database fails, I should catch the exception and display an error message.\n\nSimilarly, if the user tries to read or delete a user that doesn't exist, I should handle that gracefully, maybe by checking if any rows are returned and informing the user accordingly.\n\nAlso, for create operations, I need to check if a user with the same email already exists. If so, I should decide whether to allow updating the existing user or to prevent inserting a duplicate.\n\nIn this script, I'll consider email as the unique identifier, so if a user with the same email already exists, inserting it again should fail or optionally update the existing record.\n\nBut to keep it simple, I'll make create operations insert new users only, and if the email already exists, it should fail with an appropriate error message.\n\nSimilarly, update and delete operations should only proceed if the user exists.\n\nAlright, I think I have a plan. Let's start implementing this step by step.\n\nFirst, set up argparse to handle the command line arguments.\n\nI need:\n\n- --host (required)\n\n- --port (default to 9042, which is the default Cassandra port)\n\n- --keyspace (required)\n\n- --operation (required, choices: create, read, update, delete)\n\n- --name (for create and update)\n\n- --email (for all operations except create, where it's required)\n\n- --age (for create and update)\n\nI need to ensure that for each operation, the required arguments are provided.\n\nFor example:\n\n- create: require name, email, age\n\n- read: require email\n\n- update: require email, and at least one of name or age\n\n- delete: require email\n\nI'll need to add these checks in the script after parsing the arguments.\n\nNow, connect to the Cassandra cluster using the provided host and port, and set the keyspace.\n\nThen, create the users table if it doesn't exist.\n\nAfter that, based on the operation, perform the corresponding CRUD operation.\n\nLet's start writing some code.\n\nFirst, import the necessary modules:\n\nimport argparse\n\nfrom cassandra.cluster import Cluster\n\nfrom cassandra.query import SimpleStatement\n\nThen, set up the argument parser:\n\nparser = argparse.ArgumentParser(description='Cassandra CRUD operations for users.')\n\nparser.add_argument('--host', required=True, help='Cassandra host')\n\nparser.add_argument('--port', type=int, default=9042, help='Cassandra port')\n\nparser.add_argument('--keyspace', required=True, help='Cassandra keyspace')\n\nparser.add_argument('--operation', required=True, choices=['create', 'read', 'update', 'delete'], help='Operation to perform')\n\nparser.add_argument('--name', help='User name')\n\nparser.add_argument('--email', help='User email')\n\nparser.add_argument('--age', type=int, help='User age')\n\nargs = parser.parse_args()\n\nNow, I need to validate the arguments based on the operation.\n\nFor example, if operation is 'create', ensure that name, email, and age are provided.\n\nif args.operation == 'create':\n\nif not args.name or not args.email or not args.age:\n\nparser.error('Create operation requires --name, --email, and --age.')\n\nelif args.operation == 'read':\n\nif not args.email:\n\nparser.error('Read operation requires --email.')\n\nelif args.operation == 'update':\n\nif not args.email or (not args.name and not args.age):\n\nparser.error('Update operation requires --email and at least one of --name or --age.')\n\nelif args.operation == 'delete':\n\nif not args.email:\n\nparser.error('Delete operation requires --email.')\n\nThis should cover the required arguments for each operation.\n\nNext, connect to the Cassandra cluster.\n\ncluster = Cluster(contact_points=[args.host], port=args.port)\n\ntry:\n\nsession = cluster.connect(args.keyspace)\n\nexcept Exception as e:\n\nprint(f\"Unable to connect to Cassandra: {e}\")\n\nexit(1)\n\nNow, create the users table if it doesn't exist.\n\ncreate_table_query = \"\"\"\n\nCREATE TABLE IF NOT EXISTS users (\n\nemail text PRIMARY KEY,\n\nname text,\n\nage int\n\n)\n\n\"\"\"\n\ntry:\n\nsession.execute(create_table_query)\n\nexcept Exception as e:\n\nprint(f\"Error creating table: {e}\")\n\nexit(1)\n\nGood, now depending on the operation, call the corresponding function.\n\nI'll define functions for each operation: create_user, read_user, update_user, delete_user.\n\nLet's start with the create_user function.\n\ndef create_user(session, name, email, age):\n\nquery = \"INSERT INTO users (email, name, age) VALUES (%s, %s, %s)\"\n\ntry:\n\nsession.execute(query, (email, name, age))\n\nprint(\"User created successfully.\")\n\nexcept Exception as e:\n\nprint(f\"Error creating user: {e}\")\n\nCheck if the email already exists before inserting?\n\nActually, since email is the primary key, inserting a user with an existing email will raise an error. So, I can catch that specific error and inform the user.\n\nBut to make it clearer, I can first check if the user exists.\n\ndef user_exists(session, email):\n\nquery = \"SELECT email FROM users WHERE email = %s\"\n\nrows = session.execute(query, (email,))\n\nreturn rows.fetchone() is not None\n\nThen, in create_user:\n\nif user_exists(session, email):\n\nprint(\"User with this email already exists. Unable to create.\")\n\nelse:\n\ntry:\n\nsession.execute(query, (email, name, age))\n\nprint(\"User created successfully.\")\n\nexcept Exception as e:\n\nprint(f\"Error creating user: {e}\")\n\nThat's better.\n\nNext, the read_user function.\n\ndef read_user(session, email):\n\nquery = \"SELECT * FROM users WHERE email = %s\"\n\ntry:\n\nrows = session.execute(query, (email,))\n\nfor row in rows:\n\nprint(f\"Name: {row.name}, Email: {row.email}, Age: {row.age}\")\n\nexcept Exception as e:\n\nprint(f\"Error reading user: {e}\")\n\nBut I should check if any rows are returned to know if the user exists.\n\ndef read_user(session, email):\n\nquery = \"SELECT * FROM users WHERE email = %s\"\n\ntry:\n\nrows = session.execute(query, (email,))\n\nif rows:\n\nfor row in rows:\n\nprint(f\"Name: {row.name}, Email: {row.email}, Age: {row.age}\")\n\nelse:\n\nprint(\"User not found.\")\n\nexcept Exception as e:\n\nprint(f\"Error reading user: {e}\")\n\nGood.\n\nNow, the update_user function. This needs to handle partial updates, meaning updating only name or only age, or both.\n\ndef update_user(session, email, name=None, age=None):\n\nif not name and not age:\n\nprint(\"No fields to update provided.\")\n\nreturn\n\nquery_parts = []\n\nparams = []\n\nif name:\n\nquery_parts.append(\"name = %s\")\n\nparams.append(name)\n\nif age is not None:\n\nquery_parts.append(\"age = %s\")\n\nparams.append(age)\n\nset_clause = ', '.join(query_parts)\n\nquery = f\"UPDATE users SET {set_clause} WHERE email = %s\"\n\nparams.append(email)\n\ntry:\n\nsession.execute(query, params)\n\nprint(\"User updated successfully.\")\n\nexcept Exception as e:\n\nprint(f\"Error updating user: {e}\")\n\nThis way, only the provided fields are updated.\n\nFinally, the delete_user function.\n\ndef delete_user(session, email):\n\nif not user_exists(session, email):\n\nprint(\"User not found. Unable to delete.\")\n\nelse:\n\nquery = \"DELETE FROM users WHERE email = %s\"\n\ntry:\n\nsession.execute(query, (email,))\n\nprint(\"User deleted successfully.\")\n\nexcept Exception as e:\n\nprint(f\"Error deleting user: {e}\")\n\nI'm checking if the user exists before deleting to provide a clearer message, but in Cassandra, deleting a non-existent row doesn't raise an error, it just does nothing. So, I can skip the existence check if I want.\n\nBut to be consistent, I'll keep the existence check.\n\nNow, back to the main script flow.\n\nAfter parsing arguments and connecting to the database, I can call the corresponding function based on the operation.\n\nif args.operation == 'create':\n\ncreate_user(session, args.name, args.email, args.age)\n\nelif args.operation == 'read':\n\nread_user(session, args.email)\n\nelif args.operation == 'update':\n\nupdate_user(session, args.email, name=args.name, age=args.age)\n\nelif args.operation == 'delete':\n\ndelete_user(session, args.email)\n\nFinally, close the connection.\n\ncluster.shutdown()\n\nPutting it all together, the script would look like this:\n\nimport argparse\n\nfrom cassandra.cluster import Cluster\n\nfrom cassandra.query import SimpleStatement\n\ndef main():\n\nparser = argparse.ArgumentParser(description='Cassandra CRUD operations for users.')\n\nparser.add_argument('--host', required=True, help='Cassandra host')\n\nparser.add_argument('--port', type=int, default=9042, help='Cassandra port')\n\nparser.add_argument('--keyspace', required=True, help='Cassandra keyspace')\n\nparser.add_argument('--operation', required=True, choices=['create', 'read', 'update', 'delete'], help='Operation to perform')\n\nparser.add_argument('--name', help='User name')\n\nparser.add_argument('--email', help='User email')\n\nparser.add_argument('--age', type=int, help='User age')\n\nargs = parser.parse_args()\n\n# Validate arguments based on operation\n\nif args.operation == 'create':\n\nif not args.name or not args.email or not args.age:\n\nparser.error('Create operation requires --name, --email, and --age.')\n\nelif args.operation == 'read':\n\nif not args.email:\n\nparser.error('Read operation requires --email.')\n\nelif args.operation == 'update':\n\nif not args.email or (not args.name and not args.age):\n\nparser.error('Update operation requires --email and at least one of --name or --age.')\n\nelif args.operation == 'delete':\n\nif not args.email:\n\nparser.error('Delete operation requires --email.')\n\n# Connect to Cassandra\n\ncluster = Cluster(contact_points=[args.host], port=args.port)\n\ntry:\n\nsession = cluster.connect(args.keyspace)\n\nexcept Exception as e:\n\nprint(f\"Unable to connect to Cassandra: {e}\")\n\nexit(1)\n\n# Create table if not exists\n\ncreate_table_query = \"\"\"\n\nCREATE TABLE IF NOT EXISTS users (\n\nemail text PRIMARY KEY,\n\nname text,\n\nage int\n\n)\n\n\"\"\"\n\ntry:\n\nsession.execute(create_table_query)\n\nexcept Exception as e:\n\nprint(f\"Error creating table: {e}\")\n\nexit(1)\n\n# Define CRUD functions\n\ndef create_user(session, name, email, age):\n\nif user_exists(session, email):\n\nprint(\"User with this email already exists. Unable to create.\")\n\nelse:\n\ntry:\n\nquery = \"INSERT INTO users (email, name, age) VALUES (%s, %s, %s)\"\n\nsession.execute(query, (email, name, age))\n\nprint(\"User created successfully.\")\n\nexcept Exception as e:\n\nprint(f\"Error creating user: {e}\")\n\ndef read_user(session, email):\n\nquery = \"SELECT * FROM users WHERE email = %s\"\n\ntry:\n\nrows = session.execute(query, (email,))\n\nif rows:\n\nfor row in rows:\n\nprint(f\"Name: {row.name}, Email: {row.email}, Age: {row.age}\")\n\nelse:\n\nprint(\"User not found.\")\n\nexcept Exception as e:\n\nprint(f\"Error reading user: {e}\")\n\ndef update_user(session, email, name=None, age=None):\n\nif not name and not age:\n\nprint(\"No fields to update provided.\")\n\nreturn\n\nquery_parts = []\n\nparams = []\n\nif name:\n\nquery_parts.append(\"name = %s\")\n\nparams.append(name)\n\nif age is not None:\n\nquery_parts.append(\"age = %s\")\n\nparams.append(age)\n\nset_clause = ', '.join(query_parts)\n\nquery = f\"UPDATE users SET {set_clause} WHERE email = %s\"\n\nparams.append(email)\n\ntry:\n\nsession.execute(query, params)\n\nprint(\"User updated successfully.\")\n\nexcept Exception as e:\n\nprint(f\"Error updating user: {e}\")\n\ndef delete_user(session, email):\n\nif not user_exists(session, email):\n\nprint(\"User not found. Unable to delete.\")\n\nelse:\n\nquery = \"DELETE FROM users WHERE email = %s\"\n\ntry:\n\nsession.execute(query, (email,))\n\nprint(\"User deleted successfully.\")\n\nexcept Exception as e:\n\nprint(f\"Error deleting user: {e}\")\n\ndef user_exists(session, email):\n\nquery = \"SELECT email FROM users WHERE email = %s\"\n\nrows = session.execute(query, (email,))\n\nreturn rows.fetchone() is not None\n\n# Perform operation\n\nif args.operation == 'create':\n\ncreate_user(session, args.name, args.email, args.age)\n\nelif args.operation == 'read':\n\nread_user(session, args.email)\n\nelif args.operation == 'update':\n\nupdate_user(session, args.email, name=args.name, age=args.age)\n\nelif args.operation == 'delete':\n\ndelete_user(session, args.email)\n\n# Close connection\n\ncluster.shutdown()\n\nif __name__ == '__main__':\n\nmain()\n\nI think this covers all the required functionality. The script connects to a Cassandra database, creates a users table if it doesn't exist, and performs create, read, update, and delete operations based on the provided command line arguments.\n\nI should test this script with different operations to ensure it works as expected.\n\nFirst, test creating a user:\n\npython script.py --host localhost --port 9042 --keyspace mykeyspace --operation create --name John --email john@example.com --age 30\n\nExpected output: User created successfully.\n\nThen, try reading the user:\n\npython script.py --host localhost --port 9042 --keyspace mykeyspace --operation read --email john@example.com\n\nExpected output: Name: John, Email: john@example.com, Age: 30\n\nNext, update the user's age:\n\npython script.py --host localhost --port 9042 --keyspace mykeyspace --operation update --email john@example.com --age 31\n\nExpected output: User updated successfully.\n\nRead the user again to verify the update:\n\npython script.py --host localhost --port 9042 --keyspace mykeyspace --operation read --email john@example.com\n\nExpected output: Name: John, Email: john@example.com, Age: 31\n\nThen, delete the user:\n\npython script.py --host localhost --port 9042 --keyspace mykeyspace --operation delete --email john@example.com\n\nExpected output: User deleted successfully.\n\nFinally, try reading the deleted user:\n\npython script.py --host localhost --port 9042 --keyspace mykeyspace --operation read --email john@example.com\n\nExpected output: User not found.\n\nI should also test for error cases, like trying to create a user that already exists, or updating a user that doesn't exist.\n\nAlright, I think this script should work as intended. ## Final Solution\nTo create a Python script that connects to a Cassandra database and performs basic CRUD operations on a table containing user information (name, email, age), follow the steps below. The script will support command line arguments for specifying the connection details (host, port, keyspace).\n\n### Solution Code\n\n```python\nimport argparse\nfrom cassandra.cluster import Cluster\nfrom cassandra.query import SimpleStatement\n\ndef main():\n    parser = argparse.ArgumentParser(description='Cassandra CRUD operations for users.')\n    parser.add_argument('--host', required=True, help='Cassandra host')\n    parser.add_argument('--port', type=int, default=9042, help='Cassandra port')\n    parser.add_argument('--keyspace', required=True, help='Cassandra keyspace')\n    parser.add_argument('--operation', required=True, choices=['create', 'read', 'update', 'delete'], help='Operation to perform')\n    parser.add_argument('--name', help='User name')\n    parser.add_argument('--email', help='User email')\n    parser.add_argument('--age', type=int, help='User age')\n    args = parser.parse_args()\n\n    # Validate arguments based on operation\n    if args.operation == 'create':\n        if not args.name or not args.email or not args.age:\n            parser.error('Create operation requires --name, --email, and --age.')\n    elif args.operation == 'read':\n        if not args.email:\n            parser.error('Read operation requires --email.')\n    elif args.operation == 'update':\n        if not args.email or (not args.name and not args.age):\n            parser.error('Update operation requires --email and at least one of --name or --age.')\n    elif args.operation == 'delete':\n        if not args.email:\n            parser.error('Delete operation requires --email.')\n\n    # Connect to Cassandra\n    cluster = Cluster(contact_points=[args.host], port=args.port)\n    try:\n        session = cluster.connect(args.keyspace)\n    except Exception as e:\n        print(f\"Unable to connect to Cassandra: {e}\")\n        exit(1)\n\n    # Create table if not exists\n    create_table_query = \"\"\"\n    CREATE TABLE IF NOT EXISTS users (\n        email text PRIMARY KEY,\n        name text,\n        age int\n    )\n    \"\"\"\n    try:\n        session.execute(create_table_query)\n    except Exception as e:\n        print(f\"Error creating table: {e}\")\n        exit(1)\n\n    # Define CRUD functions\n    def create_user(session, name, email, age):\n        if user_exists(session, email):\n            print(\"User with this email already exists. Unable to create.\")\n        else:\n            try:\n                query = \"INSERT INTO users (email, name, age) VALUES (%s, %s, %s)\"\n                session.execute(query, (email, name, age))\n                print(\"User created successfully.\")\n            except Exception as e:\n                print(f\"Error creating user: {e}\")\n\n    def read_user(session, email):\n        query = \"SELECT * FROM users WHERE email = %s\"\n        try:\n            rows = session.execute(query, (email,))\n            if rows:\n                for row in rows:\n                    print(f\"Name: {row.name}, Email: {row.email}, Age: {row.age}\")\n            else:\n                print(\"User not found.\")\n        except Exception as e:\n            print(f\"Error reading user: {e}\")\n\n    def update_user(session, email, name=None, age=None):\n        if not name and not age:\n            print(\"No fields to update provided.\")\n            return\n        query_parts = []\n        params = []\n        if name:\n            query_parts.append(\"name = %s\")\n            params.append(name)\n        if age is not None:\n            query_parts.append(\"age = %s\")\n            params.append(age)\n        set_clause = ', '.join(query_parts)\n        query = f\"UPDATE users SET {set_clause} WHERE email = %s\"\n        params.append(email)\n        try:\n            session.execute(query, params)\n            print(\"User updated successfully.\")\n        except Exception as e:\n            print(f\"Error updating user: {e}\")\n\n    def delete_user(session, email):\n        if not user_exists(session, email):\n            print(\"User not found. Unable to delete.\")\n        else:\n            query = \"DELETE FROM users WHERE email = %s\"\n            try:\n                session.execute(query, (email,))\n                print(\"User deleted successfully.\")\n            except Exception as e:\n                print(f\"Error deleting user: {e}\")\n\n    def user_exists(session, email):\n        query = \"SELECT email FROM users WHERE email = %s\"\n        rows = session.execute(query, (email,))\n        return rows.fetchone() is not None\n\n    # Perform operation\n    if args.operation == 'create':\n        create_user(session, args.name, args.email, args.age)\n    elif args.operation == 'read':\n        read_user(session, args.email)\n    elif args.operation == 'update':\n        update_user(session, args.email, name=args.name, age=args.age)\n    elif args.operation == 'delete':\n        delete_user(session, args.email)\n\n    # Close connection\n    cluster.shutdown()\n\nif __name__ == '__main__':\n    main()\n```\n\n### Explanation\n\n1. **Argument Parsing**:\n   - Use `argparse` to handle command-line arguments for host, port, keyspace, operation, name, email, and age.\n   - Validate arguments based on the specified operation to ensure required data is provided.\n\n2. **Database Connection**:\n   - Connect to the Cassandra cluster using the provided host and port, and set the specified keyspace.\n   - Create a table named `users` if it doesn't exist, with columns for email (PRIMARY KEY), name, and age.\n\n3. **CRUD Operations**:\n   - **Create**: Insert a new user into the table. Check if a user with the same email already exists before inserting.\n   - **Read**: Retrieve and display user data based on the email provided.\n   - **Update**: Update the name and/or age of an existing user.\n   - **Delete**: Remove a user from the table based on the email provided.\n\n4. **Error Handling**:\n   - Handle exceptions for database operations and provide user-friendly error messages.\n   - Ensure that operations like updating or deleting check for the existence of the user before performing the action."
    }
]