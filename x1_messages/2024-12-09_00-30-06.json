[
    {
        "role": "user",
        "content": "Develop a Python Flask API with two endpoints: one for adding new products (with properties like name, price, and description) to a MongoDB collection, and another for searching products by name or price range. Ensure proper validation and error handling for both endpoints.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Alright, I've got this task to create a Python Flask API with two endpoints: one for adding new products to a MongoDB collection and another for searching products by name or price range. I need to make sure that there's proper validation and error handling for both endpoints. Sounds straightforward, but I want to make sure I cover all the bases.\n\nFirst things first, I need to set up a Flask application and connect it to a MongoDB database. I've worked with Flask before, but I'm a bit rusty on the MongoDB integration. I think I'll use the PyMongo library to handle the connection and operations with MongoDB.\n\nSo, to start, I need to install Flask and PyMongo. I can do this using pip:\n\n```bash\npip install Flask PyMongo\n```\n\nNext, I need to set up the Flask app and configure the connection to MongoDB. Assuming I have a MongoDB server running locally, I can set up the connection like this:\n\n```python\nfrom flask import Flask, request, jsonify\nfrom pymongo import MongoClient\n\napp = Flask(__name__)\n\n# Configure MongoDB connection\nclient = MongoClient('mongodb://localhost:27017/')\ndb = client['product_database']\nproducts_collection = db['products']\n```\n\nNow, I need to create the endpoint for adding new products. The products should have properties like name, price, and description. I need to make sure that these fields are provided and are of the correct types. For validation, I can use the `request` object from Flask to access the JSON data sent in the request.\n\nLet me sketch out the endpoint for adding a product:\n\n```python\n@app.route('/add_product', methods=['POST'])\ndef add_product():\n    data = request.get_json()\n    \n    # Validate required fields\n    if not all(key in data for key in ['name', 'price', 'description']):\n        return jsonify({'error': 'Missing required fields'}), 400\n    \n    # Validate data types\n    if not isinstance(data['name'], str):\n        return jsonify({'error': 'Name must be a string'}), 400\n    if not isinstance(data['price'], (int, float)):\n        return jsonify({'error': 'Price must be a number'}), 400\n    if not isinstance(data['description'], str):\n        return jsonify({'error': 'Description must be a string'}), 400\n    \n    # Insert the product into the database\n    product_id = products_collection.insert_one(data).inserted_id\n    return jsonify({'message': 'Product added successfully', 'id': str(product_id)}), 201\n```\n\nThis seems solid. I'm checking that all required fields are present and that they are of the correct types. If everything is okay, I'm inserting the product into the MongoDB collection and returning the product's ID.\n\nNow, for the search endpoint. This should allow searching by product name or by price range. Searching by name could be a simple text search, maybe case-insensitive. Searching by price range would require specifying a minimum and/or maximum price.\n\nI need to decide how the search parameters will be passed. Perhaps using query parameters in the URL. For example:\n\n- To search by name: `/search?name=widget`\n\n- To search by price range: `/search?min_price=10&max_price=100`\n\n- To search by both name and price range: `/search?name=widget&min_price=10&max_price=100`\n\nI need to handle these parameters appropriately and build a MongoDB query based on them.\n\nHere's a rough idea of how the search endpoint could look:\n\n```python\n@app.route('/search', methods=['GET'])\ndef search_products():\n    name = request.args.get('name')\n    min_price = request.args.get('min_price')\n    max_price = request.args.get('max_price')\n    \n    query = {}\n    \n    if name:\n        query['name'] = {'$regex': name, '$options': 'i'}  # Case-insensitive search\n    if min_price:\n        query['price'] = {'$gte': float(min_price)} if 'price' not in query else {'$and': [{'$gte': float(min_price)}, query['price']]}\n    if max_price:\n        if 'price' not in query:\n            query['price'] = {'$lte': float(max_price)}\n        else:\n            query['price']['$lte'] = float(max_price)\n    \n    # Execute the query\n    results = products_collection.find(query)\n    \n    # Convert results to list of dictionaries\n    products = [{'name': product['name'], 'price': product['price'], 'description': product['description']} for product in results]\n    \n    return jsonify(products), 200\n```\n\nHmm, I think there might be a better way to handle the price range query. Specifically, if both min_price and max_price are provided, I need to make sure that the price is within that range. If only min_price is provided, then price should be greater than or equal to min_price, and similarly if only max_price is provided.\n\nI might need to adjust the way I build the query for the price field.\n\nLet me think about this again.\n\n- If only min_price is provided: `{'price': {'$gte': min_price}}`\n\n- If only max_price is provided: `{'price': {'$lte': max_price}}`\n\n- If both are provided: `{'price': {'$gte': min_price, '$lte': max_price}}`\n\nSo, I need to build the query accordingly.\n\nHere's an improved version:\n\n```python\n@app.route('/search', methods=['GET'])\ndef search_products():\n    name = request.args.get('name')\n    min_price = request.args.get('min_price')\n    max_price = request.args.get('max_price')\n    \n    query = {}\n    \n    if name:\n        query['name'] = {'$regex': name, '$options': 'i'}  # Case-insensitive search\n    \n    price_query = {}\n    if min_price:\n        price_query['$gte'] = float(min_price)\n    if max_price:\n        price_query['$lte'] = float(max_price)\n    \n    if price_query:\n        query['price'] = price_query\n    \n    # Execute the query\n    results = products_collection.find(query)\n    \n    # Convert results to list of dictionaries\n    products = [{'name': product['name'], 'price': product['price'], 'description': product['description']} for product in results]\n    \n    return jsonify(products), 200\n```\n\nThis should work better. Now, if both min_price and max_price are provided, the query for price will be `{'price': {'$gte': min_price, '$lte': max_price}}`. If only one of them is provided, it will adjust accordingly.\n\nI should also consider what happens if invalid values are provided for min_price or max_price. For example, if someone passes a non-numeric value, it will raise an error when trying to convert it to float. I need to handle such cases gracefully.\n\nLet me add some validation for the price parameters:\n\n```python\n@app.route('/search', methods=['GET'])\ndef search_products():\n    name = request.args.get('name')\n    min_price = request.args.get('min_price')\n    max_price = request.args.get('max_price')\n    \n    query = {}\n    \n    if name:\n        query['name'] = {'$regex': name, '$options': 'i'}  # Case-insensitive search\n    \n    price_query = {}\n    if min_price:\n        try:\n            price_query['$gte'] = float(min_price)\n        except ValueError:\n            return jsonify({'error': 'min_price must be a number'}), 400\n    if max_price:\n        try:\n            price_query['$lte'] = float(max_price)\n        except ValueError:\n            return jsonify({'error': 'max_price must be a number'}), 400\n    \n    if price_query:\n        query['price'] = price_query\n    \n    # Execute the query\n    results = products_collection.find(query)\n    \n    # Convert results to list of dictionaries\n    products = [{'name': product['name'], 'price': product['price'], 'description': product['description']} for product in results]\n    \n    return jsonify(products), 200\n```\n\nThat's better. Now, if someone passes a non-numeric value for min_price or max_price, the API will return an error message instead of crashing.\n\nI should also think about what happens if someone tries to add a product with invalid data. In the add_product endpoint, I already have some validation, but maybe I should also check for empty strings or other edge cases.\n\nFor example, perhaps the name shouldn't be empty, and the price should be a positive number.\n\nLet me update the add_product endpoint to include these checks:\n\n```python\n@app.route('/add_product', methods=['POST'])\ndef add_product():\n    data = request.get_json()\n    \n    # Validate required fields\n    if not all(key in data for key in ['name', 'price', 'description']):\n        return jsonify({'error': 'Missing required fields'}), 400\n    \n    # Validate data types and values\n    if not isinstance(data['name'], str) or not data['name'].strip():\n        return jsonify({'error': 'Name must be a non-empty string'}), 400\n    if not isinstance(data['price'], (int, float)) or data['price'] <= 0:\n        return jsonify({'error': 'Price must be a positive number'}), 400\n    if not isinstance(data['description'], str):\n        return jsonify({'error': 'Description must be a string'}), 400\n    \n    # Insert the product into the database\n    product_id = products_collection.insert_one(data).inserted_id\n    return jsonify({'message': 'Product added successfully', 'id': str(product_id)}), 201\n```\n\nAlright, now the name must be a non-empty string, and the price must be a positive number.\n\nI should also consider rate limiting or other security measures, but for the sake of this task, I'll keep it simple.\n\nAnother thing to think about is whether to return the entire list of products in the search endpoint or to implement pagination, especially if there could be a large number of results. But for now, I'll keep it simple and return all matching products.\n\nI should test these endpoints to make sure they work as expected.\n\nFirst, test adding a product:\n\n- Send a POST request to `/add_product` with JSON data:\n\n```json\n{\n    \"name\": \"Example Product\",\n    \"price\": 19.99,\n    \"description\": \"This is an example product.\"\n}\n```\n\nExpected response:\n\n```json\n{\n    \"message\": \"Product added successfully\",\n    \"id\": \"some_object_id\"\n}\n```\n\nStatus code: 201\n\nNow, test searching for products:\n\n- Send a GET request to `/search?name=example`\n\nExpected response:\n\nA list of products where the name contains \"example\", in this case, the product we just added.\n\nSimilarly, test searching by price range:\n\n- Send a GET request to `/search?min_price=10&max_price=20`\n\nExpected response:\n\nA list of products where the price is between 10 and 20.\n\nAlso, test edge cases:\n\n- Missing fields in add_product\n\n- Invalid data types in add_product\n\n- Invalid price values in search\n\nMake sure that appropriate error messages are returned in these cases.\n\nI think that covers the basic requirements. If I had more time, I might look into adding more features, like updating or deleting products, but for now, this should suffice.\n\n## Final Solution\nTo create a Python Flask API with two endpoints for managing products in a MongoDB database, follow these steps:\n\n### Prerequisites\n- Install Flask and PyMongo:\n  ```bash\n  pip install Flask PyMongo\n  ```\n\n### Solution Code\n\n```python\nfrom flask import Flask, request, jsonify\nfrom pymongo import MongoClient\nfrom bson.objectid import ObjectId\n\napp = Flask(__name__)\n\n# Configure MongoDB connection\nclient = MongoClient('mongodb://localhost:27017/')\ndb = client['product_database']\nproducts_collection = db['products']\n\n@app.route('/add_product', methods=['POST'])\ndef add_product():\n    data = request.get_json()\n    \n    # Validate required fields\n    if not all(key in data for key in ['name', 'price', 'description']):\n        return jsonify({'error': 'Missing required fields'}), 400\n    \n    # Validate data types and values\n    if not isinstance(data['name'], str) or not data['name'].strip():\n        return jsonify({'error': 'Name must be a non-empty string'}), 400\n    if not isinstance(data['price'], (int, float)) or data['price'] <= 0:\n        return jsonify({'error': 'Price must be a positive number'}), 400\n    if not isinstance(data['description'], str):\n        return jsonify({'error': 'Description must be a string'}), 400\n    \n    # Insert the product into the database\n    product_id = products_collection.insert_one(data).inserted_id\n    return jsonify({'message': 'Product added successfully', 'id': str(product_id)}), 201\n\n@app.route('/search', methods=['GET'])\ndef search_products():\n    name = request.args.get('name')\n    min_price = request.args.get('min_price')\n    max_price = request.args.get('max_price')\n    \n    query = {}\n    \n    if name:\n        query['name'] = {'$regex': name, '$options': 'i'}  # Case-insensitive search\n    \n    price_query = {}\n    if min_price:\n        try:\n            price_query['$gte'] = float(min_price)\n        except ValueError:\n            return jsonify({'error': 'min_price must be a number'}), 400\n    if max_price:\n        try:\n            price_query['$lte'] = float(max_price)\n        except ValueError:\n            return jsonify({'error': 'max_price must be a number'}), 400\n    \n    if price_query:\n        query['price'] = price_query\n    \n    # Execute the query\n    results = products_collection.find(query)\n    \n    # Convert results to list of dictionaries\n    products = [{'name': product['name'], 'price': product['price'], 'description': product['description'], 'id': str(product['_id'])} for product in results]\n    \n    return jsonify(products), 200\n\nif __name__ == '__main__':\n    app.run(debug=True)\n```\n\n### Explanation\n\n1. **Flask App Setup**:\n   - Import necessary modules and set up the Flask app.\n   - Configure MongoDB connection using PyMongo.\n\n2. **Add Product Endpoint** (`/add_product`):\n   - Accepts POST requests with JSON data containing `name`, `price`, and `description`.\n   - Validates that all required fields are present and of correct types.\n   - Ensures the name is a non-empty string and price is a positive number.\n   - Inserts the product into the MongoDB collection and returns a success message with the product's ID.\n\n3. **Search Products Endpoint** (`/search`):\n   - Accepts GET requests with optional query parameters `name`, `min_price`, and `max_price`.\n   - Builds a MongoDB query based on provided parameters.\n   - Performs case-insensitive regex search for the name.\n   - Validates and handles price range queries.\n   - Returns a JSON list of products that match the search criteria.\n\nThis API ensures proper validation and error handling for both adding and searching products, providing a robust foundation for managing product data in a MongoDB database."
    }
]