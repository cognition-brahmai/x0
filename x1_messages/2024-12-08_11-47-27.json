[
    {
        "role": "user",
        "content": "Create a Java program that connects to a PostgreSQL database, reads data from multiple tables with foreign key relationships, and performs complex queries involving joins, aggregations, and filtering based on user input.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Alright, I'm going to try to create a Java program that connects to a PostgreSQL database and does some fancy stuff with the data. I need to read from multiple tables that are related through foreign keys, and then perform some complex queries that involve joining these tables, aggregating data, and filtering based on user input.\n\nFirst things first, I need to set up the database connection. I've worked with JDBC before, so I should be okay there. I need to make sure I have the PostgreSQL JDBC driver included in my project. If I'm using Maven, I can add it as a dependency in the pom.xml file.\n\nOkay, so step one: Set up the database connection.\n\nI need to load the driver, then establish a connection using the URL, username, and password. Something like this:\n\n```java\nString url = \"jdbc:postgresql://localhost:5432/mydatabase\";\nString user = \"myuser\";\nString password = \"mypassword\";\n\ntry {\n    Connection connection = DriverManager.getConnection(url, user, password);\n    // Proceed with queries\n} catch (SQLException e) {\n    e.printStackTrace();\n}\n```\n\nNext, I need to understand the database schema. Since there are multiple tables with foreign key relationships, I need to know how they are linked. For example, let's assume I have two tables: \"orders\" and \"customers\", where \"orders\" has a foreign key referencing \"customers\".\n\nSo, tables:\n\n- customers: customer_id (primary key), name, email\n\n- orders: order_id (primary key), customer_id (foreign key), order_date, amount\n\nI need to perform joins to combine data from these tables based on the foreign key relationships.\n\nFor example, to get all orders along with customer names, I would join the orders and customers tables on customer_id.\n\nIn SQL, that would look like:\n\n```sql\nSELECT orders.order_id, customers.name, orders.order_date, orders.amount\nFROM orders\nJOIN customers ON orders.customer_id = customers.customer_id;\n```\n\nIn Java, I would execute this query using the Connection object, get a ResultSet, and then process it.\n\nBut the user wants complex queries involving aggregations and filtering. So, maybe they want to see the total amount ordered by each customer, or orders above a certain amount, or orders within a specific date range.\n\nLet me think about how to handle user input for filtering.\n\nI could prompt the user to enter criteria such as minimum order amount, date range, or customer name.\n\nThen, build the SQL query dynamically based on the user's input.\n\nFor example:\n\n- If the user specifies a minimum order amount, add a WHERE clause to filter orders with amount >= that value.\n\n- If the user specifies a date range, add a WHERE clause to filter orders within that date range.\n\n- If the user specifies a customer name, join with customers and add a WHERE clause to match the customer name.\n\nAlso, for aggregations, maybe they want to see the total amount ordered by each customer.\n\nThat would involve grouping by customer and summing the order amounts.\n\nIn SQL:\n\n```sql\nSELECT customers.name, SUM(orders.amount) as total_ordered\nFROM orders\nJOIN customers ON orders.customer_id = customers.customer_id\nGROUP BY customers.name;\n```\n\nI need to make sure to handle cases where there are no orders for a customer, perhaps using LEFT JOIN to include all customers, even those with no orders.\n\nAlso, need to handle null values appropriately.\n\nLet me sketch out the steps for the program:\n\n1. Establish database connection.\n\n2. Prompt user for input to define query filters and aggregation requirements.\n\n3. Based on user input, construct the SQL query dynamically.\n\n4. Execute the query and process the ResultSet.\n\n5. Display the results to the user.\n\nI need to make sure to use prepared statements to prevent SQL injection, especially since user input is involved.\n\nBut since the queries are complex and involve joins and aggregations, I need to build the SQL strings carefully.\n\nMaybe I can use string concatenation with placeholders for the user inputs in the WHERE clauses.\n\nWait, but that's prone to SQL injection. So, better to use prepared statements with ? placeholders for the user inputs.\n\nFor example:\n\n```java\nString sql = \"SELECT customers.name, orders.order_id, orders.order_date, orders.amount \" +\n             \"FROM orders \" +\n             \"JOIN customers ON orders.customer_id = customers.customer_id \" +\n             \"WHERE orders.amount >= ? AND orders.order_date BETWEEN ? AND ?\";\n```\n\nThen, set the parameters using the PreparedStatement:\n\n```java\nPreparedStatement pstmt = connection.prepareStatement(sql);\npstmt.setDouble(1, minValue);\npstmt.setDate(2, startDate);\npstmt.setDate(3, endDate);\n```\n\nThat's safer.\n\nNow, for aggregations, I might need to use GROUP BY in the query.\n\nMake sure to select the grouped columns and the aggregate functions correctly.\n\nAlso, need to handle different types of user input, like dates, numbers, strings, etc.\n\nI need to validate the user input to ensure it's in the correct format.\n\nFor example, dates should be in a specific format that can be parsed into java.sql.Date.\n\nLet me think about how to structure the user input prompts.\n\nMaybe I can present a menu to the user:\n\n- Option 1: View all orders with customer names.\n\n- Option 2: View total amount ordered by each customer.\n\n- Option 3: View orders above a certain amount.\n\n- Option 4: View orders within a date range.\n\n- Option 5: View orders for a specific customer.\n\nThen, based on the option selected, prompt for any necessary input parameters.\n\nFor example, for option 3, ask for the minimum order amount.\n\nFor option 4, ask for start date and end date.\n\nFor option 5, ask for customer name.\n\nThis way, the program is more user-friendly and less error-prone.\n\nAlso, I can predefine the SQL queries for each option and just adjust the WHERE clauses as needed.\n\nLet me start by writing the code to establish the database connection.\n\nFirst, I need to make sure the PostgreSQL JDBC driver is available.\n\nIf I'm using Maven, I can add this dependency:\n\n```xml\n<dependency>\n    <groupId>org.postgresql</groupId>\n    <artifactId>postgresql</artifactId>\n    <version>42.2.18</version>\n</dependency>\n```\n\nThen, in my Java code:\n\n```java\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.SQLException;\n\npublic class DatabaseConnector {\n    public static Connection connect() {\n        String url = \"jdbc:postgresql://localhost:5432/mydatabase\";\n        String user = \"myuser\";\n        String password = \"mypassword\";\n        Connection connection = null;\n        try {\n            connection = DriverManager.getConnection(url, user, password);\n        } catch (SQLException e) {\n            System.out.println(\"Database connection failed\");\n            e.printStackTrace();\n        }\n        return connection;\n    }\n}\n```\n\nNext, I can create a class to handle the user interface and query execution.\n\nLet's call it DatabaseQueryApp.\n\nIn this class, I can have a main method that presents the menu to the user and handles their choices.\n\nI'll use the Scanner class to read user input.\n\nFirst, import necessary classes:\n\n```java\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Scanner;\n```\n\nThen, define the DatabaseQueryApp class:\n\n```java\npublic class DatabaseQueryApp {\n    public static void main(String[] args) {\n        Connection connection = DatabaseConnector.connect();\n        if (connection != null) {\n            Scanner scanner = new Scanner(System.in);\n            boolean quit = false;\n            while (!quit) {\n                System.out.println(\"\\nPlease choose an option:\");\n                System.out.println(\"1: View all orders with customer names\");\n                System.out.println(\"2: View total amount ordered by each customer\");\n                System.out.println(\"3: View orders above a certain amount\");\n                System.out.println(\"4: View orders within a date range\");\n                System.out.println(\"5: View orders for a specific customer\");\n                System.out.println(\"6: Quit\");\n                int choice = scanner.nextInt();\n                scanner.nextLine(); // Consume newline\n\n                switch (choice) {\n                    case 1:\n                        viewAllOrders(connection);\n                        break;\n                    case 2:\n                        viewTotalPerCustomer(connection);\n                        break;\n                    case 3:\n                        viewOrdersAboveAmount(connection, scanner);\n                        break;\n                    case 4:\n                        viewOrdersInRange(connection, scanner);\n                        break;\n                    case 5:\n                        viewOrdersByCustomer(connection, scanner);\n                        break;\n                    case 6:\n                        quit = true;\n                        break;\n                    default:\n                        System.out.println(\"Invalid option. Please try again.\");\n                }\n            }\n            try {\n                connection.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    // Method implementations go here\n}\n```\n\nNow, I need to implement each of the methods corresponding to the menu options.\n\nStarting with viewAllOrders:\n\nThis should perform a simple join between orders and customers to display all orders with customer names.\n\nSQL:\n\n```sql\nSELECT customers.name, orders.order_id, orders.order_date, orders.amount\nFROM orders\nJOIN customers ON orders.customer_id = customers.customer_id\nORDER BY orders.order_id;\n```\n\nIn Java:\n\n```java\nprivate static void viewAllOrders(Connection connection) {\n    String sql = \"SELECT customers.name, orders.order_id, orders.order_date, orders.amount \" +\n                 \"FROM orders \" +\n                 \"JOIN customers ON orders.customer_id = customers.customer_id \" +\n                 \"ORDER BY orders.order_id\";\n    try {\n        PreparedStatement pstmt = connection.prepareStatement(sql);\n        ResultSet rs = pstmt.executeQuery();\n        while (rs.next()) {\n            String customerName = rs.getString(\"name\");\n            int orderId = rs.getInt(\"order_id\");\n            java.sql.Date orderDate = rs.getDate(\"order_date\");\n            double amount = rs.getDouble(\"amount\");\n            System.out.printf(\"Order %d: Customer %s, Date %s, Amount %.2f%n\",\n                              orderId, customerName, orderDate, amount);\n        }\n    } catch (SQLException e) {\n        e.printStackTrace();\n    }\n}\n```\n\nNext, viewTotalPerCustomer:\n\nThis should group orders by customer and sum the amounts.\n\nSQL:\n\n```sql\nSELECT customers.name, SUM(orders.amount) as total_ordered\nFROM orders\nJOIN customers ON orders.customer_id = customers.customer_id\nGROUP BY customers.name\nORDER BY total_ordered DESC;\n```\n\nIn Java:\n\n```java\nprivate static void viewTotalPerCustomer(Connection connection) {\n    String sql = \"SELECT customers.name, SUM(orders.amount) as total_ordered \" +\n                 \"FROM orders \" +\n                 \"JOIN customers ON orders.customer_id = customers.customer_id \" +\n                 \"GROUP BY customers.name \" +\n                 \"ORDER BY total_ordered DESC\";\n    try {\n        PreparedStatement pstmt = connection.prepareStatement(sql);\n        ResultSet rs = pstmt.executeQuery();\n        while (rs.next()) {\n            String customerName = rs.getString(\"name\");\n            double totalOrdered = rs.getDouble(\"total_ordered\");\n            System.out.printf(\"%s: Total ordered %.2f%n\", customerName, totalOrdered);\n        }\n    } catch (SQLException e) {\n        e.printStackTrace();\n    }\n}\n```\n\nNow, viewOrdersAboveAmount:\n\nThis requires user input for the minimum amount.\n\nSQL:\n\n```sql\nSELECT customers.name, orders.order_id, orders.order_date, orders.amount\nFROM orders\nJOIN customers ON orders.customer_id = customers.customer_id\nWHERE orders.amount >= ?\nORDER BY orders.amount DESC;\n```\n\nIn Java:\n\n```java\nprivate static void viewOrdersAboveAmount(Connection connection, Scanner scanner) {\n    System.out.print(\"Enter minimum order amount: \");\n    double minValue = scanner.nextDouble();\n    scanner.nextLine(); // Consume newline\n\n    String sql = \"SELECT customers.name, orders.order_id, orders.order_date, orders.amount \" +\n                 \"FROM orders \" +\n                 \"JOIN customers ON orders.customer_id = customers.customer_id \" +\n                 \"WHERE orders.amount >= ? \" +\n                 \"ORDER BY orders.amount DESC\";\n    try {\n        PreparedStatement pstmt = connection.prepareStatement(sql);\n        pstmt.setDouble(1, minValue);\n        ResultSet rs = pstmt.executeQuery();\n        while (rs.next()) {\n            String customerName = rs.getString(\"name\");\n            int orderId = rs.getInt(\"order_id\");\n            java.sql.Date orderDate = rs.getDate(\"order_date\");\n            double amount = rs.getDouble(\"amount\");\n            System.out.printf(\"Order %d: Customer %s, Date %s, Amount %.2f%n\",\n                              orderId, customerName, orderDate, amount);\n        }\n    } catch (SQLException e) {\n        e.printStackTrace();\n    }\n}\n```\n\nNext, viewOrdersInRange:\n\nThis requires user input for start and end dates.\n\nI need to handle date input carefully.\n\nSQL:\n\n```sql\nSELECT customers.name, orders.order_id, orders.order_date, orders.amount\nFROM orders\nJOIN customers ON orders.customer_id = customers.customer_id\nWHERE orders.order_date BETWEEN ? AND ?\nORDER BY orders.order_date;\n```\n\nIn Java:\n\n```java\nprivate static void viewOrdersInRange(Connection connection, Scanner scanner) {\n    System.out.print(\"Enter start date (yyyy-MM-dd): \");\n    String startDateStr = scanner.nextLine();\n    System.out.print(\"Enter end date (yyyy-MM-dd): \");\n    String endDateStr = scanner.nextLine();\n\n    java.sql.Date startDate = java.sql.Date.valueOf(startDateStr);\n    java.sql.Date endDate = java.sql.Date.valueOf(endDateStr);\n\n    String sql = \"SELECT customers.name, orders.order_id, orders.order_date, orders.amount \" +\n                 \"FROM orders \" +\n                 \"JOIN customers ON orders.customer_id = customers.customer_id \" +\n                 \"WHERE orders.order_date BETWEEN ? AND ? \" +\n                 \"ORDER BY orders.order_date\";\n    try {\n        PreparedStatement pstmt = connection.prepareStatement(sql);\n        pstmt.setDate(1, startDate);\n        pstmt.setDate(2, endDate);\n        ResultSet rs = pstmt.executeQuery();\n        while (rs.next()) {\n            String customerName = rs.getString(\"name\");\n            int orderId = rs.getInt(\"order_id\");\n            java.sql.Date orderDate = rs.getDate(\"order_date\");\n            double amount = rs.getDouble(\"amount\");\n            System.out.printf(\"Order %d: Customer %s, Date %s, Amount %.2f%n\",\n                              orderId, customerName, orderDate, amount);\n        }\n    } catch (SQLException e) {\n        e.printStackTrace();\n    }\n}\n```\n\nFinally, viewOrdersByCustomer:\n\nThis requires user input for the customer name.\n\nSQL:\n\n```sql\nSELECT customers.name, orders.order_id, orders.order_date, orders.amount\nFROM orders\nJOIN customers ON orders.customer_id = customers.customer_id\nWHERE customers.name = ?\nORDER BY orders.order_id;\n```\n\nIn Java:\n\n```java\nprivate static void viewOrdersByCustomer(Connection connection, Scanner scanner) {\n    System.out.print(\"Enter customer name: \");\n    String customerName = scanner.nextLine();\n\n    String sql = \"SELECT customers.name, orders.order_id, orders.order_date, orders.amount \" +\n                 \"FROM orders \" +\n                 \"JOIN customers ON orders.customer_id = customers.customer_id \" +\n                 \"WHERE customers.name = ? \" +\n                 \"ORDER BY orders.order_id\";\n    try {\n        PreparedStatement pstmt = connection.prepareStatement(sql);\n        pstmt.setString(1, customerName);\n        ResultSet rs = pstmt.executeQuery();\n        while (rs.next()) {\n            String custName = rs.getString(\"name\");\n            int orderId = rs.getInt(\"order_id\");\n            java.sql.Date orderDate = rs.getDate(\"order_date\");\n            double amount = rs.getDouble(\"amount\");\n            System.out.printf(\"Order %d: Customer %s, Date %s, Amount %.2f%n\",\n                              orderId, custName, orderDate, amount);\n        }\n    } catch (SQLException e) {\n        e.printStackTrace();\n    }\n}\n```\n\nI should also add some error handling for invalid dates or other input errors.\n\nFor example, if the user enters an invalid date format, Date.valueOf() will throw an exception.\n\nI need to handle such cases gracefully.\n\nPerhaps I can surround the date parsing with try-catch blocks and inform the user if there's an error.\n\nSimilarly, for other inputs, ensure that the program doesn't crash due to invalid input.\n\nAlso, consider adding pagination for queries that might return a large number of rows.\n\nBut for simplicity, I'll skip that for now.\n\nLastly, make sure to close all resources like ResultSet, PreparedStatement, and Connection to avoid leaks.\n\nIn a real-world application, I would use try-with-resources or ensure that these are closed finally.\n\nBut for this example, I'll keep it simple.\n\nThat's pretty much it.\n\nI think this should cover the requirements of connecting to a PostgreSQL database, performing joins, aggregations, and filtering based on user input.\n\n## Final Solution\nTo create a Java program that connects to a PostgreSQL database, reads data from multiple tables with foreign key relationships, and performs complex queries involving joins, aggregations, and filtering based on user input, follow these steps.\n\n### Prerequisites\n\n1. **Java Development Kit (JDK)** installed.\n2. **PostgreSQL JDBC Driver** added to your project dependencies. If using Maven, include the following dependency in your `pom.xml`:\n\n    ```xml\n    <dependency>\n        <groupId>org.postgresql</groupId>\n        <artifactId>postgresql</artifactId>\n        <version>42.2.18</version>\n    </dependency>\n    ```\n\n3. A PostgreSQL database with relevant tables and data.\n\n### Solution Code\n\n#### DatabaseConnector.java\n\nManages the database connection.\n\n```java\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.SQLException;\n\npublic class DatabaseConnector {\n    public static Connection connect() {\n        String url = \"jdbc:postgresql://localhost:5432/mydatabase\";\n        String user = \"myuser\";\n        String password = \"mypassword\";\n        Connection connection = null;\n        try {\n            connection = DriverManager.getConnection(url, user, password);\n        } catch (SQLException e) {\n            System.out.println(\"Database connection failed\");\n            e.printStackTrace();\n        }\n        return connection;\n    }\n}\n```\n\n#### DatabaseQueryApp.java\n\nHandles user interactions and executes database queries based on user choices.\n\n```java\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Scanner;\n\npublic class DatabaseQueryApp {\n    public static void main(String[] args) {\n        Connection connection = DatabaseConnector.connect();\n        if (connection != null) {\n            Scanner scanner = new Scanner(System.in);\n            boolean quit = false;\n            while (!quit) {\n                System.out.println(\"\\nPlease choose an option:\");\n                System.out.println(\"1: View all orders with customer names\");\n                System.out.println(\"2: View total amount ordered by each customer\");\n                System.out.println(\"3: View orders above a certain amount\");\n                System.out.println(\"4: View orders within a date range\");\n                System.out.println(\"5: View orders for a specific customer\");\n                System.out.println(\"6: Quit\");\n                int choice = scanner.nextInt();\n                scanner.nextLine(); // Consume newline\n\n                switch (choice) {\n                    case 1:\n                        viewAllOrders(connection);\n                        break;\n                    case 2:\n                        viewTotalPerCustomer(connection);\n                        break;\n                    case 3:\n                        viewOrdersAboveAmount(connection, scanner);\n                        break;\n                    case 4:\n                        viewOrdersInRange(connection, scanner);\n                        break;\n                    case 5:\n                        viewOrdersByCustomer(connection, scanner);\n                        break;\n                    case 6:\n                        quit = true;\n                        break;\n                    default:\n                        System.out.println(\"Invalid option. Please try again.\");\n                }\n            }\n            try {\n                connection.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private static void viewAllOrders(Connection connection) {\n        String sql = \"SELECT customers.name, orders.order_id, orders.order_date, orders.amount \" +\n                     \"FROM orders \" +\n                     \"JOIN customers ON orders.customer_id = customers.customer_id \" +\n                     \"ORDER BY orders.order_id\";\n        try {\n            PreparedStatement pstmt = connection.prepareStatement(sql);\n            ResultSet rs = pstmt.executeQuery();\n            while (rs.next()) {\n                String customerName = rs.getString(\"name\");\n                int orderId = rs.getInt(\"order_id\");\n                java.sql.Date orderDate = rs.getDate(\"order_date\");\n                double amount = rs.getDouble(\"amount\");\n                System.out.printf(\"Order %d: Customer %s, Date %s, Amount %.2f%n\",\n                                  orderId, customerName, orderDate, amount);\n            }\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void viewTotalPerCustomer(Connection connection) {\n        String sql = \"SELECT customers.name, SUM(orders.amount) as total_ordered \" +\n                     \"FROM orders \" +\n                     \"JOIN customers ON orders.customer_id = customers.customer_id \" +\n                     \"GROUP BY customers.name \" +\n                     \"ORDER BY total_ordered DESC\";\n        try {\n            PreparedStatement pstmt = connection.prepareStatement(sql);\n            ResultSet rs = pstmt.executeQuery();\n            while (rs.next()) {\n                String customerName = rs.getString(\"name\");\n                double totalOrdered = rs.getDouble(\"total_ordered\");\n                System.out.printf(\"%s: Total ordered %.2f%n\", customerName, totalOrdered);\n            }\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void viewOrdersAboveAmount(Connection connection, Scanner scanner) {\n        System.out.print(\"Enter minimum order amount: \");\n        double minValue = scanner.nextDouble();\n        scanner.nextLine(); // Consume newline\n\n        String sql = \"SELECT customers.name, orders.order_id, orders.order_date, orders.amount \" +\n                     \"FROM orders \" +\n                     \"JOIN customers ON orders.customer_id = customers.customer_id \" +\n                     \"WHERE orders.amount >= ? \" +\n                     \"ORDER BY orders.amount DESC\";\n        try {\n            PreparedStatement pstmt = connection.prepareStatement(sql);\n            pstmt.setDouble(1, minValue);\n            ResultSet rs = pstmt.executeQuery();\n            while (rs.next()) {\n                String customerName = rs.getString(\"name\");\n                int orderId = rs.getInt(\"order_id\");\n                java.sql.Date orderDate = rs.getDate(\"order_date\");\n                double amount = rs.getDouble(\"amount\");\n                System.out.printf(\"Order %d: Customer %s, Date %s, Amount %.2f%n\",\n                                  orderId, customerName, orderDate, amount);\n            }\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void viewOrdersInRange(Connection connection, Scanner scanner) {\n        System.out.print(\"Enter start date (yyyy-MM-dd): \");\n        String startDateStr = scanner.nextLine();\n        System.out.print(\"Enter end date (yyyy-MM-dd): \");\n        String endDateStr = scanner.nextLine();\n\n        java.sql.Date startDate = java.sql.Date.valueOf(startDateStr);\n        java.sql.Date endDate = java.sql.Date.valueOf(endDateStr);\n\n        String sql = \"SELECT customers.name, orders.order_id, orders.order_date, orders.amount \" +\n                     \"FROM orders \" +\n                     \"JOIN customers ON orders.customer_id = customers.customer_id \" +\n                     \"WHERE orders.order_date BETWEEN ? AND ? \" +\n                     \"ORDER BY orders.order_date\";\n        try {\n            PreparedStatement pstmt = connection.prepareStatement(sql);\n            pstmt.setDate(1, startDate);\n            pstmt.setDate(2, endDate);\n            ResultSet rs = pstmt.executeQuery();\n            while (rs.next()) {\n                String customerName = rs.getString(\"name\");\n                int orderId = rs.getInt(\"order_id\");\n                java.sql.Date orderDate = rs.getDate(\"order_date\");\n                double amount = rs.getDouble(\"amount\");\n                System.out.printf(\"Order %d: Customer %s, Date %s, Amount %.2f%n\",\n                                  orderId, customerName, orderDate, amount);\n            }\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void viewOrdersByCustomer(Connection connection, Scanner scanner) {\n        System.out.print(\"Enter customer name: \");\n        String customerName = scanner.nextLine();\n\n        String sql = \"SELECT customers.name, orders.order_id, orders.order_date, orders.amount \" +\n                     \"FROM orders \" +\n                     \"JOIN customers ON orders.customer_id = customers.customer_id \" +\n                     \"WHERE customers.name = ? \" +\n                     \"ORDER BY orders.order_id\";\n        try {\n            PreparedStatement pstmt = connection.prepareStatement(sql);\n            pstmt.setString(1, customerName);\n            ResultSet rs = pstmt.executeQuery();\n            while (rs.next()) {\n                String custName = rs.getString(\"name\");\n                int orderId = rs.getInt(\"order_id\");\n                java.sql.Date orderDate = rs.getDate(\"order_date\");\n                double amount = rs.getDouble(\"amount\");\n                System.out.printf(\"Order %d: Customer %s, Date %s, Amount %.2f%n\",\n                                  orderId, custName, orderDate, amount);\n            }\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n### Explanation\n\n1. **Database Connection**: The `DatabaseConnector` class manages the JDBC connection to the PostgreSQL database.\n2. **User Interface**: The `DatabaseQueryApp` class provides a menu-driven interface for users to select different query operations.\n3. **Query Execution**: Based on user input, the appropriate method is called to execute the corresponding SQL query using PreparedStatements to prevent SQL injection.\n4. **Results Display**: Query results are fetched and displayed in a formatted manner.\n\nThis setup ensures that the program is user-friendly, handles various query complexities, and maintains safety against SQL injection through the use of prepared statements."
    }
]