[
    {
        "role": "user",
        "content": "Design a TypeScript class that represents a basic graph data structure with nodes and edges. Implement methods for adding nodes, connecting nodes with edges, and performing depth-first and breadth-first traversals.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Sure, I can help you with that! Let's design a simple graph data structure in TypeScript. We'll create a class that allows us to add nodes, connect them with edges, and perform both depth-first search (DFS) and breadth-first search (BFS) traversals.\n\nFirst, we need to define what a graph is. A graph consists of nodes (also called vertices) and edges that connect these nodes. In this implementation, we'll consider an undirected graph, meaning that edges don't have a direction.\n\n### Step 1: Define the Graph Class\n\nWe'll start by creating a class called `Graph`. This class will have a map to store nodes, where each node is identified by a unique key.\n\n```typescript\nclass Graph {\n  private nodes: Map<string, Set<string>>;\n\n  constructor() {\n    this.nodes = new Map();\n  }\n}\n```\n\n### Step 2: Add Nodes\n\nWe need a method to add nodes to the graph. Each node will be identified by a unique string key.\n\n```typescript\naddNode(node: string): void {\n  if (!this.nodes.has(node)) {\n    this.nodes.set(node, new Set());\n  } else {\n    console.log(`Node ${node} already exists.`);\n  }\n}\n```\n\n### Step 3: Connect Nodes with Edges\n\nTo connect two nodes with an edge, we'll add each node to the other's set of neighbors.\n\n```typescript\naddEdge(node1: string, node2: string): void {\n  if (this.nodes.has(node1) && this.nodes.has(node2)) {\n    this.nodes.get(node1)?.add(node2);\n    this.nodes.get(node2)?.add(node1);\n  } else {\n    console.log(\"Both nodes must exist in the graph to create an edge.\");\n  }\n}\n```\n\n### Step 4: Depth-First Search (DFS)\n\nDFS traverses the graph by exploring as far as possible along each branch before backtracking.\n\n```typescript\ndfs(startNode: string): string[] {\n  const visited = new Set<string>();\n  const result: string[] = [];\n\n  const traverse = (node: string): void => {\n    if (!visited.has(node)) {\n      visited.add(node);\n      result.push(node);\n      const neighbors = this.nodes.get(node);\n      if (neighbors) {\n        for (const neighbor of neighbors) {\n          traverse(neighbor);\n        }\n      }\n    }\n  };\n\n  traverse(startNode);\n  return result;\n}\n```\n\n### Step 5: Breadth-First Search (BFS)\n\nBFS traverses the graph level by level, exploring all neighbors before moving to the next level.\n\n```typescript\nbfs(startNode: string): string[] {\n  const visited = new Set<string>();\n  const result: string[] = [];\n  const queue: string[] = [];\n\n  queue.push(startNode);\n  visited.add(startNode);\n\n  while (queue.length > 0) {\n    const node = queue.shift();\n    if (node) {\n      result.push(node);\n      const neighbors = this.nodes.get(node);\n      if (neighbors) {\n        for (const neighbor of neighbors) {\n          if (!visited.has(neighbor)) {\n            queue.push(neighbor);\n            visited.add(neighbor);\n          }\n        }\n      }\n    }\n  }\n\n  return result;\n}\n```\n\n### Final Graph Class\n\nPutting it all together, here's the complete `Graph` class:\n\n```typescript\nclass Graph {\n  private nodes: Map<string, Set<string>>;\n\n  constructor() {\n    this.nodes = new Map();\n  }\n\n  addNode(node: string): void {\n    if (!this.nodes.has(node)) {\n      this.nodes.set(node, new Set());\n    } else {\n      console.log(`Node ${node} already exists.`);\n    }\n  }\n\n  addEdge(node1: string, node2: string): void {\n    if (this.nodes.has(node1) && this.nodes.has(node2)) {\n      this.nodes.get(node1)?.add(node2);\n      this.nodes.get(node2)?.add(node1);\n    } else {\n      console.log(\"Both nodes must exist in the graph to create an edge.\");\n    }\n  }\n\n  dfs(startNode: string): string[] {\n    const visited = new Set<string>();\n    const result: string[] = [];\n\n    const traverse = (node: string): void => {\n      if (!visited.has(node)) {\n        visited.add(node);\n        result.push(node);\n        const neighbors = this.nodes.get(node);\n        if (neighbors) {\n          for (const neighbor of neighbors) {\n            traverse(neighbor);\n          }\n        }\n      }\n    };\n\n    traverse(startNode);\n    return result;\n  }\n\n  bfs(startNode: string): string[] {\n    const visited = new Set<string>();\n    const result: string[] = [];\n    const queue: string[] = [];\n\n    queue.push(startNode);\n    visited.add(startNode);\n\n    while (queue.length > 0) {\n      const node = queue.shift();\n      if (node) {\n        result.push(node);\n        const neighbors = this.nodes.get(node);\n        if (neighbors) {\n          for (const neighbor of neighbors) {\n            if (!visited.has(neighbor)) {\n              queue.push(neighbor);\n              visited.add(neighbor);\n            }\n          }\n        }\n      }\n    }\n\n    return result;\n  }\n}\n```\n\n### Example Usage\n\nHere's how you can use this `Graph` class:\n\n```typescript\nconst graph = new Graph();\n\ngraph.addNode(\"A\");\ngraph.addNode(\"B\");\ngraph.addNode(\"C\");\ngraph.addNode(\"D\");\n\ngraph.addEdge(\"A\", \"B\");\ngraph.addEdge(\"A\", \"C\");\ngraph.addEdge(\"B\", \"D\");\ngraph.addEdge(\"C\", \"D\");\n\nconsole.log(\"DFS traversal starting from A:\", graph.dfs(\"A\"));\nconsole.log(\"BFS traversal starting from A:\", graph.bfs(\"A\"));\n```\n\nThis should output:\n\n```\nDFS traversal starting from A: [ 'A', 'B', 'D', 'C' ]\nBFS traversal starting from A: [ 'A', 'B', 'C', 'D' ]\n```\n\nI hope this helps! Let me know if you have any questions or need further explanations."
    }
]