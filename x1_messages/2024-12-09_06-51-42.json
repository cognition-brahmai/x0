[
    {
        "role": "user",
        "content": "Create a Python program that implements a simple trie data structure for storing words. The trie should support insertion, deletion, and searching operations."
    },
    {
        "role": "assistant",
        "content": "Sure! I can help you with that. A trie, also known as a prefix tree, is a tree-like data structure that is commonly used to store a dynamic set of strings, where the keys are usually strings. Each node in the trie represents a single character of the key, and the path from the root to any node forms a prefix of the keys stored in the trie.\n\nImplementing a trie in Python involves creating a class to represent each node in the trie and another class to manage the trie operations such as insertion, deletion, and searching.\n\nHere's a simple implementation of a trie in Python:\n\n```python\nclass TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def insert(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                node.children[char] = TrieNode()\n            node = node.children[char]\n        node.is_end_of_word = True\n\n    def search(self, word):\n        node = self.root\n        for char in word:\n            if char not in node.children:\n                return False\n            node = node.children[char]\n        return node.is_end_of_word\n\n    def delete(self, word):\n        def _delete(node, word, index):\n            if index == len(word):\n                if not node.is_end_of_word:\n                    return False\n                node.is_end_of_word = False\n                return len(node.children) == 0\n            char = word[index]\n            if char not in node.children:\n                return False\n            should_delete_current_node = _delete(node.children[char], word, index + 1)\n            if should_delete_current_node:\n                del node.children[char]\n                return len(node.children) == 0\n            return False\n        _delete(self.root, word, 0)\n\n# Example usage:\ntrie = Trie()\ntrie.insert(\"hello\")\ntrie.insert(\"world\")\nprint(trie.search(\"hello\"))  # Output: True\nprint(trie.search(\"world\"))  # Output: True\nprint(trie.search(\"hell\"))   # Output: False\ntrie.delete(\"hello\")\nprint(trie.search(\"hello\"))  # Output: False\n```\n\n### Explanation:\n\n1. **TrieNode Class**:\n   - Each node contains a dictionary (`children`) to hold references to its child nodes.\n   - A boolean flag (`is_end_of_word`) to mark the end of a word.\n\n2. **Trie Class**:\n   - The `root` attribute is the root node of the trie.\n   - **insert(word)**: Inserts a word into the trie. It traverses the trie, creating new nodes for each character if they don't already exist. Finally, it marks the end of the word.\n   - **search(word)**: Searches for a word in the trie. It traverses the trie following the path defined by the characters in the word. If the entire word is found and the end node is marked as the end of a word, it returns `True`; otherwise, `False`.\n   - **delete(word)**: Deletes a word from the trie. It uses a helper function `_delete` to traverse the trie and remove nodes corresponding to the word. It also cleans up any empty nodes that are no longer part of any other word.\n\nThis implementation provides the basic operations needed for a trie and can be extended with additional features as needed."
    }
]