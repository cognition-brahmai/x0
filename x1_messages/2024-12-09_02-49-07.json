[
    {
        "role": "user",
        "content": "Write a Java program that implements a simple LRU (Least Recently Used) cache with a fixed size. The cache should support insertion, deletion, and retrieval operations in O(1) time complexity."
    },
    {
        "role": "assistant",
        "content": "Implementing an LRU (Least Recently Used) cache in Java with O(1) time complexity for insertion, deletion, and retrieval operations requires a combination of a HashMap and a Doubly Linked List. The HashMap provides quick access to the cache entries, while the Doubly Linked List helps in maintaining the order of usage.\n\nBelow is a simple implementation of an LRU cache in Java:\n\n```java\nimport java.util.HashMap;\n\nclass LRUCache {\n    class DLinkedNode {\n        int key;\n        int value;\n        DLinkedNode prev;\n        DLinkedNode next;\n    }\n\n    private void addNode(DLinkedNode node) {\n        node.prev = head;\n        node.next = head.next;\n\n        head.next.prev = node;\n        head.next = node;\n    }\n\n    private void removeNode(DLinkedNode node){\n        DLinkedNode prev = node.prev;\n        DLinkedNode next = node.next;\n\n        prev.next = next;\n        next.prev = prev;\n    }\n\n    private void moveToHead(DLinkedNode node){\n        removeNode(node);\n        addNode(node);\n    }\n\n    private DLinkedNode popTail() {\n        DLinkedNode res = tail.prev;\n        removeNode(res);\n        return res;\n    }\n\n    private DLinkedNode head;\n    private DLinkedNode tail;\n    private HashMap<Integer, DLinkedNode> cache = new HashMap<Integer, DLinkedNode>();\n    private int size;\n    private int capacity;\n\n    public LRUCache(int capacity) {\n        this.size = 0;\n        this.capacity = capacity;\n\n        head = new DLinkedNode();\n        // head.prev = null;\n\n        tail = new DLinkedNode();\n        // tail.next = null;\n\n        head.next = tail;\n        tail.prev = head;\n    }\n\n    public int get(int key) {\n        DLinkedNode node = cache.get(key);\n        if (node == null) return -1;\n\n        // move the accessed node to the head;\n        moveToHead(node);\n\n        return node.value;\n    }\n\n    public void put(int key, int value) {\n        DLinkedNode node = cache.get(key);\n\n        if(node == null) {\n            DLinkedNode newNode = new DLinkedNode();\n            newNode.key = key;\n            newNode.value = value;\n\n            cache.put(key, newNode);\n            addNode(newNode);\n\n            ++size;\n\n            if(size > capacity) {\n                // pop the tail\n                DLinkedNode tail = popTail();\n                cache.remove(tail.key);\n                --size;\n            }\n        } else {\n            // update the value.\n            node.value = value;\n            moveToHead(node);\n        }\n    }\n}\n```\n\nThis implementation maintains a doubly linked list to keep track of the order of usage. The `addNode` and `removeNode` methods manage the insertion and removal of nodes in the linked list, while `moveToHead` is used to move a recently used node to the front of the list. The `popTail` method removes the least recently used node from the end of the list.\n\nThe `get` method retrieves a value from the cache and moves the corresponding node to the front of the list if it exists. The `put` method inserts a new key-value pair into the cache, moving the corresponding node to the front if it already exists, or adding a new node if it doesn't, and evicting the least recently used item if the cache exceeds its capacity.\n\nThis design ensures that all operations are performed in O(1) time complexity, meeting the requirements for an efficient LRU cache."
    }
]