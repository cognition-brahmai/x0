[
    {
        "role": "user",
        "content": "Write a Java program that implements a doubly linked list data structure with methods for adding elements at the beginning, end, and specified index, as well as removing elements by value or index.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Alright, I'm going to write a Java program that implements a doubly linked list. I need to make sure that it has methods for adding elements at the beginning, end, and at a specified index. Also, it should have methods for removing elements by value or by index. Let's start by understanding what a doubly linked list is.\n\nA doubly linked list is a type of linked list in which each node has pointers to both the next and previous nodes. This allows traversing the list in both forward and backward directions.\n\nFirst, I need to define the structure of a node in the doubly linked list. Each node should contain the data and two references: one to the next node and one to the previous node.\n\nI'll create a class called `DoublyLinkedList` that will have a private inner class called `Node` to represent each element in the list.\n\nI need to keep track of the head and tail of the list, as well as the size of the list.\n\nLet's list out the methods I need to implement:\n\n1. `addFirst(E element)`: Adds an element to the beginning of the list.\n\n2. `addLast(E element)`: Adds an element to the end of the list.\n\n3. `add(int index, E element)`: Adds an element at the specified index.\n\n4. `remove(int index)`: Removes the element at the specified index.\n\n5. `remove(E element)`: Removes the first occurrence of the specified element.\n\n6. Optionally, I can implement other methods like `get(int index)`, `size()`, `isEmpty()`, etc., but for now, I'll focus on the required methods.\n\nI should also handle edge cases, such as:\n\n- Adding to an empty list.\n\n- Adding or removing from index 0.\n\n- Adding or removing from the end of the list.\n\n- Handling invalid indices.\n\n- Removing an element that doesn't exist.\n\nI need to decide on the type of elements the list will hold. Since it's a generic doubly linked list, I'll make the class generic, like `DoublyLinkedList<E>`.\n\nLet me start by defining the `Node` class.\n\n```java\nprivate static class Node<E> {\n    E data;\n    Node<E> prev;\n    Node<E> next;\n\n    Node(E data) {\n        this.data = data;\n        this.prev = null;\n        this.next = null;\n    }\n}\n```\n\nNow, the `DoublyLinkedList` class.\n\n```java\npublic class DoublyLinkedList<E> {\n    private Node<E> head;\n    private Node<E> tail;\n    private int size;\n\n    public DoublyLinkedList() {\n        this.head = null;\n        this.tail = null;\n        this.size = 0;\n    }\n\n    // Method to add an element to the beginning of the list\n    public void addFirst(E element) {\n        Node<E> newNode = new Node<>(element);\n        if (head == null) {\n            head = newNode;\n            tail = newNode;\n        } else {\n            newNode.next = head;\n            head.prev = newNode;\n            head = newNode;\n        }\n        size++;\n    }\n\n    // Method to add an element to the end of the list\n    public void addLast(E element) {\n        Node<E> newNode = new Node<>(element);\n        if (tail == null) {\n            head = newNode;\n            tail = newNode;\n        } else {\n            newNode.prev = tail;\n            tail.next = newNode;\n            tail = newNode;\n        }\n        size++;\n    }\n\n    // Method to add an element at a specified index\n    public void add(int index, E element) {\n        if (index < 0 || index > size) {\n            throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size: \" + size);\n        }\n        if (index == 0) {\n            addFirst(element);\n        } else if (index == size) {\n            addLast(element);\n        } else {\n            Node<E> current = getNode(index);\n            Node<E> newNode = new Node<>(element);\n            newNode.prev = current.prev;\n            newNode.next = current;\n            current.prev.next = newNode;\n            current.prev = newNode;\n            size++;\n        }\n    }\n\n    // Method to remove the element at a specified index\n    public E remove(int index) {\n        if (index < 0 || index >= size) {\n            throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size: \" + size);\n        }\n        if (index == 0) {\n            return removeFirst();\n        } else if (index == size - 1) {\n            return removeLast();\n        } else {\n            Node<E> current = getNode(index);\n            current.prev.next = current.next;\n            current.next.prev = current.prev;\n            size--;\n            return current.data;\n        }\n    }\n\n    // Method to remove the first occurrence of a specified element\n    public boolean remove(E element) {\n        Node<E> current = head;\n        while (current != null) {\n            if (current.data.equals(element)) {\n                if (current == head) {\n                    removeFirst();\n                } else if (current == tail) {\n                    removeLast();\n                } else {\n                    current.prev.next = current.next;\n                    current.next.prev = current.prev;\n                    size--;\n                }\n                return true;\n            }\n            current = current.next;\n        }\n        return false;\n    }\n\n    // Helper method to get the node at a specified index\n    private Node<E> getNode(int index) {\n        if (index < (size >> 1)) { // if index is closer to the head\n            Node<E> current = head;\n            for (int i = 0; i < index; i++) {\n                current = current.next;\n            }\n            return current;\n        } else { // index is closer to the tail\n            Node<E> current = tail;\n            for (int i = size - 1; i > index; i--) {\n                current = current.prev;\n            }\n            return current;\n        }\n    }\n\n    // Method to remove the first element\n    private E removeFirst() {\n        if (head == null) {\n            throw new NoSuchElementException();\n        }\n        E data = head.data;\n        head = head.next;\n        if (head == null) {\n            tail = null;\n        } else {\n            head.prev = null;\n        }\n        size--;\n        return data;\n    }\n\n    // Method to remove the last element\n    private E removeLast() {\n        if (tail == null) {\n            throw new NoSuchElementException();\n        }\n        E data = tail.data;\n        tail = tail.prev;\n        if (tail == null) {\n            head = null;\n        } else {\n            tail.next = null;\n        }\n        size--;\n        return data;\n    }\n\n    // Method to get the size of the list\n    public int size() {\n        return size;\n    }\n\n    // Method to check if the list is empty\n    public boolean isEmpty() {\n        return size == 0;\n    }\n\n    // Method to print the list\n    public void printList() {\n        Node<E> current = head;\n        while (current != null) {\n            System.out.print(current.data + \" \");\n            current = current.next;\n        }\n        System.out.println();\n    }\n}\n```\n\nI think this covers the basic requirements. I've implemented methods to add elements at the beginning, end, and at a specified index, as well as remove elements by value or index. I've also included some helper methods like `size()`, `isEmpty()`, and `printList()` for testing purposes.\n\nI should test this implementation to make sure it works correctly.\n\nLet me write a simple test class to verify the functionality.\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        DoublyLinkedList<Integer> list = new DoublyLinkedList<>();\n\n        list.addFirst(10);\n        list.printList(); // Expected: 10\n\n        list.addLast(20);\n        list.printList(); // Expected: 10 20\n\n        list.add(1, 15);\n        list.printList(); // Expected: 10 15 20\n\n        list.remove(1);\n        list.printList(); // Expected: 10 20\n\n        list.remove(10);\n        list.printList(); // Expected: 20\n\n        list.addFirst(5);\n        list.addLast(25);\n        list.printList(); // Expected: 5 20 25\n\n        list.remove(0);\n        list.printList(); // Expected: 20 25\n\n        list.remove(25);\n        list.printList(); // Expected: 20\n\n        list.remove(0);\n        list.printList(); // Expected: empty\n\n        System.out.println(\"Size: \" + list.size()); // Expected: 0\n    }\n}\n```\n\nThis test seems to cover various scenarios, including adding and removing elements at different positions, removing by value, and handling empty lists.\n\nI should also consider edge cases like removing from an empty list or adding/removing at invalid indices.\n\nLet me add some more tests for edge cases.\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        DoublyLinkedList<Integer> list = new DoublyLinkedList<>();\n\n        list.addFirst(10);\n        list.printList(); // Expected: 10\n\n        list.addLast(20);\n        list.printList(); // Expected: 10 20\n\n        list.add(1, 15);\n        list.printList(); // Expected: 10 15 20\n\n        list.remove(1);\n        list.printList(); // Expected: 10 20\n\n        list.remove(10);\n        list.printList(); // Expected: 20\n\n        list.addFirst(5);\n        list.addLast(25);\n        list.printList(); // Expected: 5 20 25\n\n        list.remove(0);\n        list.printList(); // Expected: 20 25\n\n        list.remove(25);\n        list.printList(); // Expected: 20\n\n        list.remove(0);\n        list.printList(); // Expected: empty\n\n        System.out.println(\"Size: \" + list.size()); // Expected: 0\n\n        // Edge cases\n        try {\n            list.remove(0);\n        } catch (IndexOutOfBoundsException e) {\n            System.out.println(\"Caught exception: \" + e.getMessage());\n        }\n\n        try {\n            list.add(-1, 1);\n        } catch (IndexOutOfBoundsException e) {\n            System.out.println(\"Caught exception: \" + e.getMessage());\n        }\n\n        try {\n            list.add(1, 1);\n        } catch (IndexOutOfBoundsException e) {\n            System.out.println(\"Caught exception: \" + e.getMessage());\n        }\n\n        list.addFirst(1);\n        list.printList(); // Expected: 1\n\n        list.remove(1);\n        list.printList(); // Expected: 1\n\n        list.remove(0);\n        list.printList(); // Expected: empty\n    }\n}\n```\n\nThis should cover most of the edge cases. I need to make sure that the program handles invalid indices and empty lists gracefully, throwing appropriate exceptions where necessary.\n\nI should also ensure that the `size` variable is updated correctly after each addition and removal.\n\nAdditionally, I can implement other methods like `get(int index)`, `set(int index, E element)`, etc., to make the list more functional, but for now, I'll stick to the required methods.\n\nI think this implementation should work fine for the specified requirements.\n\n## Final Solution\nTo implement a doubly linked list in Java with methods for adding elements at the beginning, end, and specified index, as well as removing elements by value or index, you can use the following code:\n\n```java\npublic class DoublyLinkedList<E> {\n    private static class Node<E> {\n        E data;\n        Node<E> prev;\n        Node<E> next;\n\n        Node(E data) {\n            this.data = data;\n            this.prev = null;\n            this.next = null;\n        }\n    }\n\n    private Node<E> head;\n    private Node<E> tail;\n    private int size;\n\n    public DoublyLinkedList() {\n        this.head = null;\n        this.tail = null;\n        this.size = 0;\n    }\n\n    public void addFirst(E element) {\n        Node<E> newNode = new Node<>(element);\n        if (head == null) {\n            head = newNode;\n            tail = newNode;\n        } else {\n            newNode.next = head;\n            head.prev = newNode;\n            head = newNode;\n        }\n        size++;\n    }\n\n    public void addLast(E element) {\n        Node<E> newNode = new Node<>(element);\n        if (tail == null) {\n            head = newNode;\n            tail = newNode;\n        } else {\n            newNode.prev = tail;\n            tail.next = newNode;\n            tail = newNode;\n        }\n        size++;\n    }\n\n    public void add(int index, E element) {\n        if (index < 0 || index > size) {\n            throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size: \" + size);\n        }\n        if (index == 0) {\n            addFirst(element);\n        } else if (index == size) {\n            addLast(element);\n        } else {\n            Node<E> current = getNode(index);\n            Node<E> newNode = new Node<>(element);\n            newNode.prev = current.prev;\n            newNode.next = current;\n            current.prev.next = newNode;\n            current.prev = newNode;\n            size++;\n        }\n    }\n\n    public E remove(int index) {\n        if (index < 0 || index >= size) {\n            throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size: \" + size);\n        }\n        if (index == 0) {\n            return removeFirst();\n        } else if (index == size - 1) {\n            return removeLast();\n        } else {\n            Node<E> current = getNode(index);\n            current.prev.next = current.next;\n            current.next.prev = current.prev;\n            size--;\n            return current.data;\n        }\n    }\n\n    public boolean remove(E element) {\n        Node<E> current = head;\n        while (current != null) {\n            if (current.data.equals(element)) {\n                if (current == head) {\n                    removeFirst();\n                } else if (current == tail) {\n                    removeLast();\n                } else {\n                    current.prev.next = current.next;\n                    current.next.prev = current.prev;\n                    size--;\n                }\n                return true;\n            }\n            current = current.next;\n        }\n        return false;\n    }\n\n    private Node<E> getNode(int index) {\n        if (index < (size >> 1)) { // if index is closer to the head\n            Node<E> current = head;\n            for (int i = 0; i < index; i++) {\n                current = current.next;\n            }\n            return current;\n        } else { // index is closer to the tail\n            Node<E> current = tail;\n            for (int i = size - 1; i > index; i--) {\n                current = current.prev;\n            }\n            return current;\n        }\n    }\n\n    private E removeFirst() {\n        if (head == null) {\n            throw new NoSuchElementException();\n        }\n        E data = head.data;\n        head = head.next;\n        if (head == null) {\n            tail = null;\n        } else {\n            head.prev = null;\n        }\n        size--;\n        return data;\n    }\n\n    private E removeLast() {\n        if (tail == null) {\n            throw new NoSuchElementException();\n        }\n        E data = tail.data;\n        tail = tail.prev;\n        if (tail == null) {\n            head = null;\n        } else {\n            tail.next = null;\n        }\n        size--;\n        return data;\n    }\n\n    public int size() {\n        return size;\n    }\n\n    public boolean isEmpty() {\n        return size == 0;\n    }\n\n    public void printList() {\n        Node<E> current = head;\n        while (current != null) {\n            System.out.print(current.data + \" \");\n            current = current.next;\n        }\n        System.out.println();\n    }\n}\n```\n\n### Explanation\n- **Node Class**: A private static inner class that represents each element in the list, containing the data and references to the previous and next nodes.\n- **DoublyLinkedList Class**: Manages the list with methods to add and remove elements at various positions.\n  - `addFirst(E element)`: Adds an element to the beginning of the list.\n  - `addLast(E element)`: Adds an element to the end of the list.\n  - `add(int index, E element)`: Adds an element at the specified index.\n  - `remove(int index)`: Removes the element at the specified index.\n  - `remove(E element)`: Removes the first occurrence of the specified element.\n  - Helper methods like `getNode(int index)`, `removeFirst()`, and `removeLast()` assist in managing the list efficiently.\n  - `printList()`: A utility method to print the list for verification.\n\nThis implementation ensures that all specified operations are handled correctly, including edge cases such as empty lists and invalid indices."
    }
]