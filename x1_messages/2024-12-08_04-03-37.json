[
    {
        "role": "user",
        "content": "Write a Node.js script that listens for incoming HTTP requests on port 3000 and responds with the current time in JSON format. Use the built-in 'http' module without any external libraries."
    },
    {
        "role": "assistant",
        "content": "Alright, I need to write a Node.js script that listens for HTTP requests on port 3000 and responds with the current time in JSON format. I should use only the built-in 'http' module and no external libraries. Okay, let's break this down.\n\nFirst, I need to set up a server that listens on port 3000. In Node.js, I can use the 'http' module to create an HTTP server. I'll need to require the 'http' module and then create a server that handles requests and responses.\n\nSo, I'll start by requiring the 'http' module:\n\n```javascript\nconst http = require('http');\n```\n\nNext, I need to create a server that listens on port 3000. I can do this by calling the `createServer` method from the 'http' module and passing it a request listener function. This function will handle incoming requests and send back a response.\n\nThe request listener function takes two parameters: `request` and `response`. I need to send back the current time in JSON format. So, inside this function, I'll get the current time and format it as a JSON object.\n\nLet me think about how to get the current time. In JavaScript, I can use the `Date` object to get the current date and time. I'll create a new `Date` object and then extract the relevant parts like hours, minutes, seconds, etc.\n\nI need to format this time into a JSON object. For example, something like:\n\n```json\n{\n  \"currentTime\": \"HH:MM:SS\"\n}\n```\n\nI need to make sure that the time is in the correct format. Maybe I can use the `toISOString` method of the `Date` object to get a standardized time format.\n\nAlso, I need to set the HTTP headers to indicate that the response is in JSON format. I can do this by setting the 'Content-Type' header to 'application/json'.\n\nLet me outline the steps again:\n\n1. Require the 'http' module.\n\n2. Create an HTTP server that listens on port 3000.\n\n3. In the request listener function:\n\na. Get the current time using the `Date` object.\n\nb. Format the time as a JSON object.\n\nc. Set the 'Content-Type' header to 'application/json'.\n\nd. Send back the JSON response.\n\n4. Start the server and log a message to indicate that it's running.\n\nLet me try to write some pseudocode for this:\n\n```\n\nconst http = require('http');\n\nconst server = http.createServer((request, response) => {\n\n  const currentTime = new Date();\n\n  const timeString = currentTime.toISOString();\n\n  const jsonResponse = JSON.stringify({ currentTime: timeString });\n\n  response.setHeader('Content-Type', 'application/json');\n\n  response.end(jsonResponse);\n\n});\n\nserver.listen(3000, () => {\n\n  console.log('Server is running on port 3000');\n\n});\n```\n\nThat seems straightforward. Let me think if there's anything I'm missing.\n\nI should consider different types of HTTP requests. For now, I'll assume that the server should respond with the current time for any type of request, but perhaps I should handle only GET requests and return an appropriate response for other methods.\n\nAlso, I should handle any errors that might occur, like if the server can't start on port 3000 because it's already in use.\n\nLet me add some error handling. I can add an event listener for the 'error' event on the server.\n\nSo, updated pseudocode:\n\n```\n\nconst http = require('http');\n\nconst server = http.createServer((request, response) => {\n\n  if (request.method !== 'GET') {\n\n    response.statusCode = 405;\n\n    response.setHeader('Content-Type', 'application/json');\n\n    response.end(JSON.stringify({ error: 'Method Not Allowed' }));\n\n    return;\n\n  }\n\n  const currentTime = new Date();\n\n  const timeString = currentTime.toISOString();\n\n  const jsonResponse = JSON.stringify({ currentTime: timeString });\n\n  response.setHeader('Content-Type', 'application/json');\n\n  response.end(jsonResponse);\n\n});\n\nserver.listen(3000, () => {\n\n  console.log('Server is running on port 3000');\n\n});\n\nserver.on('error', (err) => {\n\n  console.error('Server error:', err);\n\n});\n```\n\nThis looks better. Now, I'm handling only GET requests and returning a 405 Method Not Allowed for other methods.\n\nI should also consider handling other HTTP headers or request parameters, but since the task is simple, maybe it's unnecessary.\n\nLet me think about how to format the time. Using `toISOString()` gives me a string in ISO format, which is precise and includes time zone information. That should be fine, but if I need a different format, I can customize it.\n\nFor example, if I want the time in the format \"HH:MM:SS\", I can extract the hours, minutes, and seconds from the `Date` object and format them accordingly.\n\nLet me see:\n\n```\n\nconst currentTime = new Date();\n\nconst hours = String(currentTime.getHours()).padStart(2, '0');\n\nconst minutes = String(currentTime.getMinutes()).padStart(2, '0');\n\nconst seconds = String(currentTime.getSeconds()).padStart(2, '0');\n\nconst timeString = `${hours}:${minutes}:${seconds}`;\n\n```\n\nThis will give me the time in \"HH:MM:SS\" format. I can include this in the JSON response along with the ISO string if needed.\n\nPerhaps I should include both for completeness.\n\nSo, the JSON response could be:\n\n```json\n{\n\n  \"currentTime\": \"2023-10-05T12:34:56.789Z\",\n\n  \"formattedTime\": \"12:34:56\"\n\n}\n```\n\nThis way, the client gets both the standard ISO format and a human-readable formatted time.\n\nLet me update the pseudocode accordingly:\n\n```\n\nconst http = require('http');\n\nconst server = http.createServer((request, response) => {\n\n  if (request.method !== 'GET') {\n\n    response.statusCode = 405;\n\n    response.setHeader('Content-Type', 'application/json');\n\n    response.end(JSON.stringify({ error: 'Method Not Allowed' }));\n\n    return;\n\n  }\n\n  const currentTime = new Date();\n\n  const timeString = currentTime.toISOString();\n\n  const hours = String(currentTime.getHours()).padStart(2, '0');\n\n  const minutes = String(currentTime.getMinutes()).padStart(2, '0');\n\n  const seconds = String(currentTime.getSeconds()).padStart(2, '0');\n\n  const formattedTime = `${hours}:${minutes}:${seconds}`;\n\n  const jsonResponse = JSON.stringify({\n\n    currentTime: timeString,\n\n    formattedTime: formattedTime\n\n  });\n\n  response.setHeader('Content-Type', 'application/json');\n\n  response.end(jsonResponse);\n\n});\n\nserver.listen(3000, () => {\n\n  console.log('Server is running on port 3000');\n\n});\n\nserver.on('error', (err) => {\n\n  console.error('Server error:', err);\n\n});\n```\n\nThis seems comprehensive. Now, I need to make sure that the server runs without errors and that the response is correctly formatted.\n\nI should also think about performance. Since this is a simple server that only responds with the current time, performance shouldn't be an issue. But in general, it's good to keep the request handling minimal to handle a high number of requests.\n\nAnother thing to consider is whether to handle different time zones. Currently, the ISO string includes the timezone offset, and the formatted time is in the server's local time. If I need to support different time zones based on client preferences, I would need to handle query parameters or headers that specify the desired time zone.\n\nBut for this task, I'll keep it simple and assume that the server's local time is sufficient.\n\nLet me think about how to test this server. I can use a web browser or tools like curl or Postman to send HTTP requests to localhost:3000 and see if the response is as expected.\n\nFor example, using curl:\n\n```\n\ncurl http://localhost:3000\n\n```\n\nThis should return the JSON object with the current time.\n\nI should also test with different HTTP methods, like POST, to ensure that it returns a 405 error.\n\nLet me write down some test cases:\n\n1. Send a GET request and verify that the response is a JSON object with the current time.\n\n2. Send a POST request and verify that the response is a 405 Method Not Allowed with an error message in JSON format.\n\n3. Send a request to a different port and verify that the server doesn't respond.\n\n4. Stop the server and send a request to port 3000 to ensure it doesn't respond.\n\nThese tests will help confirm that the server is working as intended.\n\nNow, let me think about error handling in more detail. If there's an error while creating the server, like if port 3000 is already in use, I should handle that gracefully.\n\nIn the pseudocode above, I've added an 'error' event listener to the server, which will log any errors that occur during the server's operation.\n\nAdditionally, I can handle specific error cases, like 'EADDRINUSE', which indicates that the port is already in use.\n\nHere's how I can do that:\n\n```\n\nserver.on('error', (err) => {\n\n  if (err.syscall === 'listen') {\n\n    switch (err.code) {\n\n      case 'EACCES':\n\n        console.error(`Port 3000 requires elevated privileges.`);\n\n        process.exit(1);\n\n        break;\n\n      case 'EADDRINUSE':\n\n        console.error(`Port 3000 is already in use.`);\n\n        process.exit(1);\n\n        break;\n\n      default:\n\n        console.error(`Unexpected error while listening on port 3000: ${err}`);\n\n        process.exit(1);\n\n        break;\n\n    }\n\n  }\n\n});\n```\n\nThis will provide more specific error messages based on the error code.\n\nLet me incorporate this into the pseudocode:\n\n```\n\nconst http = require('http');\n\nconst server = http.createServer((request, response) => {\n\n  if (request.method !== 'GET') {\n\n    response.statusCode = 405;\n\n    response.setHeader('Content-Type', 'application/json');\n\n    response.end(JSON.stringify({ error: 'Method Not Allowed' }));\n\n    return;\n\n  }\n\n  const currentTime = new Date();\n\n  const timeString = currentTime.toISOString();\n\n  const hours = String(currentTime.getHours()).padStart(2, '0');\n\n  const minutes = String(currentTime.getMinutes()).padStart(2, '0');\n\n  const seconds = String(currentTime.getSeconds()).padStart(2, '0');\n\n  const formattedTime = `${hours}:${minutes}:${seconds}`;\n\n  const jsonResponse = JSON.stringify({\n\n    currentTime: timeString,\n\n    formattedTime: formattedTime\n\n  });\n\n  response.setHeader('Content-Type', 'application/json');\n\n  response.end(jsonResponse);\n\n});\n\nserver.listen(3000, () => {\n\n  console.log('Server is running on port 3000');\n\n});\n\nserver.on('error', (err) => {\n\n  if (err.syscall === 'listen') {\n\n    switch (err.code) {\n\n      case 'EACCES':\n\n        console.error(`Port 3000 requires elevated privileges.`);\n\n        process.exit(1);\n\n        break;\n\n      case 'EADDRINUSE':\n\n        console.error(`Port 3000 is already in use.`);\n\n        process.exit(1);\n\n        break;\n\n      default:\n\n        console.error(`Unexpected error while listening on port 3000: ${err}`);\n\n        process.exit(1);\n\n        break;\n\n    }\n\n  }\n\n});\n```\n\nThis should cover most of the potential errors.\n\nNow, I need to make sure that the server closes properly when interrupted, for example, when Ctrl+C is pressed.\n\nBy default, Node.js handles SIGINT signals and exits gracefully, but I can add a shutdown hook to ensure that any cleanup is performed.\n\nFor this simple server, it's probably not necessary, but good practice:\n\n```\n\nprocess.on('SIGINT', () => {\n\n  server.close(() => {\n\n    console.log('Server closed.');\n\n    process.exit(0);\n\n  });\n\n});\n```\n\nThis will ensure that the server closes properly and logs a message before exiting.\n\nAdding this to the pseudocode:\n\n```\n\nconst http = require('http');\n\nconst server = http.createServer((request, response) => {\n\n  if (request.method !== 'GET') {\n\n    response.statusCode = 405;\n\n    response.setHeader('Content-Type', 'application/json');\n\n    response.end(JSON.stringify({ error: 'Method Not Allowed' }));\n\n    return;\n\n  }\n\n  const currentTime = new Date();\n\n  const timeString = currentTime.toISOString();\n\n  const hours = String(currentTime.getHours()).padStart(2, '0');\n\n  const minutes = String(currentTime.getMinutes()).padStart(2, '0');\n\n  const seconds = String(currentTime.getSeconds()).padStart(2, '0');\n\n  const formattedTime = `${hours}:${minutes}:${seconds}`;\n\n  const jsonResponse = JSON.stringify({\n\n    currentTime: timeString,\n\n    formattedTime: formattedTime\n\n  });\n\n  response.setHeader('Content-Type', 'application/json');\n\n  response.end(jsonResponse);\n\n});\n\nserver.listen(3000, () => {\n\n  console.log('Server is running on port 3000');\n\n});\n\nserver.on('error', (err) => {\n\n  if (err.syscall === 'listen') {\n\n    switch (err.code) {\n\n      case 'EACCES':\n\n        console.error(`Port 3000 requires elevated privileges.`);\n\n        process.exit(1);\n\n        break;\n\n      case 'EADDRINUSE':\n\n        console.error(`Port 3000 is already in use.`);\n\n        process.exit(1);\n\n        break;\n\n      default:\n\n        console.error(`Unexpected error while listening on port 3000: ${err}`);\n\n        process.exit(1);\n\n        break;\n\n    }\n\n  }\n\n});\n\nprocess.on('SIGINT', () => {\n\n  server.close(() => {\n\n    console.log('Server closed.');\n\n    process.exit(0);\n\n  });\n\n});\n```\n\nThis should cover most scenarios.\n\nLet me think about logging. Currently, I have a log message when the server starts and when it closes. I might also want to log each request or errors during request handling.\n\nFor a simple script, logging every request might be overkill, but it's good practice for larger applications.\n\nI can add a console.log statement inside the request listener to log the method and URL of each request.\n\nLike this:\n\n```\n\nconst handleRequest = (request, response) => {\n\n  console.log(`Received ${request.method} request for ${request.url}`);\n\n  // Rest of the request handling\n\n};\n\nconst server = http.createServer(handleRequest);\n\n```\n\nThis will help in debugging and monitoring.\n\nAdding this to the pseudocode:\n\n```\n\nconst http = require('http');\n\nconst handleRequest = (request, response) => {\n\n  console.log(`Received ${request.method} request for ${request.url}`);\n\n  if (request.method !== 'GET') {\n\n    response.statusCode = 405;\n\n    response.setHeader('Content-Type', 'application/json');\n\n    response.end(JSON.stringify({ error: 'Method Not Allowed' }));\n\n    return;\n\n  }\n\n  const currentTime = new Date();\n\n  const timeString = currentTime.toISOString();\n\n  const hours = String(currentTime.getHours()).padStart(2, '0');\n\n  const minutes = String(currentTime.getMinutes()).padStart(2, '0');\n\n  const seconds = String(currentTime.getSeconds()).padStart(2, '0');\n\n  const formattedTime = `${hours}:${minutes}:${seconds}`;\n\n  const jsonResponse = JSON.stringify({\n\n    currentTime: timeString,\n\n    formattedTime: formattedTime\n\n  });\n\n  response.setHeader('Content-Type', 'application/json');\n\n  response.end(jsonResponse);\n\n};\n\nconst server = http.createServer(handleRequest);\n\nserver.listen(3000, () => {\n\n  console.log('Server is running on port 3000');\n\n});\n\nserver.on('error', (err) => {\n\n  if (err.syscall === 'listen') {\n\n    switch (err.code) {\n\n      case 'EACCES':\n\n        console.error(`Port 3000 requires elevated privileges.`);\n\n        process.exit(1);\n\n        break;\n\n      case 'EADDRINUSE':\n\n        console.error(`Port 3000 is already in use.`);\n\n        process.exit(1);\n\n        break;\n\n      default:\n\n        console.error(`Unexpected error while listening on port 3000: ${err}`);\n\n        process.exit(1);\n\n        break;\n\n    }\n\n  }\n\n});\n\nprocess.on('SIGINT', () => {\n\n  server.close(() => {\n\n    console.log('Server closed.');\n\n    process.exit(0);\n\n  });\n\n});\n```\n\nNow, I need to make sure that the JSON response is correctly formatted and valid.\n\nI can use `JSON.stringify` to convert the JavaScript object to a JSON string, which should be fine.\n\nI should also ensure that there are no syntax errors in the script.\n\nTo be thorough, I can add some comments to the code to explain what each part does, especially for someone who might be reviewing or maintaining the code in the future.\n\nHere's the pseudocode with comments:\n\n```\n\nconst http = require('http');\n\n// Request handling function\n\nconst handleRequest = (request, response) => {\n\n  console.log(`Received ${request.method} request for ${request.url}`);\n\n  if (request.method !== 'GET') {\n\n    // Respond with 405 Method Not Allowed for non-GET requests\n\n    response.statusCode = 405;\n\n    response.setHeader('Content-Type', 'application/json');\n\n    response.end(JSON.stringify({ error: 'Method Not Allowed' }));\n\n    return;\n\n  }\n\n  // Get current time\n\n  const currentTime = new Date();\n\n  const timeString = currentTime.toISOString();\n\n  const hours = String(currentTime.getHours()).padStart(2, '0');\n\n  const minutes = String(currentTime.getMinutes()).padStart(2, '0');\n\n  const seconds = String(currentTime.getSeconds()).padStart(2, '0');\n\n  const formattedTime = `${hours}:${minutes}:${seconds}`;\n\n  // Create JSON response\n\n  const jsonResponse = JSON.stringify({\n\n    currentTime: timeString,\n\n    formattedTime: formattedTime\n\n  });\n\n  // Set content type header\n\n  response.setHeader('Content-Type', 'application/json');\n\n  // Send response\n\n  response.end(jsonResponse);\n\n};\n\n// Create HTTP server\n\nconst server = http.createServer(handleRequest);\n\n// Start server on port 3000\n\nserver.listen(3000, () => {\n\n  console.log('Server is running on port 3000');\n\n});\n\n// Handle errors during server operation\n\nserver.on('error', (err) => {\n\n  if (err.syscall === 'listen') {\n\n    switch (err.code) {\n\n      case 'EACCES':\n\n        console.error(`Port 3000 requires elevated privileges.`);\n\n        process.exit(1);\n\n        break;\n\n      case 'EADDRINUSE':\n\n        console.error(`Port 3000 is already in use.`);\n\n        process.exit(1);\n\n        break;\n\n      default:\n\n        console.error(`Unexpected error while listening on port 3000: ${err}`);\n\n        process.exit(1);\n\n        break;\n\n    }\n\n  }\n\n});\n\n// Gracefully handle shutdown on SIGINT (Ctrl+C)\n\nprocess.on('SIGINT', () => {\n\n  server.close(() => {\n\n    console.log('Server closed.');\n\n    process.exit(0);\n\n  });\n\n});\n```\n\nThis should cover all the necessary aspects for this task.\n\nNow, I need to write the actual code based on this pseudocode.\n\n## Final Solution\nTo create a Node.js script that listens for incoming HTTP requests on port 3000 and responds with the current time in JSON format, you can use the built-in `http` module. This solution involves setting up a basic server that handles GET requests and returns the current time in both ISO string and a formatted \"HH:MM:SS\" string.\n\n### Solution Code\n\n```javascript\nconst http = require('http');\n\n// Request handling function\nconst handleRequest = (request, response) => {\n  console.log(`Received ${request.method} request for ${request.url}`);\n  if (request.method !== 'GET') {\n    // Respond with 405 Method Not Allowed for non-GET requests\n    response.statusCode = 405;\n    response.setHeader('Content-Type', 'application/json');\n    response.end(JSON.stringify({ error: 'Method Not Allowed' }));\n    return;\n  }\n  // Get current time\n  const currentTime = new Date();\n  const timeString = currentTime.toISOString();\n  const hours = String(currentTime.getHours()).padStart(2, '0');\n  const minutes = String(currentTime.getMinutes()).padStart(2, '0');\n  const seconds = String(currentTime.getSeconds()).padStart(2, '0');\n  const formattedTime = `${hours}:${minutes}:${seconds}`;\n  // Create JSON response\n  const jsonResponse = JSON.stringify({\n    currentTime: timeString,\n    formattedTime: formattedTime\n  });\n  // Set content type header\n  response.setHeader('Content-Type', 'application/json');\n  // Send response\n  response.end(jsonResponse);\n};\n\n// Create HTTP server\nconst server = http.createServer(handleRequest);\n\n// Start server on port 3000\nserver.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});\n\n// Handle errors during server operation\nserver.on('error', (err) => {\n  if (err.syscall === 'listen') {\n    switch (err.code) {\n      case 'EACCES':\n        console.error(`Port 3000 requires elevated privileges.`);\n        process.exit(1);\n        break;\n      case 'EADDRINUSE':\n        console.error(`Port 3000 is already in use.`);\n        process.exit(1);\n        break;\n      default:\n        console.error(`Unexpected error while listening on port 3000: ${err}`);\n        process.exit(1);\n        break;\n    }\n  }\n});\n\n// Gracefully handle shutdown on SIGINT (Ctrl+C)\nprocess.on('SIGINT', () => {\n  server.close(() => {\n    console.log('Server closed.');\n    process.exit(0);\n  });\n});\n```\n\n### Explanation\n\n1. **HTTP Server Setup**: We use the `http` module to create a server that listens on port 3000.\n2. **Request Handling**: The server handles incoming requests, responding only to GET requests with the current time in JSON format. Other HTTP methods receive a \"405 Method Not Allowed\" response.\n3. **Current Time Retrieval**: The current time is fetched using the `Date` object and formatted into both ISO string and a human-readable \"HH:MM:SS\" format.\n4. **Response Formatting**: The response is constructed as a JSON object containing both time formats and is sent with the `Content-Type` header set to `application/json`.\n5. **Error Handling**: The server handles errors such as port already in use or permission issues, logging appropriate messages and exiting with error codes.\n6. **Graceful Shutdown**: The server shuts down gracefully on receiving a SIGINT signal (Ctrl+C), logging a shutdown message before exiting.\n\nThis script provides a robust and straightforward way to serve the current time over HTTP using Node.js's built-in modules."
    }
]