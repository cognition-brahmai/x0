[
    {
        "role": "user",
        "content": "Create a Python program that implements a doubly linked list with methods for insertion, deletion, searching, and traversing the list."
    },
    {
        "role": "assistant",
        "content": "Sure! I'd be happy to help you create a Python program that implements a doubly linked list with methods for insertion, deletion, searching, and traversing the list.\n\nFirst, let's understand what a doubly linked list is. A doubly linked list is a type of linked list in which each node contains a reference to the previous as well as the next node in the sequence. This allows traversal in both directions, which can be useful in certain scenarios.\n\nHere's a basic outline of the steps we'll take to create this program:\n\n1. **Define the Node class**: Each node will have data and two pointers, one pointing to the next node and another to the previous node.\n\n2. **Define the DoublyLinkedList class**: This class will manage the nodes. It will have methods to insert nodes (at the beginning, end, or at a specific position), delete nodes, search for a node, and traverse the list (print the list in forward and backward directions).\n\n3. **Implement the methods**:\n   - **Insertion**: We'll implement methods to insert at the beginning, end, and at a specific position.\n   - **Deletion**: We'll implement a method to delete a node based on its value.\n   - **Searching**: We'll implement a method to check if a node with a specific value exists in the list.\n   - **Traversal**: We'll implement methods to print the list in both forward and backward directions.\n\n4. **Test the implementation**: We'll create an instance of the DoublyLinkedList and perform various operations to ensure everything works as expected.\n\nLet's start by defining the Node class.\n\n## Final Solution\nTo implement a doubly linked list in Python, we need to define a `Node` class and a `DoublyLinkedList` class. The `Node` class will represent each element in the list, containing data and references to the previous and next nodes. The `DoublyLinkedList` class will manage these nodes, providing methods to insert, delete, search, and traverse the list.\n\n### Approach\n\n1. **Node Class**:\n   - Each node has three attributes: `data`, `prev`, and `next`.\n   - `data` holds the value of the node.\n   - `prev` points to the previous node in the list.\n   - `next` points to the next node in the list.\n\n2. **DoublyLinkedList Class**:\n   - Initializes with `head` and `tail` attributes set to `None`.\n   - **insert_at_beginning(data)**: Inserts a new node at the start of the list.\n   - **insert_at_end(data)**: Inserts a new node at the end of the list.\n   - **insert_after_node(prev_node, data)**: Inserts a new node after a specified node.\n   - **delete_node(value)**: Deletes the first node that matches the given value.\n   - **search(value)**: Searches for a node with the given value and returns `True` if found, else `False`.\n   - **traverse_forward()**: Prints the list from head to tail.\n   - **traverse_backward()**: Prints the list from tail to head.\n\n3. **Edge Cases**:\n   - Handle cases where the list is empty.\n   - Ensure proper updates to `head` and `tail` during insertions and deletions.\n\n### Solution Code\n\n```python\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.prev = None\n        self.next = None\n\nclass DoublyLinkedList:\n    def __init__(self):\n        self.head = None\n        self.tail = None\n\n    def insert_at_beginning(self, data):\n        new_node = Node(data)\n        if self.head is None:\n            self.head = new_node\n            self.tail = new_node\n        else:\n            new_node.next = self.head\n            self.head.prev = new_node\n            self.head = new_node\n\n    def insert_at_end(self, data):\n        new_node = Node(data)\n        if self.tail is None:\n            self.head = new_node\n            self.tail = new_node\n        else:\n            new_node.prev = self.tail\n            self.tail.next = new_node\n            self.tail = new_node\n\n    def insert_after_node(self, prev_node, data):\n        if prev_node is None:\n            print(\"Previous node cannot be None.\")\n            return\n        new_node = Node(data)\n        new_node.next = prev_node.next\n        new_node.prev = prev_node\n        if prev_node.next is not None:\n            prev_node.next.prev = new_node\n        prev_node.next = new_node\n        if prev_node == self.tail:\n            self.tail = new_node\n\n    def delete_node(self, value):\n        current = self.head\n        while current:\n            if current.data == value:\n                if current.prev is not None:\n                    current.prev.next = current.next\n                else:\n                    self.head = current.next\n                if current.next is not None:\n                    current.next.prev = current.prev\n                else:\n                    self.tail = current.prev\n                return\n            current = current.next\n\n    def search(self, value):\n        current = self.head\n        while current:\n            if current.data == value:\n                return True\n            current = current.next\n        return False\n\n    def traverse_forward(self):\n        current = self.head\n        while current:\n            print(current.data, end=\" <-> \")\n            current = current.next\n        print(\"None\")\n\n    def traverse_backward(self):\n        current = self.tail\n        while current:\n            print(current.data, end=\" <-> \")\n            current = current.prev\n        print(\"None\")\n\n# Example usage\nif __name__ == \"__main__\":\n    dll = DoublyLinkedList()\n    dll.insert_at_end(1)\n    dll.insert_at_end(2)\n    dll.insert_at_end(3)\n    dll.insert_at_beginning(0)\n    dll.insert_after_node(dll.head.next, 1.5)\n    dll.traverse_forward()  # Output: 0 <-> 1 <-> 1.5 <-> 2 <-> 3 <-> None\n    dll.traverse_backward() # Output: 3 <-> 2 <-> 1.5 <-> 1 <-> 0 <-> None\n    print(dll.search(1.5))  # Output: True\n    dll.delete_node(1.5)\n    dll.traverse_forward()  # Output: 0 <-> 1 <-> 2 <-> 3 <-> None\n```\n\n### Explanation\n\n- **Node Class**: Initializes a node with data and optional references to previous and next nodes.\n- **DoublyLinkedList Class**:\n  - **insert_at_beginning(data)**: Adds a new node at the start, updating head and tail accordingly.\n  - **insert_at_end(data)**: Adds a new node at the end, updating tail and previous node's next reference.\n  - **insert_after_node(prev_node, data)**: Inserts a new node after a specified node, handling edge cases.\n  - **delete_node(value)**: Removes the first node that matches the value, adjusting references.\n  - **search(value)**: Traverses the list to find if the value exists, returning a boolean.\n  - **traverse_forward()**: Prints the list from head to tail.\n  - **traverse_backward()**: Prints the list from tail to head.\n\nThis implementation ensures that all operations maintain the integrity of the doubly linked list's structure."
    }
]