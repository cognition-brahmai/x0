[
    {
        "role": "user",
        "content": "Create a C++ application that uses the Paho MQTT library to publish and subscribe to messages in an MQTT broker. The application should allow users to enter custom topics and messages, as well as display incoming messages from subscribed topics in real-time."
    },
    {
        "role": "assistant",
        "content": "To create a C++ application that uses the Paho MQTT library for publishing and subscribing to messages in an MQTT broker, you'll need to follow these steps:\n\n1. **Install the Paho MQTT C++ Library:**\n   - You can download the Paho MQTT C++ library from the Eclipse Paho website or install it via package managers.\n   - For example, on Ubuntu, you can install it using:\n     ```sh\n     sudo apt-get install libpaho-mqttpp3-dev\n     ```\n\n2. **Set Up Your Development Environment:**\n   - Make sure you have a C++ compiler installed (like g++).\n   - Set up your project directory and create the necessary source files.\n\n3. **Write the Code:**\n   - You'll need to handle both publishing and subscribing functionalities.\n   - Use multi-threading to handle real-time message display.\n\nHere's a basic example to get you started:\n\n### Main Application Code\n\n```cpp\n#include <iostream>\n#include <thread>\n#include <mutex>\n#include <condition_variable>\n#include <string>\n\n#include <MQTTClient.h>\n\n#define ADDRESS     \"tcp://mqtt.eclipse.org:1883\"\n#define CLIENTID    \"ExampleClientPub\"\n#define TOPIC       \"test/topic\"\n#define PAYLOAD     \"Hello World!\"\n#define QOS         1\n#define TIMEOUT     10000L\n\nstd::mutex mtx;\nstd::condition_variable cv;\nbool message_arrived = false;\n\nclass Callback : public virtual MQTTClient_callback\n{\npublic:\n    void deliveryComplete(MQTTClient_deliveryToken dt) {\n        std::cout << \"Message delivered\" << std::endl;\n    }\n\n    void connected(void* context, MQTTClient_connectReturnCode connReturnCode) {\n        std::cout << \"Connected\" << std::endl;\n    }\n\n    void messageArrived(MQTTClient_deliveryToken dt, MQTTClient_message* message) {\n        std::unique_lock<std::mutex> lock(mtx);\n        std::string payload((char*)message->payload, message->payloadlen);\n        std::cout << \"Message arrived: \" << payload << std::endl;\n        message_arrived = true;\n        cv.notify_all();\n        MQTTClient_freeMessage(&message);\n        MQTTClient_freeToken(&dt);\n    }\n};\n\nvoid subscribe_thread(MQTTClient& client, const std::string& topic) {\n    Callback callback;\n    client.setCallback(&callback);\n\n    MQTTClient_subscribeOptions subopts = MQTTClient_subscribeOptions_initializer;\n    subopts.qos = QOS;\n\n    int rc = client.subscribe(topic.c_str(), subopts);\n    if (rc != MQTTCLIENT_SUCCESS) {\n        std::cerr << \"Failed to subscribe, return code \" << rc << std::endl;\n        return;\n    }\n\n    while (true) {\n        {\n            std::unique_lock<std::mutex> lock(mtx);\n            cv.wait(lock, []{ return message_arrived; });\n            message_arrived = false;\n        }\n    }\n}\n\nint main(int argc, char* argv[]) {\n    MQTTClient client;\n    MQTTClient_connectOptions conn_opts = MQTTClient_connectOptions_initializer;\n    int rc;\n\n    std::string broker_address = ADDRESS;\n    std::string client_id = CLIENTID;\n    std::string default_topic = TOPIC;\n\n    std::cout << \"Enter MQTT broker address (default: \" << broker_address << \"): \";\n    std::string input;\n    std::getline(std::cin, input);\n    if (!input.empty()) {\n        broker_address = input;\n    }\n\n    std::cout << \"Enter client ID (default: \" << client_id << \"): \";\n    std::getline(std::cin, input);\n    if (!input.empty()) {\n        client_id = input;\n    }\n\n    if (MQTTClient_create(&client, broker_address.c_str(), client_id.c_str(), MQTTCLIENT_PERSISTENCE_NONE, NULL) != MQTTCLIENT_SUCCESS) {\n        std::cerr << \"Failed to create MQTT client.\" << std::endl;\n        return 1;\n    }\n\n    conn_opts.keepAliveInterval = 20;\n    conn_opts.cleansession = 1;\n\n    if ((rc = MQTTClient_connect(client, &conn_opts)) != MQTTCLIENT_SUCCESS) {\n        std::cerr << \"Failed to connect, return code \" << rc << std::endl;\n        MQTTClient_destroy(&client);\n        return 1;\n    }\n\n    std::thread subscriber(subscribe_thread, std::ref(client), default_topic);\n\n    while (true) {\n        std::string topic, message;\n        std::cout << \"Enter topic (default: \" << default_topic << \"): \";\n        std::getline(std::cin, topic);\n        if (topic.empty()) {\n            topic = default_topic;\n        }\n\n        std::cout << \"Enter message: \";\n        std::getline(std::cin, message);\n\n        MQTTClient_message pubmsg = MQTTClient_message_initializer;\n        pubmsg.payload = (char*)message.c_str();\n        pubmsg.payloadlen = message.size();\n        pubmsg.qos = QOS;\n        pubmsg.retained = 0;\n\n        MQTTClient_deliveryToken token;\n        if (MQTTClient_publishMessage(client, topic.c_str(), &pubmsg, &token) != MQTTCLIENT_SUCCESS) {\n            std::cerr << \"Failed to publish message.\" << std::endl;\n            continue;\n        }\n\n        MQTTClient_waitForCompletion(client, token, TIMEOUT);\n    }\n\n    subscriber.join();\n    MQTTClient_disconnect(client, TIMEOUT);\n    MQTTClient_destroy(&client);\n\n    return 0;\n}\n```\n\n### Explanation\n\n1. **Include Necessary Headers:**\n   - Include standard headers for input/output, threading, and string operations.\n   - Include the Paho MQTT C++ library headers.\n\n2. **Define Constants:**\n   - Define default values for the MQTT broker address, client ID, topic, payload, QoS, and timeout.\n\n3. **Callback Class:**\n   - Define a callback class to handle MQTT events like message arrival and connection status.\n\n4. **Subscribe Thread:**\n   - Create a separate thread for subscribing to topics to handle real-time message display.\n\n5. **Main Function:**\n   - Prompt the user for the MQTT broker address and client ID.\n   - Create an MQTT client and connect to the broker.\n   - Start a subscription thread for the specified topic.\n   - In the main thread, allow the user to enter topics and messages to publish.\n   - Handle message publication and wait for completion.\n\n6. **Cleanup:**\n   - Join the subscription thread.\n   - Disconnect and destroy the MQTT client.\n\nThis example provides a basic structure. You can enhance it by adding error handling, supporting multiple topics, and improving the user interface."
    }
]