[
    {
        "role": "user",
        "content": "Implement a binary search tree in C++ with the following operations: insert, delete, search, and find the minimum and maximum elements.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Sure! Implementing a binary search tree (BST) in C++ involves creating a structure for the nodes and defining functions for insertion, deletion, search, and finding the minimum and maximum elements. Below is a step-by-step implementation:\n\n### Step 1: Define the Node Structure\n\nFirst, define a structure for the nodes of the BST. Each node will contain an integer key and pointers to its left and right children.\n\n```cpp\nstruct Node {\n    int key;\n    Node* left;\n    Node* right;\n    Node(int k) : key(k), left(nullptr), right(nullptr) {}\n};\n```\n\n### Step 2: Implement the BST Class\n\nNext, create a class for the BST that contains methods for insertion, deletion, search, and finding the minimum and maximum elements.\n\n```cpp\nclass BST {\nprivate:\n    Node* root;\n\n    // Helper functions\n    Node* insert(Node* node, int key);\n    Node* findMin(Node* node);\n    Node* findMax(Node* node);\n    Node* deleteNode(Node* node, int key);\n    Node* findSuccessor(Node* node);\n    bool search(Node* node, int key);\n\npublic:\n    BST() : root(nullptr) {}\n\n    void insert(int key) {\n        root = insert(root, key);\n    }\n\n    void deleteNode(int key) {\n        root = deleteNode(root, key);\n    }\n\n    bool search(int key) {\n        return search(root, key);\n    }\n\n    int findMin() {\n        if (root == nullptr) {\n            throw std::runtime_error(\"Tree is empty\");\n        }\n        return findMin(root)->key;\n    }\n\n    int findMax() {\n        if (root == nullptr) {\n            throw std::runtime_error(\"Tree is empty\");\n        }\n        return findMax(root)->key;\n    }\n};\n```\n\n### Step 3: Implement the Helper Functions\n\nNow, implement the helper functions for each operation.\n\n#### Insertion\n\nInsert a new node with the given key into the BST.\n\n```cpp\nNode* BST::insert(Node* node, int key) {\n    if (node == nullptr) {\n        return new Node(key);\n    }\n    if (key < node->key) {\n        node->left = insert(node->left, key);\n    } else if (key > node->key) {\n        node->right = insert(node->right, key);\n    }\n    return node;\n}\n```\n\n#### Search\n\nSearch for a node with the given key in the BST.\n\n```cpp\nbool BST::search(Node* node, int key) {\n    if (node == nullptr) {\n        return false;\n    }\n    if (key == node->key) {\n        return true;\n    } else if (key < node->key) {\n        return search(node->left, key);\n    } else {\n        return search(node->right, key);\n    }\n}\n```\n\n#### Find Minimum\n\nFind the node with the smallest key in the BST.\n\n```cpp\nNode* BST::findMin(Node* node) {\n    if (node == nullptr) {\n        return nullptr;\n    }\n    if (node->left == nullptr) {\n        return node;\n    }\n    return findMin(node->left);\n}\n```\n\n#### Find Maximum\n\nFind the node with the largest key in the BST.\n\n```cpp\nNode* BST::findMax(Node* node) {\n    if (node == nullptr) {\n        return nullptr;\n    }\n    if (node->right == nullptr) {\n        return node;\n    }\n    return findMax(node->right);\n}\n```\n\n#### Deletion\n\nDelete a node with the given key from the BST.\n\n```cpp\nNode* BST::deleteNode(Node* node, int key) {\n    if (node == nullptr) {\n        return node;\n    }\n    if (key < node->key) {\n        node->left = deleteNode(node->left, key);\n    } else if (key > node->key) {\n        node->right = deleteNode(node->right, key);\n    } else {\n        if (node->left == nullptr) {\n            Node* temp = node->right;\n            delete node;\n            return temp;\n        } else if (node->right == nullptr) {\n            Node* temp = node->left;\n            delete node;\n            return temp;\n        }\n        Node* temp = findMin(node->right);\n        node->key = temp->key;\n        node->right = deleteNode(node->right, temp->key);\n    }\n    return node;\n}\n```\n\n### Step 4: Main Function\n\nFinally, write a main function to test the BST operations.\n\n```cpp\n#include <iostream>\n#include <stdexcept>\n\nint main() {\n    BST tree;\n\n    tree.insert(50);\n    tree.insert(30);\n    tree.insert(20);\n    tree.insert(40);\n    tree.insert(70);\n    tree.insert(60);\n    tree.insert(80);\n\n    std::cout << \"Minimum element: \" << tree.findMin() << std::endl;\n    std::cout << \"Maximum element: \" << tree.findMax() << std::endl;\n    std::cout << \"Search 40: \" << (tree.search(40) ? \"Found\" : \"Not Found\") << std::endl;\n    std::cout << \"Search 90: \" << (tree.search(90) ? \"Found\" : \"Not Found\") << std::endl;\n\n    tree.deleteNode(20);\n    std::cout << \"After deleting 20, search 20: \" << (tree.search(20) ? \"Found\" : \"Not Found\") << std::endl;\n\n    tree.deleteNode(30);\n    std::cout << \"After deleting 30, search 30: \" << (tree.search(30) ? \"Found\" : \"Not Found\") << std::endl;\n\n    tree.deleteNode(50);\n    std::cout << \"After deleting 50, search 50: \" << (tree.search(50) ? \"Found\" : \"Not Found\") << std::endl;\n\n    return 0;\n}\n```\n\nThis implementation covers all the required operations for a binary search tree in C++. You can expand upon this by adding more features such as in-order traversal for printing the tree, balancing the tree, etc."
    }
]