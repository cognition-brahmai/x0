[
    {
        "role": "user",
        "content": "Write a Java program that implements a simple HTTP server using the built-in libraries. The server should support GET requests to retrieve static files from a specified directory.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Alright, I've got this task to create a simple HTTP server in Java that can handle GET requests for static files from a specified directory. I need to use built-in libraries, so no external dependencies. Okay, let's break this down.\n\nFirst, I need to understand what an HTTP server does, especially for GET requests. When a client makes a GET request to the server, it's asking for a specific resource, usually specified by a URL path. In this case, the resource is a static file from a directory on the server's file system.\n\nSo, my server needs to:\n\n1. Listen for incoming HTTP requests on a specific port.\n\n2. Parse the request to extract the requested URL path.\n\n3. Map the URL path to a file in the specified directory.\n\n4. Read the file and send it back to the client as the response.\n\n5. Handle cases where the file doesn't exist or there are errors.\n\nI need to use Java's built-in libraries for this. I recall that Java has the `java.net` package, which includes classes for network programming, and `java.nio.file` for file I/O, which might be useful here.\n\nLet me think about the high-level structure of the program. I probably need to create a server socket that listens for incoming connections. Then, for each connection, I need to read the HTTP request, process it, and generate an appropriate HTTP response.\n\nI should also consider that HTTP requests can have headers, but for simplicity, I'll assume that the requests are basic and only the first line is relevant, which should contain the GET method and the URL path.\n\nAn example of a GET request:\n\n```\n\nGET /index.html HTTP/1.1\n\nHost: www.example.com\n\n...\n\n```\n\nI need to parse this to extract \"/index.html\" and then look for a file named \"index.html\" in the specified directory.\n\nOnce I have the file, I need to read its contents and send them back in the HTTP response. I should also include the correct MIME type in the response headers based on the file extension.\n\nWait, handling MIME types might be a bit involved. Maybe for simplicity, I can just send all files with a default MIME type like \"text/plain\", but ideally, I should have some basic mappings for common file types: \".html\" to \"text/html\", \".css\" to \"text/css\", \".js\" to \"application/javascript\", etc.\n\nAlso, I need to handle cases where the file doesn't exist or there are errors reading the file. In those cases, I should send an appropriate HTTP error response, like 404 Not Found or 500 Internal Server Error.\n\nLet me outline the steps in code:\n\n1. Create a `ServerSocket` to listen on a specified port.\n\n2. Accept incoming connections using `accept()`.\n\n3. For each connection, read the HTTP request from the input stream.\n\n4. Parse the request to extract the requested path.\n\n5. Map the path to a file in the specified directory.\n\n6. Check if the file exists and is readable.\n\n7. If yes, read the file and send an HTTP 200 OK response with the file content and correct MIME type.\n\n8. If not, send an HTTP 404 Not Found response.\n\n9. Close the connection.\n\nI need to make sure that the server can handle multiple requests, so I should probably handle each connection in a separate thread.\n\nLet me think about how to read the HTTP request. Since HTTP is text-based, I can read lines from the input stream until I encounter a blank line, which signifies the end of headers.\n\nBut for simplicity, perhaps I can read just the first line, extract the path, and ignore the rest of the headers.\n\nOnce I have the path, I need to map it to a file in the specified directory. I should be careful to avoid directory traversal attacks, so I need to ensure that the requested path does not escape the specified directory.\n\nFor example, if the specified directory is \"/var/www\", and the request is for \"/../secret/file\", it should not allow accessing files outside of \"/var/www\".\n\nTo prevent this, I can use `java.nio.file.Path`'s `resolve` and `normalize` methods to get the canonical path and ensure it starts with the base directory.\n\nOnce I have the file path, I can check if it exists and is a file (not a directory). If it is, I can read its contents and send them back in the response.\n\nFor sending the response, I need to format it according to the HTTP protocol. A basic HTTP response looks like this:\n\n```\n\nHTTP/1.1 200 OK\n\nContent-Type: text/html\n\nContent-Length: 1234\n\nDate: Mon, 27 Jul 2009 12:28:53 GMT\n\nServer: MyServer\n\nConnection: close\n\n \n\n<!DOCTYPE html>\n\n<html>\n\n<body>\n\nHello, World!\n\n</body>\n\n</html>\n\n```\n\nI need to include the status line, headers, a blank line, and then the message body (the file content).\n\nFor error responses, like 404, it would be similar, but with a different status code and an error message as the body.\n\nI should also consider handling only GET requests and reject other methods like POST, PUT, etc., by sending a 405 Method Not Allowed response.\n\nAdditionally, I should think about closing the connection properly after sending the response to avoid resource leaks.\n\nLet me consider using buffers for reading and writing data to improve performance.\n\nI should also think about exception handling to manage any errors that occur during network operations or file I/O.\n\nMoreover, I need to specify the directory from which to serve files. Maybe I can take it as a command-line argument.\n\nWait, the prompt says \"a specified directory,\" so perhaps it's configurable.\n\nI should also consider that some files might be large, so I need to handle them efficiently without loading the entire file into memory at once.\n\nMaybe I can read the file in chunks and send them to the client gradually.\n\nBut for simplicity, perhaps I can read the entire file into a byte array and send it at once.\n\nBut I should be mindful of memory usage.\n\nAlternatively, I can use streaming to read and write the file in smaller chunks.\n\nI think using streaming is a better approach.\n\nIn Java, I can use `InputStream` and `OutputStream` for this purpose.\n\nLet me think about the code structure.\n\nI can create a class, say `SimpleHttpServer`, with a `main` method that starts the server.\n\nThe server will create a `ServerSocket` on a specified port, say 8080 by default.\n\nIt will have a method to handle each client connection in a separate thread.\n\nEach handler thread will read the request, process it, generate the response, and close the connection.\n\nI need to parse the HTTP request. The first line should contain the method, path, and HTTP version.\n\nI can split this line by spaces to get these components.\n\nThen, check if the method is GET. If not, respond with 405 Method Not Allowed.\n\nIf it is GET, extract the path and map it to a file in the base directory.\n\nThen, check if the file exists and is a regular file.\n\nIf yes, read the file and send a 200 OK response with the file content and appropriate Content-Type header.\n\nIf not, send a 404 Not Found response with an error message.\n\nI need to determine the Content-Type based on the file extension.\n\nI can create a simple mapping for common extensions.\n\nFor example:\n\n- .html -> text/html\n\n- .css -> text/css\n\n- .js -> application/javascript\n\n- .png -> image/png\n\n- .jpg -> image/jpeg\n\n- etc.\n\nFor unknown extensions, I can default to \"application/octet-stream\".\n\nI should also include the Content-Length header, which is the size of the file.\n\nFor error responses, I can have a simple error message as the response body.\n\nI need to make sure that the response is properly formatted, with headers separated by CRLF (\u201c\\r\\n\u201d), and an empty line between headers and body.\n\nAlso, I need to flush the output stream after sending the response to ensure the client receives it promptly.\n\nLet me sketch a rough code outline:\n\n```java\n\nimport java.io.*;\n\nimport java.net.*;\n\nimport java.nio.file.*;\n\nimport java.util.concurrent.*;\n\npublic class SimpleHttpServer {\n\n private static final int PORT = 8080;\n\n private static final String DOCUMENT_ROOT = \"/path/to/directory\"; // to be specified\n\n \n\n public static void main(String[] args) throws IOException {\n\n ServerSocket serverSocket = new ServerSocket(PORT);\n\n System.out.println(\"Server started on port \" + PORT);\n\n \n\n while (true) {\n\n Socket clientSocket = serverSocket.accept();\n\n System.out.println(\"New client connected\");\n\n \n\n // Handle the request in a separate thread\n\n ExecutorService executor = Executors.newCachedThreadPool();\n\n executor.execute(new ClientHandler(clientSocket));\n\n }\n\n }\n\n \n\n private static class ClientHandler implements Runnable {\n\n private final Socket clientSocket;\n\n \n\n public ClientHandler(Socket socket) {\n\n this.clientSocket = socket;\n\n }\n\n \n\n @Override\n\n public void run() {\n\n try {\n\n handleRequest();\n\n } catch (IOException e) {\n\n e.printStackTrace();\n\n } finally {\n\n try {\n\n clientSocket.close();\n\n } catch (IOException e) {\n\n e.printStackTrace();\n\n }\n\n }\n\n }\n\n \n\n private void handleRequest() throws IOException {\n\n InputStream input = clientSocket.getInputStream();\n\n OutputStream output = clientSocket.getOutputStream();\n\n \n\n // Read the request\n\n BufferedReader reader = new BufferedReader(new InputStreamReader(input));\n\n String requestLine = reader.readLine();\n\n \n\n // Parse the request\n\n if (requestLine != null) {\n\n String[] parts = requestLine.split(\" \");\n\n if (parts.length == 3) {\n\n String method = parts[0];\n\n String path = parts[1];\n\n String protocol = parts[2];\n\n \n\n if (\"GET\".equalsIgnoreCase(method)) {\n\n serveFile(path, output);\n\n } else {\n\n sendResponse(output, 405, \"Method Not Allowed\", \"text/plain\", \"405 Method Not Allowed\");\n\n }\n\n }\n\n }\n\n }\n\n \n\n private void serveFile(String path, OutputStream output) throws IOException {\n\n Path filePath = Paths.get(DOCUMENT_ROOT, path.substring(1)); // remove leading '/'\n\n if (Files.exists(filePath) && Files.isRegularFile(filePath)) {\n\n String contentType = getContentType(path);\n\n long length = Files.size(filePath);\n\n sendResponse(output, 200, \"OK\", contentType, Files.newInputStream(filePath), (int) length);\n\n } else {\n\n sendResponse(output, 404, \"Not Found\", \"text/plain\", \"404 Not Found\");\n\n }\n\n }\n\n \n\n private String getContentType(String path) {\n\n if (path.endsWith(\".html\")) return \"text/html\";\n\n if (path.endsWith(\".css\")) return \"text/css\";\n\n if (path.endsWith(\".js\")) return \"application/javascript\";\n\n if (path.endsWith(\".png\")) return \"image/png\";\n\n if (path.endsWith(\".jpg\") || path.endsWith(\".jpeg\")) return \"image/jpeg\";\n\n return \"application/octet-stream\";\n\n }\n\n \n\n private void sendResponse(OutputStream output, int statusCode, String statusMessage, String contentType, InputStream entity, int contentLength) throws IOException {\n\n PrintWriter writer = new PrintWriter(new OutputStreamWriter(output, \"UTF-8\"), true);\n\n \n\n writer.println(\"HTTP/1.1 \" + statusCode + \" \" + statusMessage);\n\n writer.println(\"Content-Type: \" + contentType);\n\n writer.println(\"Content-Length: \" + contentLength);\n\n writer.println(\"Connection: close\"); // Close connection after completion\n\n writer.println(); // Blank line between headers and body\n\n \n\n byte[] buffer = new byte[4096];\n\n int bytesRead;\n\n while ((bytesRead = entity.read(buffer)) != -1) {\n\n output.write(buffer, 0, bytesRead);\n\n }\n\n \n\n output.flush();\n\n }\n\n \n\n private void sendResponse(OutputStream output, int statusCode, String statusMessage, String contentType, String entity) throws IOException {\n\n sendResponse(output, statusCode, statusMessage, contentType, new ByteArrayInputStream(entity.getBytes(\"UTF-8\")), entity.length());\n\n }\n\n }\n\n}\n\n```\n\nThis is a rough outline. I need to refine it and handle edge cases.\n\nFirst, I need to handle the specified directory. Maybe make it a command-line argument.\n\nAlso, I need to ensure that the filePath is within the DOCUMENT_ROOT to prevent directory traversal attacks.\n\nI can use `Path.resolve` and `normalize` to get the canonical path and check if it starts with DOCUMENT_ROOT.\n\nLet me add that.\n\nAlso, I need to close the streams properly.\n\nI should use try-with-resources for that.\n\nMoreover, I should handle exceptions gracefully and send appropriate error responses.\n\nLet me adjust the code accordingly.\n\nAlso, I need to consider that the client may keep the connection open expecting more data, but for simplicity, I'll assume \"Connection: close\" for now.\n\nLet me also think about threading. Using a cached thread pool can be problematic if too many requests come in simultaneously, as it may create too many threads.\n\nMaybe I should use a fixed-size thread pool.\n\nBut for simplicity, I'll keep it as is.\n\nLet me also consider that reading the request line may not be sufficient, as some requests may have additional headers.\n\nBut for a simple server, assuming that the request is just one line should be okay.\n\nAlternatively, I can read until a blank line is encountered to skip headers.\n\nBut for now, I'll keep it simple.\n\nLet me also think about the character encoding. I'll assume UTF-8 for text files.\n\nBut in reality, I may need to handle different encodings based on the file.\n\nThis can be complicated, so perhaps I'll stick with UTF-8 for text files and send binary files as-is.\n\nLet me also consider sending the Last-Modified header, but that might be overkill for this simple server.\n\nAdditionally, I should handle cases where the path is a directory. Maybe list the directory contents or look for an index file like \"index.html\".\n\nFor now, I'll assume that only files are requested, not directories.\n\nBut to handle directories, I can check if the path points to a directory, and if so, either list the contents or look for \"index.html\" inside it.\n\nThis would make it more functional.\n\nLet me add that to the `serveFile` method.\n\nIf the path is a directory, check if it contains an \"index.html\" file, and serve that. If not, list the directory contents.\n\nI need to decide how to format the directory listing. Maybe just a plain text list of files.\n\nLet me proceed with that.\n\nAlso, I need to handle the case where the path is \"/\" , which should serve the \"index.html\" in the root directory.\n\nAlright, let's adjust the code accordingly.\n\nAlso, I need to make sure that the server can handle multiple concurrent requests without stepping on each other's toes.\n\nUsing separate threads for each request should take care of that.\n\nLet me also think about logging. Maybe print out the requests being handled.\n\nThis can be useful for debugging.\n\nI'll add some print statements for that.\n\nLet me also consider adding a Date header to the responses, but that might require importing more libraries.\n\nFor simplicity, I'll omit it.\n\nLet me also think about the server signature. Maybe include a \"Server\" header in the response.\n\nSomething like \"Server: SimpleHttpServer/1.0\"\n\nThis is optional but nice to have.\n\nLet me add that.\n\nAlso, I should consider handling the \"Host\" header, but for this simple server, I can ignore it.\n\nNow, regarding the specified directory. I need to make it configurable, perhaps via a command-line argument.\n\nLet me modify the `main` method to accept the directory path as an argument.\n\nIf not provided, use a default directory like \"./www\".\n\nI need to handle the case where the directory does not exist or is not accessible.\n\nIn such cases, the server should fail to start with an appropriate error message.\n\nLet me add that check.\n\nAlso, I should ensure that the directory path is absolute, to prevent any confusion.\n\nI can use `Paths.get(DOCUMENT_ROOT).toAbsolutePath().normalize()` to get the canonical path.\n\nLet me incorporate all these thoughts into the code.\n\nHere's an updated version:\n\n```java\n\nimport java.io.*;\n\nimport java.net.*;\n\nimport java.nio.file.*;\n\nimport java.util.concurrent.*;\n\npublic class SimpleHttpServer {\n\n private static final int PORT = 8080;\n\n private static String DOCUMENT_ROOT = \"./www\"; // default directory\n\n \n\n public static void main(String[] args) {\n\n if (args.length > 0) {\n\n DOCUMENT_ROOT = args[0];\n\n }\n\n \n\n Path rootPath = Paths.get(DOCUMENT_ROOT).toAbsolutePath().normalize();\n\n if (!Files.exists(rootPath) || !Files.isDirectory(rootPath) || !Files.isReadable(rootPath)) {\n\n System.err.println(\"Document root directory does not exist or is not readable: \" + rootPath);\n\n System.exit(1);\n\n }\n\n \n\n try (ServerSocket serverSocket = new ServerSocket(PORT)) {\n\n System.out.println(\"Server started on port \" + PORT + \", serving files from \" + rootPath);\n\n \n\n while (true) {\n\n Socket clientSocket = serverSocket.accept();\n\n System.out.println(\"New client connected\");\n\n \n\n // Handle the request in a separate thread\n\n ExecutorService executor = Executors.newCachedThreadPool();\n\n executor.execute(new ClientHandler(clientSocket, rootPath.toString()));\n\n }\n\n }\n\n catch (IOException e) {\n\n System.err.println(\"Could not listen on port \" + PORT);\n\n System.exit(1);\n\n }\n\n }\n\n \n\n private static class ClientHandler implements Runnable {\n\n private final Socket clientSocket;\n\n private final String documentRoot;\n\n \n\n public ClientHandler(Socket socket, String root) {\n\n this.clientSocket = socket;\n\n this.documentRoot = root;\n\n }\n\n \n\n @Override\n\n public void run() {\n\n try {\n\n handleRequest();\n\n } catch (IOException e) {\n\n e.printStackTrace();\n\n } finally {\n\n try {\n\n clientSocket.close();\n\n } catch (IOException e) {\n\n e.printStackTrace();\n\n }\n\n }\n\n }\n\n \n\n private void handleRequest() throws IOException {\n\n InputStream input = clientSocket.getInputStream();\n\n OutputStream output = clientSocket.getOutputStream();\n\n \n\n // Read the request\n\n BufferedReader reader = new BufferedReader(new InputStreamReader(input));\n\n String requestLine = reader.readLine();\n\n \n\n // Parse the request\n\n if (requestLine != null) {\n\n String[] parts = requestLine.split(\" \");\n\n if (parts.length == 3) {\n\n String method = parts[0];\n\n String path = parts[1];\n\n String protocol = parts[2];\n\n \n\n if (\"GET\".equalsIgnoreCase(method)) {\n\n serveFile(path, output);\n\n } else {\n\n sendResponse(output, 405, \"Method Not Allowed\", \"text/plain\", \"405 Method Not Allowed\");\n\n }\n\n }\n\n }\n\n }\n\n \n\n private void serveFile(String path, OutputStream output) throws IOException {\n\n if (\"/\".equals(path)) {\n\n path = \"/index.html\";\n\n }\n\n \n\n Path filePath = Paths.get(documentRoot, path.substring(1)).normalize();\n\n Path rootPath = Paths.get(documentRoot).toAbsolutePath().normalize();\n\n \n\n if (!filePath.toAbsolutePath().normalize().startsWith(rootPath)) {\n\n sendResponse(output, 403, \"Forbidden\", \"text/plain\", \"403 Forbidden: Directory traversal attempt\");\n\n return;\n\n }\n\n \n\n if (Files.exists(filePath)) {\n\n if (Files.isDirectory(filePath)) {\n\n serveDirectory(filePath, output);\n\n } else {\n\n serveSingleFile(filePath, output);\n\n }\n\n } else {\n\n sendResponse(output, 404, \"Not Found\", \"text/plain\", \"404 Not Found\");\n\n }\n\n }\n\n \n\n private void serveSingleFile(Path filePath, OutputStream output) throws IOException {\n\n String contentType = getContentType(filePath.toString());\n\n long length = Files.size(filePath);\n\n \n\n try (InputStream fileInputStream = Files.newInputStream(filePath)) {\n\n sendResponse(output, 200, \"OK\", contentType, fileInputStream, (int) length);\n\n }\n\n }\n\n \n\n private void serveDirectory(Path dirPath, OutputStream output) throws IOException {\n\n StringBuilder directoryListing = new StringBuilder();\n\n directoryListing.append(\"<html><body><h1>Directory listing for \").append(dirPath.getFileName()).append(\":</h1><ul>\");\n\n \n\n try (DirectoryStream<Path> streams = Files.newDirectoryStream(dirPath)) {\n\n for (Path entry : streams) {\n\n directoryListing.append(\"<li><a href=\\\"\").append(entry.getFileName()).append(\"\\\">\").append(entry.getFileName()).append(\"</a></li>\");\n\n }\n\n }\n\n directoryListing.append(\"</ul></body></html>\");\n\n \n\n sendResponse(output, 200, \"OK\", \"text/html\", directoryListing.toString());\n\n }\n\n \n\n private String getContentType(String path) {\n\n if (path.endsWith(\".html\")) return \"text/html\";\n\n if (path.endsWith(\".css\")) return \"text/css\";\n\n if (path.endsWith(\".js\")) return \"application/javascript\";\n\n if (path.endsWith(\".png\")) return \"image/png\";\n\n if (path.endsWith(\".jpg\") || path.endsWith(\".jpeg\")) return \"image/jpeg\";\n\n return \"application/octet-stream\";\n\n }\n\n \n\n private void sendResponse(OutputStream output, int statusCode, String statusMessage, String contentType, InputStream entity, int contentLength) throws IOException {\n\n PrintWriter writer = new PrintWriter(new OutputStreamWriter(output, \"UTF-8\"), true);\n\n \n\n writer.println(\"HTTP/1.1 \" + statusCode + \" \" + statusMessage);\n\n writer.println(\"Content-Type: \" + contentType);\n\n writer.println(\"Content-Length: \" + contentLength);\n\n writer.println(\"Server: SimpleHttpServer/1.0\");\n\n writer.println(\"Connection: close\"); // Close connection after completion\n\n writer.println(); // Blank line between headers and body\n\n \n\n byte[] buffer = new byte[4096];\n\n int bytesRead;\n\n try {\n\n while ((bytesRead = entity.read(buffer)) != -1) {\n\n output.write(buffer, 0, bytesRead);\n\n }\n\n } finally {\n\n entity.close();\n\n }\n\n \n\n output.flush();\n\n }\n\n \n\n private void sendResponse(OutputStream output, int statusCode, String statusMessage, String contentType, String entity) throws IOException {\n\n sendResponse(output, statusCode, statusMessage, contentType, new ByteArrayInputStream(entity.getBytes(\"UTF-8\")), entity.length());\n\n }\n\n }\n\n}\n\n```\n\nThis seems more comprehensive.\n\nI've added handling for directory requests by either serving an index.html file if it exists or providing a directory listing.\n\nI've also added checks to prevent directory traversal attacks by ensuring that the requested file path stays within the document root.\n\nI've made the document root configurable via a command-line argument and set a default if none is provided.\n\nI've also ensured that the server closes connections properly and handles exceptions.\n\nI should test this server with various scenarios:\n\n- Requesting an existing file.\n\n- Requesting a directory with an index.html.\n\n- Requesting a directory without an index.html, expecting a directory listing.\n\n- Requesting a non-existent file or directory, expecting a 404.\n\n- Attempting directory traversal, expecting a 403 Forbidden.\n\n- Making a POST request, expecting a 405.\n\nI should also check that the server can handle multiple concurrent requests without issues.\n\nAdditionally, I need to make sure that the server doesn't crash on error conditions and handles them gracefully.\n\nI might also want to add more MIME types to the content type mapping.\n\nOverall, this should serve as a basic static file HTTP server in Java using built-in libraries.\n\n**Final Solution**\n\nTo create a simple HTTP server in Java that serves static files from a specified directory, you can use the following code. This server handles GET requests and basic directory listings.\n\n```java\nimport java.io.*;\nimport java.net.*;\nimport java.nio.file.*;\nimport java.util.concurrent.*;\n\npublic class SimpleHttpServer {\n\n    private static final int PORT = 8080;\n    private static String DOCUMENT_ROOT = \"./www\"; // default directory\n\n    public static void main(String[] args) {\n        if (args.length > 0) {\n            DOCUMENT_ROOT = args[0];\n        }\n\n        Path rootPath = Paths.get(DOCUMENT_ROOT).toAbsolutePath().normalize();\n        if (!Files.exists(rootPath) || !Files.isDirectory(rootPath) || !Files.isReadable(rootPath)) {\n            System.err.println(\"Document root directory does not exist or is not readable: \" + rootPath);\n            System.exit(1);\n        }\n\n        try (ServerSocket serverSocket = new ServerSocket(PORT)) {\n            System.out.println(\"Server started on port \" + PORT + \", serving files from \" + rootPath);\n\n            while (true) {\n                Socket clientSocket = serverSocket.accept();\n                System.out.println(\"New client connected\");\n\n                // Handle the request in a separate thread\n                ExecutorService executor = Executors.newCachedThreadPool();\n                executor.execute(new ClientHandler(clientSocket, rootPath.toString()));\n            }\n        } catch (IOException e) {\n            System.err.println(\"Could not listen on port \" + PORT);\n            System.exit(1);\n        }\n    }\n\n    private static class ClientHandler implements Runnable {\n        private final Socket clientSocket;\n        private final String documentRoot;\n\n        public ClientHandler(Socket socket, String root) {\n            this.clientSocket = socket;\n            this.documentRoot = root;\n        }\n\n        @Override\n        public void run() {\n            try {\n                handleRequest();\n            } catch (IOException e) {\n                e.printStackTrace();\n            } finally {\n                try {\n                    clientSocket.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n\n        private void handleRequest() throws IOException {\n            InputStream input = clientSocket.getInputStream();\n            OutputStream output = clientSocket.getOutputStream();\n\n            // Read the request\n            BufferedReader reader = new BufferedReader(new InputStreamReader(input));\n            String requestLine = reader.readLine();\n\n            // Parse the request\n            if (requestLine != null) {\n                String[] parts = requestLine.split(\" \");\n                if (parts.length == 3) {\n                    String method = parts[0];\n                    String path = parts[1];\n                    String protocol = parts[2];\n\n                    if (\"GET\".equalsIgnoreCase(method)) {\n                        serveFile(path, output);\n                    } else {\n                        sendResponse(output, 405, \"Method Not Allowed\", \"text/plain\", \"405 Method Not Allowed\");\n                    }\n                }\n            }\n        }\n\n        private void serveFile(String path, OutputStream output) throws IOException {\n            if (\"/\".equals(path)) {\n                path = \"/index.html\";\n            }\n\n            Path filePath = Paths.get(documentRoot, path.substring(1)).normalize();\n            Path rootPath = Paths.get(documentRoot).toAbsolutePath().normalize();\n\n            if (!filePath.toAbsolutePath().normalize().startsWith(rootPath)) {\n                sendResponse(output, 403, \"Forbidden\", \"text/plain\", \"403 Forbidden: Directory traversal attempt\");\n                return;\n            }\n\n            if (Files.exists(filePath)) {\n                if (Files.isDirectory(filePath)) {\n                    serveDirectory(filePath, output);\n                } else {\n                    serveSingleFile(filePath, output);\n                }\n            } else {\n                sendResponse(output, 404, \"Not Found\", \"text/plain\", \"404 Not Found\");\n            }\n        }\n\n        private void serveSingleFile(Path filePath, OutputStream output) throws IOException {\n            String contentType = getContentType(filePath.toString());\n            long length = Files.size(filePath);\n\n            try (InputStream fileInputStream = Files.newInputStream(filePath)) {\n                sendResponse(output, 200, \"OK\", contentType, fileInputStream, (int) length);\n            }\n        }\n\n        private void serveDirectory(Path dirPath, OutputStream output) throws IOException {\n            StringBuilder directoryListing = new StringBuilder();\n            directoryListing.append(\"<html><body><h1>Directory listing for \").append(dirPath.getFileName()).append(\":</h1><ul>\");\n\n            try (DirectoryStream<Path> streams = Files.newDirectoryStream(dirPath)) {\n                for (Path entry : streams) {\n                    directoryListing.append(\"<li><a href=\\\"\").append(entry.getFileName()).append(\"\\\">\").append(entry.getFileName()).append(\"</a></li>\");\n                }\n            }\n            directoryListing.append(\"</ul></body></html>\");\n\n            sendResponse(output, 200, \"OK\", \"text/html\", directoryListing.toString());\n        }\n\n        private String getContentType(String path) {\n            if (path.endsWith(\".html\")) return \"text/html\";\n            if (path.endsWith(\".css\")) return \"text/css\";\n            if (path.endsWith(\".js\")) return \"application/javascript\";\n            if (path.endsWith(\".png\")) return \"image/png\";\n            if (path.endsWith(\".jpg\") || path.endsWith(\".jpeg\")) return \"image/jpeg\";\n            return \"application/octet-stream\";\n        }\n\n        private void sendResponse(OutputStream output, int statusCode, String statusMessage, String contentType, InputStream entity, int contentLength) throws IOException {\n            PrintWriter writer = new PrintWriter(new OutputStreamWriter(output, \"UTF-8\"), true);\n\n            writer.println(\"HTTP/1.1 \" + statusCode + \" \" + statusMessage);\n            writer.println(\"Content-Type: \" + contentType);\n            writer.println(\"Content-Length: \" + contentLength);\n            writer.println(\"Server: SimpleHttpServer/1.0\");\n            writer.println(\"Connection: close\"); // Close connection after completion\n            writer.println(); // Blank line between headers and body\n\n            byte[] buffer = new byte[4096];\n            int bytesRead;\n            try {\n                while ((bytesRead = entity.read(buffer)) != -1) {\n                    output.write(buffer, 0, bytesRead);\n                }\n            } finally {\n                entity.close();\n            }\n\n            output.flush();\n        }\n\n        private void sendResponse(OutputStream output, int statusCode, String statusMessage, String contentType, String entity) throws IOException {\n            sendResponse(output, statusCode, statusMessage, contentType, new ByteArrayInputStream(entity.getBytes(\"UTF-8\")), entity.length());\n        }\n    }\n}\n```\n\n### Explanation\n\n1. **Server Setup**:\n   - The server listens on port 8080 by default.\n   - The document root directory is either provided as a command-line argument or defaults to `./www`.\n   - Ensures the document root exists and is readable.\n\n2. **Request Handling**:\n   - Each client connection is handled in a separate thread for concurrency.\n   - Reads and parses the HTTP request to extract the method, path, and protocol.\n\n3. **GET Request Handling**:\n   - For GET requests, serves the requested file or directory.\n   - Prevents directory traversal attacks by validating the requested path.\n   - Serves an index.html file for directory paths or lists the directory contents if no index.html is present.\n\n4. **Response Generation**:\n   - Sends appropriate HTTP responses with status codes, headers, and entities.\n   - Includes basic error handling for methods not allowed and nonexistent files.\n\nThis server is a simple implementation for educational purposes and may require enhancements for production use, such as handling more HTTP methods, improving error responses, and enhancing security features."
    }
]