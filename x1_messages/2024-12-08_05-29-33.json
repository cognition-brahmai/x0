[
    {
        "role": "user",
        "content": "Write a Golang web server that serves static files from a specified directory and provides endpoints for uploading new files and deleting existing ones. The server should support command line flags for port number, listening IP address, and the static files directory path.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Alright, I'm going to write a Go web server that serves static files from a specified directory and includes endpoints for uploading and deleting files. I'll also make sure it supports command line flags for the port number, listening IP address, and the static files directory path.\n\nFirst, I need to set up the basic structure of the web server using the `net/http` package. I'll use the `http.FileServer` handler to serve static files. For uploading and deleting files, I'll create custom handlers.\n\nI should start by importing the necessary packages:\n\n```go\npackage main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n)\n```\n\nNext, I'll define command line flags for the port, IP address, and static files directory:\n\n```go\nvar (\n\tport          = flag.String(\"port\", \"8080\", \"Port number to listen on\")\n\tip            = flag.String(\"ip\", \"127.0.0.1\", \"IP address to listen on\")\n\tstaticDir     = flag.String(\"static\", \"./static\", \"Directory to serve static files from\")\n)\n```\n\nI need to parse the flags:\n\n```go\nflag.Parse()\n```\n\nNow, I'll set up the file server:\n\n```go\nfs := http.FileServer(http.Dir(*staticDir))\n```\n\nI'll create a route to serve static files:\n\n```go\nhttp.Handle(\"/static/\", http.StripPrefix(\"/static/\", fs))\n```\n\nFor uploading files, I'll create an endpoint like `/upload`. This handler needs to handle multipart forms to receive files:\n\n```go\nhttp.HandleFunc(\"/upload\", uploadHandler)\n```\n\nI'll define the `uploadHandler` function:\n\n```go\nfunc uploadHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodPost {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tr.ParseMultipartForm(10 << 20) // Set maximum upload size to 10MB\n\n\tfile, header, err := r.FormFile(\"file\")\n\tif err != nil {\n\t\thttp.Error(w, \"Error retrieving file from form data\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tdefer file.Close()\n\n\tfilepath := filepath.Join(*staticDir, header.Filename)\n\tout, err := os.Create(filepath)\n\tif err != nil {\n\t\thttp.Error(w, \"Error creating file on server\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\tdefer out.Close()\n\n\t_, err = io.Copy(out, file)\n\tif err != nil {\n\t\thttp.Error(w, \"Error saving file\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tfmt.Fprintf(w, \"Successfully uploaded %s\\n\", header.Filename)\n}\n```\n\nFor deleting files, I'll create a `/delete` endpoint:\n\n```go\nhttp.HandleFunc(\"/delete\", deleteHandler)\n```\n\nAnd define the `deleteHandler`:\n\n```go\nfunc deleteHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodDelete {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tr.ParseForm()\n\n\tfilename := r.FormValue(\"filename\")\n\tif filename == \"\" {\n\t\thttp.Error(w, \"Filename is required\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tfilepath := filepath.Join(*staticDir, filename)\n\terr := os.Remove(filepath)\n\tif err != nil {\n\t\thttp.Error(w, \"Error deleting file\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tfmt.Fprintf(w, \"Successfully deleted %s\\n\", filename)\n}\n```\n\nFinally, I'll start the server:\n\n```go\nlog.Printf(\"Starting server on %s:%s\\n\", *ip, *port)\nerr := http.ListenAndServe(fmt.Sprintf(\"%s:%s\", *ip, *port), nil)\nif err != nil {\n\tlog.Fatalf(\"Could not start server: %s\\n\", err)\n}\n```\n\nPutting it all together, the complete code looks like this:\n\n```go\npackage main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n)\n\nvar (\n\tport          = flag.String(\"port\", \"8080\", \"Port number to listen on\")\n\tip            = flag.String(\"ip\", \"127.0.0.1\", \"IP address to listen on\")\n\tstaticDir     = flag.String(\"static\", \"./static\", \"Directory to serve static files from\")\n)\n\nfunc main() {\n\tflag.Parse()\n\n\tfs := http.FileServer(http.Dir(*staticDir))\n\thttp.Handle(\"/static/\", http.StripPrefix(\"/static/\", fs))\n\n\thttp.HandleFunc(\"/upload\", uploadHandler)\n\thttp.HandleFunc(\"/delete\", deleteHandler)\n\n\tlog.Printf(\"Starting server on %s:%s\\n\", *ip, *port)\n\terr := http.ListenAndServe(fmt.Sprintf(\"%s:%s\", *ip, *port), nil)\n\tif err != nil {\n\t\tlog.Fatalf(\"Could not start server: %s\\n\", err)\n\t}\n}\n\nfunc uploadHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodPost {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tr.ParseMultipartForm(10 << 20) // Set maximum upload size to 10MB\n\n\tfile, header, err := r.FormFile(\"file\")\n\tif err != nil {\n\t\thttp.Error(w, \"Error retrieving file from form data\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tdefer file.Close()\n\n\tfilepath := filepath.Join(*staticDir, header.Filename)\n\tout, err := os.Create(filepath)\n\tif err != nil {\n\t\thttp.Error(w, \"Error creating file on server\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\tdefer out.Close()\n\n\t_, err = io.Copy(out, file)\n\tif err != nil {\n\t\thttp.Error(w, \"Error saving file\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tfmt.Fprintf(w, \"Successfully uploaded %s\\n\", header.Filename)\n}\n\nfunc deleteHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodDelete {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tr.ParseForm()\n\n\tfilename := r.FormValue(\"filename\")\n\tif filename == \"\" {\n\t\thttp.Error(w, \"Filename is required\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tfilepath := filepath.Join(*staticDir, filename)\n\terr := os.Remove(filepath)\n\tif err != nil {\n\t\thttp.Error(w, \"Error deleting file\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tfmt.Fprintf(w, \"Successfully deleted %s\\n\", filename)\n}\n```\n\nThis server will serve static files from the specified directory, allow uploading new files via POST requests to `/upload`, and delete existing files via DELETE requests to `/delete`. It uses command line flags to configure the listening address, port, and static files directory."
    }
]