[
    {
        "role": "user",
        "content": "Develop a Java program that uses multithreading to download multiple files concurrently from a list of URLs. The program should have a configurable number of threads and save the downloaded files to a specified directory.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Alright, I've got this task to create a Java program that can download multiple files at the same time using something called multithreading. I'm not super familiar with multithreading, but I think I can figure it out. The program needs to be able to download files from a list of URLs, and I should be able to set how many threads to use. Also, it should save these files to a specific folder that I choose.\n\nFirst, I need to understand what multithreading is. From what I know, multithreading is a way to make a program do multiple things at the same time. So, if I have multiple files to download, instead of downloading them one by one, which would take a long time, I can download them all at once or in batches, which should be faster.\n\nSo, in Java, threads are like smaller parts of the program that can run concurrently. I need to create a certain number of threads based on what the user configures, and each thread will handle downloading one file from the URL list.\n\nI need to think about how to manage these threads. Maybe I can use a thread pool, which is a group of threads that are ready to perform tasks. Java has libraries that help with thread management, like the ExecutorService.\n\nHere's a rough plan:\n\n1. **Input:** Get a list of URLs from which to download files and the number of threads to use.\n\n2. **Configuration:** Set the number of threads based on user input.\n\n3. **Thread Management:** Use ExecutorService to manage a pool of threads.\n\n4. **Download Task:** Create a task for each URL that handles the downloading and saving of the file.\n\n5. **Saving Files:** Specify the directory where the files should be saved.\n\n6. **Error Handling:** Make sure to handle cases where a URL is invalid or the file can't be downloaded.\n\nLet me start by looking up how to create a thread pool in Java. I think ExecutorService is the way to go.\n\nOkay, so in Java, I can use Executors to create an ExecutorService with a fixed number of threads. For example:\n\n```java\nExecutorService executor = Executors.newFixedThreadPool(numThreads);\n```\n\nThen, I can submit tasks to this executor, and it will manage which thread runs which task.\n\nNow, I need to define what each task does. Each task should take a URL, download the file from that URL, and save it to the specified directory.\n\nI need to figure out how to download a file from a URL in Java. I think I can use URL.openConnection() to get an InputStream from the URL, and then write that stream to a file.\n\nHere's a basic outline of what the download method might look like:\n\n```java\npublic void downloadFile(String url, String saveDirectory) {\n    try {\n        URL website = new URL(url);\n        ReadableByteChannel rbc = Channels.newChannel(website.openStream());\n        FileOutputStream fos = new FileOutputStream(saveDirectory + \"/\" + getFileName(url));\n        fos.getChannel().transferFrom(rbc, 0, Long.MAX_VALUE);\n        fos.close();\n        rbc.close();\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}\n```\n\nI need to write a method to extract the file name from the URL, so I know what to name the saved file.\n\nSomething like:\n\n```java\nprivate String getFileName(String url) {\n    return url.substring(url.lastIndexOf('/') + 1);\n}\n```\n\nBut I should also handle cases where the URL doesn't have a file name, or there are query parameters.\n\nHmm, maybe I should look for the \"Content-Disposition\" header in the HTTP response, which sometimes specifies the file name.\n\nI can do that by getting the header from the URL connection.\n\nHere's an updated version:\n\n```java\npublic void downloadFile(String url, String saveDirectory) {\n    try {\n        URL website = new URL(url);\n        HttpURLConnection connection = (HttpURLConnection) website.openConnection();\n        connection.setRequestProperty(\"User-Agent\", \"Mozilla/5.0\");\n        String disposition = connection.getHeaderField(\"Content-Disposition\");\n        String fileName;\n        if (disposition != null) {\n            int index = disposition.indexOf(\"filename=\");\n            if (index > 0) {\n                fileName = disposition.substring(index + 10, disposition.length() - 1);\n            } else {\n                fileName = getFileNameFromUrl(url);\n            }\n        } else {\n            fileName = getFileNameFromUrl(url);\n        }\n        ReadableByteChannel rbc = Channels.newChannel(connection.getInputStream());\n        FileOutputStream fos = new FileOutputStream(saveDirectory + \"/\" + fileName);\n        fos.getChannel().transferFrom(rbc, 0, Long.MAX_VALUE);\n        fos.close();\n        rbc.close();\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}\n```\n\nAnd the helper method:\n\n```java\nprivate String getFileNameFromUrl(String url) {\n    return url.substring(url.lastIndexOf('/') + 1);\n}\n```\n\nNow, I need to make sure that the saveDirectory exists. I should check if it's a valid directory and create it if it doesn't exist.\n\n```java\nFile directory = new File(saveDirectory);\nif (!directory.exists()) {\n    directory.mkdirs();\n}\n```\n\nOkay, now for the multithreading part. I need to create a class that implements Runnable, which will be my task for downloading a file.\n\nSomething like:\n\n```java\nclass DownloadTask implements Runnable {\n    private String url;\n    private String saveDirectory;\n\n    public DownloadTask(String url, String saveDirectory) {\n        this.url = url;\n        this.saveDirectory = saveDirectory;\n    }\n\n    @Override\n    public void run() {\n        downloadFile(url, saveDirectory);\n    }\n\n    private void downloadFile(String url, String saveDirectory) {\n        // The download logic from above\n    }\n\n    private String getFileNameFromUrl(String url) {\n        // The helper method\n    }\n}\n```\n\nThen, in my main class, I can create an ExecutorService with the desired number of threads, and submit DownloadTask instances for each URL.\n\nHere's a rough sketch of the main class:\n\n```java\npublic class MultiThreadedDownloader {\n\n    public static void main(String[] args) {\n        List<String> urls = Arrays.asList(\n                \"http://example.com/file1.zip\",\n                \"http://example.com/file2.zip\"\n                // more URLs\n        );\n        String saveDirectory = \"downloads\";\n        int numThreads = 5;\n\n        ExecutorService executor = Executors.newFixedThreadPool(numThreads);\n\n        for (String url : urls) {\n            executor.execute(new DownloadTask(url, saveDirectory));\n        }\n\n        executor.shutdown();\n        while (!executor.isTerminated()) {\n            // Wait for all tasks to finish\n        }\n        System.out.println(\"All downloads complete.\");\n    }\n}\n```\n\nI need to make sure to handle exceptions properly and maybe add some logging to see the progress of downloads.\n\nAlso, I should consider thread safety, especially if multiple threads are trying to write to the same directory at the same time. But since each file has a unique name, I don't think there will be conflicts.\n\nWait, but what if two threads try to download files with the same name? I need to handle that case to avoid overwriting files accidentally.\n\nMaybe I should include some unique identifier in the file name if there are duplicates.\n\nAlternatively, I can make sure that the file names are unique by including the URL's path or using a hash of the URL.\n\nLet me modify the getFileName method to handle duplicates.\n\n```java\nprivate String getUniqueFileName(String url, String saveDirectory) {\n    String fileName = getFileNameFromUrl(url);\n    File file = new File(saveDirectory, fileName);\n    int count = 1;\n    while (file.exists()) {\n        String namePart = fileName.substring(0, fileName.lastIndexOf('.'));\n        String extensionPart = fileName.substring(fileName.lastIndexOf('.'));\n        file = new File(saveDirectory, namePart + \"_\" + count + extensionPart);\n        count++;\n    }\n    return file.getName();\n}\n```\n\nThen, in the downloadFile method, I can use getUniqueFileName to ensure that each file has a unique name.\n\nNow, I need to think about how to make the number of threads configurable. Maybe through command-line arguments or a configuration file.\n\nFor simplicity, I'll allow the user to specify the number of threads as a command-line argument.\n\nUpdate the main method to accept arguments:\n\n```java\npublic static void main(String[] args) {\n    if (args.length < 2) {\n        System.out.println(\"Usage: java MultiThreadedDownloader <save_directory> <num_threads>\");\n        return;\n    }\n    String saveDirectory = args[0];\n    int numThreads = Integer.parseInt(args[1]);\n\n    List<String> urls = Arrays.asList(\n            \"http://example.com/file1.zip\",\n            \"http://example.com/file2.zip\"\n            // more URLs\n    );\n\n    ExecutorService executor = Executors.newFixedThreadPool(numThreads);\n\n    for (String url : urls) {\n        executor.execute(new DownloadTask(url, saveDirectory));\n    }\n\n    executor.shutdown();\n    while (!executor.isTerminated()) {\n        // Wait for all tasks to finish\n    }\n    System.out.println(\"All downloads complete.\");\n}\n```\n\nBut in a real-world scenario, the list of URLs should also be configurable, maybe read from a file or provided via command line.\n\nFor now, I'll hardcode them in the example, but I can think about making it more flexible later.\n\nI should also add some error handling in case the URL is invalid or the connection times out.\n\nMaybe log the error and continue with the next URL.\n\nAdditionally, it might be useful to have a way to track the progress of downloads, like showing how many files have been downloaded so far.\n\nI can achieve this by maintaining a counter that increments every time a file is downloaded.\n\nBut since we're dealing with multithreading, I need to make sure that the counter is thread-safe.\n\nI can use an AtomicInteger for that.\n\nHere's how I can implement it:\n\nIn the main class:\n\n```java\nAtomicInteger downloadedCount = new AtomicInteger(0);\n```\n\nThen, pass this to the DownloadTask.\n\nModify DownloadTask to accept the counter:\n\n```java\nclass DownloadTask implements Runnable {\n    private String url;\n    private String saveDirectory;\n    private AtomicInteger downloadedCount;\n\n    public DownloadTask(String url, String saveDirectory, AtomicInteger downloadedCount) {\n        this.url = url;\n        this.saveDirectory = saveDirectory;\n        this.downloadedCount = downloadedCount;\n    }\n\n    @Override\n    public void run() {\n        try {\n            downloadFile(url, saveDirectory);\n            downloadedCount.incrementAndGet();\n            System.out.println(\"Downloaded: \" + url + \", Completed: \" + downloadedCount.get() + \" / \" + totalDownloads);\n        } catch (Exception e) {\n            System.err.println(\"Error downloading \" + url + \": \" + e.getMessage());\n        }\n    }\n\n    // rest of the methods\n}\n```\n\nWait, but I need to know the total number of downloads to show progress.\n\nI can pass the total number to the DownloadTask as well.\n\nSo, update the constructor:\n\n```java\npublic DownloadTask(String url, String saveDirectory, AtomicInteger downloadedCount, int totalDownloads) {\n    this.url = url;\n    this.saveDirectory = saveDirectory;\n    this.downloadedCount = downloadedCount;\n    this.totalDownloads = totalDownloads;\n}\n```\n\nAnd in the main method:\n\n```java\nint totalDownloads = urls.size();\nAtomicInteger downloadedCount = new AtomicInteger(0);\n\nfor (String url : urls) {\n    executor.execute(new DownloadTask(url, saveDirectory, downloadedCount, totalDownloads));\n}\n```\n\nThis way, each task can update the counter and print the progress.\n\nNow, I need to make sure that the directory exists before starting the downloads.\n\nI can do that in the main method:\n\n```java\nFile directory = new File(saveDirectory);\nif (!directory.exists()) {\n    directory.mkdirs();\n}\n```\n\nAlso, I should handle cases where the directory cannot be created, perhaps by throwing an exception or exiting the program.\n\nNow, let's think about how to make the list of URLs configurable.\n\nOne way is to read them from a file, say a text file where each line is a URL.\n\nI can add an option to specify the file containing the URLs.\n\nFor simplicity, I'll add another command-line argument for the file path.\n\nUpdate the main method:\n\n```java\npublic static void main(String[] args) {\n    if (args.length != 3) {\n        System.out.println(\"Usage: java MultiThreadedDownloader <url_file> <save_directory> <num_threads>\");\n        return;\n    }\n    String urlFile = args[0];\n    String saveDirectory = args[1];\n    int numThreads = Integer.parseInt(args[2]);\n\n    List<String> urls = readUrlsFromFile(urlFile);\n\n    File directory = new File(saveDirectory);\n    if (!directory.exists()) {\n        if (!directory.mkdirs()) {\n            System.err.println(\"Failed to create directory: \" + saveDirectory);\n            return;\n        }\n    }\n\n    ExecutorService executor = Executors.newFixedThreadPool(numThreads);\n    AtomicInteger downloadedCount = new AtomicInteger(0);\n    int totalDownloads = urls.size();\n\n    for (String url : urls) {\n        executor.execute(new DownloadTask(url, saveDirectory, downloadedCount, totalDownloads));\n    }\n\n    executor.shutdown();\n    while (!executor.isTerminated()) {\n        // Wait for all tasks to finish\n    }\n    System.out.println(\"All downloads complete.\");\n}\n\nprivate static List<String> readUrlsFromFile(String fileName) {\n    // Implementation to read URLs from file\n}\n```\n\nI need to implement the readUrlsFromFile method, which reads URLs from a file, one per line.\n\nI can use BufferedReader for this.\n\nHere's a simple implementation:\n\n```java\nprivate static List<String> readUrlsFromFile(String fileName) {\n    List<String> urls = new ArrayList<>();\n    try (BufferedReader br = new BufferedReader(new FileReader(fileName))) {\n        String line;\n        while ((line = br.readLine()) != null) {\n            urls.add(line.trim());\n        }\n    } catch (IOException e) {\n        System.err.println(\"Error reading URL file: \" + e.getMessage());\n    }\n    return urls;\n}\n```\n\nNow, the program can read URLs from a file specified by the user.\n\nI should also validate that the file exists and is readable.\n\nMaybe add a check before attempting to read it.\n\nUpdate the main method:\n\n```java\nFile file = new File(urlFile);\nif (!file.isFile() || !file.canRead()) {\n    System.err.println(\"URL file does not exist or is not readable: \" + urlFile);\n    return;\n}\nList<String> urls = readUrlsFromFile(urlFile);\n```\n\nAlright, now the program can read URLs from a file, save files to a specified directory, use a configurable number of threads, and handle concurrent downloads.\n\nI should also think about limiting the number of threads based on system resources to prevent overwhelming the system.\n\nBut for now, I'll assume the user knows how many threads are appropriate.\n\nAnother consideration is handling HTTP errors, such as 404 Not Found or 503 Service Unavailable.\n\nIn the downloadFile method, I should check the response code and handle errors accordingly.\n\nHere's an updated downloadFile method with response code checking:\n\n```java\npublic void downloadFile(String url, String saveDirectory) {\n    try {\n        URL website = new URL(url);\n        HttpURLConnection connection = (HttpURLConnection) website.openConnection();\n        connection.setRequestProperty(\"User-Agent\", \"Mozilla/5.0\");\n        int responseCode = connection.getResponseCode();\n        if (responseCode == HttpURLConnection.HTTP_OK) {\n            String disposition = connection.getHeaderField(\"Content-Disposition\");\n            String fileName;\n            if (disposition != null) {\n                int index = disposition.indexOf(\"filename=\");\n                if (index > 0) {\n                    fileName = disposition.substring(index + 10, disposition.length() - 1);\n                } else {\n                    fileName = getFileNameFromUrl(url);\n                }\n            } else {\n                fileName = getFileNameFromUrl(url);\n            }\n            String uniqueFileName = getUniqueFileName(url, saveDirectory, fileName);\n            ReadableByteChannel rbc = Channels.newChannel(connection.getInputStream());\n            FileOutputStream fos = new FileOutputStream(new File(saveDirectory, uniqueFileName));\n            fos.getChannel().transferFrom(rbc, 0, Long.MAX_VALUE);\n            fos.close();\n            rbc.close();\n            System.out.println(\"Downloaded: \" + url);\n        } else {\n            System.err.println(\"Failed to download \" + url + \", response code: \" + responseCode);\n        }\n    } catch (IOException e) {\n        System.err.println(\"Error downloading \" + url + \": \" + e.getMessage());\n    }\n}\n```\n\nI also need to modify getUniqueFileName to accept the base file name:\n\n```java\nprivate String getUniqueFileName(String url, String saveDirectory, String fileName) {\n    File file = new File(saveDirectory, fileName);\n    int count = 1;\n    while (file.exists()) {\n        String namePart = fileName.substring(0, fileName.lastIndexOf('.'));\n        String extensionPart = fileName.substring(fileName.lastIndexOf('.'));\n        file = new File(saveDirectory, namePart + \"_\" + count + extensionPart);\n        count++;\n    }\n    return file.getName();\n}\n```\n\nThis should handle cases where files with the same name are being downloaded multiple times.\n\nI should also consider adding timeouts to the URL connections to handle slow responses.\n\nI can set connect and read timeouts on the HttpURLConnection.\n\nHere's how to do that:\n\n```java\nconnection.setConnectTimeout(5000); // 5 seconds\nconnection.setReadTimeout(5000); // 5 seconds\n```\n\nI'll add these lines after opening the connection.\n\nNow, to make the program more user-friendly, I can display a progress bar or some kind of indicator showing how many files have been downloaded.\n\nBut implementing a progress bar in the console might be a bit involved.\n\nFor now, I'll stick with printing messages for each downloaded file.\n\nIf I want to make it more advanced, I could look into Java's ProgressBar API or use a third-party library.\n\nBut for this simple version, console messages should suffice.\n\nAnother thing to consider is pausing and resuming downloads, but that might be too complex for this initial implementation.\n\nI should also think about handling files that are already present in the directory.\n\nMaybe add an option to overwrite existing files or skip them.\n\nFor now, I'll keep it simple and always download the files, but with the unique naming to avoid overwriting.\n\nBut to make it more efficient, perhaps I should check if a file with the same name already exists and skip downloading it.\n\nHowever, there might be cases where the file was partially downloaded or corrupted, so overwriting should be an option.\n\nI can add a command-line option to decide whether to overwrite existing files or not.\n\nFor example, add a --overwrite flag.\n\nTo handle command-line options, I can use a library like Apache Commons CLI, but for simplicity, I'll handle it manually.\n\nUpdate the usage message:\n\n```java\nSystem.out.println(\"Usage: java MultiThreadedDownloader <url_file> <save_directory> <num_threads> [--overwrite]\");\n```\n\nThen, check if the last argument is --overwrite and set a flag accordingly.\n\nIn the main method:\n\n```java\nboolean overwrite = false;\nif (args.length == 4 && \"--overwrite\".equals(args[3])) {\n    overwrite = true;\n}\n```\n\nThen, in the downloadFile method, check if the file already exists and whether to overwrite it.\n\nSomething like:\n\n```java\nif (file.exists() && !overwrite) {\n    System.out.println(\"Skipping download, file already exists: \" + fileName);\n    downloadedCount.incrementAndGet();\n    return;\n}\n```\n\nThis way, if the --overwrite flag is not provided, and the file exists, it will skip downloading it.\n\nNow, I need to make sure that the program doesn't download the same URL multiple times.\n\nBut since the URLs are read from a file, it's up to the user to ensure there are no duplicates.\n\nAlternatively, I can remove duplicates from the list of URLs.\n\nIn the main method, after reading the URLs:\n\n```java\nSet<String> urlSet = new LinkedHashSet<>(urls);\nurls.clear();\nurls.addAll(urlSet);\n```\n\nThis will preserve the order and remove duplicates.\n\nNow, let's think about testing the program.\n\nI need to test it with a variety of URLs, including valid and invalid ones, to make sure it handles errors gracefully.\n\nI should also test with different numbers of threads to see how performance varies.\n\nMoreover, I need to make sure that the files are being saved correctly and that there are no race conditions or file access errors.\n\nI can create a small set of test URLs and a directory for downloads.\n\nAfter running the program, I can check if all the files are present in the directory and that their contents are correct.\n\nI can also monitor the program's CPU and memory usage to ensure it's not consuming too many resources.\n\nIn terms of error handling, I should make sure that if a thread encounters an exception, it doesn't bring down the entire program.\n\nEach download task should handle its own exceptions and continue without affecting other tasks.\n\nIn the current implementation, each task catches exceptions and prints an error message, which should suffice.\n\nOne more thing: I need to consider the file naming convention.\n\nIn getFileNameFromUrl, I'm taking the last part of the URL path as the file name.\n\nBut some URLs might not have a file extension, or the file name might not be indicative of the content.\n\nTo handle this, I can also look at the \"Content-Type\" header to determine the file extension if it's not present in the URL.\n\nFor example, if the Content-Type is \"image/jpeg\", I can append a .jpg extension to the file name.\n\nHere's how I can do that:\n\nUpdate the downloadFile method to get the Content-Type header and infer the extension if needed.\n\n```java\nString contentType = connection.getContentType();\nString extension = getExtensionFromContentType(contentType);\nif (extension != null && !fileName.contains(\".\")) {\n    fileName += \".\" + extension;\n}\n```\n\nAnd implement getExtensionFromContentType:\n\n```java\nprivate String getExtensionFromContentType(String contentType) {\n    if (contentType != null) {\n        if (contentType.startsWith(\"image/jpeg\")) return \"jpg\";\n        else if (contentType.startsWith(\"image/png\")) return \"png\";\n        else if (contentType.startsWith(\"application/pdf\")) return \"pdf\";\n        // add more mappings as needed\n    }\n    return null;\n}\n```\n\nThis should help in cases where the URL doesn't provide a file extension.\n\nNow, I need to consider if the program should handle redirects.\n\nBy default, HttpURLConnection follows redirects, so I don't need to do anything extra for that.\n\nBut I should make sure that the final URL is used to determine the file name, in case there are redirects.\n\nI can get the final URL after following redirects using connection.getURL().\n\nUpdate the downloadFile method to use the final URL for getting the file name.\n\n```java\nURL finalUrl = connection.getURL();\nString fileName = getFileNameFromUrl(finalUrl.toString());\n```\n\nThis ensures that even if there are redirects, the correct file name is used.\n\nAnother potential issue is that some servers might not like being hit with multiple concurrent requests from the same IP.\n\nTo mitigate this, I can add a user-agent string to the HTTP headers, as I've already done, and perhaps add a small delay between downloads.\n\nBut adding delays would defeat the purpose of multithreading, so I'll leave it out for now.\n\nUsers can adjust the number of threads based on the server's capacity.\n\nNow, to make the program more robust, I can add logging instead of printing to the console.\n\nJava has a built-in logging framework that I can use.\n\nI can configure logging to write to a file as well.\n\nBut for simplicity, I'll keep using System.out and System.err for now.\n\nFinally, I need to package the program in a way that makes it easy for users to run.\n\nI can compile the Java classes and provide a shell script or batch file to run the program with the correct classpath.\n\nAlternatively, I can create a JAR file with all the dependencies included.\n\nSince this is a simple program with no external dependencies, a JAR file should suffice.\n\nTo create a JAR file, I can use the jar command in Java.\n\nAssuming all the source files are in a src directory, I can compile them and create a JAR:\n\n```\njavac -d classes src/MultiThreadedDownloader.java\njar cf MultiThreadedDownloader.jar -C classes .\n```\n\nThen, users can run the program with:\n\n```\njava -jar MultiThreadedDownloader.jar <url_file> <save_directory> <num_threads> [--overwrite]\n```\n\nI should also create a README file explaining how to use the program, including the command-line arguments and any prerequisites.\n\nIn summary, here's the plan for the program:\n\n- Read URLs from a file specified by the user.\n\n- Download files from these URLs concurrently using a configurable number of threads.\n\n- Save the files to a specified directory, ensuring unique file names.\n\n- Option to overwrite existing files.\n\n- Handle HTTP errors and connection issues gracefully.\n\n- Provide progress messages for each downloaded file.\n\n- Ensure the program is thread-safe and handles concurrent file writes correctly.\n\nI think this covers the main requirements. Now, I'll proceed to implement the code based on this design.\n\n## Final Solution\nTo solve this problem, we need to create a Java program that uses multithreading to download multiple files concurrently from a list of URLs. The program should have a configurable number of threads and save the downloaded files to a specified directory.\n\n### Approach\n\n1. **Reading URLs from a File**: The program reads a list of URLs from a specified file.\n2. **Multithreading**: It uses a thread pool to manage a fixed number of threads for concurrent downloads.\n3. **File Downloading**: Each thread downloads a file from a URL and saves it to a specified directory with unique naming to avoid overwriting existing files.\n4. **Error Handling**: The program handles exceptions and logs errors for failed downloads.\n\n### Solution Code\n\n```java\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport java.nio.channels.*;\n\npublic class MultiThreadedDownloader {\n\n    public static void main(String[] args) {\n        if (args.length < 3) {\n            System.out.println(\"Usage: java MultiThreadedDownloader <url_file> <save_directory> <num_threads> [--overwrite]\");\n            return;\n        }\n        String urlFile = args[0];\n        String saveDirectory = args[1];\n        int numThreads = Integer.parseInt(args[2]);\n        boolean overwrite = Arrays.asList(args).contains(\"--overwrite\");\n\n        List<String> urls = readUrlsFromFile(urlFile);\n\n        File directory = new File(saveDirectory);\n        if (!directory.exists()) {\n            if (!directory.mkdirs()) {\n                System.err.println(\"Failed to create directory: \" + saveDirectory);\n                return;\n            }\n        }\n\n        ExecutorService executor = Executors.newFixedThreadPool(numThreads);\n        AtomicInteger downloadedCount = new AtomicInteger(0);\n        int totalDownloads = urls.size();\n\n        for (String url : urls) {\n            executor.execute(new DownloadTask(url, saveDirectory, downloadedCount, totalDownloads, overwrite));\n        }\n\n        executor.shutdown();\n        while (!executor.isTerminated()) {\n            // Wait for all tasks to finish\n        }\n        System.out.println(\"All downloads complete.\");\n    }\n\n    private static List<String> readUrlsFromFile(String fileName) {\n        List<String> urls = new ArrayList<>();\n        try (BufferedReader br = new BufferedReader(new FileReader(fileName))) {\n            String line;\n            while ((line = br.readLine()) != null) {\n                urls.add(line.trim());\n            }\n        } catch (IOException e) {\n            System.err.println(\"Error reading URL file: \" + e.getMessage());\n        }\n        return urls;\n    }\n}\n\nclass DownloadTask implements Runnable {\n    private String url;\n    private String saveDirectory;\n    private AtomicInteger downloadedCount;\n    private int totalDownloads;\n    private boolean overwrite;\n\n    public DownloadTask(String url, String saveDirectory, AtomicInteger downloadedCount, int totalDownloads, boolean overwrite) {\n        this.url = url;\n        this.saveDirectory = saveDirectory;\n        this.downloadedCount = downloadedCount;\n        this.totalDownloads = totalDownloads;\n        this.overwrite = overwrite;\n    }\n\n    @Override\n    public void run() {\n        try {\n            downloadFile(url, saveDirectory);\n            downloadedCount.incrementAndGet();\n            System.out.println(\"Downloaded: \" + url + \", Completed: \" + downloadedCount.get() + \" / \" + totalDownloads);\n        } catch (Exception e) {\n            System.err.println(\"Error downloading \" + url + \": \" + e.getMessage());\n        }\n    }\n\n    private void downloadFile(String url, String saveDirectory) throws IOException {\n        URL website = new URL(url);\n        HttpURLConnection connection = (HttpURLConnection) website.openConnection();\n        connection.setRequestProperty(\"User-Agent\", \"Mozilla/5.0\");\n        connection.setConnectTimeout(5000);\n        connection.setReadTimeout(5000);\n        int responseCode = connection.getResponseCode();\n        if (responseCode == HttpURLConnection.HTTP_OK) {\n            String disposition = connection.getHeaderField(\"Content-Disposition\");\n            String fileName;\n            if (disposition != null && disposition.contains(\"filename=\")) {\n                int index = disposition.indexOf(\"filename=\");\n                fileName = disposition.substring(index + 10, disposition.length() - 1);\n            } else {\n                fileName = getFileNameFromUrl(url);\n            }\n            File file = new File(saveDirectory, fileName);\n            if (file.exists() && !overwrite) {\n                System.out.println(\"Skipping download, file already exists: \" + fileName);\n                return;\n            }\n            String uniqueFileName = getUniqueFileName(saveDirectory, fileName);\n            ReadableByteChannel rbc = Channels.newChannel(connection.getInputStream());\n            FileOutputStream fos = new FileOutputStream(new File(saveDirectory, uniqueFileName));\n            fos.getChannel().transferFrom(rbc, 0, Long.MAX_VALUE);\n            fos.close();\n            rbc.close();\n            System.out.println(\"Downloaded: \" + url);\n        } else {\n            System.err.println(\"Failed to download \" + url + \", response code: \" + responseCode);\n        }\n    }\n\n    private String getFileNameFromUrl(String url) {\n        return url.substring(url.lastIndexOf('/') + 1);\n    }\n\n    private String getUniqueFileName(String saveDirectory, String fileName) {\n        File file = new File(saveDirectory, fileName);\n        if (!file.exists()) {\n            return fileName;\n        } else {\n            int count = 1;\n            String namePart = fileName.substring(0, fileName.lastIndexOf('.'));\n            String extensionPart = fileName.substring(fileName.lastIndexOf('.'));\n            while (true) {\n                String newFileName = namePart + \"_\" + count + extensionPart;\n                File newFile = new File(saveDirectory, newFileName);\n                if (!newFile.exists()) {\n                    return newFileName;\n                }\n                count++;\n            }\n        }\n    }\n}\n```\n\n### Explanation\n\n1. **Reading URLs**: The `readUrlsFromFile` method reads URLs from a specified file.\n2. **Thread Management**: An `ExecutorService` is used to manage a fixed number of threads based on user input.\n3. **Download Task**: Each `DownloadTask` downloads a file from a URL and saves it to the specified directory, ensuring unique file names and handling overwrite options.\n4. **Error Handling**: The program handles HTTP errors and I/O exceptions, logging errors for failed downloads.\n\nThis approach ensures efficient and concurrent downloading of files while managing resources effectively."
    }
]