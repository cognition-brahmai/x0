[
    {
        "role": "user",
        "content": "Implement a C++ class called \"Matrix\" that represents a 2D matrix of integers. The class should have methods for adding, subtracting, and multiplying matrices, as well as finding the determinant and inverse of a square matrix. Additionally, overload the input/output operators to read/write matrices from/to streams.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Alright, I'm going to try to implement this Matrix class in C++. It's been a while since I've done linear algebra, so I might need to brush up on some concepts like matrix multiplication, determinants, and inverses. But let's dive in.\n\nFirst, I need to define the Matrix class. It should represent a 2D matrix of integers. I'll probably use a vector of vectors to store the matrix elements, as vectors are dynamic and resizeable.\n\nSo, I'll include the necessary headers:\n\n```cpp\n#include <vector>\n#include <iostream>\n```\n\nNow, for the class definition:\n\n```cpp\nclass Matrix {\nprivate:\n    std::vector<std::vector<int>> data;\n    size_t rows;\n    size_t cols;\npublic:\n    // Constructors, methods, etc.\n};\n```\n\nI need to think about how to initialize the matrix. Maybe provide a constructor that takes the number of rows and columns, and optionally, a way to fill it with values.\n\nLet's create a constructor that takes rows and columns, and initializes the matrix with zeros:\n\n```cpp\nMatrix(size_t r, size_t c) : rows(r), cols(c), data(r, std::vector<int>(c, 0)) {}\n```\n\nAlso, I should probably have a constructor that allows initializing with a 2D vector:\n\n```cpp\nMatrix(const std::vector<std::vector<int>>& m) : data(m), rows(m.size()), cols(m[0].size()) {}\n```\n\nWait, but I need to ensure that all rows have the same number of columns. I should add a check for that.\n\n```cpp\nMatrix(const std::vector<std::vector<int>>& m) {\n    rows = m.size();\n    if (rows == 0) cols = 0;\n    else cols = m[0].size();\n    data = m;\n    // Check if all rows have the same number of columns\n    for (const auto& row : m) {\n        if (row.size() != cols) {\n            throw std::invalid_argument(\"All rows must have the same number of columns.\");\n        }\n    }\n}\n```\n\nGood, that should handle that.\n\nNow, I need to implement methods for adding, subtracting, and multiplying matrices.\n\nFor addition and subtraction, the matrices must have the same dimensions.\n\nLet's implement addition first.\n\n```cpp\nMatrix operator+(const Matrix& other) const {\n    if (rows != other.rows || cols != other.cols) {\n        throw std::invalid_argument(\"Matrices must have the same dimensions to add.\");\n    }\n    Matrix result(rows, cols);\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 0; j < cols; ++j) {\n            result.data[i][j] = data[i][j] + other.data[i][j];\n        }\n    }\n    return result;\n}\n```\n\nSimilarly for subtraction:\n\n```cpp\nMatrix operator-(const Matrix& other) const {\n    if (rows != other.rows || cols != other.cols) {\n        throw std::invalid_argument(\"Matrices must have the same dimensions to subtract.\");\n    }\n    Matrix result(rows, cols);\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 0; j < cols; ++j) {\n            result.data[i][j] = data[i][j] - other.data[i][j];\n        }\n    }\n    return result;\n}\n```\n\nFor multiplication, it's a bit more involved. The number of columns in the first matrix must match the number of rows in the second matrix.\n\nI need to implement matrix multiplication, which is not element-wise like addition and subtraction.\n\n```cpp\nMatrix operator*(const Matrix& other) const {\n    if (cols != other.rows) {\n        throw std::invalid_argument(\"The number of columns in the first matrix must match the number of rows in the second matrix.\");\n    }\n    Matrix result(rows, other.cols);\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 0; j < other.cols; ++j) {\n            int sum = 0;\n            for (size_t k = 0; k < cols; ++k) {\n                sum += data[i][k] * other.data[k][j];\n            }\n            result.data[i][j] = sum;\n        }\n    }\n    return result;\n}\n```\n\nThat should cover basic matrix multiplication.\n\nNext, finding the determinant. This is only possible for square matrices, so I need to ensure that rows == cols.\n\nI recall that for a 2x2 matrix, the determinant is ad - bc, where a, b, c, d are the elements.\n\nFor larger matrices, I think I need to use recursion and cofactor expansion.\n\nLet's implement a method to calculate the determinant.\n\nFirst, check if the matrix is square:\n\n```cpp\nint determinant() const {\n    if (rows != cols) {\n        throw std::invalid_argument(\"Matrix must be square to compute determinant.\");\n    }\n    // Implement determinant calculation\n}\n```\n\nFor a 1x1 matrix, the determinant is just that element.\n\nFor a 2x2 matrix, as I mentioned.\n\nFor larger matrices, I'll use recursion.\n\nHere's a rough idea:\n\n- For each element in the first row, compute the minor (the matrix without the row and column of that element), compute its determinant, multiply by the element and (-1)^(i+j), and sum them up.\n\nBut since it's a square matrix, j will be fixed for a given row.\n\nWait, actually, for cofactor expansion along the first row, j is always 1, since it's the first row.\n\nSo, for each element in the first row, compute the minor, compute its determinant, multiply by (-1)^(i+1), and sum.\n\nWait, more precisely, the cofactor for element a_ij is (-1)^(i+j) * det(minor_ij).\n\nFor expansion along the first row, i=1, so it's (-1)^(1+j).\n\nBut in code, indices start at 0, so adjust accordingly.\n\nThis might get complicated quickly, especially for larger matrices.\n\nAlternatively, I could use LU decomposition or other methods, but that might be overkill for this implementation.\n\nFor simplicity, I'll stick with the recursive cofactor expansion.\n\nLet's implement a helper function to get the minor matrix.\n\n```cpp\nMatrix minor(size_t row, size_t col) const {\n    Matrix m(rows - 1, cols - 1);\n    size_t r = 0;\n    for (size_t i = 0; i < rows; ++i) {\n        if (i == row) continue;\n        size_t c = 0;\n        for (size_t j = 0; j < cols; ++j) {\n            if (j == col) continue;\n            m.data[r][c] = data[i][j];\n            c++;\n        }\n        r++;\n    }\n    return m;\n}\n```\n\nNow, back to the determinant function.\n\nImplement it recursively:\n\n```cpp\nint determinant() const {\n    if (rows != cols) {\n        throw std::invalid_argument(\"Matrix must be square to compute determinant.\");\n    }\n    if (rows == 1) {\n        return data[0][0];\n    }\n    int det = 0;\n    for (size_t j = 0; j < cols; ++j) {\n        Matrix m = minor(0, j);\n        int cofactor = std::pow(-1, j) * m.determinant();\n        det += data[0][j] * cofactor;\n    }\n    return det;\n}\n```\n\nNote: std::pow returns a double, but since the exponent is an integer, it should be fine.\n\nWait, better to use a loop for exponentiation to keep it integer.\n\nLet's define a small helper function for that.\n\n```cpp\nint pow_int(int base, int exp) const {\n    int result = 1;\n    for (int i = 0; i < exp; ++i) {\n        result *= base;\n    }\n    return result;\n}\n```\n\nAnd modify the determinant function:\n\n```cpp\nint determinant() const {\n    if (rows != cols) {\n        throw std::invalid_argument(\"Matrix must be square to compute determinant.\");\n    }\n    if (rows == 1) {\n        return data[0][0];\n    }\n    int det = 0;\n    for (size_t j = 0; j < cols; ++j) {\n        Matrix m = minor(0, j);\n        int sign = (j % 2 == 0) ? 1 : -1;\n        int cofactor = sign * m.determinant();\n        det += data[0][j] * cofactor;\n    }\n    return det;\n}\n```\n\nThat should work.\n\nNext, finding the inverse of a matrix.\n\nAgain, only possible for square matrices, and the determinant must be non-zero.\n\nI think the formula for the inverse is (1/determinant) * adjugate(matrix), where adjugate is the transpose of the cofactor matrix.\n\nThis seems a bit involved.\n\nFirst, check if the matrix is square and determinant is non-zero.\n\nThen, compute the matrix of cofactors, transpose it, and multiply by (1/determinant).\n\nBut since we're dealing with integers, and division may result in fractions, I need to decide how to handle that.\n\nOption 1: Keep everything as integers, but store the inverse as a matrix of doubles or floats.\n\nOption 2: Only allow inverse if the determinant is 1 or -1, which would keep everything integer.\n\nOption 3: Implement rational numbers to store exact fractions.\n\nFor simplicity, I'll go with Option 1 and use doubles.\n\nSo, the inverse matrix will have double elements.\n\nAlternatively, I could change the Matrix class to templatize the type, but that might complicate things.\n\nWait, since the user specified that the matrix is of integers, but the inverse might have floats, I need to decide.\n\nPerhaps I'll make the inverse method return a matrix of doubles.\n\nBut then, I need to have a Matrix class that can handle different types, or perhaps have a separate class for matrices with double elements.\n\nThis could get messy.\n\nAlternatively, I could convert the integer matrix to a double matrix before computing the inverse.\n\nLet me think about this.\n\nMaybe I'll create a template class Matrix<T>, where T is the element type.\n\nThat would be more flexible.\n\nLet me redo the class as a template.\n\n```cpp\ntemplate<typename T>\nclass Matrix {\nprivate:\n    std::vector<std::vector<T>> data;\n    size_t rows;\n    size_t cols;\npublic:\n    Matrix(size_t r, size_t c) : rows(r), cols(c), data(r, std::vector<T>(c, T())) {}\n    Matrix(const std::vector<std::vector<T>>& m) {\n        rows = m.size();\n        if (rows == 0) cols = 0;\n        else cols = m[0].size();\n        data = m;\n        for (const auto& row : m) {\n            if (row.size() != cols) {\n                throw std::invalid_argument(\"All rows must have the same number of columns.\");\n            }\n        }\n    }\n    // Other methods...\n};\n```\n\nNow, I can have Matrix<int> for integer matrices and Matrix<double> for floating-point matrices.\n\nThis should make it easier to handle inverses.\n\nNow, for the inverse method, I can implement it only for square matrices, and return a Matrix<double>.\n\nBut to make it more flexible, perhaps I can implement it for any type that supports division, not just floats.\n\nI can use template specialization or enable_if to constrain the type.\n\nBut for simplicity, I'll assume that T supports division, and implement the inverse accordingly.\n\nAlternatively, I can specify that the inverse method only works for floating-point types.\n\nBut since the user specified a matrix of integers, and wants the inverse, I need to handle the conversion.\n\nMaybe I'll provide a method that returns a Matrix<double> inverse.\n\nSomething like:\n\n```cpp\nMatrix<double> inverse() const {\n    if (rows != cols) {\n        throw std::invalid_argument(\"Matrix must be square to compute inverse.\");\n    }\n    int det = determinant();\n    if (det == 0) {\n        throw std::invalid_argument(\"Matrix determinant is zero; inverse does not exist.\");\n    }\n    // Compute the matrix of cofactors\n    Matrix<T> cofactors(rows, cols);\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 0; j < cols; ++j) {\n            Matrix minor = this->minor(i, j);\n            int sign = (i + j) % 2 == 0 ? 1 : -1;\n            cofactors.data[i][j] = sign * minor.determinant();\n        }\n    }\n    // Transpose the cofactor matrix to get the adjugate\n    Matrix<T> adjugate(cols, rows);\n    for (size_t i = 0; i < rows; ++i++) {\n        for (size_t j = 0; j < cols; ++j++) {\n            adjugate.data[j][i] = cofactors.data[i][j];\n        }\n    }\n    // Divide each element by the determinant\n    Matrix<double> inverse(rows, cols);\n    double det_double = static_cast<double>(det);\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 0; j < cols; ++j) {\n            inverse.data[i][j] = static_cast<double>(adjugate.data[i][j]) / det_double;\n        }\n    }\n    return inverse;\n}\n```\n\nThis should work, but it's a bit involved.\n\nI need to make sure that the minor function is also templated correctly.\n\nWait, in the current setup, the minor function returns a Matrix<T>, which should be fine.\n\nAlso, the determinant function needs to be templated, but since it's recursive, it should work as long as T supports the necessary operations.\n\nI might need to adjust the determinant function to handle the base case appropriately for different types.\n\nBut for now, assuming T is int, it should work.\n\nNext, overloading the input and output operators.\n\nI need to overload << and >> operators to read and write matrices from/to streams.\n\nSince the class is templated, the operators should also be templated.\n\nLet's implement them as friend functions.\n\nFirst, the insertion operator (<<):\n\n```cpp\ntemplate<typename T>\nstd::ostream& operator<<(std::ostream& os, const Matrix<T>& m) {\n    for (const auto& row : m.data) {\n        for (const auto& elem : row) {\n            os << elem << ' ';\n        }\n        os << '\\n';\n    }\n    return os;\n}\n```\n\nAnd the extraction operator (>>):\n\n```cpp\ntemplate<typename T>\nstd::istream& operator>>(std::istream& is, Matrix<T>& m) {\n    for (auto& row : m.data) {\n        for (auto& elem : row) {\n            is >> elem;\n        }\n    }\n    return is;\n}\n```\n\nBut this assumes that the matrix has already been initialized with the correct size.\n\nTo make it more user-friendly, perhaps I can read the dimensions first, then read the elements.\n\nBut that would require allocating the matrix first.\n\nAlternatively, I can require that the matrix is initialized before reading from the stream.\n\nFor simplicity, I'll go with the latter approach.\n\nSo, the user needs to create a Matrix of the desired size, then read into it.\n\nSimilarly for output, it will print the matrix row by row, with elements separated by spaces.\n\nThat should suffice.\n\nLet me summarize what I have so far.\n\nI have a templated Matrix class that can handle any type T.\n\nIt has methods for addition, subtraction, multiplication, determinant, and inverse.\n\nThe inverse method assumes that T can be cast to double, and that division is defined for double.\n\nI've overloaded the << and >> operators for easy input and output.\n\nI need to test this implementation to make sure it works correctly.\n\nI should write some test cases to verify the operations.\n\nFor example:\n\n- Create two 2x2 matrices, add them, and check the result.\n\n- Multiply two 2x2 matrices and verify the product.\n\n- Compute the determinant of a 2x2 and a 3x3 matrix.\n\n- Find the inverse of a 2x2 matrix and verify that it's correct.\n\nI should also handle exceptions properly, especially when matrices have incompatible dimensions for operations like addition, subtraction, or multiplication.\n\nAdditionally, I need to ensure that the determinant and inverse methods only work for square matrices and that the determinant is non-zero for the inverse.\n\nI might want to add more error checking and perhaps improve the efficiency of some operations, especially for larger matrices.\n\nBut for a basic implementation, this should suffice.\n\nOne thing I notice is that the determinant calculation using recursion might be inefficient for large matrices, as it has exponential time complexity.\n\nIn practice, for small matrices, it's acceptable, but for larger ones, I should consider more efficient algorithms like LU decomposition.\n\nHowever, implementing LU decomposition might be beyond the scope of this task.\n\nFor now, the recursive approach will work for small matrices.\n\nAnother consideration is that the matrix elements are of type T, which could be any type supporting the necessary operations.\n\nBut I need to ensure that T supports addition, subtraction, multiplication, and, in the case of the inverse, division.\n\nTo make this more robust, I could use compile-time assertions or SFINAE to enable methods only if T supports the required operations.\n\nBut for simplicity, I'll assume that the user provides appropriate types.\n\nIn conclusion, I've implemented a templated Matrix class in C++ with the required operations and overloaded input/output operators.\n\nThis should meet the requirements of the task.\n\n## Final Solution\nTo implement a `Matrix` class in C++ that represents a 2D matrix of integers and supports operations like addition, subtraction, multiplication, determinant calculation, and finding the inverse, follow the steps below. This solution also overloads input and output operators for easy manipulation.\n\n### Approach\n\n1. **Class Definition**: Use a vector of vectors to store matrix elements.\n2. **Constructors**: Initialize matrices with given dimensions or from a 2D vector, ensuring all rows have the same number of columns.\n3. **Operations**:\n   - **Addition and Subtraction**: Matrices must have the same dimensions.\n   - **Multiplication**: The number of columns in the first matrix must match the number of rows in the second matrix.\n   - **Determinant**: Only for square matrices, calculated using recursion.\n   - **Inverse**: Only for square matrices with a non-zero determinant, computed using the adjugate matrix and determinant.\n4. **Input/Output Operators**: Overload `<<` and `>>` for easy matrix streaming.\n\n### Solution Code\n\n```cpp\n#include <vector>\n#include <iostream>\n\ntemplate<typename T>\nclass Matrix {\nprivate:\n    std::vector<std::vector<T>> data;\n    size_t rows;\n    size_t cols;\n\n    Matrix minor(size_t row, size_t col) const {\n        Matrix m(rows - 1, cols - 1);\n        size_t r = 0;\n        for (size_t i = 0; i < rows; ++i) {\n            if (i == row) continue;\n            size_t c = 0;\n            for (size_t j = 0; j < cols; ++j) {\n                if (j == col) continue;\n                m.data[r][c] = data[i][j];\n                c++;\n            }\n            r++;\n        }\n        return m;\n    }\n\npublic:\n    Matrix(size_t r, size_t c) : rows(r), cols(c), data(r, std::vector<T>(c, T())) {}\n\n    Matrix(const std::vector<std::vector<T>>& m) {\n        rows = m.size();\n        if (rows == 0) cols = 0;\n        else cols = m[0].size();\n        data = m;\n        for (const auto& row : m) {\n            if (row.size() != cols) {\n                throw std::invalid_argument(\"All rows must have the same number of columns.\");\n            }\n        }\n    }\n\n    Matrix operator+(const Matrix& other) const {\n        if (rows != other.rows || cols != other.cols) {\n            throw std::invalid_argument(\"Matrices must have the same dimensions to add.\");\n        }\n        Matrix result(rows, cols);\n        for (size_t i = 0; i < rows; ++i) {\n            for (size_t j = 0; j < cols; ++j) {\n                result.data[i][j] = data[i][j] + other.data[i][j];\n            }\n        }\n        return result;\n    }\n\n    Matrix operator-(const Matrix& other) const {\n        if (rows != other.rows || cols != other.cols) {\n            throw std::invalid_argument(\"Matrices must have the same dimensions to subtract.\");\n        }\n        Matrix result(rows, cols);\n        for (size_t i = 0; i < rows; ++i) {\n            for (size_t j = 0; j < cols; ++j) {\n                result.data[i][j] = data[i][j] - other.data[i][j];\n            }\n        }\n        return result;\n    }\n\n    Matrix operator*(const Matrix& other) const {\n        if (cols != other.rows) {\n            throw std::invalid_argument(\"The number of columns in the first matrix must match the number of rows in the second matrix.\");\n        }\n        Matrix result(rows, other.cols);\n        for (size_t i = 0; i < rows; ++i) {\n            for (size_t j = 0; j < other.cols; ++j) {\n                T sum = 0;\n                for (size_t k = 0; k < cols; ++k) {\n                    sum += data[i][k] * other.data[k][j];\n                }\n                result.data[i][j] = sum;\n            }\n        }\n        return result;\n    }\n\n    T determinant() const {\n        if (rows != cols) {\n            throw std::invalid_argument(\"Matrix must be square to compute determinant.\");\n        }\n        if (rows == 1) {\n            return data[0][0];\n        }\n        T det = 0;\n        for (size_t j = 0; j < cols; ++j) {\n            Matrix m = minor(0, j);\n            int sign = (j % 2 == 0) ? 1 : -1;\n            det += data[0][j] * sign * m.determinant();\n        }\n        return det;\n    }\n\n    Matrix<double> inverse() const {\n        if (rows != cols) {\n            throw std::invalid_argument(\"Matrix must be square to compute inverse.\");\n        }\n        T det = determinant();\n        if (det == 0) {\n            throw std::invalid_argument(\"Matrix determinant is zero; inverse does not exist.\");\n        }\n        // Compute the matrix of cofactors\n        Matrix<T> cofactors(rows, cols);\n        for (size_t i = 0; i < rows; ++i) {\n            for (size_t j = 0; j < cols; ++j) {\n                Matrix m = minor(i, j);\n                int sign = (i + j) % 2 == 0 ? 1 : -1;\n                cofactors.data[i][j] = sign * m.determinant();\n            }\n        }\n        // Transpose the cofactor matrix to get the adjugate\n        Matrix<T> adjugate(cols, rows);\n        for (size_t i = 0; i < rows; ++i++) {\n            for (size_t j = 0; j < cols; ++j++) {\n                adjugate.data[j][i] = cofactors.data[i][j];\n            }\n        }\n        // Divide each element by the determinant\n        Matrix<double> inverse(rows, cols);\n        double det_double = static_cast<double>(det);\n        for (size_t i = 0; i < rows; ++i) {\n            for (size_t j = 0; j < cols; ++j) {\n                inverse.data[i][j] = static_cast<double>(adjugate.data[i][j]) / det_double;\n            }\n        }\n        return inverse;\n    }\n};\n\ntemplate<typename T>\nstd::ostream& operator<<(std::ostream& os, const Matrix<T>& m) {\n    for (const auto& row : m.data) {\n        for (const auto& elem : row) {\n            os << elem << ' ';\n        }\n        os << '\\n';\n    }\n    return os;\n}\n\ntemplate<typename T>\nstd::istream& operator>>(std::istream& is, Matrix<T>& m) {\n    for (auto& row : m.data) {\n        for (auto& elem : row) {\n            is >> elem;\n        }\n    }\n    return is;\n}\n```\n\n### Explanation\n\n- **Matrix Representation**: Uses a vector of vectors for dynamic storage.\n- **Operations**:\n  - **Addition and Subtraction**: Element-wise operations require matrices of the same dimensions.\n  - **Multiplication**: Checks compatibility of dimensions and performs matrix multiplication.\n  - **Determinant**: Recursively calculates the determinant for square matrices.\n  - **Inverse**: Computes the inverse using the adjugate matrix and determinant, ensuring the matrix is square and non-singular.\n- **Input/Output**: Overloaded operators for easy matrix streaming, ensuring correct formatting and input handling."
    }
]