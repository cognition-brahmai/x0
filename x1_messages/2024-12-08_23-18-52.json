[
    {
        "role": "user",
        "content": "Develop a C++ program that reads a CSV file containing user information (name, age, email) and stores the data in an SQLite database. The program should also provide functionality to query the database for users based on their age or email address.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Alright, I've got this task to create a C++ program that reads a CSV file with user information\u2014name, age, email\u2014and stores it into an SQLite database. Also, the program needs to let users query the database based on age or email address. Okay, let's break this down.\n\nFirst things first, I need to make sure I have SQLite set up for use with C++. SQLite is a C library, so I'll need to include the appropriate headers and link against the SQLite library. I should check if the system has SQLite installed, and if not, guide the user on how to install it.\n\nFor reading the CSV file, I'll need to parse it line by line, splitting each line into its respective fields: name, age, and email. I need to be careful with potential commas within the fields or quoted strings, but for simplicity, let's assume the CSV is well-formed and doesn't have such complexities.\n\nStoring the data into the SQLite database means creating a table if it doesn't exist, and then inserting the records from the CSV into this table. I need to handle any potential errors that might occur during database operations, like connection failures or SQL errors.\n\nFor the query functionality, users should be able to search for users based on age or email. This probably involves constructing SQL queries based on the user's input and then executing those queries to fetch and display the results.\n\nLet me think about the structure of the program. It should have functions for connecting to the database, creating the table, reading the CSV file, inserting data into the database, and performing queries. It might be good to have a menu-driven interface so users can choose whether to import data from a CSV or perform a query.\n\nSecurity is also a concern, especially when dealing with user inputs for queries. I need to make sure to prevent SQL injection attacks, perhaps by using parameterized queries.\n\nLet's outline the steps:\n\n1. **Connect to SQLite database:**\n\n- Open a connection to the SQLite database file.\n\n2. **Create table if it doesn't exist:**\n\n- Execute a SQL command to create a table with columns for name, age, and email.\n\n3. **Read CSV file:**\n\n- Open the CSV file.\n\n- Read each line and split it into name, age, and email.\n\n- Insert each record into the database.\n\n4. **Query functionality:**\n\n- Allow users to input an age or an email address to search for.\n\n- Construct and execute the appropriate SQL query.\n\n- Display the results.\n\nI need to handle exceptions and errors gracefully, providing meaningful messages to the user.\n\nAlso, I should consider the data types for each column in the database. Name and email are strings, and age is an integer.\n\nLet me sketch a rough code structure.\n\nFirst, include necessary headers:\n\n```cpp\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <string>\n#include <sqlite3.h>\n```\n\nDefine constants for the database and table:\n\n```cpp\nconst char* DB_NAME = \"users.db\";\nconst char* TABLE_NAME = \"users\";\n```\n\nFunction to connect to the database:\n\n```cpp\nsqlite3* connectToDB() {\n    sqlite3* db;\n    int rc = sqlite3_open(DB_NAME, &db);\n    if (rc) {\n        std::cerr << \"Can't open database: \" << sqlite3_errmsg(db) << std::endl;\n        sqlite3_close(db);\n        return nullptr;\n    }\n    return db;\n}\n```\n\nFunction to create the table:\n\n```cpp\nvoid createTable(sqlite3* db) {\n    const char* sql = \"CREATE TABLE IF NOT EXISTS \" TABLE_NAME \" (\"\n                      \"id INTEGER PRIMARY KEY AUTOINCREMENT,\"\n                      \"name TEXT NOT NULL,\"\n                      \"age INTEGER NOT NULL,\"\n                      \"email TEXT UNIQUE NOT NULL\"\n                      \");\";\n    char* errMsg = 0;\n    int rc = sqlite3_exec(db, sql, 0, 0, &errMsg);\n    if (rc != SQLITE_OK) {\n        std::cerr << \"SQL error: \" << errMsg << std::endl;\n        sqlite3_free(errMsg);\n    } else {\n        std::cout << \"Table created successfully\" << std::endl;\n    }\n}\n```\n\nFunction to read CSV and insert data:\n\n```cpp\nvoid importCSV(sqlite3* db, const std::string& filename) {\n    std::ifstream file(filename);\n    if (!file.is_open()) {\n        std::cerr << \"Could not open the file - '\" << filename << \"'\" << std::endl;\n        return;\n    }\n\n    std::string line;\n    while (std::getline(file, line)) {\n        std::stringstream ss(line);\n        std::string name, email;\n        int age;\n        if (std::getline(ss, name, ',') && std::getline(ss, email, ',') && ss >> age) {\n            // Prepare SQL statement\n            sqlite3_stmt* stmt;\n            const char* sql = \"INSERT INTO \" TABLE_NAME \" (name, age, email) VALUES (?, ?, ?);\";\n            int rc = sqlite3_prepare_v2(db, sql, -1, &stmt, 0);\n            if (rc != SQLITE_OK) {\n                std::cerr << \"Prepare statement failed: \" << sqlite3_errmsg(db) << std::endl;\n                continue;\n            }\n\n            // Bind parameters\n            sqlite3_bind_text(stmt, 1, name.c_str(), -1, SQLITE_TRANSIENT);\n            sqlite3_bind_int(stmt, 2, age);\n            sqlite3_bind_text(stmt, 3, email.c_str(), -1, SQLITE_TRANSIENT);\n\n            // Execute statement\n            rc = sqlite3_step(stmt);\n            if (rc != SQLITE_DONE) {\n                std::cerr << \"Execution error: \" << sqlite3_errmsg(db) << std::endl;\n            }\n\n            // Finalize statement\n            sqlite3_finalize(stmt);\n        } else {\n            std::cerr << \"Error parsing line: \" << line << std::endl;\n        }\n    }\n    file.close();\n}\n```\n\nFunction to perform queries:\n\n```cpp\nvoid queryDatabase(sqlite3* db, const std::string& query) {\n    char* errMsg = 0;\n    int rc = sqlite3_exec(db, query.c_str(), callback, 0, &errMsg);\n    if (rc != SQLITE_OK) {\n        std::cerr << \"SQL error: \" << errMsg << std::endl;\n        sqlite3_free(errMsg);\n    }\n}\n\n// Callback function to handle query results\nstatic int callback(void* NotUsed, int argc, char** argv, char** azColName) {\n    for (int i = 0; i < argc; i++) {\n        std::cout << azColName[i] << \" = \" << (argv[i] ? argv[i] : \"NULL\") << std::endl;\n    }\n    std::cout << std::endl;\n    return 0;\n}\n```\n\nMain function to handle user input:\n\n```cpp\nint main() {\n    sqlite3* db = connectToDB();\n    if (!db) {\n        return 1;\n    }\n\n    createTable(db);\n\n    int choice;\n    do {\n        std::cout << \"\\nMenu:\\n\";\n        std::cout << \"1. Import CSV\\n\";\n        std::cout << \"2. Query by age\\n\";\n        std::cout << \"3. Query by email\\n\";\n        std::cout << \"4. Exit\\n\";\n        std::cout << \"Enter choice: \";\n        std::cin >> choice;\n\n        switch (choice) {\n            case 1: {\n                std::string filename;\n                std::cout << \"Enter CSV filename: \";\n                std::cin.ignore();\n                std::getline(std::cin, filename);\n                importCSV(db, filename);\n                break;\n            }\n            case 2: {\n                int age;\n                std::cout << \"Enter age to query: \";\n                std::cin >> age;\n                std::ostringstream oss;\n                oss << \"SELECT * FROM \" << TABLE_NAME << \" WHERE age = \" << age << \";\";\n                queryDatabase(db, oss.str());\n                break;\n            }\n            case 3: {\n                std::string email;\n                std::cout << \"Enter email to query: \";\n                std::cin.ignore();\n                std::getline(std::cin, email);\n                std::ostringstream oss;\n                oss << \"SELECT * FROM \" << TABLE_NAME << \" WHERE email = '\" << email << \"';\";\n                queryDatabase(db, oss.str());\n                break;\n            }\n            case 4:\n                std::cout << \"Exiting...\" << std::endl;\n                break;\n            default:\n                std::cout << \"Invalid choice. Please try again.\" << std::endl;\n        }\n    } while (choice != 4);\n\n    sqlite3_close(db);\n    return 0;\n}\n```\n\nWait a minute, in the query functions, especially for email, I'm directly inserting the user input into the SQL query, which is a big no-no because it can lead to SQL injection attacks. I need to fix that by using parameterized queries.\n\nLet me revise the query functions to use `sqlite3_prepare_v2` and bind parameters instead of string concatenation.\n\nHere's an improved version for querying by email:\n\n```cpp\nvoid queryByEmail(sqlite3* db, const std::string& email) {\n    sqlite3_stmt* stmt;\n    const char* sql = \"SELECT * FROM \" TABLE_NAME \" WHERE email = ?;\";\n    int rc = sqlite3_prepare_v2(db, sql, -1, &stmt, 0);\n    if (rc != SQLITE_OK) {\n        std::cerr << \"Prepare statement failed: \" << sqlite3_errmsg(db) << std::endl;\n        return;\n    }\n\n    // Bind parameters\n    sqlite3_bind_text(stmt, 1, email.c_str(), -1, SQLITE_TRANSIENT);\n\n    // Execute statement\n    rc = sqlite3_step(stmt);\n    if (rc == SQLITE_ROW) {\n        int id = sqlite3_column_int(stmt, 0);\n        const unsigned char* name = sqlite3_column_text(stmt, 1);\n        int age = sqlite3_column_int(stmt, 2);\n        const unsigned char* email = sqlite3_column_text(stmt, 3);\n\n        std::cout << \"ID: \" << id << std::endl;\n        std::cout << \"Name: \" << name << std::endl;\n        std::cout << \"Age: \" << age << std::endl;\n        std::cout << \"Email: \" << email << std::endl;\n    } else {\n        std::cout << \"No results found.\" << std::endl;\n    }\n\n    // Finalize statement\n    sqlite3_finalize(stmt);\n}\n```\n\nSimilarly, for querying by age:\n\n```cpp\nvoid queryByAge(sqlite3* db, int age) {\n    sqlite3_stmt* stmt;\n    const char* sql = \"SELECT * FROM \" TABLE_NAME \" WHERE age = ?;\";\n    int rc = sqlite3_prepare_v2(db, sql, -1, &stmt, 0);\n    if (rc != SQLITE_OK) {\n        std::cerr << \"Prepare statement failed: \" << sqlite3_errmsg(db) << std::endl;\n        return;\n    }\n\n    // Bind parameters\n    sqlite3_bind_int(stmt, 1, age);\n\n    // Execute statement\n    rc = sqlite3_step(stmt);\n    while (rc == SQLITE_ROW) {\n        int id = sqlite3_column_int(stmt, 0);\n        const unsigned char* name = sqlite3_column_text(stmt, 1);\n        int age = sqlite3_column_int(stmt, 2);\n        const unsigned char* email = sqlite3_column_text(stmt, 3);\n\n        std::cout << \"ID: \" << id << std::endl;\n        std::cout << \"Name: \" << name << std::endl;\n        std::cout << \"Age: \" << age << std::endl;\n        std::cout << \"Email: \" << email << std::endl;\n        std::cout << std::endl;\n\n        rc = sqlite3_step(stmt);\n    }\n\n    if (rc != SQLITE_DONE) {\n        std::cerr << \"Execution error: \" << sqlite3_errmsg(db) << std::endl;\n    }\n\n    // Finalize statement\n    sqlite3_finalize(stmt);\n}\n```\n\nNow, in the main function, I can call these functions instead of constructing SQL queries as strings.\n\nAlso, I should handle the case where multiple rows might match the age query, so I need to loop through all rows returned.\n\nLet me update the main function accordingly:\n\n```cpp\nint main() {\n    sqlite3* db = connectToDB();\n    if (!db) {\n        return 1;\n    }\n\n    createTable(db);\n\n    int choice;\n    do {\n        std::cout << \"\\nMenu:\\n\";\n        std::cout << \"1. Import CSV\\n\";\n        std::cout << \"2. Query by age\\n\";\n        std::cout << \"3. Query by email\\n\";\n        std::cout << \"4. Exit\\n\";\n        std::cout << \"Enter choice: \";\n        std::cin >> choice;\n\n        switch (choice) {\n            case 1: {\n                std::string filename;\n                std::cout << \"Enter CSV filename: \";\n                std::cin.ignore();\n                std::getline(std::cin, filename);\n                importCSV(db, filename);\n                break;\n            }\n            case 2: {\n                int age;\n                std::cout << \"Enter age to query: \";\n                std::cin >> age;\n                queryByAge(db, age);\n                break;\n            }\n            case 3: {\n                std::string email;\n                std::cout << \"Enter email to query: \";\n                std::cin.ignore();\n                std::getline(std::cin, email);\n                queryByEmail(db, email);\n                break;\n            }\n            case 4:\n                std::cout << \"Exiting...\" << std::endl;\n                break;\n            default:\n                std::cout << \"Invalid choice. Please try again.\" << std::endl;\n        }\n    } while (choice != 4);\n\n    sqlite3_close(db);\n    return 0;\n}\n```\n\nThis looks better. Now, the program uses parameterized queries for both age and email searches, which should prevent SQL injection attacks.\n\nI should also think about error handling in the import function. For example, if the CSV file doesn't exist or has incorrect formatting, the program should inform the user appropriately without crashing.\n\nAdditionally, I might want to add some validation for the age field, ensuring it's a positive integer and within a reasonable range.\n\nFor now, this seems like a solid starting point. I can test this program with a sample CSV file containing names, ages, and emails, and then perform queries based on age and email to verify that everything works as expected.\n\n## Final Solution\nTo solve this problem, we need to develop a C++ program that reads user information from a CSV file and stores it in an SQLite database. The program should also provide functionality to query the database based on user age or email address.\n\n### Approach\n\n1. **Connect to SQLite Database:**\n   - Open a connection to the SQLite database file.\n\n2. **Create Table if it Doesn't Exist:**\n   - Execute a SQL command to create a table with columns for name, age, and email.\n\n3. **Read CSV File:**\n   - Open the CSV file.\n   - Read each line and split it into name, age, and email.\n   - Insert each record into the database.\n\n4. **Query Functionality:**\n   - Allow users to input an age or an email address to search for.\n   - Construct and execute the appropriate SQL query.\n   - Display the results.\n\n### Solution Code\n\n```cpp\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <string>\n#include <sqlite3.h>\n\nconst char* DB_NAME = \"users.db\";\nconst char* TABLE_NAME = \"users\";\n\nsqlite3* connectToDB() {\n    sqlite3* db;\n    int rc = sqlite3_open(DB_NAME, &db);\n    if (rc) {\n        std::cerr << \"Can't open database: \" << sqlite3_errmsg(db) << std::endl;\n        sqlite3_close(db);\n        return nullptr;\n    }\n    return db;\n}\n\nvoid createTable(sqlite3* db) {\n    const char* sql = \"CREATE TABLE IF NOT EXISTS \" TABLE_NAME \" (\"\n                      \"id INTEGER PRIMARY KEY AUTOINCREMENT,\"\n                      \"name TEXT NOT NULL,\"\n                      \"age INTEGER NOT NULL,\"\n                      \"email TEXT UNIQUE NOT NULL\"\n                      \");\";\n    char* errMsg = 0;\n    int rc = sqlite3_exec(db, sql, 0, 0, &errMsg);\n    if (rc != SQLITE_OK) {\n        std::cerr << \"SQL error: \" << errMsg << std::endl;\n        sqlite3_free(errMsg);\n    } else {\n        std::cout << \"Table created successfully\" << std::endl;\n    }\n}\n\nvoid importCSV(sqlite3* db, const std::string& filename) {\n    std::ifstream file(filename);\n    if (!file.is_open()) {\n        std::cerr << \"Could not open the file - '\" << filename << \"'\" << std::endl;\n        return;\n    }\n\n    std::string line;\n    while (std::getline(file, line)) {\n        std::stringstream ss(line);\n        std::string name, email;\n        int age;\n        if (std::getline(ss, name, ',') && std::getline(ss, email, ',') && ss >> age) {\n            sqlite3_stmt* stmt;\n            const char* sql = \"INSERT INTO \" TABLE_NAME \" (name, age, email) VALUES (?, ?, ?);\";\n            int rc = sqlite3_prepare_v2(db, sql, -1, &stmt, 0);\n            if (rc != SQLITE_OK) {\n                std::cerr << \"Prepare statement failed: \" << sqlite3_errmsg(db) << std::endl;\n                continue;\n            }\n\n            sqlite3_bind_text(stmt, 1, name.c_str(), -1, SQLITE_TRANSIENT);\n            sqlite3_bind_int(stmt, 2, age);\n            sqlite3_bind_text(stmt, 3, email.c_str(), -1, SQLITE_TRANSIENT);\n\n            rc = sqlite3_step(stmt);\n            if (rc != SQLITE_DONE) {\n                std::cerr << \"Execution error: \" << sqlite3_errmsg(db) << std::endl;\n            }\n\n            sqlite3_finalize(stmt);\n        } else {\n            std::cerr << \"Error parsing line: \" << line << std::endl;\n        }\n    }\n    file.close();\n}\n\nvoid queryByAge(sqlite3* db, int age) {\n    sqlite3_stmt* stmt;\n    const char* sql = \"SELECT * FROM \" TABLE_NAME \" WHERE age = ?;\";\n    int rc = sqlite3_prepare_v2(db, sql, -1, &stmt, 0);\n    if (rc != SQLITE_OK) {\n        std::cerr << \"Prepare statement failed: \" << sqlite3_errmsg(db) << std::endl;\n        return;\n    }\n\n    sqlite3_bind_int(stmt, 1, age);\n\n    rc = sqlite3_step(stmt);\n    while (rc == SQLITE_ROW) {\n        int id = sqlite3_column_int(stmt, 0);\n        const unsigned char* name = sqlite3_column_text(stmt, 1);\n        int age = sqlite3_column_int(stmt, 2);\n        const unsigned char* email = sqlite3_column_text(stmt, 3);\n\n        std::cout << \"ID: \" << id << std::endl;\n        std::cout << \"Name: \" << name << std::endl;\n        std::cout << \"Age: \" << age << std::endl;\n        std::cout << \"Email: \" << email << std::endl;\n        std::cout << std::endl;\n\n        rc = sqlite3_step(stmt);\n    }\n\n    if (rc != SQLITE_DONE) {\n        std::cerr << \"Execution error: \" << sqlite3_errmsg(db) << std::endl;\n    }\n\n    sqlite3_finalize(stmt);\n}\n\nvoid queryByEmail(sqlite3* db, const std::string& email) {\n    sqlite3_stmt* stmt;\n    const char* sql = \"SELECT * FROM \" TABLE_NAME \" WHERE email = ?;\";\n    int rc = sqlite3_prepare_v2(db, sql, -1, &stmt, 0);\n    if (rc != SQLITE_OK) {\n        std::cerr << \"Prepare statement failed: \" << sqlite3_errmsg(db) << std::endl;\n        return;\n    }\n\n    sqlite3_bind_text(stmt, 1, email.c_str(), -1, SQLITE_TRANSIENT);\n\n    rc = sqlite3_step(stmt);\n    if (rc == SQLITE_ROW) {\n        int id = sqlite3_column_int(stmt, 0);\n        const unsigned char* name = sqlite3_column_text(stmt, 1);\n        int age = sqlite3_column_int(stmt, 2);\n        const unsigned char* email = sqlite3_column_text(stmt, 3);\n\n        std::cout << \"ID: \" << id << std::endl;\n        std::cout << \"Name: \" << name << std::endl;\n        std::cout << \"Age: \" << age << std::endl;\n        std::cout << \"Email: \" << email << std::endl;\n    } else {\n        std::cout << \"No results found.\" << std::endl;\n    }\n\n    sqlite3_finalize(stmt);\n}\n\nint main() {\n    sqlite3* db = connectToDB();\n    if (!db) {\n        return 1;\n    }\n\n    createTable(db);\n\n    int choice;\n    do {\n        std::cout << \"\\nMenu:\\n\";\n        std::cout << \"1. Import CSV\\n\";\n        std::cout << \"2. Query by age\\n\";\n        std::cout << \"3. Query by email\\n\";\n        std::cout << \"4. Exit\\n\";\n        std::cout << \"Enter choice: \";\n        std::cin >> choice;\n\n        switch (choice) {\n            case 1: {\n                std::string filename;\n                std::cout << \"Enter CSV filename: \";\n                std::cin.ignore();\n                std::getline(std::cin, filename);\n                importCSV(db, filename);\n                break;\n            }\n            case 2: {\n                int age;\n                std::cout << \"Enter age to query: \";\n                std::cin >> age;\n                queryByAge(db, age);\n                break;\n            }\n            case 3: {\n                std::string email;\n                std::cout << \"Enter email to query: \";\n                std::cin.ignore();\n                std::getline(std::cin, email);\n                queryByEmail(db, email);\n                break;\n            }\n            case 4:\n                std::cout << \"Exiting...\" << std::endl;\n                break;\n            default:\n                std::cout << \"Invalid choice. Please try again.\" << std::endl;\n        }\n    } while (choice != 4);\n\n    sqlite3_close(db);\n    return 0;\n}\n```\n\n### Explanation\n\n1. **Database Connection:**\n   - The `connectToDB` function establishes a connection to the SQLite database file specified by `DB_NAME`.\n\n2. **Table Creation:**\n   - The `createTable` function creates a table named `users` with columns for `id`, `name`, `age`, and `email` if it doesn't already exist.\n\n3. **CSV Import:**\n   - The `importCSV` function reads a CSV file, parses each line into name, email, and age, and inserts the data into the database using parameterized queries to avoid SQL injection.\n\n4. **Query Functionality:**\n   - The `queryByAge` and `queryByEmail` functions allow users to query the database based on age or email, respectively, using parameterized queries for safety.\n\n5. **Menu-Driven Interface:**\n   - The `main` function provides a menu for users to choose between importing a CSV file, querying by age, querying by email, or exiting the program."
    }
]