[
    {
        "role": "user",
        "content": "Implement a simple stack data structure in C++. The stack should support push, pop, and peek operations. Additionally, it should have a method to check whether it's empty or not. Include a main function to demonstrate these operations."
    },
    {
        "role": "assistant",
        "content": "Sure! I'd be happy to help you with that. So, you want to implement a simple stack data structure in C++, right? A stack is a Last-In-First-Out (LIFO) data structure, which means the last element you add is the first one to be removed. It's like a stack of plates; you can only take the top plate off.\n\nWe'll need to create a class for the stack that includes methods for pushing elements onto the stack, popping elements off the stack, peeking at the top element without removing it, and checking if the stack is empty.\n\nLet's start by including the necessary headers. We'll need `<iostream>` for input and output operations and `<cstdlib>` for the `exit` function in case of errors.\n\n```cpp\n#include <iostream>\n#include <cstdlib>\n```\n\nNext, we'll define the Stack class. We'll use an array to store the elements of the stack, and we'll need to keep track of the top of the stack.\n\n```cpp\nclass Stack {\nprivate:\n    static const int MAX_SIZE = 100; // Maximum size of the stack\n    int arr[MAX_SIZE];\n    int top; // Index of the top element\npublic:\n    Stack() : top(-1) {} // Constructor initializes top to -1\n    void push(int value);\n    int pop();\n    int peek();\n    bool isEmpty();\n};\n```\n\nNow, let's implement each of these methods.\n\n1. **Push operation**: This method adds an element to the top of the stack. We need to check if the stack is full before pushing.\n\n```cpp\nvoid Stack::push(int value) {\n    if (top >= MAX_SIZE - 1) {\n        std::cout << \"Stack overflow. Cannot push \" << value << std::endl;\n        exit(1);\n    }\n    arr[++top] = value;\n    std::cout << \"Pushed \" << value << \" onto the stack.\" << std::endl;\n}\n```\n\n2. **Pop operation**: This method removes the top element from the stack and returns it. We need to check if the stack is empty before popping.\n\n```cpp\nint Stack::pop() {\n    if (top < 0) {\n        std::cout << \"Stack underflow. Cannot pop from an empty stack.\" << std::endl;\n        exit(1);\n    }\n    int value = arr[top--];\n    std::cout << \"Popped \" << value << \" from the stack.\" << std::endl;\n    return value;\n}\n```\n\n3. **Peek operation**: This method returns the top element without removing it. Again, we need to check if the stack is empty.\n\n```cpp\nint Stack::peek() {\n    if (top < 0) {\n        std::cout << \"Stack is empty. Cannot peek.\" << std::endl;\n        exit(1);\n    }\n    return arr[top];\n}\n```\n\n4. **IsEmpty operation**: This method checks if the stack is empty.\n\n```cpp\nbool Stack::isEmpty() {\n    return (top < 0);\n}\n```\n\nFinally, we'll write a main function to demonstrate these operations.\n\n```cpp\nint main() {\n    Stack stack;\n\n    std::cout << \"Checking if stack is empty: \" << (stack.isEmpty() ? \"True\" : \"False\") << std::endl;\n\n    stack.push(10);\n    stack.push(20);\n    stack.push(30);\n\n    std::cout << \"Top element is: \" << stack.peek() << std::endl;\n\n    stack.pop();\n\n    std::cout << \"Top element after pop is: \" << stack.peek() << std::endl;\n\n    std::cout << \"Checking if stack is empty: \" << (stack.isEmpty() ? \"True\" : \"False\") << std::endl;\n\n    return 0;\n}\n```\n\nThis code will create a stack, push three elements onto it, peek at the top element, pop one element, peek again, and check if the stack is empty at the beginning and after popping an element.\n\nMake sure to compile and run this code to see the output and understand how each operation works.\n\nIf you have any questions or need further clarification, feel free to ask!"
    }
]