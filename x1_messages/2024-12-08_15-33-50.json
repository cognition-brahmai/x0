[
    {
        "role": "user",
        "content": "Write a JavaScript function that takes an array of integers as input and returns the longest increasing subsequence. The function should have a time complexity of O(n log n)."
    },
    {
        "role": "assistant",
        "content": "To solve this problem, we need to find the longest increasing subsequence (LIS) in an array of integers with a time complexity of O(n log n). The LIS is a sequence of elements that are in increasing order, and not necessarily contiguous.\n\n### Approach\n\n1. **Initialization**:\n   - We'll use an array `tails` to keep track of the smallest tail of all increasing subsequences with length `i+1` in `tails[i]`.\n\n2. **Iteration**:\n   - For each number in the input array, we'll use a binary search to find the position at which this number can be placed (or replace an existing number).\n   - This helps in maintaining the smallest possible tail for all lengths of increasing subsequences.\n\n3. **Binary Search**:\n   - We'll implement a helper function to perform binary search on the `tails` array to find the index at which the current number should be placed.\n\n4. **Building the LIS**:\n   - As we iterate through the array, we'll update the `tails` array and keep track of the length of the LIS.\n   - Finally, we'll reconstruct the LIS from the `tails` array.\n\n### Solution Code\n\n```javascript\nfunction longestIncreasingSubsequence(nums) {\n    if (nums.length === 0) return [];\n\n    const tails = [];\n    const prevIndices = new Array(nums.length).fill(-1);\n    let lastIndex = 0;\n\n    for (let i = 0; i < nums.length; i++) {\n        let num = nums[i];\n        let index = binarySearch(tails, num);\n\n        if (index === tails.length) {\n            tails.push(num);\n        } else {\n            tails[index] = num;\n        }\n\n        if (index > 0) {\n            prevIndices[i] = getPrevIndex(tails, num, index);\n        }\n\n        if (index === tails.length - 1) {\n            lastIndex = i;\n        }\n    }\n\n    // Reconstruct the LIS\n    const lis = [];\n    let current = lastIndex;\n    while (current !== -1) {\n        lis.unshift(nums[current]);\n        current = prevIndices[current];\n    }\n\n    return lis;\n}\n\nfunction binarySearch(tails, num) {\n    let left = 0;\n    let right = tails.length;\n\n    while (left < right) {\n        let mid = Math.floor((left + right) / 2);\n        if (tails[mid] < num) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n    return left;\n}\n\nfunction getPrevIndex(tails, num, index) {\n    let left = 0;\n    let right = index;\n\n    while (left < right) {\n        let mid = Math.floor((left + right) / 2);\n        if (tails[mid] < num) {\n            left = mid + 1;\n        } else {\n            right = mid;\n        }\n    }\n    return left - 1;\n}\n```\n\n### Explanation\n\n1. **Initialization**:\n   - `tails` array keeps track of the smallest possible tail for all increasing subsequences of different lengths.\n   - `prevIndices` array helps in reconstructing the actual LIS by storing the previous index for each element in the LIS.\n\n2. **Iteration**:\n   - For each number in the input array, we use binary search to find the position (`index`) where it can be placed in the `tails` array.\n   - If the number is larger than all elements in `tails`, it extends the longest subsequence.\n   - Otherwise, it replaces the existing element at the found position to maintain the smallest possible tail.\n\n3. **Binary Search**:\n   - The `binarySearch` function finds the index of the smallest number in `tails` which is greater than or equal to the current number.\n\n4. **Reconstructing the LIS**:\n   - Using the `prevIndices` array, we backtrack from the last index to reconstruct the actual LIS in reverse order and then reverse it to get the correct sequence.\n\nThis approach ensures that we achieve the desired time complexity of O(n log n) due to the efficient use of binary search in maintaining the `tails` array."
    }
]