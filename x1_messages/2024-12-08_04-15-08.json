[
    {
        "role": "user",
        "content": "Create a Golang program that listens for incoming HTTP requests and forwards them to another server via a WebSocket connection. The program should log request details and WebSocket messages for debugging purposes.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Alright, I have this task to create a Go program that listens for HTTP requests and forwards them to another server using a WebSocket connection. Also, I need to log request details and WebSocket messages for debugging. Sounds interesting! Let's break this down.\n\nFirst, I need to set up an HTTP server in Go that can listen for incoming requests. I know that in Go, we can use the \"net/http\" package to create HTTP servers. So, I'll need to define a handler function that will handle incoming HTTP requests.\n\nNow, for each incoming request, I need to forward it to another server via a WebSocket connection. That means I have to establish a WebSocket connection to the target server and then send the request over this WebSocket.\n\nI'm a bit fuzzy on how to handle HTTP requests over WebSocket, since WebSocket is typically used for bidirectional communication, not exactly for forwarding HTTP requests. Maybe I need to serialize the HTTP request and send it as a WebSocket message.\n\nLet me think about this. Perhaps I can convert the HTTP request into a JSON object or some other format and send it over WebSocket. Then, on the other end, there would be a server that understands this format and reconstructs the HTTP request to forward it.\n\nWait, maybe I'm overcomplicating this. Maybe I can just forward the HTTP request's method, URL, headers, and body as separate fields in a WebSocket message.\n\nFor example, I can define a message structure like this:\n\n{\n\n\"method\": \"GET\",\n\n\"url\": \"/path\",\n\n\"headers\": {\n\n\"Content-Type\": \"application/json\",\n\n...\n\n},\n\n\"body\": \"request body\"\n\n}\n\nThen, send this JSON object over WebSocket to the target server, which would then make an HTTP request with these details.\n\nHmm, that could work. I need to make sure that I handle all parts of the HTTP request correctly, especially the headers and the body.\n\nAlso, I need to consider how to handle the response from the target server. Since WebSocket is bidirectional, maybe the target server can send back a response over the same WebSocket connection, and my Go program can capture that and send it back as the HTTP response to the original requester.\n\nSo, the flow would be:\n\n1. Receive an HTTP request.\n\n2. Establish a WebSocket connection to the target server.\n\n3. Serialize the HTTP request into a WebSocket message and send it.\n\n4. Wait for a response message over the WebSocket.\n\n5. Deserialize the response message into an HTTP response.\n\n6. Send this HTTP response back to the original requester.\n\n7. Close the WebSocket connection.\n\nI need to think about error handling here. What if the WebSocket connection fails? What if the target server doesn't respond in time? I should have mechanisms to handle timeouts and connection errors.\n\nAlso, logging is important. I need to log details of the incoming HTTP request and the messages sent and received over WebSocket for debugging purposes. I can use Go's \"log\" package for this.\n\nLet me outline the steps in code terms:\n\n- Set up an HTTP server using http.HandleFunc.\n\n- In the handler function:\n\n- Extract details from the incoming HTTP request: method, URL, headers, body.\n\n- Establish a WebSocket connection to the target server using a WebSocket library like \"github.com/gorilla/websocket\".\n\n- Define a message structure to serialize the HTTP request.\n\n- Send this message over the WebSocket connection.\n\n- Wait for a response message.\n\n- Deserialize the response message into an HTTP response.\n\n- Write this response back to the original HTTP client.\n\n- Log appropriate details at each step.\n\nI need to make sure that the WebSocket connection is properly closed after the response is received.\n\nAlso, regarding the WebSocket message format, using JSON seems straightforward, but I need to ensure that all necessary fields are included and correctly serialized.\n\nLet me sketch a rough structure of the message:\n\nFor requests:\n\n{\n\n\"type\": \"http_request\",\n\n\"method\": \"GET\",\n\n\"url\": \"/path\",\n\n\"headers\": {\n\n\"Header1\": \"Value1\",\n\n\"Header2\": \"Value2\"\n\n},\n\n\"body\": \"request body\"\n\n}\n\nFor responses:\n\n{\n\n\"type\": \"http_response\",\n\n\"status_code\": 200,\n\n\"headers\": {\n\n\"Header1\": \"Value1\",\n\n\"Header2\": \"Value2\"\n\n},\n\n\"body\": \"response body\"\n\n}\n\nThis way, I can distinguish between different types of messages over WebSocket.\n\nI need to make sure that the target server understands this message format and can process it accordingly.\n\nNow, about handling the HTTP body. HTTP requests can have bodies of different content types and sizes. I need to make sure that I can handle large bodies without running into memory issues.\n\nMaybe I should read the request body in chunks and send them over WebSocket incrementally, but that might complicate things. For simplicity, I'll assume that the request and response bodies are not too large and can be read into memory.\n\nBut, to make it more robust, I should set a maximum body size to prevent DoS attacks.\n\nLet's say I set a maximum body size of 1 MB. If the request body exceeds this, I can return an error.\n\nSimilarly, for the response body, I'll assume it's not too large.\n\nI also need to consider HTTP methods like GET, POST, PUT, etc., and make sure that the method is correctly forwarded.\n\nI should also handle query parameters in the URL.\n\nIn terms of logging, I can log the request method, URL, headers, and body, and similarly for the WebSocket messages sent and received.\n\nI need to make sure that sensitive information like headers with authorization tokens are not logged in production, but for debugging purposes, it might be okay.\n\nWait, no. Even in debugging, I need to be careful with sensitive information. Maybe I can mask or redact certain headers like \"Authorization\".\n\nNow, about establishing the WebSocket connection. I need to use the WebSocket dial function from the gorilla/websocket package to connect to the target server.\n\nI need to handle any errors that occur during the connection attempt.\n\nOnce connected, I can write the serialized HTTP request message to the WebSocket connection.\n\nThen, I need to read the response message from the WebSocket connection.\n\nI should set timeouts to avoid hanging if the target server doesn't respond.\n\nAfter receiving the response message, I need to deserialize it into an HTTP response and send it back to the original client.\n\nFinally, close the WebSocket connection.\n\nI should also consider reusing WebSocket connections if possible, maybe using connection pooling, but that might be overkill for this scenario. For simplicity, I'll establish a new connection for each request.\n\nLet me think about how to implement this in code.\n\nFirst, import the necessary packages:\n\nimport (\n\n\"net/http\"\n\n\"log\"\n\n\"github.com/gorilla/websocket\"\n\n)\n\nThen, define the message structures:\n\ntype HttpRequestMessage struct {\n\nType   string            `json:\"type\"`\n\nMethod string            `json:\"method\"`\n\nUrl    string            `json:\"url\"`\n\nHeaders http.Header      `json:\"headers\"`\n\nBody    string           `json:\"body\"`\n\n}\n\ntype HttpResponseMessage struct {\n\nType       string            `json:\"type\"`\n\nStatusCode int               `json:\"status_code\"`\n\nHeaders    http.Header      `json:\"headers\"`\n\nBody       string           `json:\"body\"`\n\n}\n\nDefine the WebSocket message types:\n\nconst (\n\nMessageTypeHttpRequest = \"http_request\"\n\nMessageTypeHttpResponse = \"http_response\"\n\n)\n\nSet up the HTTP server:\n\nfunc main() {\n\nhttp.HandleFunc(\"/\", forwardHandler)\n\nlog.Println(\"Starting HTTP proxy server on :8080\")\n\nlog.Fatal(http.ListenAndServe(\":8080\", nil))\n\n}\n\nImplement the forwardHandler function:\n\nfunc forwardHandler(w http.ResponseWriter, r *http.Request) {\n\n// Extract request details\n\nmethod := r.Method\n\nurl := r.URL.RequestURI()\n\nheaders := make(http.Header)\n\nfor k, v := range r.Header {\n\nheaders[k] = v\n\n}\n\nvar body []byte\n\nif r.Body != nil {\n\nbody, _ = ioutil.ReadAll(r.Body)\n\n}\n\n// Log request details\n\nlog.Printf(\"Received HTTP %s request for %s\", method, url)\n\n// Serialize request into WebSocket message\n\nreqMsg := HttpRequestMessage{\n\nType:   MessageTypeHttpRequest,\n\nMethod: method,\n\nUrl:    url,\n\nHeaders: headers,\n\nBody: string(body),\n\n}\n\n// Connect to target WebSocket server\n\ntargetUrl := \"ws://target-server.com/ws\"\n\nconn, _, err := websocket.DefaultDialer.Dial(targetUrl, nil)\n\nif err != nil {\n\nlog.Println(\"WebSocket dial error:\", err)\n\nhttp.Error(w, \"Failed to connect to target server\", http.StatusInternalServerError)\n\nreturn\n\n}\n\ndefer conn.Close()\n\n// Send request message\n\nerr = conn.WriteJSON(reqMsg)\n\nif err != nil {\n\nlog.Println(\"WebSocket write error:\", err)\n\nhttp.Error(w, \"Failed to send request\", http.StatusInternalServerError)\n\nreturn\n\n}\n\n// Read response message\n\nvar respMsg HttpResponseMessage\n\nerr = conn.ReadJSON(&respMsg)\n\nif err != nil {\n\nlog.Println(\"WebSocket read error:\", err)\n\nhttp.Error(w, \"Failed to receive response\", http.StatusInternalServerError)\n\nreturn\n\n}\n\n// Log response details\n\nlog.Printf(\"Received HTTP response with status code %d\", respMsg.StatusCode)\n\n// Construct HTTP response\n\nw.WriteHeader(respMsg.StatusCode)\n\nfor k, v := range respMsg.Headers {\n\nw.Header()[k] = v\n\n}\n\nw.Write([]byte(respMsg.Body))\n\n}\n\nThis is a rough sketch. I need to handle errors more gracefully and consider edge cases.\n\nAlso, I need to make sure that the target WebSocket server is set up to receive these messages and forward the HTTP requests accordingly.\n\nAdditionally, I should think about concurrency. If multiple requests come in simultaneously, each should have its own WebSocket connection to the target server.\n\nI don't think I need to worry about connection pooling for now, but perhaps in the future.\n\nAlso, I should consider setting timeouts for the WebSocket connections to prevent hanging.\n\nFor example, I can set read and write timeouts when dialing the WebSocket connection.\n\nI can do this by setting the dialer's timeout:\n\ndialer := websocket.Dialer{\n\nTimeout: 10 * time.Second,\n\n}\n\nconn, _, err := dialer.Dial(targetUrl, nil)\n\nThat should help with timeout management.\n\nMoreover, I need to handle cases where the target server sends back an error or an invalid response.\n\nI should validate the response message to ensure it has the correct type and fields.\n\nFor example, check that respMsg.Type == MessageTypeHttpResponse and that StatusCode is present.\n\nIf not, I can return an error to the client.\n\nAlso, I need to handle cases where the request body cannot be read, perhaps due to connection issues or invalid requests.\n\nI should set a limit on the request body size to prevent abuses.\n\nI can use http.MaxBytesReader to limit the request body size.\n\nLike this:\n\nconst maxBodySize = 1 << 20 // 1 MB\n\nr.Body = http.MaxBytesReader(w, r.Body, maxBodySize)\n\nThis will automatically return a 413 Payload Too Large response if the body exceeds the limit.\n\nSimilarly, I should set a limit on the response body size.\n\nI need to think about how to handle large responses.\n\nPerhaps I can read the response body in chunks and write them back to the client incrementally, rather than reading the entire response into memory.\n\nBut for simplicity, I'll assume that the response body is small enough to fit into memory.\n\nAnother consideration is handling different HTTP methods. For methods like GET, the body might not be present, so I need to handle that.\n\nAlso, for methods like HEAD, I should not include a body in the response.\n\nBut in practice, HEAD requests should not have a body, so I need to make sure that the response does not have a body for HEAD requests.\n\nI need to ensure that the forwarded request includes all necessary parts, like query parameters, which are already included in r.URL.\n\nI should also handle cookies if necessary.\n\nFurthermore, I need to consider how to handle websockets that require subprotocols or custom headers.\n\nFor now, I'll keep it simple and not worry about subprotocols.\n\nBut I should allow passing headers from the incoming HTTP request to the WebSocket connection if needed.\n\nMaybe I can pass some headers to the WebSocket connection.\n\nWait, but WebSocket connections can have their own headers.\n\nI need to see how to set headers when dialing the WebSocket connection.\n\nLooking at the gorilla/websocket documentation, the Dial function accepts a *http.Header as the third parameter, which can be used to set headers for the WebSocket handshake.\n\nSo, I can create a header map and set necessary headers there.\n\nFor example:\n\nheaders := http.Header{\n\n\"Authorization\": {\"Bearer \" + token},\n\n}\n\nconn, _, err := websocket.DefaultDialer.Dial(targetUrl, headers)\n\nThis way, I can pass headers from the incoming HTTP request to the WebSocket handshake if needed.\n\nBut I need to be careful with headers that are not allowed in WebSocket handshakes.\n\nI should filter out invalid headers.\n\nAlternatively, I can keep the headers separate and only pass necessary headers to the WebSocket handshake.\n\nIn terms of logging, I need to log the request and response details without exposing sensitive information.\n\nI can create a logging function that redacts sensitive headers.\n\nFor example:\n\nfunc logRequest(r *http.Request) {\n\nlog.Printf(\"Method: %s, URL: %s\", r.Method, r.URL)\n\nfor k, v := range r.Header {\n\nif k == \"Authorization\" || k == \"Cookie\" {\n\nlog.Printf(\"%s: [redacted]\", k)\n\n} else {\n\nlog.Printf(\"%s: %s\", k, v)\n\n}\n\n}\n\nlog.Printf(\"Body: %s\", string(body))\n\n}\n\nSimilarly for the response.\n\nI should also consider logging the WebSocket messages, but again, redact sensitive information if present.\n\nNow, about the target WebSocket server. I need to ensure that it understands the message format I'm sending and can forward the HTTP requests accordingly.\n\nThis might involve setting up another server that listens for WebSocket connections and processes these messages to make HTTP requests.\n\nBut since the task is to create a Go program that forwards HTTP requests via WebSocket, I'll assume that the target server is already set up to handle these messages.\n\nOtherwise, this could turn into a larger project.\n\nSo, for now, I'll focus on the proxy server that forwards HTTP requests via WebSocket.\n\nLet me summarize the steps again:\n\n1. Set up an HTTP server that listens for incoming requests.\n\n2. For each incoming request:\n\na. Extract request method, URL, headers, and body.\n\nb. Serialize these into a WebSocket message.\n\nc. Dial a WebSocket connection to the target server.\n\nd. Send the serialized request message over WebSocket.\n\ne. Wait for a response message over WebSocket.\n\nf. Deserialize the response message into an HTTP response.\n\ng. Write the HTTP response back to the original client.\n\nh. Close the WebSocket connection.\n\nI need to implement this logic in Go, making sure to handle errors and edge cases properly.\n\nI should also consider performance implications, such as the time it takes to establish a WebSocket connection for each request.\n\nPerhaps in a production setting, I'd want to reuse connections or use a connection pool, but for this task, establishing a new connection per request should suffice.\n\nAnother thing to consider is handling HTTP redirects. If the target server returns a redirect response, I need to handle it appropriately.\n\nBut for simplicity, I'll assume that the target server handles redirects and returns the final response.\n\nAlso, I need to think about how to handle WebSocket closures or errors during the communication.\n\nFor example, if the WebSocket connection closes unexpectedly, I should return an error to the client.\n\nSimilarly, if there's an error reading from or writing to the WebSocket connection, I should handle it gracefully.\n\nI should also consider setting a read limit for WebSocket messages to prevent large messages from consuming too much memory.\n\nThe gorilla/websocket package allows setting read limits via thewebsocket.MaxMessageSize option.\n\nI can set this when creating the WebSocket connection.\n\nFor example:\n\nconn, _, err := websocket.DefaultDialer.Dial(targetUrl, nil)\n\nif err != nil {\n\nreturn err\n\n}\n\nconn.SetReadLimit(1 << 20) // 1 MB\n\nThis sets the maximum size of a message that can be read from the connection.\n\nAdditionally, I should handle panics and ensure that the program doesn't crash due to unexpected errors.\n\nI can use defer-recover to handle panics, although it's generally better to handle errors explicitly.\n\nNow, let's think about testing this setup.\n\nI need to test the proxy server with different types of HTTP requests: GET, POST, PUT, etc., with different headers and bodies.\n\nI should also test scenarios where the WebSocket connection fails or times out.\n\nI can use tools like curl or Postman to send requests to the proxy server and verify that they are correctly forwarded and responded to.\n\nI can also use the Gorilla WebSocket test suite to simulate the target WebSocket server for testing purposes.\n\nAlternatively, I can set up a simple HTTP server as the target and have the proxy forward requests to it via WebSocket.\n\nWait, but since the target server needs to understand the WebSocket messages and forward HTTP requests, it's a bit involved.\n\nMaybe for testing, I can create a mock target server that simply echoes back the received messages or returns predefined responses.\n\nThis way, I can verify that the proxy server correctly serializes and deserializes the messages.\n\nI need to make sure that the message formats are correctly defined and that there are no serialization/deserialization issues.\n\nAlso, I should ensure that the HTTP response status codes are correctly propagated back to the client.\n\nAnother consideration is handling HTTP request and response headers properly.\n\nSome headers might need to be added or modified by the proxy server.\n\nFor example, adding headers to indicate that the request was proxied.\n\nI should also handle the \"Host\" header appropriately.\n\nIf the incoming request has a \"Host\" header, I need to decide whether to forward it as is or modify it for the target server.\n\nI might need to adjust the \"Host\" header based on the target server's URL.\n\nWait, no. Since I'm forwarding the request via WebSocket to the target server, which presumably knows the intended host, I might not need to worry about the \"Host\" header.\n\nAlternatively, I can include the \"Host\" header in the serialized request message and let the target server handle it.\n\nI need to clarify this based on how the target server is set up.\n\nAssuming the target server can handle the \"Host\" header correctly, I'll include it in the serialized request message.\n\nNow, about the URL in the request message.\n\nShould it be the full URL or just the path?\n\nIf I include the full URL, the target server can forward it as is.\n\nBut if I include only the path, the target server needs to know the base URL to construct the full request.\n\nTo make it more flexible, I'll include the full URL in the request message.\n\nHowever, this might have implications for how the target server handles the request.\n\nI need to ensure that the target server can handle absolute URLs correctly.\n\nAlternatively, I can include only the path and let the target server use its own base URL.\n\nFor now, I'll include the full URL in the request message.\n\nI can always adjust this based on the target server's requirements.\n\nAnother point is handling query parameters.\n\nSince the URL includes query parameters, I don't need to handle them separately.\n\nI need to make sure that the URL is properly encoded and decoded during serialization and deserialization.\n\nI should use net/url's Query() and RawQuery methods to handle query parameters correctly.\n\nWait, in Go's net/url package, the Query() method parses the query parameters into a values.Values map, while RawQuery holds the raw query string.\n\nI should use RawQuery to preserve the exact query string when serializing the URL.\n\nSo, in the request message, I'll include the full URL, including the query string.\n\nIn code, I can get the full URL string using r.URL.String().\n\nThis should include both the path and the query string.\n\nPerfect.\n\nNow, for the response message, I need to construct an HTTP response with the status code, headers, and body received from the target server.\n\nI need to make sure that all headers are correctly set on the response.\n\nAlso, for certain headers like \"Content-Length\", I need to ensure they match the actual body size.\n\nGo's http.ResponseWriter should handle this automatically if I set the headers before writing the body.\n\nI should also handle chunked encoding if the response has it, but Go's http package should handle that transparently.\n\nI need to make sure that I don't set headers after writing the response body, as that would cause errors.\n\nSo, I should set all headers first, then write the body.\n\nIn the forwardHandler function, after deserializing the response message, I can set the status code, headers, and write the body in that order.\n\nNow, about the body being read into a string.\n\nI need to make sure that the body is correctly read as bytes, not as a string, to preserve binary data.\n\nSo, instead of storing the body as a string in the message structures, I should store it as []byte.\n\nBut JSON encoding/decoding can handle []byte by base64-encoding them.\n\nSo, I can define the body field as []byte in the message structures.\n\nFor example:\n\ntype HttpRequestMessage struct {\n\nType   string         `json:\"type\"`\n\nMethod string         `json:\"method\"`\n\nUrl    string         `json:\"url\"`\n\nHeaders http.Header   `json:\"headers\"`\n\nBody    []byte        `json:\"body\"`\n\n}\n\ntype HttpResponseMessage struct {\n\nType       string         `json:\"type\"`\n\nStatusCode int            `json:\"status_code\"`\n\nHeaders    http.Header   `json:\"headers\"`\n\nBody       []byte        `json:\"body\"`\n\n}\n\nThis way, the body is handled as binary data.\n\nI need to make sure that the target server can handle binary bodies correctly.\n\nAlso, base64-encoding the body will increase its size, which might not be efficient for large bodies.\n\nPerhaps I should consider using a different serialization format that can handle binary data more efficiently, like Protobuf or MessagePack.\n\nBut for simplicity, I'll stick with JSON and base64 for now.\n\nIf performance becomes an issue, I can consider switching to a more efficient format.\n\nAnother option is to send the body over a separate WebSocket message, but that complicates things.\n\nFor now, I'll keep it simple and include the body in the same message.\n\nNow, regarding the headers.\n\nThe http.Header type in Go is a map-like structure that allows multiple values per key.\n\nWhen serializing it to JSON, it will be converted to a map with header names as keys and header values as arrays.\n\nBut in the message structures, I defined Headers as http.Header, which should work with JSON encoding/decoding.\n\nI need to ensure that the target server can handle headers correctly when deserializing them.\n\nAlso, some headers might need to be processed differently, like setting the content type or content length.\n\nBut since I'm forwarding the entire header map, the target server can handle them as needed.\n\nI should also consider whether there are any headers that should not be forwarded, like certain hop-by-hop headers.\n\nI need to review the list of hop-by-hop headers and exclude them from the forwarded headers.\n\nAccording to RFC 2616, hop-by-hop headers include Connection, Keep-Alive, Proxy-Authenticate, Proxy-Authorization, TE, Trailers, Transfer-Encoding, Upgrade, etc.\n\nI should exclude these headers from the forwarded headers to prevent potential issues.\n\nI can create a list of hop-by-hop headers and filter them out before serializing the headers.\n\nSimilarly, the target server might need to handle its own set of headers.\n\nI need to coordinate with the target server's implementation to ensure compatibility.\n\nBut for now, I'll assume that the target server can handle the forwarded headers correctly.\n\nNext, I need to think about how to handle WebSocket errors and close frames.\n\nIf the WebSocket connection is closed by the target server, I need to handle that and return an appropriate response to the client.\n\nSimilarly, if there's an error during WebSocket communication, I should catch it and return an error response.\n\nI can set up error handling in the forwardHandler function to catch any errors that occur during the WebSocket communication and return a 500 Internal Server Error or another appropriate status code.\n\nAlso, I need to make sure that the WebSocket connection is properly closed after the response is received, regardless of whether an error occurred or not.\n\nI can use defer conn.Close() to ensure that the connection is closed after the function returns.\n\nNow, about logging.\n\nI need to log the request and response details at appropriate points.\n\nFor example:\n\n- When receiving the HTTP request: log method, URL, headers, and body.\n\n- When sending the WebSocket message: log the serialized message.\n\n- When receiving the WebSocket message: log the serialized message.\n\n- When sending the HTTP response: log status code, headers, and body.\n\nI need to make sure that the logs are formatted in a way that's easy to read and parse, if necessary.\n\nI can use log.Printf to format the log messages appropriately.\n\nAlso, as mentioned earlier, I need to redact sensitive headers like \"Authorization\" and \"Cookie\" in the logs.\n\nI can create a function that logs the headers without revealing sensitive information.\n\nFor example:\n\nfunc logHeaders(headers http.Header, redact ...string) {\n\nfor k, v := range headers {\n\nif contains(redact, k) {\n\nlog.Printf(\"%s: [redacted]\", k)\n\n} else {\n\nlog.Printf(\"%s: %s\", k, v)\n\n}\n\n}\n\n}\n\nfunc contains(slice []string, item string) bool {\n\nfor _, s := range slice {\n\nif s == item {\n\nreturn true\n\n}\n\n}\n\nreturn false\n\n}\n\nI can use this function to log headers, redacting sensitive ones.\n\nSimilarly, for the body, I can log it only if it's not too large and doesn't contain sensitive information.\n\nBut body logging can be tricky, especially for binary data, so I might skip logging the body or log only a portion of it.\n\nAlternatively, I can provide an option to log the body in debug mode.\n\nBut for now, I'll log the body as a string, assuming it's text data.\n\nIf it's binary data, it might not log correctly, but I'll handle that in a later iteration.\n\nNow, let's think about how to handle timeouts.\n\nI need to set timeouts for the WebSocket connection to prevent hanging if the target server doesn't respond.\n\nI can set read and write timeouts when dialing the WebSocket connection.\n\nIn the gorilla/websocket.Dialer, I can set the Timeout field to control the dial timeout.\n\nAdditionally, I can set the ReadDeadline and WriteDeadline on the WebSocket connection to control the read and write timeouts.\n\nFor example:\n\nconn.SetReadDeadline(time.Now().Add(10 * time.Second))\n\nconn.SetWriteDeadline(time.Now().Add(10 * time.Second))\n\nThis sets the read and write deadlines to 10 seconds from the current time.\n\nI need to set these deadlines before reading from or writing to the connection.\n\nSo, after sending the request message, I can set the read deadline for receiving the response message.\n\nSimilarly, after receiving the response message, I can set the write deadline for sending the HTTP response back to the client.\n\nThis helps ensure that the program doesn't get stuck waiting indefinitely for responses.\n\nI should also handle timeout errors appropriately and return a 504 Gateway Timeout or 500 Internal Server Error to the client.\n\nNow, about handling multiple requests concurrently.\n\nSince Go's HTTP server handles multiple requests concurrently using goroutines, each request will be handled in its own goroutine.\n\nThis means that multiple WebSocket connections can be established concurrently, one per request.\n\nI need to make sure that there are no shared resources that could cause race conditions.\n\nIn this simple setup, since each request has its own WebSocket connection, there shouldn't be any shared state.\n\nHowever, if I were to introduce connection pooling or caching, I'd need to synchronize access to those resources.\n\nBut for now, with each request having its own connection, I should be fine.\n\nI need to monitor the program's resource usage to ensure that it can handle a reasonable number of concurrent connections without running into performance issues.\n\nNow, let's think about how to handle upgrades in the HTTP request.\n\nIf the incoming request is an upgrade request, such as for WebSocket, I need to handle it appropriately.\n\nBut since my proxy is only forwarding HTTP requests via WebSocket, I don't need to handle upgrade requests.\n\nI can simply forward the upgrade request as is, and let the target server handle it.\n\nHowever, handling upgrade requests over WebSocket might be complicated, so for now, I'll assume that only regular HTTP requests are forwarded.\n\nIf needed, I can extend the proxy to handle upgrade requests in the future.\n\nAnother consideration is handling cookies.\n\nIf the incoming request has cookies, I need to forward them to the target server.\n\nSince cookies are included in the \"Cookie\" header, which I'm including in the serialized request message, they should be forwarded correctly.\n\nSimilarly, if the response from the target server includes set-cookie headers, they should be forwarded back to the client.\n\nGo's http package should handle setting these headers correctly on the response.\n\nI need to make sure that I don't modify or drop any headers unintentionally.\n\nNow, let's think about error handling in more detail.\n\nHere are some potential error scenarios:\n\n1. Failed to dial the WebSocket connection to the target server.\n\n- Return 502 Bad Gateway or 503 Service Unavailable.\n\n2. Failed to send the request message over WebSocket.\n\n- Return 500 Internal Server Error.\n\n3. Failed to receive the response message over WebSocket.\n\n- Return 504 Gateway Timeout or 500 Internal Server Error.\n\n4. Received an invalid response message from the target server.\n\n- Return 502 Bad Gateway.\n\n5. Failed to read the request body from the client.\n\n- Return 400 Bad Request or 413 Payload Too Large.\n\n6. Failed to write the response to the client.\n\n- Log the error, but there's not much else to do.\n\nI need to map these error scenarios to appropriate HTTP status codes and log the errors for debugging.\n\nI should also consider logging the errors at an error level, not just info, to distinguish them from normal operation logs.\n\nNow, about the target WebSocket server's address.\n\nIn the code, I hard-coded the target URL as \"ws://target-server.com/ws\".\n\nIn a real-world scenario, this should be configurable, perhaps via environment variables or command-line flags.\n\nI can use the flag package or viper to handle configuration.\n\nFor simplicity, I'll hard-code it for now, but I'll note that it should be made configurable in a production setup.\n\nAlso, I should consider using HTTPS for the WebSocket connection if the target server supports it.\n\nWebSocket supports both ws and wss schemes.\n\nI need to make sure that the target URL uses the correct scheme based on the target server's configuration.\n\nNow, let's think about how to run and test this program.\n\nI can run the program locally and use curl or a web browser to send HTTP requests to it.\n\nFor example:\n\ncurl -i http://localhost:8080/some/path\n\nThis should be forwarded via WebSocket to the target server, and the response should be returned.\n\nI need to make sure that the target server is running and listening for WebSocket connections.\n\nI can set up a simple WebSocket server that listens for messages, processes them, makes HTTP requests, and sends back the responses.\n\nBut setting up the target server is beyond the scope of this task, so for testing, I can create a mock target server that simulates the behavior.\n\nFor example, the mock target server can echo back the received request message as the response.\n\nThis way, I can verify that the proxy server correctly forwards the request and receives the response.\n\nI can also test with different HTTP methods and headers to ensure correctness.\n\nI should also test with large request and response bodies to see how the proxy handles them.\n\nGiven that I'm reading the entire body into memory, I need to make sure that it doesn't cause memory issues with large bodies.\n\nBut since I've set a maximum body size, it should be manageable.\n\nAnother thing to test is the logging output.\n\nI need to verify that the logs contain the necessary information without exposing sensitive data.\n\nI can send requests with authorization headers and check that they are redacted in the logs.\n\nI should also test with different error scenarios, like failing WebSocket connections or invalid responses, to ensure that the proxy handles them correctly and returns appropriate error responses.\n\nNow, let's think about how to structure the code.\n\nI can organize the code into separate functions for better readability and maintainability.\n\nFor example:\n\n- A function to extract request details and serialize them into a WebSocket message.\n\n- A function to dial the WebSocket connection and handle any errors.\n\n- A function to send the request message and receive the response message.\n\n- A function to deserialize the response message and construct the HTTP response.\n\nThis way, each step is isolated and easier to test and debug.\n\nI can also create helper functions for logging request and response details.\n\nAdditionally, I can create a reusable function for handling the WebSocket communication, so that it can be tested independently.\n\nNow, about handling the WebSocket connection.\n\nI need to make sure that only one request is sent per connection and that the connection is closed after receiving the response.\n\nSince each HTTP request gets its own WebSocket connection, there's no need to handle multiple messages per connection.\n\nThis simplifies things, as I don't have to manage message ordering or connection state.\n\nHowever, if I were to reuse connections for multiple requests, I'd need to handle message ordering and ensure that responses correspond to the correct requests.\n\nBut for now, with one connection per request, I can avoid that complexity.\n\nNow, let's consider how to handle HTTP errors.\n\nIf the target server returns an HTTP error status code, like 404 Not Found or 500 Internal Server Error, the proxy server should forward that status code and response body back to the client.\n\nIn the forwardHandler function, when deserializing the response message, I can set the status code on the http.ResponseWriter and write the response body accordingly.\n\nGo's http.ResponseWriter should handle this correctly.\n\nI also need to forward any headers from the response message, except for any hop-by-hop headers.\n\nI should review the list of hop-by-hop headers and exclude them from being set on the http.ResponseWriter.\n\nAccording to RFC 2616, hop-by-hop headers include Connection, Keep-Alive, Proxy-Authenticate, Proxy-Authorization, TE, Trailers, Transfer-Encoding, Upgrade, etc.\n\nI need to filter these headers out before setting them on the response.\n\nI can create a function to filter hop-by-hop headers from the response headers.\n\nFor example:\n\nfunc filterHopByHopHeaders(headers http.Header) {\n\nhopByHopHeaders := map[string]bool{\n\n\"Connection\":       true,\n\n\"Keep-Alive\":       true,\n\n\"Proxy-Authenticate\": true,\n\n\"Proxy-Authorization\": true,\n\n\"TE\":               true,\n\n\"Trailers\":         true,\n\n\"Transfer-Encoding\": true,\n\n\"Upgrade\":          true,\n\n}\n\nfor header := range hopByHopHeaders {\n\nheaders.Del(header)\n\n}\n\n}\n\nI can call this function on the response headers before setting them on the http.ResponseWriter.\n\nThis ensures that only end-to-end headers are forwarded to the client.\n\nNow, about the target server's implementation.\n\nSince the target server needs to receive the serialized HTTP request message, make the actual HTTP request, and send back the serialized HTTP response message, I need to ensure that it understands the message format.\n\nIn a real-world scenario, the target server would need to be implemented accordingly.\n\nFor testing purposes, I can create a simple mock target server that echoes back a predefined response message.\n\nThis way, I can verify that the proxy server correctly sends and receives messages over WebSocket.\n\nHere's a rough example of what the mock target server could look like:\n\nfunc echoHandler(conn *websocket.Conn) {\n\nfor {\n\nmsg := struct {\n\nType string `json:\"type\"`\n\n}\n\nerr := conn.ReadJSON(&msg)\n\nif err != nil {\n\nlog.Println(\"WebSocket read error:\", err)\n\nreturn\n\n}\n\nif msg.Type == MessageTypeHttpRequest {\n\n// Simulate a response\n\nrespMsg := HttpResponseMessage{\n\nType: MessageTypeHttpResponse,\n\nStatusCode: 200,\n\nHeaders: http.Header{\n\n\"Content-Type\": {\"text/plain\"},\n\n},\n\nBody: []byte(\"Echo response\"),\n\n}\n\nerr = conn.WriteJSON(respMsg)\n\nif err != nil {\n\nlog.Println(\"WebSocket write error:\", err)\n\nreturn\n\n}\n\n}\n\n}\n\n}\n\nThis mock server simply listens for request messages and sends back a fixed response message.\n\nWith this in place, I can test the proxy server by sending HTTP requests to it and verifying that it receives the echo response and forwards it back to the client.\n\nNow, let's think about how to implement the proxy server's logging.\n\nI can create a logger function that logs the request and response details.\n\nFor example:\n\nfunc logRequest(r *http.Request) {\n\nlog.Printf(\"HTTP %s request for %s\", r.Method, r.URL)\n\nlogHeaders(r.Header, \"Authorization\", \"Cookie\")\n\nif r.Body != nil {\n\nbody, _ := ioutil.ReadAll(r.Body)\n\nlog.Printf(\"Request body: %s\", body)\n\n// Reset the reader for subsequent processing\n\nr.Body = ioutil.NopCloser(bytes.NewBuffer(body))\n\n}\n\n}\n\nfunc logResponse(respMsg HttpResponseMessage) {\n\nlog.Printf(\"HTTP response with status code %d\", respMsg.StatusCode)\n\nlogHeaders(respMsg.Headers, \"Set-Cookie\")\n\nlog.Printf(\"Response body: %s\", string(respMsg.Body))\n\n}\n\nI need to be careful with reading the request body, as reading it consumes it, so I need to reset the reader after logging.\n\nIn the logRequest function, after reading the body, I create a new reader with the body bytes and set it back to r.Body using ioutil.NopCloser.\n\nThis ensures that subsequent parts of the handler can read the body again.\n\nSimilarly, in logResponse, I log the response status code, headers, and body.\n\nI redact sensitive headers like \"Set-Cookie\" in the logs.\n\nNow, let's think about how to handle different content types in the response.\n\nSome content types, like images or binary files, may not be human-readable, but I need to forward them correctly.\n\nSince I'm handling the body as []byte, it should be fine for binary data.\n\nI need to make sure that the response headers correctly indicate the content type and content length.\n\nGo's http.ResponseWriter should handle setting the content length based on the body written.\n\nBut in my current implementation, I need to set the content length manually.\n\nWait, no. If I write the body directly to w, Go will set the content length automatically.\n\nSo, I don't need to set it manually.\n\nI should remove any explicit setting of content length to avoid conflicts.\n\nNow, about handling chunked encoding.\n\nIf the target server returns a response with Transfer-Encoding: chunked, I need to make sure that the proxy server can handle it.\n\nBut since I'm reading the entire response body into memory before sending it back, chunked encoding is not an issue.\n\nHowever, in a production setup, handling large responses could be problematic.\n\nTo improve efficiency, I could stream the response body from the WebSocket connection to the HTTP client in chunks.\n\nThis would require reading the response body in parts and writing them to w incrementally.\n\nThis would also require adjusting the message format to support streaming.\n\nBut for simplicity, I'll keep it as is, assuming that response bodies are small.\n\nNow, let's think about implementing the forwardHandler function with all these considerations.\n\nHere's a more refined version:\n\nfunc forwardHandler(w http.ResponseWriter, r *http.Request) {\n\n// Log the request\n\nlogRequest(r)\n\n// Extract request details\n\nmethod := r.Method\n\nurl := r.URL.String()\n\nheaders := make(http.Header)\n\nfor k, v := range r.Header {\n\nheaders[k] = v\n\n}\n\n// Filter hop-by-hop headers\n\nfilterHopByHopHeaders(headers)\n\nvar body []byte\n\nif r.Body != nil {\n\nvar err error\n\nbody, err = ioutil.ReadAll(r.Body)\n\nif err != nil {\n\nlog.Println(\"Error reading request body:\", err)\n\nhttp.Error(w, \"Failed to read request body\", http.StatusInternalServerError)\n\nreturn\n\n}\n\n}\n\n// Serialize request into WebSocket message\n\nreqMsg := HttpRequestMessage{\n\nType:   MessageTypeHttpRequest,\n\nMethod: method,\n\nUrl:    url,\n\nHeaders: headers,\n\nBody: body,\n\n}\n\n// Connect to target WebSocket server\n\ntargetUrl := \"ws://target-server.com/ws\"\n\ndialer := websocket.Dialer{\n\nTimeout: 10 * time.Second,\n\n}\n\nconn, _, err := dialer.Dial(targetUrl, nil)\n\nif err != nil {\n\nlog.Println(\"WebSocket dial error:\", err)\n\nhttp.Error(w, \"Failed to connect to target server\", http.StatusBadGateway)\n\nreturn\n\n}\n\ndefer conn.Close()\n\n// Set read limit for WebSocket messages\n\nconn.SetReadLimit(1 << 20) // 1 MB\n\n// Send request message\n\nerr = conn.WriteJSON(reqMsg)\n\nif err != nil {\n\nlog.Println(\"WebSocket write error:\", err)\n\nhttp.Error(w, \"Failed to send request\", http.StatusInternalServerError)\n\nreturn\n\n}\n\n// Set read deadline for response\n\nerr = conn.SetReadDeadline(time.Now().Add(10 * time.Second))\n\nif err != nil {\n\nlog.Println(\"SetReadDeadline error:\", err)\n\nhttp.Error(w, \"Failed to set read deadline\", http.StatusInternalServerError)\n\nreturn\n\n}\n\n// Read response message\n\nvar respMsg HttpResponseMessage\n\nerr = conn.ReadJSON(&respMsg)\n\nif err != nil {\n\nlog.Println(\"WebSocket read error:\", err)\n\nhttp.Error(w, \"Failed to receive response\", http.StatusGatewayTimeout)\n\nreturn\n\n}\n\n// Log the response\n\nlogResponse(respMsg)\n\n// Validate response type\n\nif respMsg.Type != MessageTypeHttpResponse {\n\nhttp.Error(w, \"Invalid response type\", http.StatusBadRequest)\n\nreturn\n\n}\n\n// Set response status code\n\nw.WriteHeader(respMsg.StatusCode)\n\n// Filter hop-by-hop headers in response\n\nfilterHopByHopHeaders(respMsg.Headers)\n\n// Set response headers\n\nfor k, v := range respMsg.Headers {\n\nw.Header()[k] = v\n\n}\n\n// Write response body\n\nw.Write(respMsg.Body)\n\n}\n\nThis is a more complete implementation, handling various error cases and logging.\n\nI need to make sure to import all necessary packages:\n\nimport (\n\n\"net/http\"\n\n\"log\"\n\n\"io/ioutil\"\n\n\"bytes\"\n\n\"github.com/gorilla/websocket\"\n\n)\n\nI should also define the message types and constants as earlier.\n\nNow, I need to test this handler function with different scenarios to ensure it works as expected.\n\nI can write some unit tests using Go's testing package, but since it involves network communication, integration tests might be more appropriate.\n\nAlternatively, I can use table-driven tests to test different input cases and verify the output.\n\nHowever, setting up a mock target server for testing would be beneficial.\n\nI can create a test server that listens for WebSocket connections and responds with predefined messages based on the received request messages.\n\nThis way, I can simulate different responses and verify that the proxy server handles them correctly.\n\nI can use Go's net/http/httptest package to create a test HTTP server and gorilla/websocket's Upgrader to handle WebSocket upgrades.\n\nHere's a rough outline of how to set up a mock target server for testing:\n\nfunc mockTargetServer(w http.ResponseWriter, r *http.Request) {\n\nconn, err := websocket.Upgrade(w, r, nil, 1024, 1024)\n\nif err != nil {\n\nlog.Println(\"WebSocket upgrade error:\", err)\n\nreturn\n\n}\n\ndefer conn.Close()\n\nfor {\n\nvar reqMsg HttpRequestMessage\n\nerr := conn.ReadJSON(&reqMsg)\n\nif err != nil {\n\nlog.Println(\"WebSocket read error:\", err)\n\nreturn\n\n}\n\n// Simulate a response\n\nrespMsg := HttpResponseMessage{\n\nType: MessageTypeHttpResponse,\n\nStatusCode: 200,\n\nHeaders: http.Header{\n\n\"Content-Type\": {\"text/plain\"},\n\n},\n\nBody: []byte(\"Echo response\"),\n\n}\n\nerr = conn.WriteJSON(respMsg)\n\nif err != nil {\n\nlog.Println(\"WebSocket write error:\", err)\n\nreturn\n\n}\n\n}\n\n}\n\nThen, in my test function, I can start this mock server and set the targetUrl to point to it.\n\nThen, make HTTP requests to the proxy server and verify the responses.\n\nThis way, I can test the proxy server's behavior in isolation.\n\nI should also write tests for error scenarios, like failed WebSocket connections, invalid responses, etc.\n\nNow, considering all these points, I can proceed to implement the Go program accordingly.\n\nI need to ensure that all components are correctly integrated and that the program handles various cases gracefully.\n\nI should also pay attention to performance and resource usage, especially with regards to handling multiple concurrent connections and large request/response bodies.\n\nBut for the scope of this task, the above implementation should suffice.\n\n**Final Solution**\n\nTo create a Go program that listens for incoming HTTP requests and forwards them to another server via a WebSocket connection, while logging request details and WebSocket messages for debugging, follow the steps below.\n\n### Solution Code\n\n```go\npackage main\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"flag\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\nconst (\n\tMessageTypeHttpRequest  = \"http_request\"\n\tMessageTypeHttpResponse = \"http_response\"\n)\n\ntype HttpRequestMessage struct {\n\tType   string            `json:\"type\"`\n\tMethod string            `json:\"method\"`\n\tURL    string            `json:\"url\"`\n\tHeaders http.Header      `json:\"headers\"`\n\tBody    []byte           `json:\"body\"`\n}\n\ntype HttpResponseMessage struct {\n\tType       string            `json:\"type\"`\n\tStatusCode int               `json:\"status_code\"`\n\tHeaders    http.Header      `json:\"headers\"`\n\tBody       []byte           `json:\"body\"`\n}\n\nvar targetURL string\n\nfunc init() {\n\tflag.StringVar(&targetURL, \"target\", \"ws://target-server.com/ws\", \"Target WebSocket URL\")\n\tflag.Parse()\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", forwardHandler)\n\tlog.Println(\"Starting HTTP proxy server on :8080\")\n\tlog.Fatal(http.ListenAndServe(\":8080\", nil))\n}\n\nfunc forwardHandler(w http.ResponseWriter, r *http.Request) {\n\tlogRequest(r)\n\n\tmethod := r.Method\n\turl := r.URL.String()\n\theaders := make(http.Header)\n\tfor k, v := range r.Header {\n\t\theaders[k] = v\n\t}\n\tfilterHopByHopHeaders(headers)\n\n\tvar body []byte\n\tvar err error\n\tif r.Body != nil {\n\t\tbody, err = ioutil.ReadAll(r.Body)\n\t\tif err != nil {\n\t\t\tlog.Println(\"Error reading request body:\", err)\n\t\t\thttp.Error(w, \"Failed to read request body\", http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t}\n\n\treqMsg := HttpRequestMessage{\n\t\tType:   MessageTypeHttpRequest,\n\t\tMethod: method,\n\t\tURL:    url,\n\t\tHeaders: headers,\n\t\tBody: body,\n\t}\n\n\tdialer := websocket.Dialer{\n\t\tTimeout: 10 * time.Second,\n\t}\n\tconn, _, err := dialer.Dial(targetURL, nil)\n\tif err != nil {\n\t\tlog.Println(\"WebSocket dial error:\", err)\n\t\thttp.Error(w, \"Failed to connect to target server\", http.StatusBadGateway)\n\t\treturn\n\t}\n\tdefer conn.Close()\n\n\tconn.SetReadLimit(1 << 20) // 1 MB\n\n\terr = conn.WriteJSON(reqMsg)\n\tif err != nil {\n\t\tlog.Println(\"WebSocket write error:\", err)\n\t\thttp.Error(w, \"Failed to send request\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\terr = conn.SetReadDeadline(time.Now().Add(10 * time.Second))\n\tif err != nil {\n\t\tlog.Println(\"SetReadDeadline error:\", err)\n\t\thttp.Error(w, \"Failed to set read deadline\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tvar respMsg HttpResponseMessage\n\terr = conn.ReadJSON(&respMsg)\n\tif err != nil {\n\t\tlog.Println(\"WebSocket read error:\", err)\n\t\thttp.Error(w, \"Failed to receive response\", http.StatusGatewayTimeout)\n\t\treturn\n\t}\n\n\tlogResponse(respMsg)\n\n\tif respMsg.Type != MessageTypeHttpResponse {\n\t\thttp.Error(w, \"Invalid response type\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tw.WriteHeader(respMsg.StatusCode)\n\tfilterHopByHopHeaders(respMsg.Headers)\n\tfor k, v := range respMsg.Headers {\n\t\tw.Header()[k] = v\n\t}\n\tw.Write(respMsg.Body)\n}\n\nfunc logRequest(r *http.Request) {\n\tlog.Printf(\"HTTP %s request for %s\", r.Method, r.URL)\n\tlogHeaders(r.Header, \"Authorization\", \"Cookie\")\n\tif r.Body != nil {\n\t\tbody, _ := ioutil.ReadAll(r.Body)\n\t\tlog.Printf(\"Request body: %s\", body)\n\t\tr.Body = ioutil.NopCloser(bytes.NewBuffer(body))\n\t}\n}\n\nfunc logResponse(respMsg HttpResponseMessage) {\n\tlog.Printf(\"HTTP response with status code %d\", respMsg.StatusCode)\n\tlogHeaders(respMsg.Headers, \"Set-Cookie\")\n\tlog.Printf(\"Response body: %s\", string(respMsg.Body))\n}\n\nfunc logHeaders(headers http.Header, redact ...string) {\n\tfor k, v := range headers {\n\t\tif contains(redact, k) {\n\t\t\tlog.Printf(\"%s: [redacted]\", k)\n\t\t} else {\n\t\t\tlog.Printf(\"%s: %s\", k, v)\n\t\t}\n\t}\n}\n\nfunc contains(slice []string, item string) bool {\n\tfor _, s := range slice {\n\t\tif s == item {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc filterHopByHopHeaders(headers http.Header) {\n\thopByHopHeaders := map[string]bool{\n\t\t\"Connection\":       true,\n\t\t\"Keep-Alive\":       true,\n\t\t\"Proxy-Authenticate\": true,\n\t\t\"Proxy-Authorization\": true,\n\t\t\"TE\":               true,\n\t\t\"Trailers\":         true,\n\t\t\"Transfer-Encoding\": true,\n\t\t\"Upgrade\":          true,\n\t}\n\n\tfor header := range hopByHopHeaders {\n\t\theaders.Del(header)\n\t}\n}\n```\n\n### Explanation\n\n1. **HTTP Server Setup:** \n   - An HTTP server is set up to listen on port 8080.\n   - It handles all incoming requests using the `forwardHandler` function.\n\n2. **Request Handling:**\n   - The `forwardHandler` function extracts details from the incoming HTTP request.\n   - It establishes a WebSocket connection to a target server.\n   - It serializes the HTTP request into a WebSocket message and sends it.\n   - Waits for a response message over the WebSocket connection.\n   - Deserializes the response message into an HTTP response and sends it back to the client.\n\n3. **Logging:**\n   - Request and response details are logged for debugging purposes.\n   - Sensitive headers are redacted in logs to ensure security.\n\n4. **Error Handling:**\n   - Various error scenarios are handled, such as failing to connect to the target server or reading/writing messages.\n   - Appropriate HTTP error responses are returned to the client in case of failures.\n\n5. **Configuration:**\n   - The target WebSocket URL can be configured via a command-line flag.\n\nThis setup ensures that HTTP requests are proxied via WebSocket, providing a flexible and debuggable interface for request and response handling."
    }
]