[
    {
        "role": "user",
        "content": "Write a Java program that generates random mazes using Prim's algorithm and displays them as ASCII art in the console. The program should support command line arguments for specifying the maze dimensions (width and height) and the starting point coordinates. Additionally, implement a simple pathfinding algorithm to find the shortest path between two points in the maze.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Alright, I've got this task to create a Java program that generates random mazes using Prim's algorithm and displays them as ASCII art in the console. Also, it should accept command-line arguments for maze dimensions and starting point, and include a simple pathfinding algorithm to find the shortest path between two points.\n\nFirst, I need to understand Prim's algorithm for maze generation. Prim's algorithm is typically used for generating minimum spanning trees in graphs, but it can also be adapted to create mazes. In the context of mazes, each cell in the grid can be considered a node, and walls between cells are edges. The algorithm starts from an initial cell and repeatedly adds a random neighboring cell that hasn't been visited yet, removing the wall between them.\n\nFor ASCII art, I'll need to represent the maze in the console using characters like walls (#), paths ( ), start (S), and end (E). I need to ensure that the maze is printable and looks like a proper maze.\n\nCommand-line arguments will be used to specify the width and height of the maze, as well as the starting point coordinates. I should validate these inputs to make sure they are within the maze dimensions.\n\nLastly, implementing a pathfinding algorithm to find the shortest path between two points in the maze. I think Dijkstra's algorithm or BFS (Breadth-First Search) would be suitable for this purpose since they can find the shortest path in an unweighted grid like a maze.\n\nLet me outline the steps I need to follow:\n\n1. Parse command-line arguments for maze dimensions (width, height) and starting point coordinates (startX, startY).\n\n2. Validate the input arguments to ensure they are positive integers and within the maze boundaries.\n\n3. Implement Prim's algorithm to generate a random maze:\n\na. Initialize a grid with all cells considered as walls.\n\nb. Choose the starting cell and mark it as part of the maze.\n\nc. Add all walls of the starting cell to a list of candidate walls.\n\nd. While there are candidate walls:\n\ni. Pick a random wall from the list.\n\nii. If the cell on the other side of the wall hasn't been visited:\n\n- Remove the wall.\n\n- Mark the new cell as part of the maze.\n\n- Add the walls of the new cell to the candidate list.\n\niii. Remove the wall from the candidate list.\n\n4. Display the maze as ASCII art in the console, marking the start position.\n\n5. Implement a simple pathfinding algorithm (e.g., BFS) to find the shortest path between two points in the maze.\n\n6. Allow the user to specify the end point and display the path found.\n\nI need to consider how to represent the maze in code. I think using a 2D array where each cell can be a wall or a path is straightforward. I can use boolean values or enum types to represent the cell states.\n\nFor Prim's algorithm, I need to keep track of which cells have been visited and which walls are candidates for removal. I should ensure that the maze is fully connected, meaning there are no isolated sections.\n\nFor pathfinding, BFS is a good choice because it explores all cells at the current depth before moving on to cells at the next depth level, guaranteeing the shortest path in an unweighted grid.\n\nI should also think about how to handle the maze's boundaries. Walls around the maze should remain intact to contain the maze.\n\nLet me start by sketching a simple example manually to understand how Prim's algorithm works for maze generation.\n\nSuppose I have a 3x3 grid:\n\nInitial grid (all walls):\n\n```\n\n###\n\n###\n\n###\n\n```\n\nChoose starting cell, say (1,1):\n\n```\n\n# # #\n\n# S #\n\n# # #\n\n```\n\nCandidate walls: north, south, east, west of (1,1).\n\nRandomly choose one, say east:\n\nRemove wall between (1,1) and (1,2), mark (1,2) as path.\n\n```\n\n# # #\n\n# S P #\n\n# # #\n\n```\n\nNow, candidate walls include walls of (1,2).\n\nChoose randomly, say south:\n\nRemove wall between (1,2) and (2,2), mark (2,2) as path.\n\n```\n\n# # #\n\n# S P #\n\n# P #\n\n```\n\nContinue this process until no candidate walls are left.\n\nThis seems straightforward. Now, I need to implement this logic in code.\n\nI should also consider that the maze should have only one path between any two points, which is a property of a spanning tree.\n\nNext, for pathfinding, I'll need to represent the maze in a way that a pathfinding algorithm can traverse it. I can represent the maze as a graph where each cell is a node, and adjacent cells (without walls between them) are connected edges.\n\nIn BFS, I'll keep a queue of positions to explore, marking each cell with its predecessor to reconstruct the path later.\n\nI need to make sure that the pathfinding algorithm only moves to neighboring cells that are paths (not walls) and within the maze boundaries.\n\nOnce the end point is reached, I can trace back the path from the end to the start using the predecessor information.\n\nFinally, I need to display the maze with the path highlighted. I can use a different character, say 'x', to mark the path.\n\nI should also handle cases where there is no path between the start and end points, but since the maze is generated using Prim's algorithm, which creates a spanning tree, there should always be a path between any two points.\n\nWait, actually, in Prim's algorithm, as long as it's properly implemented, the maze should be fully connected, so there should always be a path between any two points.\n\nI need to ensure that the pathfinding algorithm doesn't get stuck in infinite loops, so I should keep track of visited cells to avoid revisiting them.\n\nLet me think about the implementation in code.\n\nFirst, I'll need a class to represent the maze.\n\nI can have a 2D array to represent the grid, with each cell being a boolean (true for path, false for wall) or an enum with states like WALL, PATH, START, END, PATH_PART.\n\nI need to parse command-line arguments. In Java, I can use the args array in the main method.\n\nI should check that there are enough arguments and that they are valid integers.\n\nFor example, java MazeGenerator width height startX startY endX endY\n\nI need to decide whether to ask for end coordinates or allow the user to input them later.\n\nTo keep it simple, I'll ask for start and end coordinates as command-line arguments.\n\nAlternatively, I can allow specifying only the start and generate a random end point, but for now, I'll stick with specifying both.\n\nIn the maze generation step, I need to implement Prim's algorithm.\n\nI need a way to represent walls and cells.\n\nOne way is to consider each cell as having four walls (north, south, east, west), and keep track of which walls are present.\n\nBut for simplicity, I can represent the maze as a grid where each cell is either a wall or a path, and maintain a separate visited matrix for the maze generation algorithm.\n\nIn Prim's algorithm, I'll need a list of candidate walls (or frontiers).\n\nI can represent the walls as pairs of cells or use some other structure.\n\nTo simplify, I can consider that when I choose a wall between two cells, one is inside the maze and the other is not yet visited.\n\nI'll remove that wall and add the new cell to the maze, then add the walls of the new cell to the candidate list.\n\nI need to make sure that I don't add walls that are already in the candidate list or that lead outside the maze.\n\nFor the ASCII art display, I need to print the maze grid, using '#' for walls and ' ' for paths, and mark the start and end points.\n\nAfter generating the maze and displaying it, I'll run the pathfinding algorithm from start to end and display the shortest path.\n\nImplementing BFS for pathfinding:\n\n- Use a queue to keep track of cells to visit.\n\n- Keep a visited matrix to avoid revisiting cells.\n\n- Keep a predecessor matrix to record the path.\n\n- Start from the start point, add it to the queue, mark it as visited.\n\n- While the queue is not empty:\n\n- Dequeue a cell.\n\n- If it's the end point, reconstruct the path using the predecessor matrix and return it.\n\n- Otherwise, add all neighboring cells that are paths and not visited to the queue, mark them as visited and record their predecessor.\n\nIf the queue becomes empty without finding the end point, there is no path. But since the maze is connected, this shouldn't happen.\n\nFinally, display the maze with the path marked.\n\nI need to think about how to represent the maze grid.\n\nI can use a char matrix where each cell is either '#', ' ', 'S', 'E', or 'x' for the path.\n\nI need to make sure that 'S' and 'E' are not overwritten by 'x' unless they are part of the path.\n\nI should also handle the case where the start and end points are the same, in which case the path is just the starting point.\n\nNow, let's consider edge cases:\n\n- Maze of minimum size, like 1x1. In this case, the start and end should be the same.\n\n- Start and end points are adjacent and there is no wall between them.\n\n- Start and end points are on the boundary of the maze.\n\n- Start or end points are provided outside the maze dimensions.\n\nI need to validate that the start and end points are within the maze boundaries and are not walls.\n\nWait, in my maze generation algorithm, the start point is always a path, but the end point needs to be ensured to be a path as well.\n\nI should allow the end point to be specified freely, and if it's a wall, perhaps adjust it to the nearest path cell.\n\nBut to keep it simple, I'll assume that the end point is always a path cell.\n\nI need to make sure that when generating the maze, the end point is within the maze's path.\n\nAlternatively, I can ensure that the end point is always a path by choosing it after the maze is generated.\n\nBut to follow the task, I'll assume that the end point is provided and is a valid path cell.\n\nI need to handle cases where the end point is provided outside the maze dimensions or invalid, but for now, I'll assume valid inputs.\n\nIn terms of code structure:\n\n- A Maze class that handles maze generation, pathfinding, and display.\n\n- A main method that parses command-line arguments and creates a Maze instance.\n\n- Methods in Maze:\n\n- generateMaze(width, height, startX, startY): generates the maze using Prim's algorithm.\n\n- displayMaze(): prints the maze as ASCII art.\n\n- findPath(startX, startY, endX, endY): finds the shortest path using BFS.\n\n- displayPath(path): marks the path in the maze display.\n\nI need to decide how to represent the maze internally.\n\nOption 1: Use a 2D char array, where each cell is '#', ' ', 'S', 'E', or 'x'.\n\nOption 2: Use an enum for cell states.\n\nI think using an enum is more type-safe and readable.\n\nDefine an enum CellType with WALL, PATH, START, END, PATH_PART.\n\nThen, the maze grid can be a 2D array of CellType.\n\nIn the generateMaze method, initialize the grid with WALL, set the start position to START, and apply Prim's algorithm to carve paths.\n\nIn the findPath method, use BFS to find the path from start to end, recording predecessors.\n\nThen, in displayPath, update the grid with PATH_PART for cells in the path.\n\nFinally, in displayMaze, print the grid, mapping each CellType to its corresponding character.\n\nI need to ensure that the start and end positions are not overwritten by PATH_PART, so I can handle their display separately.\n\nNow, let's think about the implementation of Prim's algorithm in code.\n\nI need a way to represent the list of candidate walls.\n\nEach wall can be represented by the position of the cell and the direction of the wall (north, south, east, west).\n\nAlternatively, I can represent walls as edges between cells.\n\nTo simplify, I can keep a list of wall positions, where each wall is a pair of cell positions.\n\nBut that might be inefficient.\n\nAnother approach is to keep a list of cells that are on the boundary of the current maze (i.e., cells that have at least one wall adjacent to an unvisited cell).\n\nThen, for each such boundary cell, consider its unvisited neighbors, pick one randomly, remove the wall between them, and add the new cell to the boundary list.\n\nI need to make sure that I don't add cells multiple times to the boundary list.\n\nI can maintain a set of boundary cells and a set of visited cells.\n\nInitially, the starting cell is visited, and its neighbors are boundary cells.\n\nThen, repeatedly pick a random boundary cell, check if its opposite cell is unvisited, remove the wall, mark the opposite cell as visited, and add its neighbors to the boundary list if they are unvisited.\n\nWait, perhaps it's better to represent the maze generation in terms of sets of visited and boundary cells.\n\nI can use java.util.Set to keep track of visited and boundary cells, using pairs of coordinates.\n\nFor efficiency, I can use a list or a queue for the boundary cells to pick from.\n\nYes, using a java.util.List for the boundary cells and java.util.Set for visited cells.\n\nEach time, pick a random boundary cell, find an unvisited neighbor, remove the wall between them, add the new cell to visited and its neighbors to the boundary list.\n\nContinue until there are no more boundary cells.\n\nI need to ensure that all cells are connected, so I need to make sure that the algorithm covers the entire grid.\n\nAlso, I need to handle the edges and corners correctly, where some cells have fewer neighbors.\n\nNow, for pathfinding using BFS.\n\nI can use a java.util.Queue to implement BFS.\n\nI'll need a way to represent positions in the grid, perhaps using a simple class Pos with x and y coordinates.\n\nI'll need a visited matrix to avoid revisiting cells.\n\nI'll also need a predecessor matrix to record the path.\n\nStart by enqueuing the start position, mark it as visited.\n\nWhile the queue is not empty:\n\nDequeue a cell.\n\nIf it's the end position, reconstruct the path using predecessors and return it.\n\nOtherwise, for each neighboring cell that is a path and not visited, enqueue it, mark it as visited, and set its predecessor to the current cell.\n\nIf the queue becomes empty without finding the end, there is no path. But, as mentioned earlier, this shouldn't happen in a properly generated maze.\n\nIn the path reconstruction, start from the end position and follow predecessors back to the start, collecting the path.\n\nThen, in displayPath, mark those positions in the grid with PATH_PART.\n\nFinally, in displayMaze, print the grid, mapping each CellType to its corresponding character.\n\nI need to ensure that 'S' and 'E' are displayed appropriately, even if they are part of the path.\n\nSo, in displayMaze, I can have a method that, for each cell, chooses the appropriate character based on its CellType, but give priority to 'S' and 'E' over 'x'.\n\nAlternatively, I can have a separate layer for the path, so that 'S' and 'E' are displayed on top of the path.\n\nBut to keep it simple, I can define the CellType such that START and END override PATH_PART.\n\nNow, let's think about how to implement the command-line argument parsing.\n\nIn the main method, check the number of arguments and parse them accordingly.\n\nExpected arguments: width height startX startY endX endY\n\nI need to validate that width and height are positive integers, and that start and end coordinates are within the grid.\n\nIf arguments are missing or invalid, print an error message and exit.\n\nI can use Integer.parseInt to parse the arguments and handle NumberFormatException.\n\nNow, let's consider writing some pseudocode to outline the steps.\n\nPseudocode:\n\nclass Maze {\n\nenum CellType { WALL, PATH, START, END, PATH_PART }\n\nCellType[][] grid;\n\nint width, height;\n\nMaze(int width, int height) {\n\nthis.width = width;\n\nthis.height = height;\n\nthis.grid = new CellType[height][width];\n\ninitialize grid to WALL;\n\n}\n\nvoid generateMaze(int startX, int startY) {\n\nSet<Pos> visited = new HashSet<>();\n\nList<Pos> boundary = new ArrayList<>();\n\nPos start = new Pos(startX, startY);\n\nvisited.add(start);\n\nboundary.addAll(start.getNeighbors());\n\nwhile (!boundary.isEmpty()) {\n\nPos current = boundary.remove(randomIndex(boundary));\n\nList<Pos> unvisitedNeighbors = current.getUnvisitedNeighbors(visited);\n\nif (!unvisitedNeighbors.isEmpty()) {\n\nPos neighbor = unvisitedNeighbors.get(randomIndex(unvisitedNeighbors));\n\nremoveWall(current, neighbor);\n\nvisited.add(neighbor);\n\nboundary.addAll(neighbor.getNeighbors());\n\n}\n\n}\n\n}\n\n}\n\nvoid removeWall(Pos cell1, Pos cell2) {\n\n// Calculate the wall position between cell1 and cell2\n\n// Set the wall to PATH\n\n}\n\nList<Pos> findPath(int startX, int startY, int endX, int endY) {\n\nQueue<Pos> queue = new LinkedList<>();\n\nMap<Pos, Pos> predecessors = new HashMap<>();\n\nSet<Pos> visited = new HashSet<>();\n\nPos start = new Pos(startX, startY);\n\nqueue.offer(start);\n\nvisited.add(start);\n\nwhile (!queue.isEmpty()) {\n\nPos current = queue.poll();\n\nif (current.equals(endX, endY)) {\n\nreturn reconstructPath(predecessors, start, current);\n\n}\n\nfor (Pos neighbor : current.getNeighbors()) {\n\nif (isPath(neighbor) && !visited.contains(neighbor)) {\n\nqueue.offer(neighbor);\n\nvisited.add(neighbor);\n\npredecessors.put(neighbor, current);\n\n}\n\n}\n\n}\n\nreturn null; // No path found\n\n}\n\nList<Pos> reconstructPath(Map<Pos, Pos> predecessors, Pos start, Pos current) {\n\nList<Pos> path = new ArrayList<>();\n\nwhile (current != start) {\n\npath.add(current);\n\ncurrent = predecessors.get(current);\n\n}\n\npath.add(start);\n\nCollections.reverse(path);\n\nreturn path;\n\n}\n\nvoid displayMaze() {\n\nfor (int y = 0; y < height; y++) {\n\nfor (int x = 0; x < width; x++) {\n\nSystem.out.print(getChar(grid[y][x]));\n\n}\n\nSystem.out.println();\n\n}\n\n}\n\nchar getChar(CellType type) {\n\nswitch (type) {\n\ncase WALL: return '#';\n\ncase PATH: return ' ';\n\ncase START: return 'S';\n\ncase END: return 'E';\n\ncase PATH_PART: return 'x';\n\n}\n\nreturn ' ';\n\n}\n\n}\n\nclass Pos {\n\nint x, y;\n\nPos(int x, int y) {\n\nthis.x = x;\n\nthis.y = y;\n\n}\n\nList<Pos> getNeighbors() {\n\n// Return list of valid neighboring positions\n\n}\n\nList<Pos> getUnvisitedNeighbors(Set<Pos> visited) {\n\n// Return list of unvisited neighbors\n\n}\n\nboolean equals(int x, int y) {\n\nreturn this.x == x && this.y == y;\n\n}\n\n}\n\npublic class MazeGenerator {\n\npublic static void main(String[] args) {\n\nif (args.length < 6) {\n\nSystem.out.println(\"Usage: java MazeGenerator width height startX startY endX endY\");\n\nreturn;\n\n}\n\nint width = Integer.parseInt(args[0]);\n\nint height = Integer.parseInt(args[1]);\n\nint startX = Integer.parseInt(args[2]);\n\nint startY = Integer.parseInt(args[3]);\n\nint endX = Integer.parseInt(args[4]);\n\nint endY = Integer.parseInt(args[5]);\n\nif (startX < 0 || startX >= width || startY < 0 || startY >= height) {\n\nSystem.out.println(\"Invalid start coordinates.\");\n\nreturn;\n\n}\n\nif (endX < 0 || endX >= width || endY < 0 || endY >= height) {\n\nSystem.out.println(\"Invalid end coordinates.\");\n\nreturn;\n\n}\n\nMaze maze = new Maze(width, height);\n\nmaze.generateMaze(startX, startY);\n\nmaze.setStart(startX, startY);\n\nmaze.setEnd(endX, endY);\n\nList<Pos> path = maze.findPath(startX, startY, endX, endY);\n\nif (path != null) {\n\nmaze.markPath(path);\n\nmaze.displayMaze();\n\n} else {\n\nSystem.out.println(\"No path found.\");\n\n}\n\n}\n\n}\n\nThis pseudocode outlines the structure of the Maze class and the main method.\n\nI need to implement the details, such as the Pos class, neighbor calculations, wall removal, and pathfinding.\n\nI should also handle cases where the start and end points are the same.\n\nNow, I need to think about how to represent walls between cells.\n\nIn the grid representation, each cell can have four walls: north, south, east, west.\n\nBut if I use a single grid for cell types, I need a way to represent the walls between cells.\n\nOne way is to consider that walls are shared between cells, so modifying one cell's wall affects the adjacent cell.\n\nAlternatively, I can use a separate grid for walls.\n\nBut to keep it simple, I can assume that when a cell is a PATH, its adjacent PATH cells don't have walls between them.\n\nIn the generateMaze method, when I connect two cells, I set both to PATH.\n\nIn displayMaze, I need to draw walls appropriately based on the cell types.\n\nThis can be a bit tricky.\n\nPerhaps a better approach is to have a 2D grid where each cell contains information about its four walls and whether it's been visited.\n\nBut that complicates the implementation.\n\nAlternatively, I can represent the maze as a grid of cells, where each cell knows which directions have walls.\n\nBut to keep it simple, I'll stick with a char grid and carefully handle the walls when generating the maze.\n\nIn Prim's algorithm, when I connect two cells, I need to remove the wall between them, which means setting the appropriate positions in the grid to ' ' (path).\n\nIn the displayMaze method, I need to print the grid in a way that walls are displayed correctly, considering the adjacent cells.\n\nI need to ensure that the outer borders of the maze are always walls.\n\nLet me think about how to represent the grid.\n\nI can have a 2D array where each cell is a CellType.\n\nThen, when displaying, for each cell, I print ' ' if it's PATH, '#' if it's WALL, 'S' for start, 'E' for end, and 'x' for path parts.\n\nBut I need to ensure that the walls are displayed correctly between cells.\n\nWait, perhaps I need to print the maze in a more grid-like fashion, with explicit walls between cells.\n\nFor example, for a 3x3 maze:\n\n+---+---+---+\n\n| S | | |\n\n+---+---+---+\n\n| | | |\n\n+---+---+---+\n\n| | | E |\n\n+---+---+---+\n\nIn this representation, '+' are corners, and '-' and '|' are horizontal and vertical walls.\n\nIn this way, I can ensure that the walls are displayed correctly.\n\nSo, I need to print a grid with walls, and place the 'S', 'E', and 'x' in the appropriate cell centers.\n\nThis seems more manageable.\n\nSo, the grid will be represented internally as a 2D array of CellType, and when displaying, I'll print the walls and the cell contents accordingly.\n\nI need to print the horizontal walls and vertical walls appropriately, based on the cell neighbors.\n\nFor example, for a horizontal wall between two cells, if both cells are PATH and share no wall, then the horizontal wall should not be printed.\n\nSimilarly for vertical walls.\n\nThis requires careful handling in the displayMaze method.\n\nAlternatively, I can keep track of which walls are present for each cell and print accordingly.\n\nThis might be more accurate but also more complex.\n\nTo simplify, I can assume that each cell has its own walls, and when two adjacent cells are both PATH, the wall between them is removed.\n\nIn the displayMaze method, for each cell, I print its north and west walls, and then the cell content.\n\nThen, for each row, I print the north walls of the cells, followed by the cell contents with their east walls.\n\nThis way, I can ensure that shared walls are only printed once and only if one of the adjacent cells is a wall.\n\nThis is a bit involved, but it's a common way to print grid-based mazes.\n\nI need to implement this carefully to avoid off-by-one errors in the grid indices.\n\nNow, let's think about how to implement the wall removal in Prim's algorithm.\n\nWhen I connect two cells, I need to set both cells to PATH and remove the wall between them.\n\nIn the grid representation, I need to ensure that the wall between them is not printed.\n\nSo, perhaps each cell should keep track of which of its walls are present.\n\nWait, maybe I need to have a more\u7cbe\u7ec6\u7684\u8868\u793a\u65b9\u5f0f\u6765\u8ddf\u8e2a\u6bcf\u4e2a\u5355\u5143\u683c\u7684\u5899\u58c1\u72b6\u6001\u3002\n\n\u8ba9\u6211\u5c1d\u8bd5\u5b9a\u4e49\u4e00\u4e2aCell\u7c7b\uff0c\u5176\u4e2d\u5305\u542b\u56db\u4e2a\u5899\u58c1\uff1a\u5317\u3001\u5357\u3001\u4e1c\u3001\u897f\u3002\n\nclass Cell {\n\nboolean northWall;\n\nboolean southWall;\n\nboolean eastWall;\n\nboolean westWall;\n\n}\n\n\u7136\u540e\uff0cmaze grid\u53ef\u4ee5\u662f\u4e00\u4e2aCell[][]\u6570\u7ec4\u3002\n\n\u5728\u751f\u6210\u8ff7\u5bab\u65f6\uff0c\u521d\u59cb\u65f6\u6240\u6709\u5899\u58c1\u90fd\u5b58\u5728\u3002\n\n\u5f53\u6211\u5728\u4e24\u4e2a\u5355\u5143\u683c\u4e4b\u95f4\u79fb\u9664\u5899\u58c1\u65f6\uff0c\u6211\u8bbe\u7f6e\u76f8\u5e94\u5899\u58c1\u4e3afalse\u3002\n\n\u7136\u540e\uff0c\u5728displayMaze\u65b9\u6cd5\u4e2d\uff0c\u6839\u636e\u6bcf\u4e2a\u5355\u5143\u683c\u7684\u5899\u58c1\u72b6\u6001\u6765\u6253\u5370\u8ff7\u5bab\u3002\n\n\u8fd9\u5c06\u66f4\u51c6\u786e\u5730\u8868\u793a\u8ff7\u5bab\u7684\u7ed3\u6784\u3002\n\n\u6240\u4ee5\uff0c\u6211\u5c06\u4fee\u6539Maze\u7c7b\uff0c\u4f7f\u7528Cell[][] grid\u3002\n\n\u6bcf\u4e2aCell\u5bf9\u8c61\u5c06\u8ddf\u8e2a\u5176\u56db\u4e2a\u5899\u58c1\u7684\u72b6\u6001\u3002\n\n\u5728generateMaze\u65b9\u6cd5\u4e2d\uff0c\u6211\u5c06\u521d\u59cb\u5316\u6240\u6709\u5899\u58c1\u4e3atrue\u3002\n\n\u7136\u540e\uff0c\u4ece\u8d77\u59cb\u5355\u5143\u683c\u5f00\u59cb\uff0c\u6807\u8bb0\u4e3a\u5df2\u8bbf\u95ee\uff0c\u5e76\u79fb\u9664\u5176\u968f\u673a\u90bb\u5c45\u7684\u5899\u58c1\uff0c\u5c06\u5176\u6dfb\u52a0\u5230\u8bbf\u95ee\u96c6\u548c\u8fb9\u754c\u5217\u8868\u4e2d\u3002\n\n\u7ee7\u7eed\u8fd9\u4e2a\u8fc7\u7a0b\uff0c\u76f4\u5230\u6ca1\u6709\u8fb9\u754c\u5355\u5143\u683c\u4e3a\u6b62\u3002\n\n\u5728findPath\u65b9\u6cd5\u4e2d\uff0c\u6211\u9700\u8981\u786e\u4fdd\u53ea\u5728\u8def\u5f84\u5355\u5143\u683c\u4e4b\u95f4\u79fb\u52a8\uff0c\u5373\u6ca1\u6709\u5899\u58c1\u7684\u5355\u5143\u683c\u3002\n\n\u5728displayMaze\u65b9\u6cd5\u4e2d\uff0c\u6211\u9700\u8981\u6839\u636e\u6bcf\u4e2a\u5355\u5143\u683c\u7684\u5899\u58c1\u72b6\u6001\u6765\u6253\u5370\u8ff7\u5bab\u3002\n\n\u8fd9\u5c06\u662f\u4e00\u4e2a\u66f4\u590d\u6742\u4f46\u66f4\u51c6\u786e\u7684\u5b9e\u73b0\u3002\n\n\u73b0\u5728\uff0c\u6211\u9700\u8981\u5b9a\u4e49Cell\u7c7b\u3002\n\nclass Cell {\n\nboolean northWall;\n\nboolean southWall;\n\nboolean eastWall;\n\nboolean westWall;\n\n}\n\n\u5728Maze\u7c7b\u4e2d\uff0cgrid\u5c06\u662fCell [][ ]\u3002\n\n\u6211\u9700\u8981\u5b9e\u73b0getNeighbors\u65b9\u6cd5\uff0c\u8003\u8651\u5899\u58c1\u7684\u5b58\u5728\u3002\n\n\u5728findPath\u65b9\u6cd5\u4e2d\uff0c\u5f53\u6211\u68c0\u67e5\u90bb\u5c45\u65f6\uff0c\u6211\u9700\u8981\u68c0\u67e5\u76f8\u5e94\u7684\u5899\u58c1\u662f\u5426\u4e0d\u5b58\u5728\u3002\n\n\u4f8b\u5982\uff0c\u5982\u679c\u5f53\u524d\u5355\u5143\u683c\u7684eastWall\u4e3afalse\uff0c\u5219\u4e1c\u8fb9\u7684\u5355\u5143\u683c\u662f\u53ef\u8fbe\u7684\u3002\n\n\u540c\u6837\uff0c\u5982\u679c\u90bb\u5c45\u7684westWall\u4e3afalse\uff0c\u5219\u4e5f\u662f\u53ef\u8fbe\u7684\u3002\n\n\u4f46\u4e3a\u4e86\u7b80\u5316\uff0c\u6211\u53ef\u4ee5\u5047\u8bbe\u5982\u679c\u90bb\u5c45\u7684\u76f8\u5e94\u5899\u58c1\u4e0d\u5b58\u5728\uff0c\u5219\u53ef\u4ee5\u79fb\u52a8\u5230\u8be5\u90bb\u5c45\u3002\n\n\u73b0\u5728\uff0c\u6211\u9700\u8981\u5b9e\u73b0Pos\u7c7b\uff0c\u8868\u793a\u4f4d\u7f6e\u3002\n\nclass Pos {\n\nint x, y;\n\nPos(int x, int y) {\n\nthis.x = x;\n\nthis.y = y;\n\n}\n\n}\n\n\u5728Maze\u7c7b\u4e2d\uff0c\u6211\u9700\u8981\u5b9e\u73b0getNeighbors\u65b9\u6cd5\uff0c\u8be5\u65b9\u6cd5\u8fd4\u56de\u5f53\u524d\u4f4d\u7f6e\u7684\u53ef\u8fbe\u90bb\u5c45\u3002\n\n\u5728generateMaze\u65b9\u6cd5\u4e2d\uff0c\u6211\u9700\u8981\u5b9e\u73b0\u79fb\u9664\u5899\u58c1\u7684\u903b\u8f91\u3002\n\n\u4f8b\u5982\uff0c\u5982\u679c\u6211\u9009\u62e9\u5411\u4e1c\u79fb\u52a8\uff0c\u6211\u9700\u8981\u8bbe\u7f6e\u5f53\u524d\u5355\u5143\u683c\u7684eastWall\u4e3afalse\uff0c\u90bb\u5c45\u7684westWall\u4e3afalse\u3002\n\n\u540c\u6837\u9002\u7528\u4e8e\u5176\u4ed6\u65b9\u5411\u3002\n\n\u5728displayMaze\u65b9\u6cd5\u4e2d\uff0c\u6211\u9700\u8981\u6253\u5370\u6c34\u5e73\u548c\u5782\u76f4\u5899\u58c1\uff0c\u6839\u636e\u5355\u5143\u683c\u7684\u5899\u58c1\u72b6\u6001\u3002\n\n\u8fd9\u9700\u8981\u4ed4\u7ec6\u5904\u7406\uff0c\u4ee5\u786e\u4fdd\u5899\u58c1\u6b63\u786e\u5bf9\u9f50\u3002\n\n\u73b0\u5728\uff0c\u6211\u5c06\u5c1d\u8bd5\u7f16\u5199\u4e00\u4e9b\u4ee3\u7801\u7247\u6bb5\u6765\u5b9e\u73b0\u8fd9\u4e9b\u529f\u80fd\u3002\n\n\u9996\u5148\uff0c\u5b9a\u4e49Cell\u7c7b\uff1a\n\nclass Cell {\n\nboolean northWall;\n\nboolean southWall;\n\nboolean eastWall;\n\nboolean westWall;\n\nCell() {\n\nnorthWall = true;\n\nsouthWall = true;\n\neastWall = true;\n\nwestWall = true;\n\n}\n\n}\n\n\u7136\u540e\uff0c\u5728Maze\u7c7b\u4e2d\uff1a\n\nclass Maze {\n\nCell[][] grid;\n\nint width, height;\n\nMaze(int width, int height) {\n\nthis.width = width;\n\nthis.height = height;\n\nthis.grid = new Cell[height][width];\n\nfor (int y = 0; y < height; y++) {\n\nfor (int x = 0; x < width; x++) {\n\ngrid[y][x] = new Cell();\n\n}\n\n}\n\n}\n\nvoid generateMaze(int startX, int startY) {\n\nSet<Pos> visited = new HashSet<>();\n\nList<Pos> boundary = new ArrayList<>();\n\nPos start = new Pos(startX, startY);\n\nvisited.add(start);\n\nboundary.addAll(getBoundaryNeighbors(start));\n\nwhile (!boundary.isEmpty()) {\n\nPos current = boundary.remove(randomIndex(boundary));\n\nList<Pos> unvisitedNeighbors = getUnvisitedNeighbors(current, visited);\n\nif (!unvisitedNeighbors.isEmpty()) {\n\nPos neighbor = unvisitedNeighbors.get(randomIndex(unvisitedNeighbors));\n\nremoveWall(current, neighbor);\n\nvisited.add(neighbor);\n\nboundary.addAll(getBoundaryNeighbors(neighbor));\n\n}\n\n}\n\n}\n\nList<Pos> getBoundaryNeighbors(Pos pos) {\n\nList<Pos> neighbors = new ArrayList<>();\n\nint x = pos.x;\n\nint y = pos.y;\n\nif (y > 0 && grid[y][x].northWall) {\n\nneighbors.add(new Pos(x, y - 1));\n\n}\n\nif (y < height - 1 && grid[y][x].southWall) {\n\nneighbors.add(new Pos(x, y + 1));\n\n}\n\nif (x < width - 1 && grid[y][x].eastWall) {\n\nneighbors.add(new Pos(x + 1, y));\n\n}\n\nif (x > 0 && grid[y][x].westWall) {\n\nneighbors.add(new Pos(x - 1, y));\n\n}\n\nreturn neighbors;\n\n}\n\nList<Pos> getUnvisitedNeighbors(Pos pos, Set<Pos> visited) {\n\nList<Pos> unvisited = new ArrayList<>();\n\nint x = pos.x;\n\nint y = pos.y;\n\nif (y > 0 && !visited.contains(new Pos(x, y - 1))) {\n\nunvisited.add(new Pos(x, y - 1));\n\n}\n\nif (y < height - 1 && !visited.contains(new Pos(x, y + 1))) {\n\nunvisited.add(new Pos(x, y + 1));\n\n}\n\nif (x < width - 1 && !visited.contains(new Pos(x + 1, y))) {\n\nunvisited.add(new Pos(x + 1, y));\n\n}\n\nif (x > 0 && !visited.contains(new Pos(x - 1, y))) {\n\nunvisited.add(new Pos(x - 1, y));\n\n}\n\nreturn unvisited;\n\n}\n\nvoid removeWall(Pos cell1, Pos cell2) {\n\nint x1 = cell1.x;\n\nint y1 = cell1.y;\n\nint x2 = cell2.x;\n\nint y2 = cell2.y;\n\nif (x2 == x1 + 1 && y2 == y1) {\n\ngrid[y1][x1].eastWall = false;\n\ngrid[y2][x2].westWall = false;\n\n} else if (x2 == x1 - 1 && y2 == y1) {\n\ngrid[y1][x1].westWall = false;\n\ngrid[y2][x2].eastWall = false;\n\n} else if (x2 == x1 && y2 == y1 + 1) {\n\ngrid[y1][x1].southWall = false;\n\ngrid[y2][x2].northWall = false;\n\n} else if (x2 == x1 && y2 == y1 - 1) {\n\ngrid[y1][x1].northWall = false;\n\ngrid[y2][x2].southWall = false;\n\n}\n\n}\n\nList<Pos> findPath(int startX, int startY, int endX, int endY) {\n\nQueue<Pos> queue = new LinkedList<>();\n\nMap<Pos, Pos> predecessors = new HashMap<>();\n\nSet<Pos> visited = new HashSet<>();\n\nPos start = new Pos(startX, startY);\n\nqueue.offer(start);\n\nvisited.add(start);\n\nwhile (!queue.isEmpty()) {\n\nPos current = queue.poll();\n\nif (current.x == endX && current.y == endY) {\n\nreturn reconstructPath(predecessors, start, current);\n\n}\n\nfor (Pos neighbor : getAccessibleNeighbors(current)) {\n\nif (!visited.contains(neighbor)) {\n\nqueue.offer(neighbor);\n\nvisited.add(neighbor);\n\npredecessors.put(neighbor, current);\n\n}\n\n}\n\n}\n\nreturn null;\n\n}\n\nList<Pos> reconstructPath(Map<Pos, Pos> predecessors, Pos start, Pos current) {\n\nList<Pos> path = new ArrayList<>();\n\nwhile (current != start) {\n\npath.add(current);\n\ncurrent = predecessors.get(current);\n\n}\n\npath.add(start);\n\nCollections.reverse(path);\n\nreturn path;\n\n}\n\nList<Pos> getAccessibleNeighbors(Pos pos) {\n\nList<Pos> neighbors = new ArrayList<>();\n\nint x = pos.x;\n\nint y = pos.y;\n\nif (y > 0 && !grid[y][x].northWall) {\n\nneighbors.add(new Pos(x, y - 1));\n\n}\n\nif (y < height - 1 && !grid[y][x].southWall) {\n\nneighbors.add(new Pos(x, y + 1));\n\n}\n\nif (x < width - 1 && !grid[y][x].eastWall) {\n\nneighbors.add(new Pos(x + 1, y));\n\n}\n\nif (x > 0 && !grid[y][x].westWall) {\n\nneighbors.add(new Pos(x - 1, y));\n\n}\n\nreturn neighbors;\n\n}\n\nvoid displayMaze() {\n\n// Print the top border\n\nfor (int x = 0; x < width; x++) {\n\nSystem.out.print(\"+---\");\n\n}\n\nSystem.out.println(\"+\");\n\n// Print each row\n\nfor (int y = 0; y < height; y++) {\n\n// Print north walls\n\nfor (int x = 0; x < width; x++) {\n\nSystem.out.print(\"| \");\n\nif (!grid[y][x].northWall) {\n\nSystem.out.print(\" \");\n\n} else {\n\nSystem.out.print(\" \");\n\n}\n\n}\n\nSystem.out.println(\"|\");\n\n// Print west walls and cell contents\n\nfor (int x = 0; x < width; x++) {\n\nif (!grid[y][x].westWall) {\n\nSystem.out.print(\" \");\n\n} else {\n\nSystem.out.print(\"|\");\n\n}\n\n// Print cell content (for now, just space)\n\nSystem.out.print(\" \");\n\n}\n\nSystem.out.println(\"|\");\n\n}\n\n// Print the bottom border\n\nfor (int x = 0; x < width; x++) {\n\nSystem.out.print(\"+---\");\n\n}\n\nSystem.out.println(\"+\");\n\n}\n\n}\n\n\u8fd9\u53ea\u662f\u4e00\u4e2a\u521d\u6b65\u7684\u5b9e\u73b0\uff0c\u53ef\u80fd\u9700\u8981\u8c03\u6574displayMaze\u65b9\u6cd5\u4ee5\u6b63\u786e\u663e\u793a\u5899\u58c1\u548c\u7ec6\u80de\u5185\u5bb9\u3002\n\n\u76ee\u524d\uff0cdisplayMaze\u65b9\u6cd5\u6253\u5370\u4e86\u4e00\u4e2a\u5e26\u6709\u8fb9\u6846\u7684\u7f51\u683c\uff0c\u4f46\u7ec6\u80de\u5185\u5bb9\u5c1a\u672a\u663e\u793a\u3002\n\n\u6211\u9700\u8981\u4fee\u6539displayMaze\u65b9\u6cd5\uff0c\u4ee5\u4fbf\u5728\u6bcf\u4e2a\u7ec6\u80de\u4e2d\u5fc3\u663e\u793a\u9002\u5f53\u7684\u5185\u5bb9\uff0c\u5982'S'\u3001'E'\u6216'x'\uff0c\u5177\u4f53\u53d6\u51b3\u4e8e\u7ec6\u80de\u7684\u7c7b\u578b\u3002\n\n\u6b64\u5916\uff0c\u6211\u9700\u8981\u786e\u4fdd\u5899\u58c1\u6839\u636e\u76f8\u90bb\u7ec6\u80de\u7684\u5899\u58c1\u72b6\u6001\u6b63\u786e\u663e\u793a\u3002\n\n\u8fd9\u53ef\u80fd\u9700\u8981\u66f4\u590d\u6742\u7684\u903b\u8f91\u6765\u786e\u5b9a\u54ea\u4e9b\u5899\u58c1\u5e94\u8be5\u663e\u793a\u3002\n\n\u73b0\u5728\uff0c\u6211\u5c06\u5c1d\u8bd5\u6539\u8fdbdisplayMaze\u65b9\u6cd5\u3002\n\n\u6539\u8fdb\u540e\u7684displayMaze\u65b9\u6cd5\uff1a\n\nvoid displayMaze() {\n\n// Print the top border\n\nfor (int x = 0; x < width; x++) {\n\nSystem.out.print(\"+---\");\n\n}\n\nSystem.out.println(\"+\");\n\n// Print each row\n\nfor (int y = 0; y < height; y++) {\n\n// Print north walls\n\nfor (int x = 0; x < width; x++) {\n\nSystem.out.print(\"|\");\n\nif (!grid[y][x].northWall) {\n\nSystem.out.print(\"   \");\n\n} else {\n\nSystem.out.print(\"###\");\n\n}\n\n}\n\nSystem.out.println(\"|\");\n\n// Print west walls and cell contents\n\nfor (int x = 0; x < width; x++) {\n\nif (!grid[y][x].westWall) {\n\nSystem.out.print(\" \");\n\n} else {\n\nSystem.out.print(\"|\");\n\n}\n\n// Print cell content (for now, just space)\n\nSystem.out.print(\"   \");\n\n}\n\nSystem.out.println(\"|\");\n\n}\n\n// Print the bottom border\n\nfor (int x = 0; x < width; x++) {\n\nSystem.out.print(\"+---\");\n\n}\n\nSystem.out.println(\"+\");\n\n}\n\n\u5728\u8fd9\u4e2a\u7248\u672c\u4e2d\uff0c\u6211\u786e\u4fdd\u4e86\u5899\u58c1\u6839\u636e\u7ec6\u80de\u7684\u5899\u58c1\u72b6\u6001\u6b63\u786e\u663e\u793a\u3002\n\n\u4f8b\u5982\uff0c\u5982\u679c\u5317\u5899\u5b58\u5728\uff0c\u5219\u6253\u5370\"###\"\uff0c\u5426\u5219\u6253\u5370\" \"\u3002\n\n\u7c7b\u4f3c\u5730\uff0c\u897f\u5899\u7684\u5b58\u5728\u51b3\u5b9a\u4e86\u662f\u5426\u6253\u5370\u7ad6\u76f4\u7684\u5899\u58c1\u3002\n\n\u8fd9\u5e94\u8be5\u4f1a\u4ea7\u751f\u4e00\u4e2a\u66f4\u51c6\u786e\u7684\u8ff7\u5bab\u8868\u793a\u3002\n\n\u63a5\u4e0b\u6765\uff0c\u6211\u9700\u8981\u5728Maze\u7c7b\u4e2d\u6dfb\u52a0\u65b9\u6cd5\u6765\u8bbe\u7f6e\u8d77\u59cb\u548c\u7ed3\u675f\u4f4d\u7f6e\uff0c\u5e76\u5728displayMaze\u65b9\u6cd5\u4e2d\u663e\u793a\u5b83\u4eec\u3002\n\n\u6211\u5c06\u6dfb\u52a0setStart\u548csetEnd\u65b9\u6cd5\uff0c\u8fd9\u4e9b\u65b9\u6cd5\u5c06\u8bb0\u5f55\u8d77\u59cb\u548c\u7ed3\u675f\u4f4d\u7f6e\uff0c\u5e76\u5728displayMaze\u65b9\u6cd5\u4e2d\u76f8\u5e94\u5730\u663e\u793a'S'\u548c'E'\u3002\n\n\u6b64\u5916\uff0c\u6211\u9700\u8981\u5728findPath\u65b9\u6cd5\u4e2d\u8003\u8651\u8d77\u59cb\u548c\u7ed3\u675f\u4f4d\u7f6e\uff0c\u5e76\u5728displayMaze\u65b9\u6cd5\u4e2d\u663e\u793a\u8def\u5f84\u3002\n\n\u73b0\u5728\uff0c\u6211\u5c06\u5b9e\u73b0\u8fd9\u4e9b\u529f\u80fd\u3002\n\n\u9996\u5148\uff0c\u5728Maze\u7c7b\u4e2d\u6dfb\u52a0start\u548cend\u5b57\u6bb5\uff1a\n\nclass Maze {\n\n// existing fields\n\nPos start;\n\nPos end;\n\n// existing methods\n\nvoid setStart(int x, int y) {\n\nstart = new Pos(x, y);\n\n}\n\nvoid setEnd(int x, int y) {\n\nend = new Pos(x, y);\n\n}\n\n\u7136\u540e\uff0c\u5728displayMaze\u65b9\u6cd5\u4e2d\uff0c\u6839\u636e\u7ec6\u80de\u7684\u4f4d\u7f6e\u663e\u793a'S'\u3001'E'\u6216'x'\u3002\n\n\u6211\u5c06\u6dfb\u52a0\u4e00\u4e2a\u65b9\u6cd5\u6765\u786e\u5b9a\u6bcf\u4e2a\u7ec6\u80de\u5e94\u8be5\u663e\u793a\u4ec0\u4e48\u5b57\u7b26\u3002\n\n\u4f8b\u5982\uff1a\n\nchar getCellContent(int x, int y) {\n\nif (start != null && x == start.x && y == start.y) {\n\nreturn 'S';\n\n} else if (end != null && x == end.x && y == end.y) {\n\nreturn 'E';\n\n} else {\n\nreturn ' ';\n\n}\n\n}\n\n\u7136\u540e\uff0c\u5728displayMaze\u65b9\u6cd5\u4e2d\uff0c\u6253\u5370\u7ec6\u80de\u5185\u5bb9\uff1a\n\nfor (int y = 0; y < height; y++) {\n\n// Print north walls\n\nfor (int x = 0; x < width; x++) {\n\nSystem.out.print(\"|\");\n\nif (!grid[y][x].northWall) {\n\nSystem.out.print(\"   \");\n\n} else {\n\nSystem.out.print(\"###\");\n\n}\n\n}\n\nSystem.out.println(\"|\");\n\n// Print west walls and cell contents\n\nfor (int x = 0; x < width; x++) {\n\nif (!grid[y][x].westWall) {\n\nSystem.out.print(\" \");\n\n} else {\n\nSystem.out.print(\"|\");\n\n}\n\n// Print cell content\n\nchar content = getCellContent(x, y);\n\nSystem.out.print(\" \" + content + \" \");\n\n}\n\nSystem.out.println(\"|\");\n\n}\n\n// Print the bottom border\n\nfor (int x = 0; x < width; x++) {\n\nSystem.out.print(\"+---\");\n\n}\n\nSystem.out.println(\"+\");\n\n}\n\n\u73b0\u5728\uff0c\u6211\u9700\u8981\u5728findPath\u65b9\u6cd5\u4e2d\u627e\u5230\u4ece\u8d77\u59cb\u4f4d\u7f6e\u5230\u7ed3\u675f\u4f4d\u7f6e\u7684\u6700\u77ed\u8def\u5f84\uff0c\u5e76\u5728displayMaze\u65b9\u6cd5\u4e2d\u663e\u793a\u8be5\u8def\u5f84\u3002\n\n\u4e3a\u4e86\u5b9e\u73b0\u8fd9\u4e00\u70b9\uff0c\u6211\u9700\u8981\u5728Maze\u7c7b\u4e2d\u6dfb\u52a0\u4e00\u4e2a\u65b9\u6cd5\u6765\u6807\u8bb0\u8def\u5f84\u3002\n\n\u4f8b\u5982\uff1a\n\nvoid markPath(List<Pos> path) {\n\nfor (Pos pos : path) {\n\ngrid[pos.y][pos.x].cellType = CellType.PATH_PART;\n\n}\n\n}\n\n\u4f46\u662f\uff0c\u6211\u8fd8\u6ca1\u6709\u5b9a\u4e49cellType\u3002\u4e3a\u4e86\u7b80\u5316\uff0c\u6211\u53ef\u4ee5\u7ee7\u7eed\u4f7f\u7528char\u6765\u8868\u793a\u7ec6\u80de\u7c7b\u578b\u3002\n\n\u6216\u8005\uff0c\u6211\u53ef\u4ee5\u5b9a\u4e49\u4e00\u4e2aenum CellType\uff0c\u5982\u4e4b\u524d\u8ba1\u5212\u7684\u3002\n\n\u8ba9\u6211\u5b9a\u4e49\u4e00\u4e2aenum CellType\uff1a\n\nenum CellType {\n\nWALL,\n\nPATH,\n\nSTART,\n\nEND,\n\nPATH_PART\n\n}\n\n\u7136\u540e\uff0c\u4fee\u6539Cell\u7c7b\u4ee5\u5305\u542bcellType\uff1a\n\nclass Cell {\n\nboolean northWall;\n\nboolean southWall;\n\nboolean eastWall;\n\nboolean westWall;\n\nCellType cellType;\n\nCell() {\n\nnorthWall = true;\n\nsouthWall = true;\n\neastWall = true;\n\nwestWall = true;\n\ncellType = CellType.WALL;\n\n}\n\n}\n\n\u5728Maze\u7c7b\u4e2d\uff0c\u521d\u59cb\u5316grid\u65f6\u8bbe\u7f6ecellType\u4e3aWALL\u3002\n\n\u5728generateMaze\u65b9\u6cd5\u4e2d\uff0c\u8bbe\u7f6e\u8d77\u59cb\u7ec6\u80de\u4e3aSTART\uff0c\u5176\u4ed6\u7ec6\u80de\u5728\u8bbf\u95ee\u65f6\u8bbe\u7f6e\u4e3aPATH\u3002\n\n\u5728setStart\u548csetEnd\u65b9\u6cd5\u4e2d\uff0c\u8bbe\u7f6e\u76f8\u5e94\u7684cellType\u4e3aSTART\u548cEND\u3002\n\n\u5728findPath\u65b9\u6cd5\u4e2d\uff0c\u8bbe\u7f6e\u8def\u5f84\u7ec6\u80de\u4e3aPATH_PART\u3002\n\n\u5728displayMaze\u65b9\u6cd5\u4e2d\uff0c\u6839\u636ecellType\u663e\u793a\u76f8\u5e94\u7684\u5b57\u7b26\u3002\n\n\u73b0\u5728\uff0c\u6211\u5c06\u66f4\u65b0Maze\u7c7b\u4ee5\u5305\u542b\u8fd9\u4e9b\u66f4\u6539\u3002\n\n\u66f4\u65b0\u540e\u7684Maze\u7c7b\uff1a\n\nclass Maze {\n\nenum CellType {\n\nWALL,\n\nPATH,\n\nSTART,\n\nEND,\n\nPATH_PART\n\n}\n\nclass Cell {\n\nboolean northWall;\n\nboolean southWall;\n\nboolean eastWall;\n\nboolean westWall;\n\nCellType cellType;\n\nCell() {\n\nnorthWall = true;\n\nsouthWall = true;\n\neastWall = true;\n\nwestWall = true;\n\ncellType = CellType.WALL;\n\n}\n\n}\n\nclass Pos {\n\nint x, y;\n\nPos(int x, int y) {\n\nthis.x = x;\n\nthis.y = y;\n\n}\n\n}\n\nprivate Cell[][] grid;\n\nprivate int width, height;\n\nprivate Pos start;\n\nprivate Pos end;\n\npublic Maze(int width, int height) {\n\nthis.width = width;\n\nthis.height = height;\n\nthis.grid = new Cell[height][width];\n\nfor (int y = 0; y < height; y++) {\n\nfor (int x = 0; x < width; x++) {\n\ngrid[y][x] = new Cell();\n\n}\n\n}\n\n}\n\npublic void generateMaze(int startX, int startY) {\n\nSet<Pos> visited = new HashSet<>();\n\nList<Pos> boundary = new ArrayList<>();\n\nPos start = new Pos(startX, startY);\n\ngrid[start.y][start.x].cellType = CellType.START;\n\nvisited.add(start);\n\nboundary.addAll(getBoundaryNeighbors(start));\n\nwhile (!boundary.isEmpty()) {\n\nPos current = boundary.remove(randomIndex(boundary));\n\nList<Pos> unvisitedNeighbors = getUnvisitedNeighbors(current, visited);\n\nif (!unvisitedNeighbors.isEmpty()) {\n\nPos neighbor = unvisitedNeighbors.get(randomIndex(unvisitedNeighbors));\n\nremoveWall(current, neighbor);\n\ngrid[neighbor.y][neighbor.x].cellType = CellType.PATH;\n\nvisited.add(neighbor);\n\nboundary.addAll(getBoundaryNeighbors(neighbor));\n\n}\n\n}\n\n}\n\n}\n\nprivate List<Pos> getBoundaryNeighbors(Pos pos) {\n\nList<Pos> neighbors = new ArrayList<>();\n\nint x = pos.x;\n\nint y = pos.y;\n\nif (y > 0 && grid[y][x].northWall) {\n\nneighbors.add(new Pos(x, y - 1));\n\n}\n\nif (y < height - 1 && grid[y][x].southWall) {\n\nneighbors.add(new Pos(x, y + 1));\n\n}\n\nif (x < width - 1 && grid[y][x].eastWall) {\n\nneighbors.add(new Pos(x + 1, y));\n\n}\n\nif (x > 0 && grid[y][x].westWall) {\n\nneighbors.add(new Pos(x - 1, y));\n\n}\n\nreturn neighbors;\n\n}\n\nprivate List<Pos> getUnvisitedNeighbors(Pos pos, Set<Pos> visited) {\n\nList<Pos> unvisited = new ArrayList<>();\n\nint x = pos.x;\n\nint y = pos.y;\n\nif (y > 0 && !visited.contains(new Pos(x, y - 1))) {\n\nunvisited.add(new Pos(x, y - 1));\n\n}\n\nif (y < height - 1 && !visited.contains(new Pos(x, y + 1))) {\n\nunvisited.add(new Pos(x, y + 1));\n\n}\n\nif (x < width - 1 && !visited.contains(new Pos(x + 1, y))) {\n\nunvisited.add(new Pos(x + 1, y));\n\n}\n\nif (x > 0 && !visited.contains(new Pos(x - 1, y))) {\n\nunvisited.add(new Pos(x - 1, y));\n\n}\n\nreturn unvisited;\n\n}\n\nprivate void removeWall(Pos cell1, Pos cell2) {\n\nint x1 = cell1.x;\n\nint y1 = cell1.y;\n\nint x2 = cell2.x;\n\nint y2 = cell2.y;\n\nif (x2 == x1 + 1 && y2 == y1) {\n\ngrid[y1][x1].eastWall = false;\n\ngrid[y2][x2].westWall = false;\n\n} else if (x2 == x1 - 1 && y2 == y1) {\n\ngrid[y1][x1].westWall = false;\n\ngrid[y2][x2].eastWall = false;\n\n} else if (x2 == x1 && y2 == y1 + 1) {\n\ngrid[y1][x1].southWall = false;\n\ngrid[y2][x2].northWall = false;\n\n} else if (x2 == x1 && y2 == y1 - 1) {\n\ngrid[y1][x1].northWall = false;\n\ngrid[y2][x2].southWall = false;\n\n}\n\n}\n\npublic List<Pos> findPath(int startX, int startY, int endX, int endY) {\n\nQueue<Pos> queue = new LinkedList<>();\n\nMap<Pos, Pos> predecessors = new HashMap<>();\n\nSet<Pos> visited = new HashSet<>();\n\nPos start = new Pos(startX, startY);\n\nqueue.offer(start);\n\nvisited.add(start);\n\nwhile (!queue.isEmpty()) {\n\nPos current = queue.poll();\n\nif (current.x == endX && current.y == endY) {\n\nreturn reconstructPath(predecessors, start, current);\n\n}\n\nfor (Pos neighbor : getAccessibleNeighbors(current)) {\n\nif (!visited.contains(neighbor)) {\n\nqueue.offer(neighbor);\n\nvisited.add(neighbor);\n\npredecessors.put(neighbor, current);\n\n}\n\n}\n\n}\n\nreturn null;\n\n}\n\nprivate List<Pos> reconstructPath(Map<Pos, Pos> predecessors, Pos start, Pos current) {\n\nList<Pos> path = new ArrayList<>();\n\nwhile (current != start) {\n\npath.add(current);\n\ncurrent = predecessors.get(current);\n\n}\n\npath.add(start);\n\nCollections.reverse(path);\n\nreturn path;\n\n}\n\nprivate List<Pos> getAccessibleNeighbors(Pos pos) {\n\nList<Pos> neighbors = new ArrayList<>();\n\nint x = pos.x;\n\nint y = pos.y;\n\nif (y > 0 && !grid[y][x].northWall) {\n\nneighbors.add(new Pos(x, y - 1));\n\n}\n\nif (y < height - 1 && !grid[y][x].southWall) {\n\nneighbors.add(new Pos(x, y + 1));\n\n}\n\nif (x < width - 1 && !grid[y][x].eastWall) {\n\nneighbors.add(new Pos(x + 1, y));\n\n}\n\nif (x > 0 && !grid[y][x].westWall) {\n\nneighbors.add(new Pos(x - 1, y));\n\n}\n\nreturn neighbors;\n\n}\n\npublic void setStart(int x, int y) {\n\nstart = new Pos(x, y);\n\ngrid[y][x].cellType = CellType.START;\n\n}\n\npublic void setEnd(int x, int y) {\n\nend = new Pos(x, y);\n\ngrid[y][x].cellType = CellType.END;\n\n}\n\npublic void markPath(List<Pos> path) {\n\nfor (Pos pos : path) {\n\nif (grid[pos.y][pos.x].cellType == CellType.PATH) {\n\ngrid[pos.y][pos.x].cellType = CellType.PATH_PART;\n\n}\n\n}\n\n}\n\npublic void displayMaze() {\n\nfor (int y = 0; y < height; y++) {\n\n// Print north walls\n\nfor (int x = 0; x < width; x++) {\n\nSystem.out.print(\"+\");\n\nif (!grid[y][x].northWall) {\n\nSystem.out.print(\"   \");\n\n} else {\n\nSystem.out.print(\"---\");\n\n}\n\n}\n\nSystem.out.println(\"+\");\n\n// Print west walls and cell contents\n\nfor (int x = 0; x < width; x++) {\n\nif (!grid[y][x].westWall) {\n\nSystem.out.print(\" \");\n\n} else {\n\nSystem.out.print(\"|\");\n\n}\n\n// Print cell content\n\nchar content = getCellContent(x, y);\n\nSystem.out.print(\" \" + content + \" \");\n\n}\n\nSystem.out.println(\"|\");\n\n}\n\n// Print the bottom border\n\nfor (int x = 0; x < width; x++) {\n\nSystem.out.print(\"+---\");\n\n}\n\nSystem.out.println(\"+\");\n\n}\n\nprivate char getCellContent(int x, int y) {\n\nCell cell = grid[y][x];\n\nswitch (cell.cellType) {\n\ncase START:\n\nreturn 'S';\n\ncase END:\n\nreturn 'E';\n\ncase PATH_PART:\n\nreturn 'x';\n\ndefault:\n\nreturn ' ';\n\n}\n\n}\n\nprivate int randomIndex(List<Pos> list) {\n\nreturn (int) (Math.random() * list.size());\n\n}\n\n}\n\n\u73b0\u5728\uff0cMaze\u7c7b\u5df2\u7ecf\u76f8\u5f53\u5b8c\u5584\uff0c\u53ef\u4ee5\u751f\u6210\u8ff7\u5bab\u3001\u627e\u5230\u8def\u5f84\u5e76\u663e\u793a\u5b83\u4eec\u3002\n\n\u63a5\u4e0b\u6765\uff0c\u6211\u9700\u8981\u5728\u4e3b\u7c7b\u4e2d\u5b9e\u73b0\u547d\u4ee4\u884c\u53c2\u6570\u89e3\u6790\uff0c\u5e76\u4f7f\u7528Maze\u7c7b\u751f\u6210\u8ff7\u5bab\u5e76\u663e\u793a\u8def\u5f84\u3002\n\n\u4e3b\u7c7b\u4ee3\u7801\u5982\u4e0b\uff1a\n\npublic class MazeGenerator {\n\npublic static void main(String[] args) {\n\nif (args.length < 6) {\n\nSystem.out.println(\"Usage: java MazeGenerator width height startX startY endX endY\");\n\nreturn;\n\n}\n\nint width = Integer.parseInt(args[0]);\n\nint height = Integer.parseInt(args[1]);\n\nint startX = Integer.parseInt(args[2]);\n\nint startY = Integer.parseInt(args[3]);\n\nint endX = Integer.parseInt(args[4]);\n\nint endY = Integer.parseInt(args[5]);\n\nif (startX < 0 || startX >= width || startY < 0 || startY >= height) {\n\nSystem.out.println(\"Invalid start coordinates.\");\n\nreturn;\n\n}\n\nif (endX < 0 || endX >= width || endY < 0 || endY >= height) {\n\nSystem.out.println(\"Invalid end coordinates.\");\n\nreturn;\n\n}\n\nMaze maze = new Maze(width, height);\n\nmaze.setStart(startX, startY);\n\nmaze.setEnd(endX, endY);\n\nmaze.generateMaze(startX, startY);\n\nList<Pos> path = maze.findPath(startX, startY, endX, endY);\n\nif (path != null) {\n\nmaze.markPath(path);\n\nmaze.displayMaze();\n\n} else {\n\nSystem.out.println(\"No path found.\");\n\n}\n\n}\n\n}\n\n\u8fd9\u5e94\u8be5\u53ef\u4ee5\u5de5\u4f5c\uff0c\u4f46\u53ef\u80fd\u9700\u8981\u8fdb\u4e00\u6b65\u6d4b\u8bd5\u548c\u8c03\u8bd5\u3002\n\n\u73b0\u5728\uff0c\u6211\u9700\u8981\u7f16\u8bd1\u5e76\u8fd0\u884c\u8fd9\u4e2a\u7a0b\u5e8f\uff0c\u770b\u770b\u662f\u5426\u6309\u9884\u671f\u5de5\u4f5c\u3002\n\n\u5047\u8bbe\u6211\u8fd0\u884c\uff1a\n\njava MazeGenerator 10 10 0 0 9 9\n\n\u8fd9\u5c06\u751f\u6210\u4e00\u4e2a10x10\u7684\u8ff7\u5bab\uff0c\u8d77\u59cb\u4f4d\u7f6e\u5728(0,0)\uff0c\u7ed3\u675f\u4f4d\u7f6e\u5728(9,9)\u3002\n\n\u6211\u5e0c\u671b\u770b\u5230\u63a7\u5236\u53f0\u4e2d\u6253\u5370\u51fa\u8ff7\u5bab\u7684ASCII\u827a\u672f\u8868\u793a\uff0c\u5176\u4e2d\u5305\u542b'S'\u3001'E'\u548c'x'\u6807\u8bb0\u7684\u8def\u5f84\u3002\n\n\u5982\u679c\u4e00\u5207\u6b63\u5e38\uff0c\u8fd9\u5e94\u8be5\u662f\u4e00\u4e2a\u8fde\u63a5\u8d77\u59cb\u548c\u7ed3\u675f\u4f4d\u7f6e\u7684\u968f\u673a\u751f\u6210\u7684\u8ff7\u5bab\uff0c\u4ee5\u53ca\u4ece\u8d77\u59cb\u5230\u7ed3\u675f\u7684\u6700\u77ed\u8def\u5f84\u3002\n\n\u53ef\u80fd\u9700\u8981\u8c03\u6574displayMaze\u65b9\u6cd5\uff0c\u4ee5\u786e\u4fdd\u5899\u58c1\u548c\u7ec6\u80de\u5185\u5bb9\u6b63\u786e\u5bf9\u9f50\u3002\n\n\u6b64\u5916\uff0c\u6211\u9700\u8981\u786e\u4fdd\u5728\u79fb\u9664\u5899\u58c1\u65f6\uff0c\u76f8\u90bb\u7ec6\u80de\u7684\u5899\u58c1\u72b6\u6001\u4e00\u81f4\u3002\n\n\u4f8b\u5982\uff0c\u5f53\u79fb\u9664\u4e24\u4e2a\u76f8\u90bb\u7ec6\u80de\u4e4b\u95f4\u7684\u5899\u58c1\u65f6\uff0c\u4e24\u4e2a\u7ec6\u80de\u7684\u76f8\u5173\u5899\u58c1\u90fd\u5e94\u8be5\u8bbe\u7f6e\u4e3afalse\u3002\n\n\u6211\u5df2\u7ecf\u5728removeWall\u65b9\u6cd5\u4e2d\u5904\u7406\u4e86\u8fd9\u4e00\u70b9\u3002\n\n\u6700\u540e\uff0c\u6211\u9700\u8981\u786e\u4fdd\u7a0b\u5e8f\u80fd\u591f\u5904\u7406\u8f83\u5c0f\u7684\u8ff7\u5bab\uff0c\u4f8b\u59822x2\u62161x1\uff0c\u5c3d\u7ba1\u8fd9\u4e9b\u60c5\u51b5\u53ef\u80fd\u4e0d\u592a\u6709\u8da3\u3002\n\n\u603b\u4e4b\uff0c\u8fd9\u4e2a\u5b9e\u73b0\u5e94\u8be5\u6ee1\u8db3\u4efb\u52a1\u7684\u8981\u6c42\u3002\n\n**\u6700\u7ec8\u7b54\u6848**\n\n\u8981\u751f\u6210\u968f\u673a\u8ff7\u5bab\u5e76\u627e\u5230\u4e24\u70b9\u4e4b\u95f4\u7684\u6700\u77ed\u8def\u5f84\uff0c\u53ef\u4ee5\u4f7f\u7528 Java \u7f16\u5199\u4e00\u4e2a\u63a7\u5236\u53f0\u5e94\u7528\u7a0b\u5e8f\u3002\u6b64\u5e94\u7528\u7a0b\u5e8f\u4f7f\u7528 Prim's \u7b97\u6cd5\u751f\u6210\u8ff7\u5bab\uff0c\u5e76\u4f7f\u7528 BFS\uff08\u5e7f\u5ea6\u4f18\u5148\u641c\u7d22\uff09\u7b97\u6cd5\u627e\u5230\u6700\u77ed\u8def\u5f84\u3002\u7528\u6237\u53ef\u4ee5\u901a\u8fc7\u547d\u4ee4\u884c\u53c2\u6570\u6307\u5b9a\u8ff7\u5bab\u7684\u5bbd\u5ea6\u3001\u9ad8\u5ea6\u4ee5\u53ca\u8d77\u70b9\u548c\u7ec8\u70b9\u7684\u5750\u6807\u3002\n\n### \u5b9e\u73b0\u601d\u8def\n\n1. **\u8ff7\u5bab\u751f\u6210**:\n   - \u4f7f\u7528 Prim's \u7b97\u6cd5\u751f\u6210\u8ff7\u5bab\u3002\u8be5\u7b97\u6cd5\u4ece\u4e00\u4e2a\u8d77\u59cb\u5355\u5143\u683c\u5f00\u59cb\uff0c\u9010\u6b65\u79fb\u9664\u5899\u58c1\u4ee5\u8fde\u63a5\u65b0\u7684\u5355\u5143\u683c\uff0c\u786e\u4fdd\u751f\u6210\u7684\u8ff7\u5bab\u662f\u4e00\u4e2a\u5b8c\u6574\u7684\u6811\u7ed3\u6784\uff0c\u6ca1\u6709\u5faa\u73af\u3002\n\n2. **\u8ff7\u5bab\u663e\u793a**:\n   - \u5c06\u8ff7\u5bab\u4ee5 ASCII \u827a\u672f\u7684\u5f62\u5f0f\u6253\u5370\u5230\u63a7\u5236\u53f0\uff0c\u4f7f\u7528\u5b57\u7b26\u5982 `#` \u8868\u793a\u5899\u58c1\uff0c\u7a7a\u683c\u8868\u793a\u8def\u5f84\uff0c\u5e76\u6807\u8bb0\u8d77\u70b9 `S` \u548c\u7ec8\u70b9 `E`\u3002\n\n3. **\u8def\u5f84\u67e5\u627e**:\n   - \u4f7f\u7528 BFS \u7b97\u6cd5\u4ece\u8d77\u70b9\u5230\u7ec8\u70b9\u5bfb\u627e\u6700\u77ed\u8def\u5f84\u3002\n   - BFS \u7b97\u6cd5\u901a\u8fc7\u63a2\u7d22\u6240\u6709\u53ef\u80fd\u7684\u8def\u5f84\uff0c\u4f18\u5148\u9009\u62e9\u6700\u77ed\u7684\u8def\u5f84\uff0c\u9002\u5408\u7528\u4e8e\u65e0\u6743\u91cd\u7684\u7f51\u683c\u56fe\u3002\n\n### \u89e3\u51b3\u65b9\u6848\u4ee3\u7801\n\n```java\nimport java.util.*;\n\nclass Maze {\n    enum CellType {\n        WALL, PATH, START, END, PATH_PART\n    }\n\n    class Cell {\n        boolean northWall;\n        boolean southWall;\n        boolean eastWall;\n        boolean westWall;\n        CellType cellType;\n\n        Cell() {\n            northWall = true;\n            southWall = true;\n            eastWall = true;\n            westWall = true;\n            cellType = CellType.WALL;\n        }\n    }\n\n    class Pos {\n        int x, y;\n\n        Pos(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (this == obj) return true;\n            if (obj == null || getClass() != obj.getClass()) return false;\n            Pos pos = (Pos) obj;\n            return x == pos.x && y == pos.y;\n        }\n\n        @Override\n        public int hashCode() {\n            return Objects.hash(x, y);\n        }\n    }\n\n    private Cell[][] grid;\n    private int width, height;\n    private Pos start;\n    private Pos end;\n\n    public Maze(int width, int height) {\n        this.width = width;\n        this.height = height;\n        this.grid = new Cell[height][width];\n        for (int y = 0; y < height; y++) {\n            for (int x = 0; x < width; x++) {\n                grid[y][x] = new Cell();\n            }\n        }\n    }\n\n    public void generateMaze(int startX, int startY) {\n        Set<Pos> visited = new HashSet<>();\n        List<Pos> boundary = new ArrayList<>();\n        start = new Pos(startX, startY);\n        grid[start.y][start.x].cellType = CellType.START;\n        visited.add(start);\n        boundary.addAll(getBoundaryNeighbors(start));\n        while (!boundary.isEmpty()) {\n            Pos current = boundary.remove(randomIndex(boundary));\n            List<Pos> unvisitedNeighbors = getUnvisitedNeighbors(current, visited);\n            if (!unvisitedNeighbors.isEmpty()) {\n                Pos neighbor = unvisitedNeighbors.get(randomIndex(unvisitedNeighbors));\n                removeWall(current, neighbor);\n                grid[neighbor.y][neighbor.x].cellType = CellType.PATH;\n                visited.add(neighbor);\n                boundary.addAll(getBoundaryNeighbors(neighbor));\n            }\n        }\n    }\n\n    private List<Pos> getBoundaryNeighbors(Pos pos) {\n        List<Pos> neighbors = new ArrayList<>();\n        int x = pos.x;\n        int y = pos.y;\n        if (y > 0 && grid[y][x].northWall) {\n            neighbors.add(new Pos(x, y - 1));\n        }\n        if (y < height - 1 && grid[y][x].southWall) {\n            neighbors.add(new Pos(x, y + 1));\n        }\n        if (x < width - 1 && grid[y][x].eastWall) {\n            neighbors.add(new Pos(x + 1, y));\n        }\n        if (x > 0 && grid[y][x].westWall) {\n            neighbors.add(new Pos(x - 1, y));\n        }\n        return neighbors;\n    }\n\n    private List<Pos> getUnvisitedNeighbors(Pos pos, Set<Pos> visited) {\n        List<Pos> unvisited = new ArrayList<>();\n        int x = pos.x;\n        int y = pos.y;\n        if (y > 0 && !visited.contains(new Pos(x, y - 1))) {\n            unvisited.add(new Pos(x, y - 1));\n        }\n        if (y < height - 1 && !visited.contains(new Pos(x, y + 1))) {\n            unvisited.add(new Pos(x, y + 1));\n        }\n        if (x < width - 1 && !visited.contains(new Pos(x + 1, y))) {\n            unvisited.add(new Pos(x + 1, y));\n        }\n        if (x > 0 && !visited.contains(new Pos(x - 1, y))) {\n            unvisited.add(new Pos(x - 1, y));\n        }\n        return unvisited;\n    }\n\n    private void removeWall(Pos cell1, Pos cell2) {\n        int x1 = cell1.x;\n        int y1 = cell1.y;\n        int x2 = cell2.x;\n        int y2 = cell2.y;\n        if (x2 == x1 + 1 && y2 == y1) {\n            grid[y1][x1].eastWall = false;\n            grid[y2][x2].westWall = false;\n        } else if (x2 == x1 - 1 && y2 == y1) {\n            grid[y1][x1].westWall = false;\n            grid[y2][x2].eastWall = false;\n        } else if (x2 == x1 && y2 == y1 + 1) {\n            grid[y1][x1].southWall = false;\n            grid[y2][x2].northWall = false;\n        } else if (x2 == x1 && y2 == y1 - 1) {\n            grid[y1][x1].northWall = false;\n            grid[y2][x2].southWall = false;\n        }\n    }\n\n    public List<Pos> findPath(int startX, int startY, int endX, int endY) {\n        Queue<Pos> queue = new LinkedList<>();\n        Map<Pos, Pos> predecessors = new HashMap<>();\n        Set<Pos> visited = new HashSet<>();\n        Pos start = new Pos(startX, startY);\n        queue.offer(start);\n        visited.add(start);\n        while (!queue.isEmpty()) {\n            Pos current = queue.poll();\n            if (current.x == endX && current.y == endY) {\n                return reconstructPath(predecessors, start, current);\n            }\n            for (Pos neighbor : getAccessibleNeighbors(current)) {\n                if (!visited.contains(neighbor)) {\n                    queue.offer(neighbor);\n                    visited.add(neighbor);\n                    predecessors.put(neighbor, current);\n                }\n            }\n        }\n        return null;\n    }\n\n    private List<Pos> reconstructPath(Map<Pos, Pos> predecessors, Pos start, Pos current) {\n        List<Pos> path = new ArrayList<>();\n        while (current != start) {\n            path.add(current);\n            current = predecessors.get(current);\n        }\n        path.add(start);\n        Collections.reverse(path);\n        return path;\n    }\n\n    private List<Pos> getAccessibleNeighbors(Pos pos) {\n        List<Pos> neighbors = new ArrayList<>();\n        int x = pos.x;\n        int y = pos.y;\n        if (y > 0 && !grid[y][x].northWall) {\n            neighbors.add(new Pos(x, y - 1));\n        }\n        if (y < height - 1 && !grid[y][x].southWall) {\n            neighbors.add(new Pos(x, y + 1));\n        }\n        if (x < width - 1 && !grid[y][x].eastWall) {\n            neighbors.add(new Pos(x + 1, y));\n        }\n        if (x > 0 && !grid[y][x].westWall) {\n            neighbors.add(new Pos(x - 1, y));\n        }\n        return neighbors;\n    }\n\n    public void setStart(int x, int y) {\n        start = new Pos(x, y);\n        grid[y][x].cellType = CellType.START;\n    }\n\n    public void setEnd(int x, int y) {\n        end = new Pos(x, y);\n        grid[y][x].cellType = CellType.END;\n    }\n\n    public void markPath(List<Pos> path) {\n        for (Pos pos : path) {\n            if (grid[pos.y][pos.x].cellType == CellType.PATH) {\n                grid[pos.y][pos.x].cellType = CellType.PATH_PART;\n            }\n        }\n    }\n\n    public void displayMaze() {\n        for (int y = 0; y < height; y++) {\n            // Print north walls\n            for (int x = 0; x < width; x++) {\n                System.out.print(\"+\");\n                if (!grid[y][x].northWall) {\n                    System.out.print(\"   \");\n                } else {\n                    System.out.print(\"---\");\n                }\n            }\n            System.out.println(\"+\");\n            // Print west walls and cell contents\n            for (int x = 0; x < width; x++) {\n                if (!grid[y][x].westWall) {\n                    System.out.print(\" \");\n                } else {\n                    System.out.print(\"|\");\n                }\n                // Print cell content\n                char content = getCellContent(x, y);\n                System.out.print(\" \" + content + \" \");\n            }\n            System.out.println(\"|\");\n        }\n        // Print the bottom border\n        for (int x = 0; x < width; x++) {\n            System.out.print(\"+---\");\n        }\n        System.out.println(\"+\");\n    }\n\n    private char getCellContent(int x, int y) {\n        Cell cell = grid[y][x];\n        switch (cell.cellType) {\n            case START:\n                return 'S';\n            case END:\n                return 'E';\n            case PATH_PART:\n                return 'x';\n            default:\n                return ' ';\n        }\n    }\n\n    private int randomIndex(List<Pos> list) {\n        return (int) (Math.random() * list.size());\n    }\n}\n\npublic class MazeGenerator {\n    public static void main(String[] args) {\n        if (args.length < 6) {\n            System.out.println(\"Usage: java MazeGenerator width height startX startY endX endY\");\n            return;\n        }\n\n        int width = Integer.parseInt(args[0]);\n        int height = Integer.parseInt(args[1]);\n        int startX = Integer.parseInt(args[2]);\n        int startY = Integer.parseInt(args[3]);\n        int endX = Integer.parseInt(args[4]);\n        int endY = Integer.parseInt(args[5]);\n\n        if (startX < 0 || startX >= width || startY < 0 || startY >= height) {\n            System.out.println(\"Invalid start coordinates.\");\n            return;\n        }\n        if (endX < 0 || endX >= width || endY < 0 || endY >= height) {\n            System.out.println(\"Invalid end coordinates.\");\n            return;\n        }\n\n        Maze maze = new Maze(width, height);\n        maze.setStart(startX, startY);\n        maze.setEnd(endX, endY);\n        maze.generateMaze(startX, startY);\n        List<Maze.Pos> path = maze.findPath(startX, startY, endX, endY);\n        if (path != null) {\n            maze.markPath(path);\n            maze.displayMaze();\n        } else {\n            System.out.println(\"No path found.\");\n        }\n    }\n}\n```\n\n### \u8bf4\u660e\n\n1. **\u8ff7\u5bab\u751f\u6210**:\n   - \u4f7f\u7528 Prim's \u7b97\u6cd5\u4ece\u8d77\u70b9\u5f00\u59cb\uff0c\u9010\u6b65\u79fb\u9664\u5899\u58c1\u4ee5\u8fde\u63a5\u65b0\u7684\u5355\u5143\u683c\uff0c\u786e\u4fdd\u6240\u6709\u5355\u5143\u683c\u90fd\u662f\u8fde\u901a\u7684\u3002\n\n2. **\u8def\u5f84\u67e5\u627e**:\n   - \u4f7f\u7528 BFS \u7b97\u6cd5\u4ece\u8d77\u70b9\u5230\u7ec8\u70b9\u5bfb\u627e\u6700\u77ed\u8def\u5f84\uff0c\u901a\u8fc7\u961f\u5217\u5b9e\u73b0\u5c42\u5e8f\u904d\u5386\uff0c\u786e\u4fdd\u9996\u5148\u627e\u5230\u6700\u77ed\u8def\u5f84\u3002\n\n3. **\u663e\u793a\u8ff7\u5bab**:\n   - \u4ee5 ASCII \u827a\u672f\u5f62\u5f0f\u6253\u5370\u8ff7\u5bab\uff0c\u4f7f\u7528\u4e0d\u540c\u5b57\u7b26\u8868\u793a\u5899\u58c1\u3001\u8def\u5f84\u3001\u8d77\u70b9\u3001\u7ec8\u70b9\u548c\u8def\u5f84\u90e8\u5206\uff0c\u786e\u4fdd\u53ef\u89c6\u5316\u6548\u679c\u6e05\u6670\u3002\n\n\u901a\u8fc7\u8fd9\u79cd\u65b9\u5f0f\uff0c\u7528\u6237\u53ef\u4ee5\u4ea4\u4e92\u5f0f\u5730\u751f\u6210\u548c\u63a2\u7d22\u4e0d\u540c\u5927\u5c0f\u548c\u8d77\u70b9\u7ec8\u70b9\u7684\u8ff7\u5bab\uff0c\u5e76\u53ef\u89c6\u5316\u6700\u77ed\u8def\u5f84\u3002"
    }
]