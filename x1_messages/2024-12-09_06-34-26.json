[
    {
        "role": "user",
        "content": "Build a multi-threaded file downloader in C++ that accepts a list of URLs as input, downloads files concurrently, and saves them to disk while displaying progress information.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Creating a multi-threaded file downloader in C++ that can handle multiple URLs, download files concurrently, save them to disk, and display progress information is a substantial project. It involves several components, including thread management, network requests, file I/O, and progress tracking. Below is a step-by-step guide to building such a downloader.\n\n### Prerequisites\n\n1. **C++ Compiler**: Ensure you have a modern C++ compiler that supports C++11 or later.\n2. **Networking Library**: For handling HTTP requests, you can use libraries like `libcurl` or `Boost.Asio`. This example will use `libcurl` due to its simplicity and widespread use.\n3. **Thread Support**: C++11 introduces `<thread>` and `<mutex>` for multithreading.\n\n### Steps to Build the Downloader\n\n#### 1. Setup the Project\n\nCreate a new directory for your project and set up your build system (e.g., CMake, Makefile).\n\n#### 2. Install libcurl\n\nEnsure `libcurl` is installed on your system. You can install it using your package manager:\n\n- **Ubuntu**: `sudo apt-get install libcurl4-openssl-dev`\n- **macOS**: `brew install curl`\n\n#### 3. Include Necessary Headers\n\nIn your C++ source file, include the required headers:\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <thread>\n#include <mutex>\n#include <string>\n#include <curl/curl.h>\n```\n\n#### 4. Define Global Variables and Mutexes\n\nDefine global variables to track progress and mutexes for thread safety.\n\n```cpp\nstd::mutex coutMutex;\nsize_t globalBytesReceived = 0;\nsize_t globalTotalBytes = 0;\n```\n\n#### 5. Initialize libcurl\n\nInitialize libcurl at the start of your program.\n\n```cpp\ncurl_global_init(CURL_GLOBAL_DEFAULT);\n```\n\n#### 6. Create a Function to Handle Writing Data\n\nDefine a function that libcurl will call to write received data to a file.\n\n```cpp\nstatic size_t WriteData(void* buffer, size_t size, size_t nmemb, void* userp) {\n    size_t written = fwrite(buffer, size, nmemb, (FILE*)userp);\n    std::lock_guard<std::mutex> lock(coutMutex);\n    globalBytesReceived += written;\n    return written;\n}\n```\n\n#### 7. Create a Function to Download a Single File\n\nDefine a function that each thread will execute to download a single file.\n\n```cpp\nvoid downloadFile(const std::string& url, const std::string& filename) {\n    CURL* curl;\n    FILE* fp;\n    CURLcode res;\n\n    curl = curl_easy_init();\n    if (curl) {\n        fp = fopen(filename.c_str(), \"wb\");\n        if (!fp) {\n            std::cerr << \"Failed to open file: \" << filename << std::endl;\n            curl_easy_cleanup(curl);\n            return;\n        }\n\n        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());\n        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteData);\n        curl_easy_setopt(curl, CURLOPT_WRITEDATA, fp);\n\n        res = curl_easy_perform(curl);\n        if (res != CURLE_OK) {\n            std::cerr << \"curl_easy_perform() failed: \" << curl_easy_strerror(res) << std::endl;\n        }\n\n        fclose(fp);\n        curl_easy_cleanup(curl);\n    }\n}\n```\n\n#### 8. Create a Function to Display Progress\n\nDefine a function to display download progress.\n\n```cpp\nvoid displayProgress() {\n    while (globalBytesReceived < globalTotalBytes) {\n        std::lock_guard<std::mutex> lock(coutMutex);\n        double progress = (globalBytesReceived / static_cast<double>(globalTotalBytes)) * 100.0;\n        std::cout << \"Download progress: \" << progress << \"%\" << std::endl;\n        std::this_thread::sleep_for(std::chrono::seconds(1));\n    }\n    std::cout << \"Download complete!\" << std::endl;\n}\n```\n\n#### 9. Main Function\n\nIn the main function, read the list of URLs, set up threads for downloading, and start the progress display.\n\n```cpp\nint main() {\n    // Example list of URLs and filenames\n    std::vector<std::pair<std::string, std::string>> downloads = {\n        {\"http://example.com/file1.zip\", \"file1.zip\"},\n        {\"http://example.com/file2.zip\", \"file2.zip\"}\n    };\n\n    // Calculate total bytes to download (for progress)\n    for (const auto& p : downloads) {\n        CURL* curl = curl_easy_init();\n        if (curl) {\n            curl_easy_setopt(curl, CURLOPT_URL, p.first.c_str());\n            curl_easy_setopt(curl, CURLOPT_NOBODY, 1L);\n            curl_easy_perform(curl);\n            curl_off_t size;\n            curl_easy_getinfo(curl, CURLINFO_CONTENT_LENGTH_DOWNLOAD_T, &size);\n            globalTotalBytes += size;\n            curl_easy_cleanup(curl);\n        }\n    }\n\n    // Start progress display thread\n    std::thread progressThread(displayProgress);\n\n    // Start download threads\n    std::vector<std::thread> threads;\n    for (const auto& p : downloads) {\n        threads.emplace_back(downloadFile, p.first, p.second);\n    }\n\n    // Wait for all downloads to complete\n    for (auto& th : threads) {\n        th.join();\n    }\n\n    // Join progress thread\n    progressThread.join();\n\n    curl_global_cleanup();\n    return 0;\n}\n```\n\n### Explanation\n\n1. **Initialization**: libcurl is initialized globally.\n2. **Download Function**: Each thread downloads a file using libcurl and writes it to a file.\n3. **Progress Tracking**: A separate thread displays the download progress based on global variables updated by the download threads.\n4. **Main Function**: Manages threads, calculates total download size, and coordinates the download and progress display processes.\n\nThis setup ensures that files are downloaded concurrently, and the progress is displayed in real-time. Adjustments can be made based on specific requirements, such as error handling, resume support, or more granular progress reporting."
    }
]