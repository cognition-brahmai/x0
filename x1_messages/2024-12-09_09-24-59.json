[
    {
        "role": "user",
        "content": "Develop a Python Flask application with two endpoints: one for uploading a text file and another for retrieving the word count of the uploaded file. Store the uploaded files on disk and use SQLite for storing metadata (file name, word count).\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Alright, I'm going to try to build this Flask app as per your request. So, I need two main endpoints: one for uploading a text file and another for retrieving the word count of that file. Also, I have to store the uploaded files on disk and use SQLite to keep metadata like the file name and word count.\n\nFirst things first, I need to set up a basic Flask application. I've used Flask before, so I should be okay here. I'll need to install Flask and probably Flask-SQLAlchemy for handling the SQLite database.\n\nLet me start by creating a new directory for this project and setting up a virtual environment.\n\n```bash\nmkdir flask_wordcount\ncd flask_wordcount\npython3 -m venv venv\nsource venv/bin/activate\npip install Flask Flask-SQLAlchemy\n```\n\nNow, I need to plan out the structure of my application. I should have a clear separation of concerns, so maybe I'll have a `models.py` for database models, `app.py` for the Flask app, and maybe a `utils.py` for helper functions.\n\nLet's think about the database first. I need to store metadata: file name and word count. Maybe I should also store the path where the file is saved on disk for easy retrieval.\n\nSo, in `models.py`, I'll define a SQLAlchemy model something like this:\n\n```python\nfrom flask_sqlalchemy import SQLAlchemy\n\ndb = SQLAlchemy()\n\nclass FileMetadata(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    filename = db.Column(db.String(255), nullable=False)\n    word_count = db.Column(db.Integer, nullable=False)\n    file_path = db.Column(db.String(255), nullable=False)\n```\n\nI need to make sure that the file path is unique to avoid overwriting files or confusion.\n\nNext, in `app.py`, I'll set up the Flask app and configure the database URI. I'll probably store the files in a dedicated directory, say `uploads/`.\n\n```python\nfrom flask import Flask, request, jsonify\nfrom models import db, FileMetadata\n\napp = Flask(__name__)\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///files_metadata.db'\ndb.init_app(app)\n\n@app.route('/upload', methods=['POST'])\ndef upload_file():\n    # Handle file upload and save to disk\n    # Calculate word count\n    # Save metadata to SQLite\n    pass\n\n@app.route('/wordcount/<string:filename>', methods=['GET'])\ndef get_word_count(filename):\n    # Retrieve word count from metadata based on filename\n    pass\n\nif __name__ == '__main__':\n    app.run(debug=True)\n```\n\nI need to implement the `/upload` endpoint. It should accept a POST request with a file attached. I need to make sure that only text files are accepted, maybe by checking the file extension or content type.\n\nIn the upload function, I'll do something like:\n\n- Check if a file is present in the request\n- Save the file to the `uploads/` directory with a unique name\n- Read the file content, calculate the word count\n- Store the filename, word count, and file path in the SQLite database\n\nFor retrieving the word count, the `/wordcount/<filename>` endpoint should:\n\n- Take the filename as a parameter\n- Query the database for the word count associated with that filename\n- Return the word count as a JSON response\n\nI should also handle cases where the file doesn't exist or there are errors in the process.\n\nLet me think about how to handle file uploads in Flask. Flask has request.files to handle uploaded files. I need to make sure that the file is a text file and handle any potential errors, like if the file is too large or if there's no file in the request.\n\nMaybe I should add some validation to ensure that only text files are uploaded. I can check the file extension or use the `mimetypes` module to check the content type.\n\nAlso, for storing files on disk, I need to generate a unique filename to avoid overwriting existing files. I can use UUIDs for that.\n\nLet me look up how to generate UUIDs in Python.\n\n```python\nimport uuid\n\nunique_filename = str(uuid.uuid4()) + '.txt'\n```\n\nThat should give me a unique filename each time.\n\nNow, for calculating the word count. I need to read the file, split the content into words, and count them. I need to consider that words can be separated by spaces, newlines, etc. Maybe use `split()` with whitespace as the delimiter.\n\nBut I should be careful with punctuation. For example, \"word.\" should be considered one word, not \"word\" and \".\" as separate words. So, maybe I need to strip punctuation.\n\nI can use the `string` module to get a list of punctuation characters and remove them from the content before splitting into words.\n\nHere's a rough idea:\n\n```python\nimport string\n\ndef count_words(file_path):\n    with open(file_path, 'r') as file:\n        content = file.read()\n        # Remove punctuation\n        content = content.translate(str.maketrans('', '', string.punctuation))\n        # Split into words and count\n        words = content.split()\n        return len(words)\n```\n\nI need to test this function to make sure it works as expected.\n\nNow, for the database part. I need to initialize the SQLite database and create the table for file metadata.\n\nI can do this by adding a command to create the tables:\n\n```python\nwith app.app_context():\n    db.create_all()\n```\n\nI should run this once after setting up the models.\n\nIn the upload endpoint, after saving the file and calculating the word count, I need to insert a new record into the database.\n\nSomething like:\n\n```python\nnew_metadata = FileMetadata(filename=filename, word_count=word_count, file_path=file_path)\ndb.session.add(new_metadata)\ndb.session.commit()\n```\n\nFor the word count retrieval endpoint, I need to query the database based on the filename and return the word count.\n\nBut I should consider that filenames might not be unique, especially if I'm generating unique filenames with UUIDs. Maybe it's better to use the unique filename stored in the database.\n\nAlternatively, I can use the original filename provided by the user, but then I need to handle cases where multiple files have the same name.\n\nMaybe it's better to use the unique filename for storage and provide the original filename as part of the metadata.\n\nWait, perhaps I should store both the original filename and the unique filename on disk.\n\nSo, in the database, I'll have:\n\n- original_filename: the name provided by the user\n- unique_filename: the actual name used on disk\n- word_count: the count of words in the file\n\nThis way, I can handle cases where users upload files with the same name but different content.\n\nSo, updating the model:\n\n```python\nclass FileMetadata(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    original_filename = db.Column(db.String(255), nullable=False)\n    unique_filename = db.Column(db.String(255), nullable=False, unique=True)\n    word_count = db.Column(db.Integer, nullable=False)\n    file_path = db.Column(db.String(255), nullable=False)\n```\n\nAnd when uploading, I'll store both the original and unique filenames.\n\nIn the word count endpoint, I can accept the original filename and query based on that.\n\nBut I need to handle cases where multiple files have the same original filename. Maybe I can store upload timestamps and allow users to specify a date range or something, but that might be overkill for this scenario.\n\nAlternatively, I can just inform the user that multiple files with the same name exist and they need to provide a unique identifier.\n\nThis might complicate things, so maybe it's better to just use the unique filename in the endpoint.\n\nBut that would expose the unique filename to the user, which might not be ideal.\n\nHmm.\n\nPerhaps I can store the original filename and the unique filename, and in the endpoint, accept the original filename and return the word count along with the unique filename if there are duplicates.\n\nWait, this could get messy.\n\nLet me think differently. Maybe I should just use the unique filename for storage and provide an endpoint that accepts the unique filename for retrieving the word count.\n\nBut that would require the user to keep track of the unique filename after upload.\n\nAlternatively, I can store the original filename and make sure that for a given user session, filenames are unique.\n\nBut managing user sessions might be too much for this simple app.\n\nMaybe I can just inform the user to use unique filenames and handle duplicates by overwriting the existing entry in the database.\n\nThat way, if a user uploads a new file with the same name, it replaces the old one in the database.\n\nThis seems acceptable for a simple application.\n\nSo, in the upload endpoint, before saving the new metadata, I can check if a file with the same filename already exists and update its record instead of creating a new one.\n\nThis way, the filename acts as a unique identifier, and the word count is updated upon re-upload.\n\nThis might be a reasonable approach.\n\nNow, let's think about the file path. Where should I store the uploaded files?\n\nI'll create an `uploads/` directory in the project root.\n\nI need to make sure that this directory exists before trying to save files there.\n\nI can use `os` module to check and create the directory if necessary.\n\n```python\nimport os\n\nUPLOAD_FOLDER = 'uploads'\nif not os.path.exists(UPLOAD_FOLDER):\n    os.makedirs(UPLOAD_FOLDER)\n```\n\nI should also configure Flask to use this upload folder.\n\nIn `app.py`:\n\n```python\napp.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER\n```\n\nNow, in the upload endpoint, when saving the file, I'll use this upload folder.\n\nSo, the steps in the upload endpoint are:\n\n1. Check if a file is present in the request.\n\n2. Validate that it's a text file.\n\n3. Generate a unique filename using UUID.\n\n4. Save the file to the uploads directory with the unique filename.\n\n5. Calculate the word count.\n\n6. Check if a file with the same original filename already exists in the database.\n\n- If it exists, update its word count and file path.\n\n- If not, create a new record.\n\n7. Commit the changes to the database.\n\n8. Return a success response with the unique filename or original filename.\n\nFor the word count endpoint:\n\n1. Accept the original filename as a parameter.\n\n2. Query the database for the file with that filename.\n\n3. If found, return the word count.\n\n4. If not found, return an error message.\n\nI need to handle cases where multiple files have the same original filename. If I follow the approach of updating existing records, then there should be only one record per original filename.\n\nWait, no. If I allow multiple uploads with the same filename, I'll have multiple records with the same original filename but different unique filenames.\n\nSo, in that case, querying by original filename would return multiple results.\n\nTo handle this, I could:\n\n- Return the word count of the latest upload with that filename.\n\n- Return all records with that filename and their respective word counts.\n\n- Require the user to specify which specific file they want by using the unique filename.\n\nThis could be confusing for the user. Maybe it's better to enforce unique filenames at the upload stage.\n\nI can check if a file with the same original filename already exists in the database, and if so, either overwrite it or return an error.\n\nEnforcing unique filenames would simplify things.\n\nSo, in the upload endpoint:\n\n- Check if a file with the same original filename already exists.\n\n- If it exists, return an error saying that the filename is already in use.\n\n- If not, proceed to save the file and store the metadata.\n\nThis way, each original filename is unique, and retrieving the word count is straightforward.\n\nAlternatively, I can allow overwriting: if a user uploads a new file with the same filename, it replaces the old one in the database.\n\nThis seems acceptable.\n\nSo, in code, in the upload endpoint:\n\n```python\nexisting_file = FileMetadata.query.filter_by(original_filename=original_filename).first()\nif existing_file:\n    existing_file.word_count = word_count\n    existing_file.file_path = file_path\n    existing_file.unique_filename = unique_filename\n    db.session.commit()\nelse:\n    new_metadata = FileMetadata(original_filename=original_filename, unique_filename=unique_filename, word_count=word_count, file_path=file_path)\n    db.session.add(new_metadata)\n    db.session.commit()\n```\n\nThis way, the database always has the latest upload for each original filename.\n\nNow, for the word count endpoint:\n\n```python\n@app.route('/wordcount/<string:filename>', methods=['GET'])\ndef get_word_count(filename):\n    file = FileMetadata.query.filter_by(original_filename=filename).first()\n    if file:\n        return jsonify({'filename': file.original_filename, 'word_count': file.word_count})\n    else:\n        return jsonify({'error': 'File not found'}), 404\n```\n\nI need to make sure that the filename parameter is properly sanitized to prevent SQL injection or other attacks.\n\nFlask-SQLAlchemy should handle that, but I should still be cautious.\n\nNow, let's think about the front end. Since this is a simple API, I don't need a complex front end. Maybe just some basic HTML for testing the upload functionality.\n\nI can create a simple HTML form that posts a file to the `/upload` endpoint.\n\nSomething like:\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n    <title>Upload File</title>\n</head>\n<body>\n    <h1>Upload a Text File</h1>\n    <form action=\"/upload\" method=\"post\" enctype=\"multipart/form-data\">\n        <input type=\"file\" name=\"file\" accept=\".txt\">\n        <input type=\"submit\" value=\"Upload\">\n    </form>\n</body>\n</html>\n```\n\nI'll save this as `upload.html` and serve it from the Flask app.\n\nIn `app.py`, I can add a route for the upload form:\n\n```python\n@app.route('/upload_form')\ndef upload_form():\n    return app.send_static_file('upload.html')\n```\n\nI need to make sure that the `upload.html` is placed in the `static` folder.\n\nWait, Flask serves static files from the `static` folder by default, so I can place `upload.html` there.\n\nAlternatively, I can render the template using Jinja2, but for simplicity, serving it as a static file should suffice.\n\nNow, let's think about error handling. There are several places where things can go wrong:\n\n- No file part in the request\n\n- File not found in the request\n\n- Invalid file type (not a text file)\n\n- Errors in saving the file to disk\n\n- Errors in calculating the word count\n\n- Database errors when inserting or updating records\n\nI need to handle these gracefully and return meaningful error messages to the user.\n\nFor example, in the upload endpoint:\n\n```python\n@app.route('/upload', methods=['POST'])\ndef upload_file():\n    if 'file' not in request.files:\n        return jsonify({'error': 'No file part in the request'}), 400\n    file = request.files['file']\n    if file.filename == '':\n        return jsonify({'error': 'No selected file'}), 400\n    if file and allowed_file(file.filename):\n        original_filename = file.filename\n        unique_filename = str(uuid.uuid4()) + '.txt'\n        file_path = os.path.join(app.config['UPLOAD_FOLDER'], unique_filename)\n        file.save(file_path)\n        word_count = count_words(file_path)\n        existing_file = FileMetadata.query.filter_by(original_filename=original_filename).first()\n        if existing_file:\n            existing_file.word_count = word_count\n            existing_file.file_path = file_path\n            existing_file.unique_filename = unique_filename\n            db.session.commit()\n        else:\n            new_metadata = FileMetadata(original_filename=original_filename, unique_filename=unique_filename, word_count=word_count, file_path=file_path)\n            db.session.add(new_metadata)\n            db.session.commit()\n        return jsonify({'filename': original_filename, 'word_count': word_count}), 201\n    else:\n        return jsonify({'error': 'Invalid file type. Only text files are allowed.'}), 400\n```\n\nI need to define the `allowed_file` function to check if the file is a text file.\n\nMaybe by checking the file extension:\n\n```python\ndef allowed_file(filename):\n    return '.' in filename and filename.rsplit('.', 1)[1].lower() in {'txt'}\n```\n\nThis is straightforward, but it's not foolproof, as users can upload non-text files with a `.txt` extension.\n\nTo be safer, I could try to read the file and check if it contains text, but that might be overkill for this application.\n\nNow, I need to make sure that the `uploads` directory exists before trying to save files there.\n\nI can add a check in `app.py`:\n\n```python\nimport os\n\nUPLOAD_FOLDER = 'uploads'\nif not os.path.exists(UPLOAD_FOLDER):\n    os.makedirs(UPLOAD_FOLDER)\napp.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER\n```\n\nI should also consider setting a maximum file size for uploads to prevent users from uploading huge files.\n\nFlask has a `MAX_CONTENT_LENGTH` config option for this.\n\nFor example, to limit uploads to 1MB:\n\n```python\napp.config['MAX_CONTENT_LENGTH'] = 1 * 1024 * 1024\n```\n\nI can adjust this value based on requirements.\n\nNow, let's think about testing the application.\n\nI can use tools like Postman or curl to test the endpoints.\n\nFor the upload endpoint, I'll need to send a POST request with a file attached.\n\nUsing curl, it would look something like:\n\n```bash\ncurl -X POST -H \"Content-Type: multipart/form-data\" -F \"file=@path/to/your/file.txt\" http://127.0.0.1:5000/upload\n```\n\nAnd for retrieving the word count:\n\n```bash\ncurl http://127.0.0.1:5000/wordcount/filename.txt\n```\n\nI need to make sure that the filenames are handled correctly and that the word counts are accurate.\n\nI should also consider edge cases, such as empty files, files with only whitespace, files with non-text content, etc.\n\nFor example, an empty file should have a word count of 0.\n\nA file with only whitespace should also have a word count of 0.\n\nFiles with multiple spaces between words should count each word correctly.\n\nI need to make sure that the word counting function handles these cases properly.\n\nLet me test the `count_words` function with some sample inputs.\n\nTest case 1:\n\n- Content: \"\"\n\n- Expected word count: 0\n\nTest case 2:\n\n- Content: \"   \"\n\n- Expected word count: 0\n\nTest case 3:\n\n- Content: \"Hello world\"\n\n- Expected word count: 2\n\nTest case 4:\n\n- Content: \"Hello, world!\"\n\n- Expected word count: 2\n\nTest case 5:\n\n- Content: \"Multiple    spaces\"\n\n- Expected word count: 2\n\nI need to make sure that the function handles punctuation correctly, i.e., it doesn't count punctuation as separate words.\n\nIn the `count_words` function, I'm removing punctuation before splitting into words, which should handle this.\n\nLet me verify:\n\n```python\nimport string\n\ndef count_words(file_path):\n    with open(file_path, 'r') as file:\n        content = file.read()\n        content = content.translate(str.maketrans('', '', string.punctuation))\n        words = content.split()\n        return len(words)\n\n# Test case 1\nprint(count_words(\"test1.txt\"))  # Assuming test1.txt contains \"\"\n# Expected: 0\n\n# Test case 2\nprint(count_words(\"test2.txt\"))  # Assuming test2.txt contains \"   \"\n# Expected: 0\n\n# Test case 3\nprint(count_words(\"test3.txt\"))  # Assuming test3.txt contains \"Hello world\"\n# Expected: 2\n\n# Test case 4\nprint(count_words(\"test4.txt\"))  # Assuming test4.txt contains \"Hello, world!\"\n# Expected: 2\n\n# Test case 5\nprint(count_words(\"test5.txt\"))  # Assuming test5.txt contains \"Multiple    spaces\"\n# Expected: 2\n```\n\nI need to create these test files and run the function to verify.\n\nAssuming the function works as expected, I can proceed.\n\nNow, I need to think about cleaning up old files and managing disk space, but that might be beyond the scope of this simple application.\n\nFor now, I'll focus on getting the basic functionality working.\n\nI should also consider logging for debugging and monitoring the application's behavior.\n\nFlask has built-in logging that I can configure.\n\nIn `app.py`, I can add:\n\n```python\nimport logging\n\nlogging.basicConfig(level=logging.INFO)\n```\n\nThis will log INFO and higher level messages to the console.\n\nI can add logging statements in\u5173\u952e parts of the code to track the flow and values of variables.\n\nFor example, in the upload endpoint:\n\n```python\nlogging.info(f\"Received file: {file.filename}\")\n```\n\nThis will help in debugging if something goes wrong.\n\nNow, let's think about deploying this application.\n\nSince it's a Flask app, I can run it locally using `app.run()`, but for production, I should use a proper WSGI server like Gunicorn or uWSGI.\n\nAlso, I need to consider where to store the `uploads` directory, especially if I'm deploying on a server.\n\nI should make sure that the web server has write permissions to the `uploads` directory.\n\nAdditionally, I need to think about backing up the SQLite database and the uploaded files, especially if the server is restarted or the disk is cleared.\n\nBut for now, I'll focus on getting the local development environment working correctly.\n\nI should also consider adding comments to the code for clarity and maintainability.\n\nDocumentation is important, especially if others need to understand or modify the code in the future.\n\nI can add docstrings to functions and comment on significant parts of the code.\n\nFinally, I need to make sure that all the pieces fit together correctly.\n\nLet me list out the files I need:\n\n- `app.py`: the main Flask application\n\n- `models.py`: database models\n\n- `uploads/`: directory for uploaded files\n\n- `static/upload.html`: HTML form for uploading files\n\nI need to organize these files appropriately in the project directory.\n\nHere's a proposed directory structure:\n\n```\n\nflask_wordcount/\n\n\u251c\u2500\u2500 app.py\n\n\u251c\u2500\u2500 models.py\n\n\u251c\u2500\u2500 uploads/\n\n\u251c\u2500\u2500 static/\n\n\u2502 \u2514\u2500\u2500 upload.html\n\n\u2514\u2500\u2500 venv/\n\n```\n\nI need to create these directories and files accordingly.\n\nLet me summarize the steps I need to take:\n\n1. Set up virtual environment and install required packages.\n\n2. Create `models.py` with SQLAlchemy model for file metadata.\n\n3. Create `app.py` with Flask app, upload and word count endpoints.\n\n4. Create `uploads/` directory for storing uploaded files.\n\n5. Create `static/upload.html` for the upload form.\n\n6. Run the Flask app and test the endpoints.\n\nI should also consider adding a `run.py` script to run the app, but for simplicity, I'll keep it in `app.py`.\n\nNow, I'll proceed to implement each part step by step.\n\nFirst, `models.py`:\n\n```python\n\nfrom flask_sqlalchemy import SQLAlchemy\n\ndb = SQLAlchemy()\n\nclass FileMetadata(db.Model):\n\n    id = db.Column(db.Integer, primary_key=True)\n\n    original_filename = db.Column(db.String(255), nullable=False)\n\n    unique_filename = db.Column(db.String(255), nullable=False, unique=True)\n\n    word_count = db.Column(db.Integer, nullable=False)\n\n    file_path = db.Column(db.String(255), nullable=False)\n\n```\n\nNext, `app.py`:\n\n```python\n\nimport os\n\nimport uuid\n\nfrom flask import Flask, request, jsonify\n\nfrom flask_sqlalchemy import SQLAlchemy\n\nfrom models import db, FileMetadata\n\nimport string\n\nimport logging\n\nlogging.basicConfig(level=logging.INFO)\n\napp = Flask(__name__)\n\nUPLOAD_FOLDER = 'uploads'\n\nif not os.path.exists(UPLOAD_FOLDER):\n\n    os.makedirs(UPLOAD_FOLDER)\n\napp.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER\n\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///files_metadata.db'\n\ndb.init_app(app)\n\ndef count_words(file_path):\n\n    with open(file_path, 'r') as file:\n\n        content = file.read()\n\n        content = content.translate(str.maketrans('', '', string.punctuation))\n\n        words = content.split()\n\n        return len(words)\n\n@app.route('/upload', methods=['POST'])\n\ndef upload_file():\n\n    if 'file' not in request.files:\n\n        return jsonify({'error': 'No file part in the request'}), 400\n\n    file = request.files['file']\n\n    if file.filename == '':\n\n        return jsonify({'error': 'No selected file'}), 400\n\n    if file and allowed_file(file.filename):\n\n        original_filename = file.filename\n\n        unique_filename = str(uuid.uuid4()) + '.txt'\n\n        file_path = os.path.join(app.config['UPLOAD_FOLDER'], unique_filename)\n\n        file.save(file_path)\n\n        word_count = count_words(file_path)\n\n        existing_file = FileMetadata.query.filter_by(original_filename=original_filename).first()\n\n        if existing_file:\n\n            existing_file.word_count = word_count\n\n            existing_file.file_path = file_path\n\n            existing_file.unique_filename = unique_filename\n\n            db.session.commit()\n\n        else:\n\n            new_metadata = FileMetadata(original_filename=original_filename, unique_filename=unique_filename, word_count=word_count, file_path=file_path)\n\n            db.session.add(new_metadata)\n\n            db.session.commit()\n\n        return jsonify({'filename': original_filename, 'word_count': word_count}), 201\n\n    else:\n\n        return jsonify({'error': 'Invalid file type. Only text files are allowed.'}), 400\n\n@app.route('/wordcount/<string:filename>', methods=['GET'])\n\ndef get_word_count(filename):\n\n    file = FileMetadata.query.filter_by(original_filename=filename).first()\n\n    if file:\n\n        return jsonify({'filename': file.original_filename, 'word_count': file.word_count})\n\n    else:\n\n        return jsonify({'error': 'File not found'}), 404\n\nif __name__ == '__main__':\n\n    with app.app_context():\n\n        db.create_all()\n\n    app.run(debug=True)\n\n```\n\nI need to define the `allowed_file` function in `app.py`:\n\n```python\n\ndef allowed_file(filename):\n\n    return '.' in filename and filename.rsplit('.', 1)[1].lower() in {'txt'}\n\n```\n\nAlso, I need to create the `static` directory and place `upload.html` inside it.\n\nCreate `static/upload.html`:\n\n```html\n\n<!DOCTYPE html>\n\n<html>\n\n<head>\n\n    <title>Upload File</title>\n\n</head>\n\n<body>\n\n    <h1>Upload a Text File</h1>\n\n    <form action=\"/upload\" method=\"post\" enctype=\"multipart/form-data\">\n\n        <input type=\"file\" name=\"file\" accept=\".txt\">\n\n        <input type=\"submit\" value=\"Upload\">\n\n    </form>\n\n</body>\n\n</html>\n\n```\n\nNow, I need to make sure that the Flask app serves the static files correctly.\n\nBy default, Flask serves static files from the `static` folder, so no additional configuration is needed.\n\nFinally, I need to run the app.\n\nIn the terminal, activate the virtual environment and run `app.py`:\n\n```bash\n\nsource venv/bin/activate\n\npython app.py\n\n```\n\nThe app should start running on `http://127.0.0.1:5000/`.\n\nI can access `http://127.0.0.1:5000/upload_form` to see the upload form.\n\nI can test the upload endpoint by selecting a text file and uploading it.\n\nThen, I can retrieve the word count by visiting `http://127.0.0.1:5000/wordcount/filename.txt`, replacing `filename.txt` with the actual filename I uploaded.\n\nI need to make sure that the word count is accurate and that the files are being saved in the `uploads/` directory.\n\nAlso, I should check the SQLite database to ensure that the metadata is being stored correctly.\n\nI can use an SQLite browser tool or write a small script to query the database.\n\nOverall, this should cover the basic requirements of the task.\n\nI might need to make some adjustments based on testing and real-world usage, but this should serve as a solid foundation for the Flask application.\n\n**Final Solution**\n\nTo create a Python Flask application that handles uploading of text files and retrieving their word counts, follow these steps:\n\n### Step 1: Set Up the Project\n\n1. **Create a new directory for the project:**\n   ```bash\n   mkdir flask_wordcount\n   cd flask_wordcount\n   ```\n\n2. **Set up a virtual environment:**\n   ```bash\n   python3 -m venv venv\n   source venv/bin/activate\n   ```\n\n3. **Install required packages:**\n   ```bash\n   pip install Flask Flask-SQLAlchemy\n   ```\n\n### Step 2: Define the Database Model\n\nCreate a file named `models.py`:\n\n```python\nfrom flask_sqlalchemy import SQLAlchemy\n\ndb = SQLAlchemy()\n\nclass FileMetadata(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    original_filename = db.Column(db.String(255), nullable=False)\n    unique_filename = db.Column(db.String(255), nullable=False, unique=True)\n    word_count = db.Column(db.Integer, nullable=False)\n    file_path = db.Column(db.String(255), nullable=False)\n```\n\n### Step 3: Create the Flask Application\n\nCreate a file named `app.py`:\n\n```python\nimport os\nimport uuid\nfrom flask import Flask, request, jsonify\nfrom flask_sqlalchemy import SQLAlchemy\nfrom models import db, FileMetadata\nimport string\nimport logging\n\nlogging.basicConfig(level=logging.INFO)\n\napp = Flask(__name__)\n\nUPLOAD_FOLDER = 'uploads'\nif not os.path.exists(UPLOAD_FOLDER):\n    os.makedirs(UPLOAD_FOLDER)\napp.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///files_metadata.db'\n\ndb.init_app(app)\n\ndef count_words(file_path):\n    with open(file_path, 'r') as file:\n        content = file.read()\n        content = content.translate(str.maketrans('', '', string.punctuation))\n        words = content.split()\n        return len(words)\n\n@app.route('/upload', methods=['POST'])\ndef upload_file():\n    if 'file' not in request.files:\n        return jsonify({'error': 'No file part in the request'}), 400\n    file = request.files['file']\n    if file.filename == '':\n        return jsonify({'error': 'No selected file'}), 400\n    if file and allowed_file(file.filename):\n        original_filename = file.filename\n        unique_filename = str(uuid.uuid4()) + '.txt'\n        file_path = os.path.join(app.config['UPLOAD_FOLDER'], unique_filename)\n        file.save(file_path)\n        word_count = count_words(file_path)\n        existing_file = FileMetadata.query.filter_by(original_filename=original_filename).first()\n        if existing_file:\n            existing_file.word_count = word_count\n            existing_file.file_path = file_path\n            existing_file.unique_filename = unique_filename\n            db.session.commit()\n        else:\n            new_metadata = FileMetadata(original_filename=original_filename, unique_filename=unique_filename, word_count=word_count, file_path=file_path)\n            db.session.add(new_metadata)\n            db.session.commit()\n        return jsonify({'filename': original_filename, 'word_count': word_count}), 201\n    else:\n        return jsonify({'error': 'Invalid file type. Only text files are allowed.'}), 400\n\n@app.route('/wordcount/<string:filename>', methods=['GET'])\ndef get_word_count(filename):\n    file = FileMetadata.query.filter_by(original_filename=filename).first()\n    if file:\n        return jsonify({'filename': file.original_filename, 'word_count': file.word_count})\n    else:\n        return jsonify({'error': 'File not found'}), 404\n\ndef allowed_file(filename):\n    return '.' in filename and filename.rsplit('.', 1)[1].lower() in {'txt'}\n\nif __name__ == '__main__':\n    with app.app_context():\n        db.create_all()\n    app.run(debug=True)\n```\n\n### Step 4: Create the Upload Form\n\nCreate a directory named `static` and inside it, create a file named `upload.html`:\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n    <title>Upload File</title>\n</head>\n<body>\n    <h1>Upload a Text File</h1>\n    <form action=\"/upload\" method=\"post\" enctype=\"multipart/form-data\">\n        <input type=\"file\" name=\"file\" accept=\".txt\">\n        <input type=\"submit\" value=\"Upload\">\n    </form>\n</body>\n</html>\n```\n\n### Step 5: Run the Application\n\nIn your terminal, activate the virtual environment and run the app:\n\n```bash\nsource venv/bin/activate\npython app.py\n```\n\nNow, you can access the upload form at `http://127.0.0.1:5000/upload_form`, upload a text file, and retrieve its word count using the specified endpoints."
    }
]