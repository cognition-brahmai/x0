[
    {
        "role": "user",
        "content": "Implement a C++ program that simulates the behavior of a simple LRU (Least Recently Used) cache with a fixed size. The cache should support insertion, deletion, and retrieval operations.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Implementing a Least Recently Used (LRU) cache in C++ involves creating a data structure that can efficiently handle insertion, deletion, and retrieval operations while maintaining the order of usage to evict the least recently used items when the cache reaches its capacity.\n\n### Approach\n\n1. **Data Structures**:\n   - **Doubly Linked List**: To maintain the order of elements based on their usage. The most recently used element is at the front, and the least recently used is at the back.\n   - **Unordered Map**: To provide O(1) access time for insertion, deletion, and retrieval operations. The map will store keys mapped to pointers of nodes in the doubly linked list.\n\n2. **Operations**:\n   - **Insertion**: If the key already exists, update its value and move it to the front. If the cache is full, remove the least recently used item (from the back of the list) and then add the new item to the front.\n   - **Deletion**: Remove the item by key from both the map and the list.\n   - **Retrieval**: Get the value by key and move the accessed item to the front of the list to mark it as recently used.\n\n### Solution Code\n\n```cpp\n#include <iostream>\n#include <unordered_map>\n\nclass Node {\npublic:\n    int key;\n    int value;\n    Node* prev;\n    Node* next;\n\n    Node(int k, int v) : key(k), value(v), prev(nullptr), next(nullptr) {}\n};\n\nclass LRUCache {\nprivate:\n    std::unordered_map<int, Node*> cache;\n    Node* head;\n    Node* tail;\n    int capacity;\n\n    void moveToFront(Node* node) {\n        if (node == head) return;\n        if (node == tail) {\n            tail = tail->prev;\n            tail->next = nullptr;\n        } else {\n            node->prev->next = node->next;\n            node->next->prev = node->prev;\n        }\n        node->next = head;\n        node->prev = nullptr;\n        head->prev = node;\n        head = node;\n    }\n\n    void removeNode(Node* node) {\n        if (node == head) {\n            head = head->next;\n            if (head) head->prev = nullptr;\n        } else if (node == tail) {\n            tail = tail->prev;\n            if (tail) tail->next = nullptr;\n        } else {\n            node->prev->next = node->next;\n            node->next->prev = node->prev;\n        }\n        delete node;\n    }\n\npublic:\n    LRUCache(int cap) : capacity(cap), head(nullptr), tail(nullptr) {}\n\n    int get(int key) {\n        if (cache.find(key) == cache.end()) return -1;\n        Node* node = cache[key];\n        moveToFront(node);\n        return node->value;\n    }\n\n    void put(int key, int value) {\n        if (cache.find(key) != cache.end()) {\n            Node* existing = cache[key];\n            existing->value = value;\n            moveToFront(existing);\n        } else {\n            Node* newNode = new Node(key, value);\n            cache[key] = newNode;\n            if (!head) {\n                head = tail = newNode;\n            } else {\n                newNode->next = head;\n                head->prev = newNode;\n                head = newNode;\n            }\n            if (cache.size() > capacity) {\n                int key_to_remove = tail->key;\n                removeNode(tail);\n                cache.erase(key_to_remove);\n            }\n        }\n    }\n\n    ~LRUCache() {\n        while (head) {\n            Node* temp = head;\n            head = head->next;\n            delete temp;\n        }\n    }\n};\n\nint main() {\n    LRUCache cache(2);\n    cache.put(1, 1);\n    cache.put(2, 2);\n    std::cout << cache.get(1) << std::endl; // returns 1\n    cache.put(3, 3); // evicts key 2\n    std::cout << cache.get(2) << std::endl; // returns -1 (not found)\n    cache.put(4, 4); // evicts key 1\n    std::cout << cache.get(1) << std::endl; // returns -1 (not found)\n    std::cout << cache.get(3) << std::endl; // returns 3\n    std::cout << cache.get(4) << std::endl; // returns 4\n    return 0;\n}\n```\n\n### Explanation\n\n1. **Node Class**:\n   - Represents each element in the cache with `key`, `value`, and pointers to previous and next nodes.\n\n2. **LRUCache Class**:\n   - **Constructor**: Initializes the cache with a given capacity.\n   - **get(int key)**: Retrieves the value of the key if it exists, moves the accessed node to the front, and returns the value; otherwise, returns -1.\n   - **put(int key, int value)**: Inserts or updates the key-value pair. If the key exists, updates its value and moves it to the front. If the cache is full, removes the least recently used item before inserting the new item.\n   - **moveToFront(Node* node)**: Moves a node to the front of the list.\n   - **removeNode(Node* node)**: Removes a node from the list.\n\n3. **Main Function**:\n   - Demonstrates the usage of the LRUCache with a series of put and get operations, showing how the cache maintains the most recently used items and evicts the least recently used ones when necessary."
    }
]