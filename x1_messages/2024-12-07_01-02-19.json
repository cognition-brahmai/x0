[
    {
        "role": "user",
        "content": "In Java, write a program that simulates a game of Tic Tac Toe. It should include a graphical user interface where two players can take turns clicking on a grid to place their mark. Implement checks for win conditions and a reset button to start a new game. PLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Alright, I'm going to try to make a Tic Tac Toe game in Java with a graphical user interface. I'm not super experienced with GUIs in Java, but I've done some stuff with Swing, so I'll go with that.\n\nFirst, I need to understand what Tic Tac Toe is. It's a simple game where two players take turns marking a 3x3 grid. The first player is usually 'X' and the other is 'O'. The player who succeeds in placing three of their marks in a horizontal, vertical, or diagonal row wins the game.\n\nSo, for the GUI, I need a 3x3 grid of buttons. Each button should represent a cell on the Tic Tac Toe board. When a player clicks a button, it should display 'X' or 'O' depending on whose turn it is. I need to keep track of whose turn it is and alternate between 'X' and 'O' with each click.\n\nI also need to check for win conditions after each move. So, after each click, I need to check if the current player has three in a row, column, or diagonal. If they do, I need to display a message saying they've won and maybe disable the buttons so no one can click them anymore.\n\nAdditionally, I should have a reset button that, when clicked, clears the board and allows players to start a new game.\n\nLet me think about how to structure this in Java. I'll need a class that extends JFrame to create the main window. Inside that window, I'll have a panel with a 3x3 grid of buttons. I'll probably use a GridLayout for the panel to make it easy to arrange the buttons in a grid.\n\nI need to handle button clicks, so I'll have to add action listeners to each button. In the action listener, I'll need to set the text of the button to 'X' or 'O' based on whose turn it is, and then switch the turn to the other player.\n\nI also need to implement the win condition checks. I can do this by checking all possible winning combinations after each move. There are eight possible winning lines: three rows, three columns, and two diagonals.\n\nIf none of these conditions are met and the board is full, it's a draw. So, I need to check if the board is full after each move as well.\n\nFor the reset button, I'll have another button outside the grid that, when clicked, resets the board by clearing the text of all the grid buttons and resetting the turn counter.\n\nI should also keep track of which cells have been clicked to prevent players from clicking on already occupied cells.\n\nLet me sketch out a rough plan:\n\n1. Create a JFrame window.\n\n2. Add a JPanel with a GridLayout(3,3) for the grid of buttons.\n\n3. Create 9 JButtons for the grid cells.\n\n4. Add action listeners to each grid button.\n\n5. In the action listener:\n\na. Set the text of the button to 'X' or 'O' based on whose turn it is.\n\nb. Disable the button to prevent further clicks on that cell.\n\nc. Switch the turn to the other player.\n\nd. Check for win conditions.\n\ne. If there's a winner, display a message and disable all buttons.\n\nf. If no winner and the board is full, display a draw message.\n\n6. Add a reset button that, when clicked, clears the board and allows a new game.\n\nI think that covers the basic functionality.\n\nNow, let's think about how to implement the win condition checks. I can store the state of the board in a 2D array, maybe a char[3][3], where each element is 'X', 'O', or ' ' (empty).\n\nAfter each move, I can iterate through the rows, columns, and diagonals to see if any of them have three identical marks (excluding empty cells).\n\nFor example, to check rows:\n\nfor each row:\n\nif all three cells are 'X', then X wins.\n\nif all three cells are 'O', then O wins.\n\nSimilarly, check columns and diagonals.\n\nTo check if the board is full, I can count the number of empty cells. If there are no empty cells and no winner, it's a draw.\n\nI need to make sure that once a game is over, no more moves can be made until the reset button is clicked.\n\nAlso, I should probably have some way to display whose turn it is, maybe with a label at the top.\n\nLet me think about the variables I need:\n\n- A 2D array to represent the board state.\n\n- A boolean variable to track whose turn it is (e.g., boolean isXsTurn).\n\n- Maybe an int variable to count the number of moves made.\n\n- Labels or some other GUI elements to display messages.\n\nI should also consider how to handle the action listeners. Since all grid buttons perform similar actions, maybe I can use a single action listener for all of them and determine which button was clicked based on the action event.\n\nIn Swing, I can use ActionListener for this. I'll need to add the same listener to all grid buttons, and in the actionPerformed method, I can get the source of the event (which button was clicked) and update its text accordingly.\n\nWait, but each button needs to be associated with a specific position on the board. Maybe I can set some kind of identifier for each button, like a name or a tag, to know which cell it represents.\n\nIn Swing, JComponents have an actionCommand property that can be set to identify the component. I can set the actionCommand to something like \"0-0\" for the top-left cell, \"0-1\" for the cell to its right, and so on, up to \"2-2\" for the bottom-right cell.\n\nThen, in the action listener, I can get the actionCommand of the source button and parse it to determine which row and column were clicked.\n\nAlternatively, I can create a separate inner class for the action listener and have it capture the row and column indices when creating the button.\n\nHmm, perhaps the latter is cleaner. I can create the grid buttons in a nested loop, and for each button, set its action listener with the row and column indices captured in the loop.\n\nIn Java, since loop variables are not effectively final inside nested classes, I need to make sure to capture the correct values of row and column for each button's action listener.\n\nI can do this by creating final local variables inside the loop or by using lambda expressions if I'm using Java 8 or later.\n\nAssuming I'm using Java 8, I can use lambda expressions to create the action listeners, capturing the row and column indices.\n\nSomething like:\n\nfor (int row = 0; row < 3; row++) {\n\nfor (int col = 0; col < 3; col++) {\n\nJButton button = new JButton();\n\nbutton.addActionListener(e -> {\n\nint r = row;\n\nint c = col;\n\n// Update board state and check for win\n\n});\n\ngridPanel.add(button);\n\n}\n\n}\n\nWait, but there's a known issue with loop variables in Java lambdas. The loop variables are effectively final, but if I don't assign them to local variables inside the loop, it might not work as expected.\n\nTo be safe, I can assign the loop variables to final local variables inside the loop.\n\nLike this:\n\nfor (int row = 0; row < 3; row++) {\n\nfor (int col = 0; col < 3; col++) {\n\nfinal int currentRow = row;\n\nfinal int currentCol = col;\n\nJButton button = new JButton();\n\nbutton.addActionListener(e -> {\n\n// Use currentRow and currentCol here\n\n});\n\ngridPanel.add(button);\n\n}\n\n}\n\nThat should ensure that each button's action listener has the correct row and column indices.\n\nAlright, moving forward.\n\nI need to think about how to represent the board state. I can use a 2D array, as I thought earlier.\n\nchar[][] board = new char[3][3];\n\nI'll initialize it with spaces (' ') to represent empty cells.\n\nI'll need a variable to track whose turn it is, say a boolean isXsTurn.\n\nI'll set isXsTurn to true at the start, meaning X starts first.\n\nIn the action listener, if isXsTurn is true, set the button's text to 'X' and board[currentRow][currentCol] to 'X', then set isXsTurn to false.\n\nSimilarly, if it's O's turn, set the text to 'O' and update the board accordingly.\n\nAfter updating the board, I need to check for win conditions.\n\nI'll write a method called checkWin that iterates through rows, columns, and diagonals to see if there's a winner.\n\nIf there is a winner, I can display a message, say, \"X wins!\" or \"O wins!\", and disable all grid buttons.\n\nIf there's no winner but the board is full (i.e., all cells are filled), display \"It's a draw!\".\n\nTo check if the board is full, I can iterate through the board and check if there are any empty cells left.\n\nIf there are still empty cells and no winner, the game continues.\n\nI also need to make sure that once the game is over, no more moves can be made until the reset button is clicked.\n\nTo do this, I can disable all grid buttons when a winner is detected or when it's a draw.\n\nFor the reset button, I'll add another button outside the grid, perhaps at the bottom of the frame.\n\nWhen the reset button is clicked, I'll reset the board state, set isXsTurn back to true, and enable all grid buttons.\n\nI'll also clear any win or draw messages.\n\nI should think about how to display messages to the user. Maybe I can have a JLabel at the top or bottom of the frame that shows whose turn it is and any win/draw messages.\n\nFor example, initially, it can say \"X's turn\". After each move, it can update to show the current player's turn or display win/draw messages.\n\nI can update this label in the action listener based on the game state.\n\nI should also consider the flow of the game:\n\n1. Start with an empty board, X's turn.\n\n2. Player clicks a grid button.\n\n3. If it's X's turn, place 'X' in the clicked cell, otherwise place 'O'.\n\n4. Check if the current player has won. If yes, display win message and end game.\n\n5. If not, check if the board is full. If yes, display draw message and end game.\n\n6. If neither, switch turns and display whose turn it is.\n\n7. Players continue until someone wins or it's a draw.\n\n8. Reset button allows starting a new game.\n\nI need to make sure that players cannot click on already occupied cells. To prevent this, I can check if the cell is already 'X' or 'O' before allowing a move.\n\nIn the action listener, if the board[currentRow][currentCol] is not ' ', then do nothing.\n\nWait, but I should also disable the button once it's been clicked to prevent multiple clicks.\n\nSo, in the action listener, after updating the board and the button's text, disable the button.\n\nThis way, no one can click on that cell again.\n\nAlright, I think I have a plan.\n\nLet me start by setting up the JFrame and the JPanel with the grid layout.\n\nI'll create a class, say, TicTacToe, that extends JFrame.\n\nIn the constructor, I'll set up the GUI components.\n\nFirst, create a JPanel with GridLayout(3,3) for the grid of buttons.\n\nThen, create 9 JButtons and add them to the grid panel.\n\nAdd action listeners to each button as described earlier.\n\nThen, add a reset button below the grid panel.\n\nAlso, add a JLabel to display messages.\n\nArrange these components in the frame appropriately, maybe using a BorderLayout.\n\nSo, the grid panel would be in the center, the message label at the top, and the reset button at the bottom.\n\nI can use setLayout(new BorderLayout()) for the frame, and then add components using add(gridPanel, BorderLayout.CENTER), add(messageLabel, BorderLayout.NORTH), and add(resetButton, BorderLayout.SOUTH).\n\nThat should arrange them nicely.\n\nNow, let's think about the variables.\n\nI'll have:\n\n- A 2D array to represent the board state: char[][] board = new char[3][3];\n\n- A boolean to track whose turn it is: boolean isXsTurn = true;\n\n- A JLabel to display messages: JLabel messageLabel;\n\n- The grid panel: JPanel gridPanel;\n\n- The reset button: JButton resetButton;\n\nI need to initialize the board with spaces.\n\nI can write a method to reset the board:\n\nprivate void resetBoard() {\n\nfor (int i = 0; i < 3; i++) {\n\nfor (int j = 0; j < 3; j++) {\n\nboard[i][j] = ' ';\n\n// Also, enable all grid buttons and clear their text\n\n}\n\n}\n\nisXsTurn = true;\n\n// Update messageLabel to show \"X's turn\"\n\n}\n\nIn the reset button's action listener, I'll call resetBoard().\n\nNow, for the grid buttons' action listeners, as discussed earlier, I'll need to capture the row and column for each button.\n\nI'll use lambda expressions with local final variables for row and column.\n\nIn the action listener, I'll:\n\n- Check if the cell is already occupied. If so, do nothing.\n\n- Otherwise, set the button's text to 'X' or 'O' based on isXsTurn.\n\n- Update the board array accordingly.\n\n- Disable the button to prevent further clicks.\n\n- Check for win conditions using checkWin().\n\n- If there's a winner, display the win message and disable all grid buttons.\n\n- If no winner, check if the board is full. If yes, display draw message.\n\n- If neither, switch the turn to the other player and update the message label.\n\nI need to implement the checkWin() method.\n\nI can iterate through all rows, columns, and diagonals to check for three matching symbols.\n\nHere's a rough outline:\n\nprivate boolean checkWin() {\n\n// Check rows\n\nfor (int i = 0; i < 3; i++) {\n\nif (board[i][0] != ' ' &&\n\nboard[i][0] == board[i][1] &&\n\nboard[i][1] == board[i][2]) {\n\nreturn true;\n\n}\n\n}\n\n// Check columns\n\nfor (int j = 0; j < 3; j++) {\n\nif (board[0][j] != ' ' &&\n\nboard[0][j] == board[1][j] &&\n\nboard[1][j] == board[2][j]) {\n\nreturn true;\n\n}\n\n}\n\n// Check diagonals\n\nif (board[0][0] != ' ' &&\n\nboard[0][0] == board[1][1] &&\n\nboard[1][1] == board[2][2]) {\n\nreturn true;\n\n}\n\nif (board[0][2] != ' ' &&\n\nboard[0][2] == board[1][1] &&\n\nboard[1][1] == board[2][0]) {\n\nreturn true;\n\n}\n\nreturn false;\n\n}\n\nIf this method returns true, then there's a winner.\n\nI also need to determine who the winner is, so maybe I can modify this method to return the winning symbol ('X' or 'O') or ' ' if no win.\n\nThen, in the action listener, I can check the return value and display the appropriate message.\n\nAlternatively, I can have separate methods to check rows, columns, and diagonals, but for simplicity, I'll keep it in one method.\n\nWait, perhaps it's better to have checkWin() return the winning symbol or ' ' if no win.\n\nThat way, in the action listener, I can check the return value and display the winner accordingly.\n\nSo, updating checkWin():\n\nprivate char checkWin() {\n\n// Check rows\n\nfor (int i = 0; i < 3; i++) {\n\nif (board[i][0] != ' ' &&\n\nboard[i][0] == board[i][1] &&\n\nboard[i][0] == board[i][2]) {\n\nreturn board[i][0];\n\n}\n\n}\n\n// Check columns\n\nfor (int j = 0; j < 3; j++) {\n\nif (board[0][j] != ' ' &&\n\nboard[0][j] == board[1][j] &&\n\nboard[0][j] == board[2][j]) {\n\nreturn board[0][j];\n\n}\n\n}\n\n// Check diagonals\n\nif (board[0][0] != ' ' &&\n\nboard[0][0] == board[1][1] &&\n\nboard[0][0] == board[2][2]) {\n\nreturn board[0][0];\n\n}\n\nif (board[0][2] != ' ' &&\n\nboard[0][2] == board[1][1] &&\n\nboard[0][2] == board[2][0]) {\n\nreturn board[0][2];\n\n}\n\nreturn ' ';\n\n}\n\nNow, in the action listener, I can call checkWin() and check if it returns 'X', 'O', or ' '.\n\nIf it's 'X' or 'O', display the win message and end the game.\n\nIf it's ' ', check if the board is full for a draw.\n\nTo check if the board is full, I can iterate through the board and see if there are any empty cells.\n\nI can write a method for that:\n\nprivate boolean isBoardFull() {\n\nfor (int i = 0; i < 3; i++) {\n\nfor (int j = 0; j < 3; j++) {\n\nif (board[i][j] == ' ') {\n\nreturn false;\n\n}\n\n}\n\n}\n\nreturn true;\n\n}\n\nIn the action listener, after checking for a win, if there's no win and the board is full, it's a draw.\n\nOtherwise, switch the turn to the other player and update the message label.\n\nI need to make sure that the message label is updated appropriately.\n\nFor example, initially, it says \"X's turn\".\n\nAfter X moves, it says \"O's turn\", and vice versa.\n\nIf there's a win or a draw, it displays the corresponding message and disables all grid buttons.\n\nAlso, when resetting the game, the message label should be reset to \"X's turn\", and all grid buttons should be enabled and cleared.\n\nI should also consider how to layout the GUI.\n\nUsing BorderLayout, with the grid in the center, message label at the top, and reset button at the bottom, that should work.\n\nI might want to add some padding or borders for better visual appeal.\n\nI can use JOptionPane or JDialog to display win messages, but for simplicity, I'll just update the message label.\n\nAlternatively, I can pop up a dialog box to announce the winner and ask if they want to play again, but that might be overshooting for now.\n\nI'll stick with updating the message label and enabling/disabling the grid buttons accordingly.\n\nI should also think about how to organize the code.\n\nI can have the main method in the TicTacToe class that creates an instance of TicTacToe and sets it visible.\n\nIn the constructor, I'll set up the GUI components and layout.\n\nI'll need to store references to all grid buttons to be able to enable/disable them and clear their text during reset.\n\nMaybe I can store them in a 2D array of JButtons, parallel to the board array.\n\nSo, JButton[][] gridButtons = new JButton[3][3];\n\nIn the nested loops where I create the grid buttons, I'll assign them to gridButtons[row][col].\n\nThen, in resetBoard(), I can iterate through gridButtons and set their text to empty and enable them.\n\nSimilarly, when disabling all buttons after a win or draw, I can iterate through gridButtons and disable them.\n\nThis seems efficient.\n\nLet me outline the steps in code:\n\nclass TicTacToe extends JFrame {\n\nprivate char[][] board = new char[3][3];\n\nprivate JButton[][] gridButtons = new JButton[3][3];\n\nprivate boolean isXsTurn = true;\n\nprivate JLabel messageLabel;\n\nprivate JButton resetButton;\n\npublic TicTacToe() {\n\n// Initialize board to ' '\n\nfor (int i = 0; i < 3; i++) {\n\nfor (int j = 0; j < 3; j++) {\n\nboard[i][j] = ' ';\n\n}\n\n}\n\n// Set up GUI components\n\nJPanel gridPanel = new JPanel(new GridLayout(3, 3));\n\nfor (int row = 0; row < 3; row++) {\n\nfor (int col = 0; col < 3; col++) {\n\nfinal int currentRow = row;\n\nfinal int currentCol = col;\n\nJButton button = new JButton();\n\nbutton.addActionListener(e -> {\n\nif (board[currentRow][currentCol] == ' ') {\n\nif (isXsTurn) {\n\nbutton.setText(\"X\");\n\nboard[currentRow][currentCol] = 'X';\n\n} else {\n\nbutton.setText(\"O\");\n\nboard[currentRow][currentCol] = 'O';\n\n}\n\nbutton.setEnabled(false);\n\nchar winner = checkWin();\n\nif (winner != ' ') {\n\nmessageLabel.setText(winner + \" wins!\");\n\ndisableAllButtons();\n\n} else if (isBoardFull()) {\n\nmessageLabel.setText(\"It's a draw!\");\n\ndisableAllButtons();\n\n} else {\n\nisXsTurn = !isXsTurn;\n\nmessageLabel.setText((isXsTurn ? \"X\" : \"O\") + \"'s turn\");\n\n}\n\n}\n\n});\n\ngridButtons[row][col] = button;\n\ngridPanel.add(button);\n\n}\n\n}\n\nmessageLabel = new JLabel(\"X's turn\");\n\nresetButton = new JButton(\"Reset\");\n\nresetButton.addActionListener(e -> resetBoard());\n\n// Set up frame\n\nsetLayout(new BorderLayout());\n\nadd(gridPanel, BorderLayout.CENTER);\n\nadd(messageLabel, BorderLayout.NORTH);\n\nadd(resetButton, BorderLayout.SOUTH);\n\nsetDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n\npack();\n\nsetResizable(false);\n\n}\n\nprivate void disableAllButtons() {\n\nfor (int i = 0; i < 3; i++) {\n\nfor (int j = 0; j < 3; j++) {\n\ngridButtons[i][j].setEnabled(false);\n\n}\n\n}\n\n}\n\nprivate void resetBoard() {\n\nfor (int i = 0; i < 3; i++) {\n\nfor (int j = 0; j < 3; j++) {\n\nboard[i][j] = ' ';\n\ngridButtons[i][j].setText(\"\");\n\ngridButtons[i][j].setEnabled(true);\n\n}\n\n}\n\nisXsTurn = true;\n\nmessageLabel.setText(\"X's turn\");\n\n}\n\nprivate char checkWin() {\n\n// Implement win condition checks\n\n}\n\nprivate boolean isBoardFull() {\n\n// Implement board full check\n\n}\n\npublic static void main(String[] args) {\n\nSwingUtilities.invokeLater(() -> {\n\nTicTacToe game = new TicTacToe();\n\ngame.setVisible(true);\n\n});\n\n}\n\n}\n\nI need to implement the checkWin() and isBoardFull() methods as discussed earlier.\n\nI should also make sure to handle cases where the board is not full and there's no winner, just switch turns.\n\nAdditionally, I need to ensure that only one instance of the game is running at a time, but since this is a simple application, it's probably not necessary.\n\nI should also think about internationalization or accessibility features, but for this basic implementation, it's okay to keep it simple.\n\nI might want to add some styling to the buttons, like making them larger or changing their font, but that's optional.\n\nLet me think about possible edge cases:\n\n- Players click on the same cell multiple times.\n\n- Players try to click on already occupied cells.\n\n- A player wins in the first possible move (unlikely, but possible).\n\n- A player wins diagonally, horizontally, or vertically.\n\n- The game ends in a draw.\n\n- Players click the reset button during the game or after the game ends.\n\nI need to make sure that the reset button works correctly at any stage of the game.\n\nAlso, I should ensure that the message label is updated correctly at all times.\n\nI should test the application thoroughly to make sure there are no bugs.\n\nFor example, I need to make sure that after a win or a draw, the reset button enables all grid buttons and resets the board state correctly.\n\nI should also make sure that the turn alternates correctly between players.\n\nI might want to add some delays or animations for better user experience, but that's beyond the scope of this basic implementation.\n\nI should also consider exception handling, but for this simple app, it's probably not necessary unless specific exceptions are expected.\n\nI think that's about it for now.\n\nI'll proceed to implement the code based on this plan.\n\n**Final Solution**\n\nTo solve this problem, we will create a Java Swing application that simulates a game of Tic Tac Toe. The application will feature a graphical user interface where two players can take turns clicking on a 3x3 grid to place their marks ('X' or 'O'). The game will check for win conditions after each move and provide a reset button to start a new game.\n\n### Approach\n\n1. **GUI Components:**\n   - A `JFrame` window serving as the main window.\n   - A `JPanel` with a `GridLayout(3,3)` to hold the grid of buttons.\n   - 9 `JButton` instances for the grid cells.\n   - A `JLabel` to display messages (e.g., \"X's turn\", \"O's turn\", \"X wins!\").\n   - A \"Reset\" `JButton` to restart the game.\n\n2. **Game Logic:**\n   - Track the current player's turn using a boolean variable (`isXsTurn`).\n   - Maintain a 2D array (`board`) to represent the game state.\n   - Switch turns after each valid move.\n   - Check for win conditions after each move.\n   - Check for a draw if the board is full and there is no winner.\n   - Provide a reset function to restart the game.\n\n3. **Event Handling:**\n   - Add action listeners to each grid button to handle player moves.\n   - Add an action listener to the reset button to restart the game.\n\n### Solution Code\n\n```java\nimport javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\n\npublic class TicTacToe extends JFrame {\n    private char[][] board = new char[3][3];\n    private JButton[][] gridButtons = new JButton[3][3];\n    private boolean isXsTurn = true;\n    private JLabel messageLabel;\n    private JButton resetButton;\n\n    public TicTacToe() {\n        // Initialize board to ' '\n        for (int i = 0; i < 3; i++) {\n            for (int j = 0; j < 3; j++) {\n                board[i][j] = ' ';\n            }\n        }\n\n        // Set up GUI components\n        JPanel gridPanel = new JPanel(new GridLayout(3, 3));\n        for (int row = 0; row < 3; row++) {\n            for (int col = 0; col < 3; col++) {\n                final int currentRow = row;\n                final int currentCol = col;\n                JButton button = new JButton();\n                button.addActionListener(e -> {\n                    if (board[currentRow][currentCol] == ' ') {\n                        if (isXsTurn) {\n                            button.setText(\"X\");\n                            board[currentRow][currentCol] = 'X';\n                        } else {\n                            button.setText(\"O\");\n                            board[currentRow][currentCol] = 'O';\n                        }\n                        button.setEnabled(false);\n                        char winner = checkWin();\n                        if (winner != ' ') {\n                            messageLabel.setText(winner + \" wins!\");\n                            disableAllButtons();\n                        } else if (isBoardFull()) {\n                            messageLabel.setText(\"It's a draw!\");\n                            disableAllButtons();\n                        } else {\n                            isXsTurn = !isXsTurn;\n                            messageLabel.setText((isXsTurn ? \"X\" : \"O\") + \"'s turn\");\n                        }\n                    }\n                });\n                gridButtons[row][col] = button;\n                gridPanel.add(button);\n            }\n        }\n        messageLabel = new JLabel(\"X's turn\");\n        resetButton = new JButton(\"Reset\");\n        resetButton.addActionListener(e -> resetBoard());\n\n        // Set up frame\n        setLayout(new BorderLayout());\n        add(gridPanel, BorderLayout.CENTER);\n        add(messageLabel, BorderLayout.NORTH);\n        add(resetButton, BorderLayout.SOUTH);\n        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        pack();\n        setResizable(false);\n    }\n\n    private void disableAllButtons() {\n        for (int i = 0; i < 3; i++) {\n            for (int j = 0; j < 3; j++) {\n                gridButtons[i][j].setEnabled(false);\n            }\n        }\n    }\n\n    private void resetBoard() {\n        for (int i = 0; i < 3; i++) {\n            for (int j = 0; j < 3; j++) {\n                board[i][j] = ' ';\n                gridButtons[i][j].setText(\"\");\n                gridButtons[i][j].setEnabled(true);\n            }\n        }\n        isXsTurn = true;\n        messageLabel.setText(\"X's turn\");\n    }\n\n    private char checkWin() {\n        // Check rows\n        for (int i = 0; i < 3; i++) {\n            if (board[i][0] != ' ' && board[i][0] == board[i][1] && board[i][1] == board[i][2]) {\n                return board[i][0];\n            }\n        }\n        // Check columns\n        for (int j = 0; j < 3; j++) {\n            if (board[0][j] != ' ' && board[0][j] == board[1][j] && board[1][j] == board[2][j]) {\n                return board[0][j];\n            }\n        }\n        // Check diagonals\n        if (board[0][0] != ' ' && board[0][0] == board[1][1] && board[1][1] == board[2][2]) {\n            return board[0][0];\n        }\n        if (board[0][2] != ' ' && board[0][2] == board[1][1] && board[1][1] == board[2][0]) {\n            return board[0][2];\n        }\n        return ' ';\n    }\n\n    private boolean isBoardFull() {\n        for (int i = 0; i < 3; i++) {\n            for (int j = 0; j < 3; j++) {\n                if (board[i][j] == ' ') {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            TicTacToe game = new TicTacToe();\n            game.setVisible(true);\n        });\n    }\n}\n```\n\n### Explanation\n\n- **GUI Setup:** The `JFrame` contains a `JPanel` with a `GridLayout(3,3)` for the grid buttons, a `JLabel` for messages, and a \"Reset\" `JButton`.\n- **Game State Management:** The `board` array tracks the game state, and `isXsTurn` alternates turns between players.\n- **Event Handling:** Each grid button's action listener handles player moves, updates the board, checks for win conditions, and switches turns accordingly.\n- **Win and Draw Conditions:** The `checkWin` method checks all possible winning combinations, and `isBoardFull` checks for a draw.\n- **Reset Functionality:** The reset button triggers the `resetBoard` method, which resets the game state and GUI components for a new game."
    }
]