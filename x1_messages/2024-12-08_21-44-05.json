[
    {
        "role": "user",
        "content": "Create a C++ program that implements a Binary Search Tree with methods for insertion, deletion, search, and in-order traversal."
    },
    {
        "role": "assistant",
        "content": "I'd be happy to help you with that! Implementing a Binary Search Tree (BST) in C++ involves several steps, including defining the structure of the tree nodes, implementing methods for insertion, deletion, search, and traversal. Below is a complete example of how you can achieve this.\n\n### Explanation\n\n1. **Node Structure**:\n   - Each node in the BST contains an integer value and pointers to its left and right children.\n\n2. **Insertion**:\n   - Insert a new node with the given value into the BST.\n   - Maintain the BST property where left child < parent < right child.\n\n3. **Deletion**:\n   - Remove a node with the given value from the BST.\n   - Handle different cases: node with no children, one child, or two children.\n\n4. **Search**:\n   - Find a node with the given value in the BST.\n   - Return true if found, else false.\n\n5. **In-Order Traversal**:\n   - Traverse the tree in-order (left, root, right).\n   - Print the values of nodes in ascending order.\n\n### Solution Code\n\n```cpp\n#include <iostream>\nusing namespace std;\n\nclass Node {\npublic:\n    int value;\n    Node* left;\n    Node* right;\n    Node(int val) : value(val), left(nullptr), right(nullptr) {}\n};\n\nclass BST {\nprivate:\n    Node* root;\n\n    // Helper functions\n    Node* insert(Node* node, int value) {\n        if (node == nullptr) return new Node(value);\n        if (value < node->value)\n            node->left = insert(node->left, value);\n        else if (value > node->value)\n            node->right = insert(node->right, value);\n        return node;\n    }\n\n    Node* minValueNode(Node* node) {\n        Node* current = node;\n        while (current && current->left != nullptr)\n            current = current->left;\n        return current;\n    }\n\n    Node* deleteNode(Node* node, int value) {\n        if (node == nullptr) return node;\n        if (value < node->value)\n            node->left = deleteNode(node->left, value);\n        else if (value > node->value)\n            node->right = deleteNode(node->right, value);\n        else {\n            // Node with only one child or no child\n            if (node->left == nullptr) {\n                Node* temp = node->right;\n                delete node;\n                return temp;\n            } else if (node->right == nullptr) {\n                Node* temp = node->left;\n                delete node;\n                return temp;\n            }\n            // Node with two children: Get the inorder successor (smallest in the right subtree)\n            Node* temp = minValueNode(node->right);\n            // Copy the inorder successor's content to this node\n            node->value = temp->value;\n            // Delete the inorder successor\n            node->right = deleteNode(node->right, temp->value);\n        }\n        return node;\n    }\n\n    bool search(Node* node, int value) {\n        if (node == nullptr) return false;\n        if (value == node->value) return true;\n        else if (value < node->value) return search(node->left, value);\n        else return search(node->right, value);\n    }\n\n    void inOrderTraversal(Node* node) {\n        if (node != nullptr) {\n            inOrderTraversal(node->left);\n            cout << node->value << \" \";\n            inOrderTraversal(node->right);\n        }\n    }\n\npublic:\n    BST() : root(nullptr) {}\n\n    void insert(int value) {\n        root = insert(root, value);\n    }\n\n    void deleteNode(int value) {\n        root = deleteNode(root, value);\n    }\n\n    bool search(int value) {\n        return search(root, value);\n    }\n\n    void inOrderTraversal() {\n        inOrderTraversal(root);\n        cout << endl;\n    }\n};\n\nint main() {\n    BST bst;\n    bst.insert(50);\n    bst.insert(30);\n    bst.insert(20);\n    bst.insert(40);\n    bst.insert(70);\n    bst.insert(60);\n    bst.insert(80);\n\n    cout << \"In-order traversal: \";\n    bst.inOrderTraversal();\n\n    cout << \"Search 40: \" << (bst.search(40) ? \"Found\" : \"Not Found\") << endl;\n    cout << \"Search 90: \" << (bst.search(90) ? \"Found\" : \"Not Found\") << endl;\n\n    bst.deleteNode(20);\n    cout << \"After deleting 20: \";\n    bst.inOrderTraversal();\n\n    bst.deleteNode(30);\n    cout << \"After deleting 30: \";\n    bst.inOrderTraversal();\n\n    bst.deleteNode(50);\n    cout << \"After deleting 50: \";\n    bst.inOrderTraversal();\n\n    return 0;\n}\n```\n\n### Explanation of the Code\n\n1. **Node Structure**:\n   - The `Node` class defines the structure of each node in the BST, containing an integer value and pointers to left and right children.\n\n2. **BST Class**:\n   - The `BST` class manages the BST operations.\n   - **Insertion**: Recursively finds the correct position to insert a new node while maintaining the BST properties.\n   - **Deletion**: Handles three cases:\n     - Node with no children.\n     - Node with one child.\n     - Node with two children (finds the in-order successor to replace the deleted node).\n   - **Search**: Recursively searches for a node with the given value.\n   - **In-Order Traversal**: Prints the values of nodes in ascending order.\n\n3. **Main Function**:\n   - Demonstrates inserting nodes, performing in-order traversal, searching for values, and deleting nodes.\n   - Outputs the results of these operations to verify correctness.\n\nThis implementation ensures that all BST operations are correctly handled, providing a solid foundation for further extensions or modifications."
    }
]