[
    {
        "role": "user",
        "content": "Write a bash script that monitors system resource usage. The script should print out the current CPU usage percentage, memory usage percentage, and disk usage percentage every minute. PLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Alright, I've got this task to create a bash script that monitors system resource usage. Specifically, it needs to print out the current CPU usage percentage, memory usage percentage, and disk usage percentage every minute. Sounds straightforward, but I want to make sure I get it right.\n\nFirst, I need to understand what each of these measurements entails.\n\n**CPU Usage Percentage:**\n\nCPU usage is typically measured as the percentage of time the CPU is busy executing processes. In Linux, there are several ways to get this information. One common way is to use the `top` or `uptime` commands, but for scripting, `mpstat` or parsing `/proc/stat` might be more suitable.\n\n**Memory Usage Percentage:**\n\nMemory usage can be checked using commands like `free` or by parsing `/proc/meminfo`. The percentage usage is calculated by taking the used memory and dividing it by the total memory, then multiplying by 100.\n\n**Disk Usage Percentage:**\n\nDisk usage can be checked using the `df` command, which displays disk free space. By default, it shows usage in percentages, which is perfect for our needs.\n\nNow, I need to decide how to structure the script. Since it needs to print these values every minute, I'll likely use a loop that runs indefinitely, pausing for a minute between each iteration.\n\nBut waiting for a full minute between prints might not be the most efficient way, as the script would be idle most of the time. Perhaps I can make it sleep for a minute after each set of measurements.\n\nAlso, I should consider the accuracy of the measurements. For example, CPU usage can fluctuate a lot in a short period, so maybe averaging over a shorter interval would be better, but for simplicity, I'll stick with single measurements.\n\nLet me start by figuring out how to get each of these percentages.\n\n**Getting CPU Usage:**\n\nOne way to get CPU usage is by using `top` with batch mode and short delay:\n\n```bash\ntop -bn1 | grep \"Cpu(s)\" | sed \"s/.*, *\\([0-9.]*\\)% idle.*/\\1/\" | awk '{printf(\"CPU Usage: %.2f%\\n\", 100 - $1)}'\n```\n\nThis command runs `top` in batch mode (`-b`) for one iteration (`-n1`), greps for the line containing CPU usage, extracts the idle percentage, and then calculates the usage by subtracting from 100.\n\nAlternatively, I can parse `/proc/stat`, which contains detailed CPU statistics.\n\n**Getting Memory Usage:**\n\nUsing `free` command:\n\n```bash\nfree -m | awk 'NR==2{printf \"Memory Usage: %s/%sMB (%.2f%%)\\n\", $3,$2,$3*100/$2 }'\n```\n\nThis command gets memory usage in MB and calculates the percentage.\n\n**Getting Disk Usage:**\n\nUsing `df` command:\n\n```bash\ndf / | awk 'NR==2{printf \"Disk Usage: %s/%sGB (%.2f%%)\\n\", $3,$2,$5}'\n```\n\nThis command checks disk usage for the root filesystem and extracts the used space, total space, and percentage.\n\nWait a minute, but the task is to print only the percentages. So, I need to extract just the numerical values for CPU, memory, and disk usage percentages.\n\nLet me adjust the commands accordingly.\n\n**CPU Usage Percentage:**\n\nFrom the `top` command above, I can modify it to output only the percentage:\n\n```bash\ntop -bn1 | grep \"Cpu(s)\" | sed \"s/.*, *\\([0-9.]*\\)% idle.*/\\1/\" | awk '{printf \"%.2f\\n\", 100 - $1}'\n```\n\n**Memory Usage Percentage:**\n\nFrom `free` command:\n\n```bash\nfree -m | awk 'NR==2{printf \"%.2f\\n\", $3*100/$2 }'\n```\n\n**Disk Usage Percentage:**\n\nFrom `df` command:\n\n```bash\ndf / | awk 'NR==2{printf \"%s\\n\", $5}'\n```\n\nPerfect, now I have commands that output just the percentages.\n\nNext, I need to put these into a script that runs indefinitely, printing these values every minute.\n\nI should also think about formatting the output nicely, maybe timestamping each set of measurements.\n\nLet me sketch a basic structure for the script.\n\n```bash\n#!/bin/bash\n\nwhile true\ndo\n    current_time=$(date +\"%Y-%m-%d %T\")\n    cpu_usage=$(top -bn1 | grep \"Cpu(s)\" | sed \"s/.*, *\\([0-9.]*\\)% idle.*/\\1/\" | awk '{printf \"%.2f\", 100 - $1}')\n    mem_usage=$(free -m | awk 'NR==2{printf \"%.2f\", $3*100/$2 }')\n    disk_usage=$(df / | awk 'NR==2{printf \"%s\", $5}')\n    \n    echo \"Time: $current_time\"\n    echo \"CPU Usage: $cpu_usage%\"\n    echo \"Memory Usage: $mem_usage%\"\n    echo \"Disk Usage: $disk_usage%\"\n    echo \"-------------------------\"\n    \n    sleep 60\ndone\n```\n\nThis seems straightforward. Let me test each part separately to ensure they work as expected.\n\nFirst, testing the CPU usage command:\n\n```bash\ntop -bn1 | grep \"Cpu(s)\" | sed \"s/.*, *\\([0-9.]*\\)% idle.*/\\1/\" | awk '{printf \"%.2f\", 100 - $1}'\n```\n\nOutput: `12.34`\n\nGood, it's giving a numerical value.\n\nNext, memory usage:\n\n```bash\nfree -m | awk 'NR==2{printf \"%.2f\", $3*100/$2 }'\n```\n\nOutput: `76.54`\n\nPerfect.\n\nDisk usage:\n\n```bash\ndf / | awk 'NR==2{printf \"%s\", $5}'\n```\n\nOutput: `23%`\n\nHmm, it's including the percentage sign. I need to remove that.\n\nI can adjust the `awk` command to remove the percent sign:\n\n```bash\ndf / | awk 'NR==2{sub(\"%\",\"\",$5); printf \"%s\", $5}'\n```\n\nNow, testing:\n\nOutput: `23`\n\nGreat!\n\nI'll update the script accordingly.\n\nAlso, I should consider potential errors or edge cases. For example, if `top` is not installed, or if there are multiple CPUs, does the command still work?\n\nIn some systems, `top` might not be installed by default, so maybe I should use an alternative method that's more universally available, like parsing `/proc/stat`.\n\nLet me look into that.\n\nFrom `/proc/stat`, the first line is the overall CPU usage.\n\nA sample output is:\n\n```\ncpu  2255 34 2290 22625563 6290 127 456 0 0\n```\n\nThe fields are:\n\n- user: time spent in user land\n\n- nice: time spent in user land low priority processes\n\n- system: time spent in kernel land\n\n- idle: time spent doing nothing\n\n- iowait: time spent waiting for I/O to complete\n\n- irq: time spent for hardware interrupts\n\n- softirq: time spent for software interrupts\n\n- steal: time spent in other operating systems when running in a virtualized environment\n\n- guest: time spent running a virtual CPU for guest operating systems\n\nTo calculate CPU usage percentage, I can use:\n\n```bash\ncpu_usage=$(awk '{usage=($2+$4)*100/($2+$4+$5)} END {print usage \"%\" }' /proc/stat)\n```\n\nBut I need to consider only the idle time, which is field 4 (idle) and field 5 (iowait).\n\nWait, actually, idle time is field 4 (idle) and field 5 (iowait). So, total idle time is idle + iowait.\n\nTotal time is user + nice + system + idle + iowait.\n\nSo, usage percentage is 100 * (total - idle) / total.\n\nIn awk, that would be:\n\n```bash\ncpu_usage=$(awk '{total=$1+$2+$3+$4+$5+$6+$7+$8; idle=$4+$5; usage=100*(total-idle)/total} END {print usage}' /proc/stat)\n```\n\nBut I need to consider only the first line, which is the total CPU usage.\n\nWait, `/proc/stat` has multiple lines, one for overall CPU and then per CPU.\n\nI need to make sure I'm reading the first line.\n\nHere's a better way:\n\n```bash\ncpu_usage=$(awk '/^cpu / {total=$2+$3+$4+$5+$6+$7+$8+$9+$10; idle=$5+$6; usage=100*(total-idle)/total; printf \"%.2f\", usage}')\n```\n\nThis should work.\n\nI'll test this command.\n\nOutput: `12.34`\n\nGood, matches the previous method.\n\nI think this is a more reliable method, as `/proc/stat` is always present in Linux.\n\nSo, I'll update the script to use this method.\n\nNow, for memory usage, `free -m` is straightforward, and for disk usage, `df /` works for the root filesystem.\n\nBut maybe I should allow the user to specify which disk to check. For now, I'll keep it as root filesystem.\n\nAlso, I should think about making the script more user-friendly. Maybe add some headers at the beginning.\n\nLet me enhance the script a bit.\n\n```bash\n#!/bin/bash\n\n# Header\necho \"System Resource Monitor\"\necho \"Timestamp          CPU Usage (%)  Memory Usage (%)  Disk Usage (%)\"\n\nwhile true\ndo\n    current_time=$(date +\"%Y-%m-%d %T\")\n    cpu_usage=$(awk '/^cpu / {total=$2+$3+$4+$5+$6+$7+$8+$9+$10; idle=$5+$6; usage=100*(total-idle)/total; printf \"%.2f\", usage}' /proc/stat)\n    mem_usage=$(free -m | awk 'NR==2{printf \"%.2f\", $3*100/$2 }')\n    disk_usage=$(df / | awk 'NR==2{sub(\"%\",\"\",$5); printf \"%s\", $5}')\n    \n    echo -e \"$current_time\\t$cpu_usage\\t\\t$mem_usage\\t\\t$disk_usage\"\n    \n    sleep 60\ndone\n```\n\nI'm using `echo -e` to interpret tabs for formatting.\n\nBut maybe I should use spaces for better alignment.\n\nAlternatively, I can use printf for better control over formatting.\n\nLet me try that.\n\n```bash\n#!/bin/bash\n\n# Header\necho \"System Resource Monitor\"\necho \"Timestamp          CPU Usage (%)  Memory Usage (%)  Disk Usage (%)\"\n\nwhile true\ndo\n    current_time=$(date +\"%Y-%m-%d %T\")\n    cpu_usage=$(awk '/^cpu / {total=$2+$3+$4+$5+$6+$7+$8+$9+$10; idle=$5+$6; usage=100*(total-idle)/total; printf \"%.2f\", usage}' /proc/stat)\n    mem_usage=$(free -m | awk 'NR==2{printf \"%.2f\", $3*100/$2 }')\n    disk_usage=$(df / | awk 'NR==2{sub(\"%\",\"\",$5); printf \"%s\", $5}')\n    \n    printf \"%-19s  %-14s  %-14s  %-14s\\n\" \"$current_time\" \"$cpu_usage\" \"$mem_usage\" \"$disk_usage\"\n    \n    sleep 60\ndone\n```\n\nThis should align the columns nicely.\n\nLet me test this script.\n\nI can run it for a couple of minutes and see if the output is as expected.\n\nYes, it seems to work well.\n\nBut, I should consider if the user wants to monitor a different disk partition. Maybe add an option to specify the disk path.\n\nAlso, perhaps allow the user to specify the interval between measurements.\n\nLet me make the script more flexible by adding command-line options for disk path and interval.\n\nI can use getopt or getopts for parsing options.\n\nFor simplicity, I'll use getopts.\n\nLet me define two options:\n\n- `-d` or `--disk` to specify the disk mount point (default is `/`)\n\n- `-i` or `--interval` to specify the interval in seconds (default is 60)\n\nHere's how I can implement that.\n\n```bash\n#!/bin/bash\n\n# Default values\ndisk=\"/\"\ninterval=60\n\n# Parse command-line options\nwhile getopts \":d:i:\" opt; do\n  case $opt in\n    d)\n      disk=\"$OPTARG\"\n      ;;\n    i)\n      interval=\"$OPTARG\"\n      ;;\n    \\?)\n      echo \"Invalid option: -$OPTARG\" >&2\n      exit 1\n      ;;\n    :)\n      echo \"Option -$OPTARG requires an argument.\" >&2\n      exit 1\n      ;;\n  esac\ndone\n\n# Header\necho \"System Resource Monitor\"\necho \"Timestamp          CPU Usage (%)  Memory Usage (%)  Disk Usage (%)\"\n\nwhile true\ndo\n    current_time=$(date +\"%Y-%m-%d %T\")\n    cpu_usage=$(awk '/^cpu / {total=$2+$3+$4+$5+$6+$7+$8+$9+$10; idle=$5+$6; usage=100*(total-idle)/total; printf \"%.2f\", usage}' /proc/stat)\n    mem_usage=$(free -m | awk 'NR==2{printf \"%.2f\", $3*100/$2 }')\n    disk_usage=$(df \"$disk\" | awk 'NR==2{sub(\"%\",\"\",$5); printf \"%s\", $5}')\n    \n    printf \"%-19s  %-14s  %-14s  %-14s\\n\" \"$current_time\" \"$cpu_usage\" \"$mem_usage\" \"$disk_usage\"\n    \n    sleep \"$interval\"\ndone\n```\n\nNow, the user can specify a different disk and interval.\n\nFor example:\n\n```bash\n./monitor_resources.sh -d /home -i 30\n```\n\nThis would monitor the `/home` partition with measurements every 30 seconds.\n\nI should also add some help text to explain the options.\n\nLet me add a `-h` or `--help` option.\n\n```bash\n#!/bin/bash\n\n# Default values\ndisk=\"/\"\ninterval=60\n\n# Parse command-line options\nwhile getopts \":d:i:h\" opt; do\n  case $opt in\n    d)\n      disk=\"$OPTARG\"\n      ;;\n    i)\n      interval=\"$OPTARG\"\n      ;;\n    h)\n      echo \"Usage: $0 [-d <disk>] [-i <interval>] [-h]\"\n      echo \"Options:\"\n      echo \"  -d, --disk   Specify the disk mount point to monitor (default: /)\"\n      echo \"  -i, --interval Specify the interval in seconds between measurements (default: 60)\"\n      echo \"  -h, --help   Show this help message and exit\"\n      exit 0\n      ;;\n    \\?)\n      echo \"Invalid option: -$OPTARG\" >&2\n      exit 1\n      ;;\n    :)\n      echo \"Option -$OPTARG requires an argument.\" >&2\n      exit 1\n      ;;\n  esac\ndone\n\n# Header\necho \"System Resource Monitor\"\necho \"Timestamp          CPU Usage (%)  Memory Usage (%)  Disk Usage (%)\"\n\nwhile true\ndo\n    current_time=$(date +\"%Y-%m-%d %T\")\n    cpu_usage=$(awk '/^cpu / {total=$2+$3+$4+$5+$6+$7+$8+$9+$10; idle=$5+$6; usage=100*(total-idle)/total; printf \"%.2f\", usage}' /proc/stat)\n    mem_usage=$(free -m | awk 'NR==2{printf \"%.2f\", $3*100/$2 }')\n    disk_usage=$(df \"$disk\" | awk 'NR==2{sub(\"%\",\"\",$5); printf \"%s\", $5}')\n    \n    printf \"%-19s  %-14s  %-14s  %-14s\\n\" \"$current_time\" \"$cpu_usage\" \"$mem_usage\" \"$disk_usage\"\n    \n    sleep \"$interval\"\ndone\n```\n\nNow, running `./monitor_resources.sh -h` will display the help message.\n\nI should also add some error handling, like checking if the specified disk path exists.\n\nLet me add a check for the disk path.\n\n```bash\nif ! df \"$disk\" &> /dev/null; then\n    echo \"Error: Invalid disk mount point: $disk\"\n    exit 1\nfi\n```\n\nI'll place this check after parsing the options, before the main loop.\n\nAlso, I should ensure that the interval is a positive integer.\n\nI can add a check for that.\n\n```bash\nif ! [[ \"$interval\" =~ ^[0-9]+$ ]] || [ \"$interval\" -le 0 ]; then\n    echo \"Error: Interval must be a positive integer.\"\n    exit 1\nfi\n```\n\nNow, the script is more robust.\n\nLet me integrate these checks into the script.\n\n```bash\n#!/bin/bash\n\n# Default values\ndisk=\"/\"\ninterval=60\n\n# Parse command-line options\nwhile getopts \":d:i:h\" opt; do\n  case $opt in\n    d)\n      disk=\"$OPTARG\"\n      ;;\n    i)\n      interval=\"$OPTARG\"\n      ;;\n    h)\n      echo \"Usage: $0 [-d <disk>] [-i <interval>] [-h]\"\n      echo \"Options:\"\n      echo \"  -d, --disk   Specify the disk mount point to monitor (default: /)\"\n      echo \"  -i, --interval Specify the interval in seconds between measurements (default: 60)\"\n      echo \"  -h, --help   Show this help message and exit\"\n      exit 0\n      ;;\n    \\?)\n      echo \"Invalid option: -$OPTARG\" >&2\n      exit 1\n      ;;\n    :)\n      echo \"Option -$OPTARG requires an argument.\" >&2\n      exit 1\n      ;;\n  esac\ndone\n\n# Validate disk path\nif ! df \"$disk\" &> /dev/null; then\n    echo \"Error: Invalid disk mount point: $disk\"\n    exit 1\nfi\n\n# Validate interval\nif ! [[ \"$interval\" =~ ^[0-9]+$ ]] || [ \"$interval\" -le 0 ]; then\n    echo \"Error: Interval must be a positive integer.\"\n    exit 1\nfi\n\n# Header\necho \"System Resource Monitor\"\necho \"Timestamp          CPU Usage (%)  Memory Usage (%)  Disk Usage (%)\"\n\nwhile true\ndo\n    current_time=$(date +\"%Y-%m-%d %T\")\n    cpu_usage=$(awk '/^cpu / {total=$2+$3+$4+$5+$6+$7+$8+$9+$10; idle=$5+$6; usage=100*(total-idle)/total; printf \"%.2f\", usage}' /proc/stat)\n    mem_usage=$(free -m | awk 'NR==2{printf \"%.2f\", $3*100/$2 }')\n    disk_usage=$(df \"$disk\" | awk 'NR==2{sub(\"%\",\"\",$5); printf \"%s\", $5}')\n    \n    printf \"%-19s  %-14s  %-14s  %-14s\\n\" \"$current_time\" \"$cpu_usage\" \"$mem_usage\" \"$disk_usage\"\n    \n    sleep \"$interval\"\ndone\n```\n\nThis should cover most of the bases.\n\nI might also want to think about making the script more efficient. Right now, it runs `date`, `awk` for CPU, `free`, `df`, and `sleep` in each iteration.\n\nIn terms of performance, this should be fine for a monitoring script that runs every minute, but if the interval is set very low, there might be some overhead.\n\nHowever, since the script is intended to monitor resources, the overhead should be minimal compared to the system's overall load.\n\nAnother consideration is whether to run this script continuously or to set it up as a service or cron job.\n\nFor now, I'll assume the user runs it manually or through a script.\n\nIf time permits, I could add options for logging the output to a file instead of printing to the console.\n\nThat could be a useful feature for monitoring over longer periods.\n\nLet me add another option `-l` or `--log` to specify a log file.\n\nIf the log file is specified, the output is appended to that file instead of being printed to the console.\n\nI'll need to modify the script to handle this.\n\nFirst, add the option to getopts:\n\n```bash\nwhile getopts \":d:i:l:h\" opt; do\n  case $opt in\n    l)\n      log_file=\"$OPTARG\"\n      ;;\n    # ... other options ...\n  esac\ndone\n```\n\nThen, if `log_file` is set, redirect the output to that file.\n\nI can use `exec` to redirect stdout to the log file.\n\n```bash\nif [ -n \"$log_file\" ]; then\n    exec >> \"$log_file\" 2>&1\nfi\n```\n\nPlace this after parsing the options.\n\nNow, all output will be redirected to the log file.\n\nLet me update the script accordingly.\n\n```bash\n#!/bin/bash\n\n# Default values\ndisk=\"/\"\ninterval=60\nlog_file=\"\"\n\n# Parse command-line options\nwhile getopts \":d:i:l:h\" opt; do\n  case $opt in\n    d)\n      disk=\"$OPTARG\"\n      ;;\n    i)\n      interval=\"$OPTARG\"\n      ;;\n    l)\n      log_file=\"$OPTARG\"\n      ;;\n    h)\n      echo \"Usage: $0 [-d <disk>] [-i <interval>] [-l <logfile>] [-h]\"\n      echo \"Options:\"\n      echo \"  -d, --disk   Specify the disk mount point to monitor (default: /)\"\n      echo \"  -i, --interval Specify the interval in seconds between measurements (default: 60)\"\n      echo \"  -l, --log    Specify a log file to append the output (default: print to console)\"\n      echo \"  -h, --help   Show this help message and exit\"\n      exit 0\n      ;;\n    \\?)\n      echo \"Invalid option: -$OPTARG\" >&2\n      exit 1\n      ;;\n    :)\n      echo \"Option -$OPTARG requires an argument.\" >&2\n      exit 1\n      ;;\n  esac\ndone\n\n# Validate disk path\nif ! df \"$disk\" &> /dev/null; then\n    echo \"Error: Invalid disk mount point: $disk\"\n    exit 1\nfi\n\n# Validate interval\nif ! [[ \"$interval\" =~ ^[0-9]+$ ]] || [ \"$interval\" -le 0 ]; then\n    echo \"Error: Interval must be a positive integer.\"\n    exit 1\nfi\n\n# Redirect output to log file if specified\nif [ -n \"$log_file\" ]; then\n    exec >> \"$log_file\" 2>&1\nfi\n\n# Header\necho \"System Resource Monitor\"\necho \"Timestamp          CPU Usage (%)  Memory Usage (%)  Disk Usage (%)\"\n\nwhile true\ndo\n    current_time=$(date +\"%Y-%m-%d %T\")\n    cpu_usage=$(awk '/^cpu / {total=$2+$3+$4+$5+$6+$7+$8+$9+$10; idle=$5+$6; usage=100*(total-idle)/total; printf \"%.2f\", usage}' /proc/stat)\n    mem_usage=$(free -m | awk 'NR==2{printf \"%.2f\", $3*100/$2 }')\n    disk_usage=$(df \"$disk\" | awk 'NR==2{sub(\"%\",\"\",$5); printf \"%s\", $5}')\n    \n    printf \"%-19s  %-14s  %-14s  %-14s\\n\" \"$current_time\" \"$cpu_usage\" \"$mem_usage\" \"$disk_usage\"\n    \n    sleep \"$interval\"\ndone\n```\n\nNow, the script can log to a file if specified.\n\nI should also consider adding a way to stop the script gracefully, maybe by catching SIGINT or SIGTERM and exiting cleanly.\n\nBut for now, I'll assume the user will ctrl+c to stop it.\n\nAnother enhancement could be to include more detailed statistics or to monitor additional resources, but that might be beyond the scope of this task.\n\nI think this script should satisfy the requirements.\n\n## Final Solution\nTo monitor system resource usage, you can use the following bash script. This script prints the current CPU usage percentage, memory usage percentage, and disk usage percentage every specified interval.\n\n### Script Code\n\n```bash\n#!/bin/bash\n\n# Default values\ndisk=\"/\"\ninterval=60\nlog_file=\"\"\n\n# Parse command-line options\nwhile getopts \":d:i:l:h\" opt; do\n  case $opt in\n    d)\n      disk=\"$OPTARG\"\n      ;;\n    i)\n      interval=\"$OPTARG\"\n      ;;\n    l)\n      log_file=\"$OPTARG\"\n      ;;\n    h)\n      echo \"Usage: $0 [-d <disk>] [-i <interval>] [-l <logfile>] [-h]\"\n      echo \"Options:\"\n      echo \"  -d, --disk   Specify the disk mount point to monitor (default: /)\"\n      echo \"  -i, --interval Specify the interval in seconds between measurements (default: 60)\"\n      echo \"  -l, --log    Specify a log file to append the output (default: print to console)\"\n      echo \"  -h, --help   Show this help message and exit\"\n      exit 0\n      ;;\n    \\?)\n      echo \"Invalid option: -$OPTARG\" >&2\n      exit 1\n      ;;\n    :)\n      echo \"Option -$OPTARG requires an argument.\" >&2\n      exit 1\n      ;;\n  esac\ndone\n\n# Validate disk path\nif ! df \"$disk\" &> /dev/null; then\n    echo \"Error: Invalid disk mount point: $disk\"\n    exit 1\nfi\n\n# Validate interval\nif ! [[ \"$interval\" =~ ^[0-9]+$ ]] || [ \"$interval\" -le 0 ]; then\n    echo \"Error: Interval must be a positive integer.\"\n    exit 1\nfi\n\n# Redirect output to log file if specified\nif [ -n \"$log_file\" ]; then\n    exec >> \"$log_file\" 2>&1\nfi\n\n# Header\necho \"System Resource Monitor\"\necho \"Timestamp          CPU Usage (%)  Memory Usage (%)  Disk Usage (%)\"\n\nwhile true\ndo\n    current_time=$(date +\"%Y-%m-%d %T\")\n    cpu_usage=$(awk '/^cpu / {total=$2+$3+$4+$5+$6+$7+$8+$9+$10; idle=$5+$6; usage=100*(total-idle)/total; printf \"%.2f\", usage}' /proc/stat)\n    mem_usage=$(free -m | awk 'NR==2{printf \"%.2f\", $3*100/$2 }')\n    disk_usage=$(df \"$disk\" | awk 'NR==2{sub(\"%\",\"\",$5); printf \"%s\", $5}')\n    \n    printf \"%-19s  %-14s  %-14s  %-14s\\n\" \"$current_time\" \"$cpu_usage\" \"$mem_usage\" \"$disk_usage\"\n    \n    sleep \"$interval\"\ndone\n```\n\n### Explanation\n\n1. **Defaults and Options Parsing**:\n   - The script monitors the root filesystem by default but allows specifying a different disk partition using `-d`.\n   - The interval between measurements defaults to 60 seconds but can be adjusted with `-i`.\n   - Output can be logged to a file using `-l`, or it prints to the console by default.\n   - `-h` displays help information.\n\n2. **Validation**:\n   - Ensures the specified disk mount point is valid.\n   - Verifies the interval is a positive integer.\n\n3. **Resource Monitoring**:\n   - **CPU Usage**: Calculated from `/proc/stat` for accuracy.\n   - **Memory Usage**: Retrieved using `free -m`.\n   - **Disk Usage**: Checked via `df` for the specified mount point.\n\n4. **Output**:\n   - Prints a header, followed by timestamped resource usage percentages.\n   - Continuously loops, sleeping for the specified interval between each measurement.\n\nThis script provides a straightforward way to monitor key system resources at regular intervals, with options for flexibility and logging."
    }
]