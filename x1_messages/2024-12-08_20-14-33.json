[
    {
        "role": "user",
        "content": "Design a TypeScript implementation of a priority queue using a min-heap data structure. Include methods for insertion, deletion, and finding the minimum element.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Sure! Implementing a priority queue using a min-heap in TypeScript involves creating a class that manages elements with priorities, where the element with the highest priority (in this case, the smallest value) is always at the front. A min-heap is a complete binary tree where each node is smaller than its children, making it efficient for these operations.\n\nBelow is a TypeScript implementation of such a priority queue:\n\n```typescript\nclass MinHeap {\n    private heap: number[];\n\n    constructor() {\n        this.heap = [];\n    }\n\n    private getParentIndex(index: number): number {\n        return Math.floor((index - 1) / 2);\n    }\n\n    private getLeftChildIndex(index: number): number {\n        return 2 * index + 1;\n    }\n\n    private getRightChildIndex(index: number): number {\n        return 2 * index + 2;\n    }\n\n    private swap(index1: number, index2: number): void {\n        [this.heap[index1], this.heap[index2]] = [this.heap[index2], this.heap[index1]];\n    }\n\n    private heapifyUp(index: number): void {\n        let current = index;\n        const parent = this.getParentIndex(current);\n\n        while (current > 0 && this.heap[current] < this.heap[parent]) {\n            this.swap(current, parent);\n            current = parent;\n            parent = this.getParentIndex(current);\n        }\n    }\n\n    private heapifyDown(index: number): void {\n        let current = index;\n        const left = this.getLeftChildIndex(current);\n        const right = this.getRightChildIndex(current);\n        let smallest = current;\n\n        if (left < this.heap.length && this.heap[left] < this.heap[smallest]) {\n            smallest = left;\n        }\n\n        if (right < this.heap.length && this.heap[right] < this.heap[smallest]) {\n            smallest = right;\n        }\n\n        if (smallest !== current) {\n            this.swap(current, smallest);\n            this.heapifyDown(smallest);\n        }\n    }\n\n    public insert(value: number): void {\n        this.heap.push(value);\n        this.heapifyUp(this.heap.length - 1);\n    }\n\n    public deleteMin(): number | undefined {\n        if (this.heap.length === 0) {\n            return undefined;\n        }\n\n        if (this.heap.length === 1) {\n            return this.heap.pop();\n        }\n\n        const min = this.heap[0];\n        this.heap[0] = this.heap.pop() as number;\n        this.heapifyDown(0);\n        return min;\n    }\n\n    public findMin(): number | undefined {\n        return this.heap.length > 0 ? this.heap[0] : undefined;\n    }\n\n    public size(): number {\n        return this.heap.length;\n    }\n\n    public toArray(): number[] {\n        return this.heap;\n    }\n}\n\n// Example usage:\nconst pq = new MinHeap();\npq.insert(3);\npq.insert(1);\npq.insert(4);\npq.insert(1);\npq.insert(5);\n\nconsole.log(pq.findMin()); // Outputs: 1\nconsole.log(pq.deleteMin()); // Outputs: 1\nconsole.log(pq.findMin()); // Outputs: 1\nconsole.log(pq.deleteMin()); // Outputs: 1\nconsole.log(pq.findMin()); // Outputs: 3\n```\n\n### Explanation:\n\n1. **MinHeap Class**:\n   - **heap**: An array to store the heap elements.\n   - **getParentIndex**, **getLeftChildIndex**, **getRightChildIndex**: Helper methods to calculate indices of parent and children nodes.\n   - **swap**: Swaps two elements in the heap array.\n   - **heapifyUp**: Moves a newly added element up to its correct position to maintain the heap property.\n   - **heapifyDown**: Moves an element down to its correct position to maintain the heap property after deletion.\n\n2. **Methods**:\n   - **insert(value)**: Adds a value to the heap and maintains the heap property by heapifying up.\n   - **deleteMin()**: Removes and returns the smallest element (root of the heap), then maintains the heap property by heapifying down.\n   - **findMin()**: Returns the smallest element without removing it.\n   - **size()**: Returns the number of elements in the heap.\n   - **toArray()**: Returns the heap as an array (for debugging or inspection purposes).\n\nThis implementation ensures that insertion and deletion operations are efficient, operating in O(log n) time complexity due to the heap properties."
    }
]