[
    {
        "role": "user",
        "content": "Design a TypeScript implementation of a priority queue using a min-heap data structure. Include methods for insertion, deletion, and finding the minimum element."
    },
    {
        "role": "assistant",
        "content": "Certainly! Below is a TypeScript implementation of a priority queue using a min-heap data structure. This implementation includes methods for insertion, deletion, and finding the minimum element.\n\nFirst, make sure you have TypeScript set up in your environment. If not, you can install it via npm:\n\n```bash\nnpm install -g typescript\n```\n\nNow, let's create a file named `PriorityQueue.ts` and implement the priority queue.\n\n## Final Solution\n\nTo solve this problem, we will implement a priority queue using a min-heap data structure in TypeScript. The priority queue will support insertion, deletion, and finding the minimum element efficiently.\n\n### Approach\n\n1. **Min-Heap Implementation**:\n   - A min-heap is a complete binary tree where the parent node is less than or equal to its children.\n   - We will use an array to represent the heap, where the root is at index 0.\n   - Methods will include `insert`, `extractMin`, and `getMin`.\n\n2. **Heap Operations**:\n   - **Insertion**: Add the new element to the end of the array and then swim it up to its correct position.\n   - **Extraction of Minimum**: Remove the root element (minimum element), move the last element to the root, and then sink it down to its correct position.\n   - **Finding Minimum**: Simply return the root element.\n\n3. **Helper Methods**:\n   - `swim`: Moves an element up the heap if it is smaller than its parent.\n   - `sink`: Moves an element down the heap if it is larger than its children.\n\n### Solution Code\n\n```typescript\nclass MinHeapPriorityQueue {\n    private heap: number[];\n\n    constructor() {\n        this.heap = [];\n    }\n\n    /**\n     * Insert a new element into the priority queue.\n     * @param value The element to be inserted.\n     */\n    insert(value: number): void {\n        this.heap.push(value);\n        this.swim(this.heap.length - 1);\n    }\n\n    /**\n     * Remove and return the minimum element from the priority queue.\n     * @returns The minimum element.\n     */\n    extractMin(): number | undefined {\n        if (this.heap.length === 0) return undefined;\n        const min = this.heap[0];\n        const last = this.heap.pop();\n        if (this.heap.length > 0 && last !== undefined) {\n            this.heap[0] = last;\n            this.sink(0);\n        }\n        return min;\n    }\n\n    /**\n     * Get the minimum element without removing it.\n     * @returns The minimum element.\n     */\n    getMin(): number | undefined {\n        return this.heap.length > 0 ? this.heap[0] : undefined;\n    }\n\n    /**\n     * Swim the element at the given index up to its correct position.\n     * @param index The index of the element to swim.\n     */\n    private swim(index: number): void {\n        while (index > 0) {\n            const parentIndex = Math.floor((index - 1) / 2);\n            if (this.heap[parentIndex] > this.heap[index]) {\n                [this.heap[parentIndex], this.heap[index]] = [this.heap[index], this.heap[parentIndex]];\n                index = parentIndex;\n            } else {\n                break;\n            }\n        }\n    }\n\n    /**\n     * Sink the element at the given index down to its correct position.\n     * @param index The index of the element to sink.\n     */\n    private sink(index: number): void {\n        const length = this.heap.length;\n        while (true) {\n            let smallest = index;\n            const leftChild = 2 * index + 1;\n            const rightChild = 2 * index + 2;\n\n            if (leftChild < length && this.heap[leftChild] < this.heap[smallest]) {\n                smallest = leftChild;\n            }\n\n            if (rightChild < length && this.heap[rightChild] < this.heap[smallest]) {\n                smallest = rightChild;\n            }\n\n            if (smallest !== index) {\n                [this.heap[index], this.heap[smallest]] = [this.heap[smallest], this.heap[index]];\n                index = smallest;\n            } else {\n                break;\n            }\n        }\n    }\n}\n\n// Example usage:\nconst pq = new MinHeapPriorityQueue();\npq.insert(3);\npq.insert(1);\npq.insert(4);\npq.insert(1);\npq.insert(5);\n\nconsole.log(pq.extractMin()); // Output: 1\nconsole.log(pq.extractMin()); // Output: 1\nconsole.log(pq.getMin());     // Output: 3\n```\n\n### Explanation\n\n1. **MinHeapPriorityQueue Class**:\n   - **heap**: An array to store the heap elements.\n   - **insert(value)**: Adds the value to the heap and swims it up to maintain the heap property.\n   - **extractMin()**: Removes and returns the smallest element, then sinks down the new root to maintain the heap property.\n   - **getMin()**: Returns the smallest element without removing it.\n\n2. **Helper Methods**:\n   - **swim(index)**: Moves the element at the given index up the heap if it is smaller than its parent.\n   - **sink(index)**: Moves the element at the given index down the heap if it is larger than its children.\n\nThis implementation ensures that insertion and deletion operations are efficient, maintaining the heap property at all times."
    }
]