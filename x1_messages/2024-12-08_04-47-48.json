[
    {
        "role": "user",
        "content": "Write a Python script that monitors a directory for new files and automatically compresses them into a .zip archive once they are detected.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Alright, I've got this task to create a Python script that watches a specific directory for any new files and automatically zips them up as soon as they appear. Sounds pretty straightforward, but I need to make sure I cover all the bases here.\n\nFirst things first, I need to decide how to monitor the directory for new files. In Python, there's a library called `watchdog` that's perfect for this kind of job. It allows you to set up event handlers that trigger when specific file system events occur, like creating, modifying, or deleting files. So, I'll need to install that package if it's not already available.\n\nI can install `watchdog` using pip:\n\n```bash\npip install watchdog\n```\n\nOnce I have `watchdog`, I can set up an event handler that listens for new files being created in the directory we're interested in. When a new file is detected, the handler will be triggered, and I can have it perform the zipping operation.\n\nBut before diving into the code, I should think about a few things:\n\n1. **Directory Path:** The script needs to know which directory to watch. It would be good to make this configurable, maybe through command-line arguments or a configuration file.\n\n2. **Zip File Name:** When a new file is detected, how should the zip file be named? Should it include the original file's name, a timestamp, or something else?\n\n3. **Compression Level:** Python's `zipfile` module allows specifying the compression level. I can set this according to how much compression is needed versus the time it takes to compress.\n\n4. **Error Handling:** What if there are issues while compressing the file, like permission errors or disk space issues? The script should handle these gracefully and perhaps log the errors.\n\n5. **Performance:** If the directory gets a lot of files quickly, the script should handle the load without slowing down or missing events.\n\n6. **Security:** Need to ensure that the script doesn't zip sensitive files or execute any code from the files it's zipping.\n\n7. **Stopping the Script:** How to gracefully stop the script when needed.\n\nAlright, let's start by setting up the basic structure of the script using `watchdog`.\n\nFirst, import the necessary modules:\n\n```python\nimport sys\nimport time\nimport zipfile\nfrom watchdog.observers import Observer\nfrom watchdog.events import FileSystemEventHandler\nimport os\n```\n\nNext, I need to create an event handler class that inherits from `FileSystemEventHandler`. This class will have methods that handle different types of events. For now, I'm interested in the `on_created` event, which is triggered when a new file is created in the watched directory.\n\nHere's a skeleton of the event handler:\n\n```python\nclass NewFileHandler(FileSystemEventHandler):\n    def on_created(self, event):\n        if not event.is_directory:\n            self.compress_file(event.src_path)\n    \n    def compress_file(self, file_path):\n        # Logic to compress the file goes here\n        pass\n```\n\nIn the `compress_file` method, I'll use Python's `zipfile` module to create a zip archive containing the new file. I need to decide on the name of the zip file. One approach is to use the original file's name with a `.zip` extension. For example, if the new file is `document.txt`, the zip file would be `document.txt.zip`.\n\nHere's how I can implement the `compress_file` method:\n\n```python\ndef compress_file(self, file_path):\n    zip_path = file_path + '.zip'\n    with zipfile.ZipFile(zip_path, 'w') as zipf:\n        zipf.write(file_path, os.path.basename(file_path), zipfile.ZIP_DEFLATED)\n    print(f'Compressed {file_path} to {zip_path}')\n```\n\nThis code creates a zip file with the same name as the original file plus `.zip`, and adds the file to the zip archive with the original file's base name.\n\nNow, I need to set up the observer that will watch the directory for events. I'll need to specify the directory to watch and the event handler to use.\n\nHere's how to set up the observer:\n\n```python\nif __name__ == \"__main__\":\n    if len(sys.argv) < 2:\n        print(\"Usage: python script.py /path/to/directory\")\n        sys.exit(1)\n    \n    path = sys.argv[1]\n    event_handler = NewFileHandler()\n    observer = Observer()\n    observer.schedule(event_handler, path, recursive=False)\n    observer.start()\n    try:\n        while True:\n            time.sleep(1)\n    except KeyboardInterrupt:\n        observer.stop()\n    observer.join()\n```\n\nIn this code, the script expects the directory path as a command-line argument. It sets up the observer to watch the specified directory with the `NewFileHandler` event handler. The `observer.start()` method starts the observation in a separate thread, and the main thread sleeps to keep the program running. When the user interrupts the program (e.g., with Ctrl+C), the observer is stopped gracefully.\n\nLet me test this basic implementation. Suppose I have a directory `/tmp/watchme`, and I run the script with that path:\n\n```bash\npython script.py /tmp/watchme\n```\n\nNow, if I create a new file in `/tmp/watchme`, say `test.txt`, the script should detect it and create `test.txt.zip` in the same directory.\n\nSeems to work fine for this simple case. But I need to consider some edge cases and add more robustness.\n\nFirst, what if the file is being written to when the script tries to compress it? For example, if a large file is being uploaded or saved, it might not be fully written yet when the script detects its creation. To handle this, I could add a delay before compressing the file to give time for the file write operation to complete.\n\nI can modify the `on_created` method to include a delay:\n\n```python\ndef on_created(self, event):\n    if not event.is_directory:\n        time.sleep(5)  # Wait for 5 seconds to ensure the file is fully written\n        self.compress_file(event.src_path)\n```\n\nFive seconds might be enough for most cases, but it could be made configurable.\n\nAnother consideration is that multiple files might be created in quick succession, and the script should handle them all without overlapping or missing any.\n\nAlso, I should think about logging instead of just printing messages. Python's `logging` module can be used for this purpose. It's better than print statements for production-level scripts.\n\nLet me import the `logging` module and set it up:\n\n```python\nimport logging\n\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(message)s')\n```\n\nThen, replace the print statement in `compress_file` with a log message:\n\n```python\nlogging.info(f'Compressed {file_path} to {zip_path}')\n```\n\nThis will give timestamps and a more formal logging output.\n\nNext, I should handle exceptions that might occur during compression. For example, if there's a permission issue or disk space is full, the script should log the error instead of crashing.\n\nI can wrap the compression logic in a try-except block:\n\n```python\ndef compress_file(self, file_path):\n    zip_path = file_path + '.zip'\n    try:\n        with zipfile.ZipFile(zip_path, 'w') as zipf:\n            zipf.write(file_path, os.path.basename(file_path), zipfile.ZIP_DEFLATED)\n        logging.info(f'Compressed {file_path} to {zip_path}')\n    except Exception as e:\n        logging.error(f'Failed to compress {file_path}: {e}')\n```\n\nThis way, any errors during compression are caught and logged, and the script can continue running.\n\nAnother enhancement could be to move the compressed files to a different directory or delete the original after compression, depending on the requirements. But for now, I'll keep it simple and just create the zip file alongside the original.\n\nLet me also consider if the script should handle subdirectories. In the current implementation, `recursive=False` in `observer.schedule`, so it only watches the specified directory and not its subdirectories. If there's a need to watch subdirectories as well, I can set `recursive=True`.\n\nBut for this task, I'll keep it non-recursive to avoid unnecessary overhead.\n\nFinally, I should think about how to stop the script. Currently, it runs indefinitely until interrupted by the user. Depending on the use case, I might want to have other ways to stop it, like sending a signal or using a control file.\n\nFor now, the keyboard interrupt method is sufficient.\n\nLet me summarize the final script:\n\n```python\nimport sys\nimport time\nimport zipfile\nfrom watchdog.observers import Observer\nfrom watchdog.events import FileSystemEventHandler\nimport os\nimport logging\n\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(message)s')\n\nclass NewFileHandler(FileSystemEventHandler):\n    def on_created(self, event):\n        if not event.is_directory:\n            time.sleep(5)  # Wait for 5 seconds to ensure the file is fully written\n            self.compress_file(event.src_path)\n    \n    def compress_file(self, file_path):\n        zip_path = file_path + '.zip'\n        try:\n            with zipfile.ZipFile(zip_path, 'w') as zipf:\n                zipf.write(file_path, os.path.basename(file_path), zipfile.ZIP_DEFLATED)\n            logging.info(f'Compressed {file_path} to {zip_path}')\n        except Exception as e:\n            logging.error(f'Failed to compress {file_path}: {e}')\n\nif __name__ == \"__main__\":\n    if len(sys.argv) < 2:\n        print(\"Usage: python script.py /path/to/directory\")\n        sys.exit(1)\n    \n    path = sys.argv[1]\n    event_handler = NewFileHandler()\n    observer = Observer()\n    observer.schedule(event_handler, path, recursive=False)\n    observer.start()\n    try:\n        while True:\n            time.sleep(1)\n    except KeyboardInterrupt:\n        observer.stop()\n    observer.join()\n```\n\nThis script should fulfill the requirement of monitoring a directory for new files and automatically compressing them into zip archives.\n\n## Final Solution\nTo create a Python script that monitors a directory for new files and automatically compresses them into a `.zip` archive, you can use the `watchdog` library for file system event monitoring and the `zipfile` module for compression.\n\n### Solution Code\n\n```python\nimport sys\nimport time\nimport zipfile\nfrom watchdog.observers import Observer\nfrom watchdog.events import FileSystemEventHandler\nimport os\nimport logging\n\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(message)s')\n\nclass NewFileHandler(FileSystemEventHandler):\n    def on_created(self, event):\n        if not event.is_directory:\n            time.sleep(5)  # Wait for 5 seconds to ensure the file is fully written\n            self.compress_file(event.src_path)\n    \n    def compress_file(self, file_path):\n        zip_path = file_path + '.zip'\n        try:\n            with zipfile.ZipFile(zip_path, 'w') as zipf:\n                zipf.write(file_path, os.path.basename(file_path), zipfile.ZIP_DEFLATED)\n            logging.info(f'Compressed {file_path} to {zip_path}')\n        except Exception as e:\n            logging.error(f'Failed to compress {file_path}: {e}')\n\nif __name__ == \"__main__\":\n    if len(sys.argv) < 2:\n        print(\"Usage: python script.py /path/to/directory\")\n        sys.exit(1)\n    \n    path = sys.argv[1]\n    event_handler = NewFileHandler()\n    observer = Observer()\n    observer.schedule(event_handler, path, recursive=False)\n    observer.start()\n    try:\n        while True:\n            time.sleep(1)\n    except KeyboardInterrupt:\n        observer.stop()\n    observer.join()\n```\n\n### Explanation\n\n1. **Monitoring Directory Changes**: The `watchdog` library is used to monitor the specified directory for new files. It provides an `Observer` that watches for file system events and an `EventHandler` to handle these events.\n\n2. **Handling New Files**: The `NewFileHandler` class inherits from `FileSystemEventHandler` and overrides the `on_created` method to handle new file creation events. A 5-second delay is introduced to ensure the file is fully written before attempting to compress it.\n\n3. **Compressing Files**: The `compress_file` method creates a `.zip` archive of the new file using Python's `zipfile` module. It logs information about the compression process using Python's `logging` module.\n\n4. **Script Execution**: The script takes the directory path as a command-line argument. It starts the `Observer` to begin monitoring and runs indefinitely until interrupted (e.g., via Ctrl+C).\n\nThis script ensures that any new files created in the specified directory are automatically compressed into `.zip` archives, providing a efficient way to manage and archive files as they are added."
    }
]