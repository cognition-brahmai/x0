[
    {
        "role": "user",
        "content": "Write a Java program that reads a CSV file containing user information (first name, last name, email, and age) and stores the data in an SQLite database. The program should handle exceptions for missing or invalid data and provide meaningful error messages.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Alright, I have this task to create a Java program that reads a CSV file with user information\u2014first name, last name, email, and age\u2014and then stores this data into an SQLite database. Also, I need to make sure that the program handles exceptions properly, especially for missing or invalid data, and gives useful error messages.\n\nFirst, I need to set up my environment. Since I'm using Java, I'll need to make sure I have the JDK installed, and I'll also need the SQLite JDBC driver because Java doesn't come with built-in support for SQLite.\n\nTo get the SQLite JDBC driver, I can download it from the official website or include it via Maven or Gradle if I'm using a build tool. For simplicity, I'll assume I'm using Maven, so I'll add the dependency to my pom.xml:\n\n```xml\n<dependency>\n    <groupId>org.xerial</groupId>\n    <artifactId>sqlite-jdbc</artifactId>\n    <version>3.36.0.3</version>\n</dependency>\n```\n\nNext, I need to design the CSV file format. Let's assume the CSV file has columns in this order: first_name, last_name, email, age. It's a good idea to have a header row, but I'll make it optional in the program.\n\nI'll need to read the CSV file. For reading CSV files in Java, I can use the built-in classes like BufferedReader and Scanner, but handling CSV can be tricky due to potential quotes and delimiters within fields. So, it's better to use a library like OpenCSV, which simplifies reading and writing CSV files.\n\nI'll add the OpenCSV dependency to my pom.xml:\n\n```xml\n<dependency>\n    <groupId>com.opencsv</groupId>\n    <artifactId>opencsv</artifactId>\n    <version>5.5.2</version>\n</dependency>\n```\n\nNow, I'll create a class to represent a user. Let's call it User.\n\n```java\npublic class User {\n    private String firstName;\n    private String lastName;\n    private String email;\n    private int age;\n\n    // Constructors, getters, and setters\n}\n```\n\nI need to validate the user data. For example, names should not be empty, email should be in a valid format, and age should be a positive integer.\n\nI can create a method to validate the user data.\n\n```java\npublic static boolean isValidUser(User user) {\n    if (user.getFirstName() == null || user.getFirstName().trim().isEmpty()) {\n        System.err.println(\"First name is required.\");\n        return false;\n    }\n    if (user.getLastName() == null || user.getLastName().trim().isEmpty()) {\n        System.err.println(\"Last name is required.\");\n        return false;\n    }\n    if (user.getEmail() == null || !user.getEmail().matches(\"^[\\\\w.-]+@[\\\\w.-]+\\\\.\\\\w+$\")) {\n        System.err.println(\"Invalid email format.\");\n        return false;\n    }\n    if (user.getAge() < 0) {\n        System.err.println(\"Age cannot be negative.\");\n        return false;\n    }\n    return true;\n}\n```\n\nNext, I need to set up the SQLite database. I'll create a table to store user information.\n\nThe SQL statement for creating the table could be:\n\n```sql\nCREATE TABLE users (\n    id INTEGER PRIMARY KEY AUTOINCREMENT,\n    first_name TEXT NOT NULL,\n    last_name TEXT NOT NULL,\n    email TEXT NOT NULL UNIQUE,\n    age INTEGER NOT NULL\n);\n```\n\nI'll write a method to initialize the database and create the table if it doesn't exist.\n\n```java\npublic static void initDatabase(Connection conn) throws SQLException {\n    String sql = \"CREATE TABLE IF NOT EXISTS users (\" +\n                    \"id INTEGER PRIMARY KEY AUTOINCREMENT,\" +\n                    \"first_name TEXT NOT NULL,\" +\n                    \"last_name TEXT NOT NULL,\" +\n                    \"email TEXT NOT NULL UNIQUE,\" +\n                    \"age INTEGER NOT NULL\" +\n                 \");\";\n    try (Statement stmt = conn.createStatement()) {\n        stmt.execute(sql);\n    }\n}\n```\n\nNow, I need to read the CSV file and insert the data into the database.\n\nFirst, I'll use OpenCSV to read the CSV file.\n\n```java\nReader reader = new FileReader(\"users.csv\");\nCSVReader csvReader = new CSVReader(reader);\nString[] line;\nwhile ((line = csvReader.readNext()) != null) {\n    // process each line\n}\n```\n\nFor each line, I'll create a User object and validate it. If valid, I'll insert it into the database; otherwise, I'll log an error.\n\nBut I need to handle cases where the CSV might have missing fields or extra fields.\n\nTo make it robust, I'll assume that the CSV has exactly four fields per row, corresponding to first name, last name, email, and age.\n\nI'll also handle the header row. If the first row has column names, I'll skip it.\n\nTo detect if the first row is a header, I can check if the first row contains strings like \"first_name\", \"last_name\", \"email\", \"age\".\n\nAlternatively, I can always skip the first row if it's a header.\n\nFor simplicity, I'll assume the first row is the header and skip it.\n\nSo, in the CSVReader, I'll call csvReader.readNext() once to skip the header.\n\nThen, for each subsequent row, I'll create a User object.\n\nBut I need to handle cases where some fields are missing or empty.\n\nFor example, if a row has only three fields instead of four, I'll need to handle that.\n\nI can check the length of the line array and ensure it has exactly four elements.\n\nIf not, I'll log an error for that row.\n\nAlso, for the age field, which is supposed to be an integer, I need to parse it and handle parsing exceptions.\n\nSo, I'll wrap the parsing in a try-catch block.\n\nHere's some pseudocode for processing each row:\n\n```java\nwhile ((line = csvReader.readNext()) != null) {\n    if (line.length != 4) {\n        System.err.println(\"Invalid row: expected 4 fields, got \" + line.length);\n        continue;\n    }\n    String firstName = line[0].trim();\n    String lastName = line[1].trim();\n    String email = line[2].trim();\n    String ageStr = line[3].trim();\n    int age;\n    try {\n        age = Integer.parseInt(ageStr);\n    } catch (NumberFormatException e) {\n        System.err.println(\"Invalid age: \" + ageStr);\n        continue;\n    }\n    User user = new User(firstName, lastName, email, age);\n    if (isValidUser(user)) {\n        insertUserIntoDatabase(conn, user);\n    }\n}\n```\n\nI need to write the insertUserIntoDatabase method.\n\nIt should insert the user into the users table.\n\nTo avoid SQL injection, I'll use PreparedStatements.\n\nHere's how I can do it:\n\n```java\npublic static void insertUserIntoDatabase(Connection conn, User user) throws SQLException {\n    String sql = \"INSERT INTO users (first_name, last_name, email, age) VALUES (?, ?, ?, ?);\";\n    try (PreparedStatement pstmt = conn.prepareStatement(sql)) {\n        pstmt.setString(1, user.getFirstName());\n        pstmt.setString(2, user.getLastName());\n        pstmt.setString(3, user.getEmail());\n        pstmt.setInt(4, user.getAge());\n        pstmt.executeUpdate();\n    } catch (SQLException e) {\n        System.err.println(\"Error inserting user: \" + user);\n        e.printStackTrace();\n    }\n}\n```\n\nI should also handle unique constraints, for example, if the email already exists in the database.\n\nSQLite will throw a constraint violation exception in that case.\n\nI can catch that specific exception and provide a meaningful error message.\n\nTo do that, I need to check the SQL exception's error code or error message.\n\nIn SQLite, constraint violations have a specific error code.\n\nI can check if the error code is SQLITE_CONSTRAINT (which is 19), and then handle it accordingly.\n\nHere's an updated version of the insert method:\n\n```java\npublic static void insertUserIntoDatabase(Connection conn, User user) throws SQLException {\n    String sql = \"INSERT INTO users (first_name, last_name, email, age) VALUES (?, ?, ?, ?);\";\n    try (PreparedStatement pstmt = conn.prepareStatement(sql)) {\n        pstmt.setString(1, user.getFirstName());\n        pstmt.setString(2, user.getLastName());\n        pstmt.setString(3, user.getEmail());\n        pstmt.setInt(4, user.getAge());\n        pstmt.executeUpdate();\n    } catch (SQLException e) {\n        if (e.getErrorCode() == 19) { // SQLITE_CONSTRAINT\n            System.err.println(\"Email already exists: \" + user.getEmail());\n        } else {\n            System.err.println(\"Error inserting user: \" + user);\n            e.printStackTrace();\n        }\n    }\n}\n```\n\nNow, I need to put all these pieces together in the main method.\n\nFirst, establish a connection to the SQLite database.\n\nThen, initialize the database by creating the users table if it doesn't exist.\n\nThen, read the CSV file and process each row as described.\n\nFinally, close the database connection.\n\nHere's the main method structure:\n\n```java\npublic static void main(String[] args) {\n    Connection conn = null;\n    try {\n        // load SQLite JDBC driver\n        Class.forName(\"org.sqlite.JDBC\");\n        \n        // create a connection to the database\n        conn = DriverManager.getConnection(\"jdbc:sqlite:user_data.db\");\n        \n        // initialize the database\n        initDatabase(conn);\n        \n        // read the CSV file and insert data into the database\n        readAndInsertCSVData(conn, \"users.csv\");\n        \n        System.out.println(\"Data import completed successfully.\");\n    } catch (ClassNotFoundException e) {\n        System.err.println(\"SQLite JDBC driver not found.\");\n        e.printStackTrace();\n    } catch (SQLException e) {\n        System.err.println(\"Database operation failed.\");\n        e.printStackTrace();\n    } finally {\n        try {\n            if (conn != null) {\n                conn.close();\n            }\n        } catch (SQLException e) {\n            System.err.println(\"Database connection close failed.\");\n            e.printStackTrace();\n        }\n    }\n}\n```\n\nI need to implement the readAndInsertCSVData method.\n\nIt should handle reading the CSV file, skipping the header, processing each row, validating the user data, and inserting into the database.\n\nHere's how it can be done:\n\n```java\npublic static void readAndInsertCSVData(Connection conn, String csvFilePath) {\n    try (Reader reader = new FileReader(csvFilePath);\n         CSVReader csvReader = new CSVReader(reader)) {\n        \n        // skip header\n        csvReader.readNext();\n        \n        String[] line;\n        while ((line = csvReader.readNext()) != null) {\n            if (line.length != 4) {\n                System.err.println(\"Invalid row: expected 4 fields, got \" + line.length);\n                continue;\n            }\n            String firstName = line[0].trim();\n            String lastName = line[1].trim();\n            String email = line[2].trim();\n            String ageStr = line[3].trim();\n            int age;\n            try {\n                age = Integer.parseInt(ageStr);\n            } catch (NumberFormatException e) {\n                System.err.println(\"Invalid age: \" + ageStr);\n                continue;\n            }\n            User user = new User(firstName, lastName, email, age);\n            if (isValidUser(user)) {\n                insertUserIntoDatabase(conn, user);\n            }\n        }\n    } catch (IOException e) {\n        System.err.println(\"Error reading CSV file.\");\n        e.printStackTrace();\n    } catch (SQLException e) {\n        System.err.println(\"Database operation failed.\");\n        e.printStackTrace();\n    }\n}\n```\n\nI should also handle cases where the CSV file doesn't exist or can't be read.\n\nI can catch FileNotFoundException and provide a meaningful message.\n\nAdditionally, I can add command-line arguments to specify the CSV file path and the database file path, making the program more flexible.\n\nFor example, the user can run the program like this:\n\n```\njava CSVToSQLite users.csv user_data.db\n```\n\nTo do that, I'll modify the main method to accept command-line arguments.\n\nHere's an updated main method:\n\n```java\npublic static void main(String[] args) {\n    if (args.length < 2) {\n        System.err.println(\"Usage: java CSVToSQLite <csv_file_path> <database_file_path>\");\n        return;\n    }\n    String csvFilePath = args[0];\n    String dbFilePath = args[1];\n    \n    Connection conn = null;\n    try {\n        // load SQLite JDBC driver\n        Class.forName(\"org.sqlite.JDBC\");\n        \n        // create a connection to the database\n        conn = DriverManager.getConnection(\"jdbc:sqlite:\" + dbFilePath);\n        \n        // initialize the database\n        initDatabase(conn);\n        \n        // read the CSV file and insert data into the database\n        readAndInsertCSVData(conn, csvFilePath);\n        \n        System.out.println(\"Data import completed successfully.\");\n    } catch (ClassNotFoundException e) {\n        System.err.println(\"SQLite JDBC driver not found.\");\n        e.printStackTrace();\n    } catch (SQLException e) {\n        System.err.println(\"Database operation failed.\");\n        e.printStackTrace();\n    } finally {\n        try {\n            if (conn != null) {\n                conn.close();\n            }\n        } catch (SQLException e) {\n            System.err.println(\"Database connection close failed.\");\n            e.printStackTrace();\n        }\n    }\n}\n```\n\nThis way, the program is more versatile and can be used with different CSV and database files.\n\nI should also add some logging or status messages to inform the user about the progress, like how many records were read from the CSV, how many were inserted into the database, and how many were invalid.\n\nTo do that, I can keep counters for these statistics.\n\nHere's an updated version of the readAndInsertCSVData method with counters:\n\n```java\npublic static void readAndInsertCSVData(Connection conn, String csvFilePath) {\n    int totalRecords = 0;\n    int insertedRecords = 0;\n    int invalidRecords = 0;\n    \n    try (Reader reader = new FileReader(csvFilePath);\n         CSVReader csvReader = new CSVReader(reader)) {\n        \n        // skip header\n        csvReader.readNext();\n        \n        String[] line;\n        while ((line = csvReader.readNext()) != null) {\n            totalRecords++;\n            if (line.length != 4) {\n                System.err.println(\"Invalid row: expected 4 fields, got \" + line.length);\n                invalidRecords++;\n                continue;\n            }\n            String firstName = line[0].trim();\n            String lastName = line[1].trim();\n            String email = line[2].trim();\n            String ageStr = line[3].trim();\n            int age;\n            try {\n                age = Integer.parseInt(ageStr);\n            } catch (NumberFormatException e) {\n                System.err.println(\"Invalid age: \" + ageStr);\n                invalidRecords++;\n                continue;\n            }\n            User user = new User(firstName, lastName, email, age);\n            if (isValidUser(user)) {\n                insertUserIntoDatabase(conn, user);\n                insertedRecords++;\n            } else {\n                invalidRecords++;\n            }\n        }\n    } catch (IOException e) {\n        System.err.println(\"Error reading CSV file.\");\n        e.printStackTrace();\n    } catch (SQLException e) {\n        System.err.println(\"Database operation failed.\");\n        e.printStackTrace();\n    }\n    \n    System.out.println(\"Total records read from CSV: \" + totalRecords);\n    System.out.println(\"Records inserted into database: \" + insertedRecords);\n    System.out.println(\"Invalid records skipped: \" + invalidRecords);\n}\n```\n\nThis will give the user a clear overview of what happened during the import process.\n\nI should also consider batch inserts for better performance, especially if the CSV file is large.\n\nIn SQLite, batch inserts can be performed by grouping multiple INSERT statements into a single transaction.\n\nI can modify the insertUserIntoDatabase method to use batch inserts.\n\nFirst, I'll need to keep track of multiple users to insert at once.\n\nAlternatively, I can wrap multiple inserts in a single database transaction.\n\nHere's how I can modify the readAndInsertCSVData method to use batch inserts:\n\n```java\npublic static void readAndInsertCSVData(Connection conn, String csvFilePath) throws SQLException, IOException {\n    int totalRecords = 0;\n    int insertedRecords = 0;\n    int invalidRecords = 0;\n    \n    try (Reader reader = new FileReader(csvFilePath);\n         CSVReader csvReader = new CSVReader(reader);\n         PreparedStatement pstmt = conn.prepareStatement(\"INSERT INTO users (first_name, last_name, email, age) VALUES (?, ?, ?, ?);\")) {\n        \n        // skip header\n        csvReader.readNext();\n        \n        String[] line;\n        while ((line = csvReader.readNext()) != null) {\n            totalRecords++;\n            if (line.length != 4) {\n                System.err.println(\"Invalid row: expected 4 fields, got \" + line.length);\n                invalidRecords++;\n                continue;\n            }\n            String firstName = line[0].trim();\n            String lastName = line[1].trim();\n            String email = line[2].trim();\n            String ageStr = line[3].trim();\n            int age;\n            try {\n                age = Integer.parseInt(ageStr);\n            } catch (NumberFormatException e) {\n                System.err.println(\"Invalid age: \" + ageStr);\n                invalidRecords++;\n                continue;\n            }\n            User user = new User(firstName, lastName, email, age);\n            if (isValidUser(user)) {\n                pstmt.setString(1, user.getFirstName());\n                pstmt.setString(2, user.getLastName());\n                pstmt.setString(3, user.getEmail());\n                pstmt.setInt(4, user.getAge());\n                pstmt.addBatch();\n                insertedRecords++;\n            } else {\n                invalidRecords++;\n            }\n        }\n        \n        // Execute the batch\n        pstmt.executeBatch();\n    }\n    \n    System.out.println(\"Total records read from CSV: \" + totalRecords);\n    System.out.println(\"Records inserted into database: \" + insertedRecords);\n    System.out.println(\"Invalid records skipped: \" + invalidRecords);\n}\n```\n\nHowever, I need to manage the batch size to optimize performance. Executing a large batch in one go might consume too much memory or cause other issues.\n\nI can set a batch size, say 1000, and execute the batch every 1000 records.\n\nHere's an improved version:\n\n```java\npublic static void readAndInsertCSVData(Connection conn, String csvFilePath) throws SQLException, IOException {\n    int totalRecords = 0;\n    int insertedRecords = 0;\n    int invalidRecords = 0;\n    final int BATCH_SIZE = 1000;\n    \n    try (Reader reader = new FileReader(csvFilePath);\n         CSVReader csvReader = new CSVReader(reader);\n         PreparedStatement pstmt = conn.prepareStatement(\"INSERT INTO users (first_name, last_name, email, age) VALUES (?, ?, ?, ?);\")) {\n        \n        // skip header\n        csvReader.readNext();\n        \n        String[] line;\n        while ((line = csvReader.readNext()) != null) {\n            totalRecords++;\n            if (line.length != 4) {\n                System.err.println(\"Invalid row: expected 4 fields, got \" + line.length);\n                invalidRecords++;\n                continue;\n            }\n            String firstName = line[0].trim();\n            String lastName = line[1].trim();\n            String email = line[2].trim();\n            String ageStr = line[3].trim();\n            int age;\n            try {\n                age = Integer.parseInt(ageStr);\n            } catch (NumberFormatException e) {\n                System.err.println(\"Invalid age: \" + ageStr);\n                invalidRecords++;\n                continue;\n            }\n            User user = new User(firstName, lastName, email, age);\n            if (isValidUser(user)) {\n                pstmt.setString(1, user.getFirstName());\n                pstmt.setString(2, user.getLastName());\n                pstmt.setString(3, user.getEmail());\n                pstmt.setInt(4, user.getAge());\n                pstmt.addBatch();\n                insertedRecords++;\n                if (insertedRecords % BATCH_SIZE == 0) {\n                    pstmt.executeBatch();\n                    conn.commit(); // commit after each batch\n                }\n            } else {\n                invalidRecords++;\n            }\n        }\n        \n        // Execute any remaining batches\n        if (insertedRecords % BATCH_SIZE != 0) {\n            pstmt.executeBatch();\n            conn.commit();\n        }\n    }\n    \n    System.out.println(\"Total records read from CSV: \" + totalRecords);\n    System.out.println(\"Records inserted into database: \" + insertedRecords);\n    System.out.println(\"Invalid records skipped: \" + invalidRecords);\n}\n```\n\nI also added conn.commit() after each batch to ensure that the transactions are committed periodically, which can help with performance and data integrity.\n\nAdditionally, I should set the auto-commit mode of the connection to false, as batch operations require manual commit.\n\nI can do this right after establishing the database connection:\n\n```java\nconn.setAutoCommit(false);\n```\n\nAnd in the finally block, set it back to true or handle it appropriately.\n\nNow, putting it all together, here's the complete Java program:\n\n```java\nimport com.opencsv.CSVReader;\nimport com.opencsv.exceptions.CsvException;\n\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.sql.*;\n\npublic class CSVToSQLite {\n\n    public static void main(String[] args) {\n        if (args.length < 2) {\n            System.err.println(\"Usage: java CSVToSQLite <csv_file_path> <database_file_path>\");\n            return;\n        }\n        String csvFilePath = args[0];\n        String dbFilePath = args[1];\n        \n        Connection conn = null;\n        try {\n            // load SQLite JDBC driver\n            Class.forName(\"org.sqlite.JDBC\");\n            \n            // create a connection to the database\n            conn = DriverManager.getConnection(\"jdbc:sqlite:\" + dbFilePath);\n            \n            // disable auto-commit for batch inserts\n            conn.setAutoCommit(false);\n            \n            // initialize the database\n            initDatabase(conn);\n            \n            // read the CSV file and insert data into the database\n            readAndInsertCSVData(conn, csvFilePath);\n            \n            System.out.println(\"Data import completed successfully.\");\n        } catch (ClassNotFoundException e) {\n            System.err.println(\"SQLite JDBC driver not found.\");\n            e.printStackTrace();\n        } catch (SQLException e) {\n            System.err.println(\"Database operation failed.\");\n            e.printStackTrace();\n        } catch (IOException e) {\n            System.err.println(\"Error reading CSV file.\");\n            e.printStackTrace();\n        } finally {\n            try {\n                if (conn != null) {\n                    conn.close();\n                }\n            } catch (SQLException e) {\n                System.err.println(\"Database connection close failed.\");\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public static void initDatabase(Connection conn) throws SQLException {\n        String sql = \"CREATE TABLE IF NOT EXISTS users (\" +\n                        \"id INTEGER PRIMARY KEY AUTOINCREMENT,\" +\n                        \"first_name TEXT NOT NULL,\" +\n                        \"last_name TEXT NOT NULL,\" +\n                        \"email TEXT NOT NULL UNIQUE,\" +\n                        \"age INTEGER NOT NULL\" +\n                     \");\";\n        try (Statement stmt = conn.createStatement()) {\n            stmt.execute(sql);\n        }\n    }\n\n    public static void readAndInsertCSVData(Connection conn, String csvFilePath) throws SQLException, IOException {\n        int totalRecords = 0;\n        int insertedRecords = 0;\n        int invalidRecords = 0;\n        final int BATCH_SIZE = 1000;\n        \n        try (Reader reader = new FileReader(csvFilePath);\n             CSVReader csvReader = new CSVReader(reader);\n             PreparedStatement pstmt = conn.prepareStatement(\"INSERT INTO users (first_name, last_name, email, age) VALUES (?, ?, ?, ?);\")) {\n            \n            // skip header\n            csvReader.readNext();\n            \n            String[] line;\n            while ((line = csvReader.readNext()) != null) {\n                totalRecords++;\n                if (line.length != 4) {\n                    System.err.println(\"Invalid row: expected 4 fields, got \" + line.length);\n                    invalidRecords++;\n                    continue;\n                }\n                String firstName = line[0].trim();\n                String lastName = line[1].trim();\n                String email = line[2].trim();\n                String ageStr = line[3].trim();\n                int age;\n                try {\n                    age = Integer.parseInt(ageStr);\n                } catch (NumberFormatException e) {\n                    System.err.println(\"Invalid age: \" + ageStr);\n                    invalidRecords++;\n                    continue;\n                }\n                User user = new User(firstName, lastName, email, age);\n                if (isValidUser(user)) {\n                    pstmt.setString(1, user.getFirstName());\n                    pstmt.setString(2, user.getLastName());\n                    pstmt.setString(3, user.getEmail());\n                    pstmt.setInt(4, user.getAge());\n                    pstmt.addBatch();\n                    insertedRecords++;\n                    if (insertedRecords % BATCH_SIZE == 0) {\n                        pstmt.executeBatch();\n                        conn.commit(); // commit after each batch\n                    }\n                } else {\n                    invalidRecords++;\n                }\n            }\n            \n            // Execute any remaining batches\n            if (insertedRecords % BATCH_SIZE != 0) {\n                pstmt.executeBatch();\n                conn.commit();\n            }\n        }\n        \n        System.out.println(\"Total records read from CSV: \" + totalRecords);\n        System.out.println(\"Records inserted into database: \" + insertedRecords);\n        System.out.println(\"Invalid records skipped: \" + invalidRecords);\n    }\n\n    public static boolean isValidUser(User user) {\n        if (user.getFirstName() == null || user.getFirstName().trim().isEmpty()) {\n            System.err.println(\"First name is required.\");\n            return false;\n        }\n        if (user.getLastName() == null || user.getLastName().trim().isEmpty()) {\n            System.err.println(\"Last name is required.\");\n            return false;\n        }\n        if (user.getEmail() == null || !user.getEmail().matches(\"^[\\\\w.-]+@[\\\\w.-]+\\\\.\\\\w+$\")) {\n            System.err.println(\"Invalid email format.\");\n            return false;\n        }\n        if (user.getAge() < 0) {\n            System.err.println(\"Age cannot be negative.\");\n            return false;\n        }\n        return true;\n    }\n}\n\nclass User {\n    private String firstName;\n    private String lastName;\n    private String email;\n    private int age;\n\n    public User(String firstName, String lastName, String email, int age) {\n        this.firstName = firstName;\n        this.lastName = lastName;\n        this.email = email;\n        this.age = age;\n    }\n\n    public String getFirstName() {\n        return firstName;\n    }\n\n    public String getLastName() {\n        return lastName;\n    }\n\n    public String getEmail() {\n        return email;\n    }\n\n    public int getAge() {\n        return age;\n    }\n}\n```\n\nThis program should fulfill the requirements: it reads a CSV file containing user information, validates the data, inserts valid records into an SQLite database, handles exceptions, and provides meaningful error messages."
    }
]