[
    {
        "role": "user",
        "content": "Create a C++ implementation of a hash table with separate chaining for collision resolution, supporting basic operations like insert, delete, and search.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Sure! I can help you with that. Implementing a hash table with separate chaining in C++ involves several steps. We'll need to create a hash table that can store key-value pairs, handle collisions using separate chaining, and support insertion, deletion, and search operations.\n\nFirst, let's understand the basic concepts:\n\n1. **Hash Table**: A data structure that implements an associative array abstract data type, a structure that can map keys to values. It uses a hash function to compute an index into an array of buckets or slots, from which the desired value can be found.\n\n2. **Separate Chaining**: A method for handling collisions in a hash table. Each bucket in the hash table contains a linked list of elements that hash to the same index.\n\nNow, let's outline the steps to implement this:\n\n1. **Define the Node Structure**: Since we're using separate chaining, each bucket will contain a linked list. So, we need a structure for the nodes of these linked lists.\n\n2. **Define the Hash Table Structure**: This will contain an array of buckets, each of which is a linked list of nodes.\n\n3. **Implement the Hash Function**: This function will take a key and return an index into the array of buckets.\n\n4. **Implement Insertion**: Compute the hash index for the key and insert the key-value pair into the linked list at that index.\n\n5. **Implement Search**: Compute the hash index for the key and search the linked list at that index for the key.\n\n6. **Implement Deletion**: Compute the hash index for the key and delete the key-value pair from the linked list at that index.\n\nLet's proceed to write the code step by step.\n\n### Step 1: Define the Node Structure\n\nEach node in the linked list will store a key-value pair and a pointer to the next node.\n\n```cpp\nstruct Node {\n    int key;\n    int value;\n    Node* next;\n    Node(int k, int v) : key(k), value(v), next(nullptr) {}\n};\n```\n\n### Step 2: Define the Hash Table Structure\n\nThe hash table will contain an array of buckets, where each bucket is a linked list (starting with a node).\n\n```cpp\nclass HashTable {\nprivate:\n    static const int TABLE_SIZE = 100; // You can choose a different size\n    Node* table[TABLE_SIZE];\npublic:\n    HashTable() {\n        for (int i = 0; i < TABLE_SIZE; i++) {\n            table[i] = nullptr;\n        }\n    }\n    // Other methods will be defined here\n};\n```\n\n### Step 3: Implement the Hash Function\n\nA simple hash function can be the modulus of the key with the table size.\n\n```cpp\nint hash(int key) {\n    return key % TABLE_SIZE;\n}\n```\n\n### Step 4: Implement Insertion\n\nCompute the hash index and insert the key-value pair into the linked list at that index.\n\n```cpp\nvoid insert(int key, int value) {\n    int index = hash(key);\n    Node* newNode = new Node(key, value);\n    newNode->next = table[index];\n    table[index] = newNode;\n}\n```\n\n### Step 5: Implement Search\n\nCompute the hash index and search the linked list at that index for the key.\n\n```cpp\nint search(int key) {\n    int index = hash(key);\n    Node* current = table[index];\n    while (current != nullptr) {\n        if (current->key == key) {\n            return current->value;\n        }\n        current = current->next;\n    }\n    return -1; // Key not found\n}\n```\n\n### Step 6: Implement Deletion\n\nCompute the hash index and delete the key-value pair from the linked list at that index.\n\n```cpp\nbool remove(int key) {\n    int index = hash(key);\n    Node* current = table[index];\n    Node* previous = nullptr;\n    while (current != nullptr) {\n        if (current->key == key) {\n            if (previous == nullptr) {\n                table[index] = current->next;\n            } else {\n                previous->next = current->next;\n            }\n            delete current;\n            return true;\n        }\n        previous = current;\n        current = current->next;\n    }\n    return false; // Key not found\n}\n```\n\n### Full Implementation\n\nPutting it all together:\n\n```cpp\n#include <iostream>\n\nconst int TABLE_SIZE = 100;\n\nstruct Node {\n    int key;\n    int value;\n    Node* next;\n    Node(int k, int v) : key(k), value(v), next(nullptr) {}\n};\n\nclass HashTable {\nprivate:\n    Node* table[TABLE_SIZE];\n    int hash(int key) {\n        return key % TABLE_SIZE;\n    }\npublic:\n    HashTable() {\n        for (int i = 0; i < TABLE_SIZE; i++) {\n            table[i] = nullptr;\n        }\n    }\n    void insert(int key, int value) {\n        int index = hash(key);\n        Node* newNode = new Node(key, value);\n        newNode->next = table[index];\n        table[index] = newNode;\n    }\n    int search(int key) {\n        int index = hash(key);\n        Node* current = table[index];\n        while (current != nullptr) {\n            if (current->key == key) {\n                return current->value;\n            }\n            current = current->next;\n        }\n        return -1; // Key not found\n    }\n    bool remove(int key) {\n        int index = hash(key);\n        Node* current = table[index];\n        Node* previous = nullptr;\n        while (current != nullptr) {\n            if (current->key == key) {\n                if (previous == nullptr) {\n                    table[index] = current->next;\n                } else {\n                    previous->next = current->next;\n                }\n                delete current;\n                return true;\n            }\n            previous = current;\n            current = current->next;\n        }\n        return false; // Key not found\n    }\n};\n\nint main() {\n    HashTable ht;\n    ht.insert(1, 10);\n    ht.insert(2, 20);\n    ht.insert(101, 1010); // Should chain with key 1\n\n    std::cout << \"Search 1: \" << ht.search(1) << std::endl; // Should return 10\n    std::cout << \"Search 2: \" << ht.search(2) << std::endl; // Should return 20\n    std::cout << \"Search 101: \" << ht.search(101) << std::endl; // Should return 1010\n\n    ht.remove(2);\n    std::cout << \"Search 2 after removal: \" << ht.search(2) << std::endl; // Should return -1\n\n    return 0;\n}\n```\n\nThis is a basic implementation of a hash table with separate chaining in C++. You can expand upon this by adding more features, such as resizing the table, handling different types of keys and values, or improving the hash function for better distribution."
    }
]