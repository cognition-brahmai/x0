[
    {
        "role": "user",
        "content": "Develop a Python script that generates a random maze using Prim's algorithm. The maze should be represented as a 2D grid, where each cell can be either a wall or a path. Display the generated maze using ASCII characters.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Alright, I've got this task to create a Python script that generates a random maze using Prim's algorithm and then displays it using ASCII characters. I'm excited to tackle this because mazes have always fascinated me, and implementing an algorithm to generate them sounds like a fun challenge.\n\nFirst things first, I need to understand what Prim's algorithm is and how it can be applied to maze generation. I know that Prim's algorithm is primarily used to find the minimum spanning tree in a weighted graph, but I've heard it can also be used to generate mazes, which are essentially spanning trees of a grid graph.\n\nSo, to start, I need to represent the maze as a grid. Each cell in the grid can be either a wall or a path. In maze terminology, the paths are the cells that you can move through, and the walls are the obstacles.\n\nI think I'll represent the grid as a 2D list in Python, where each element is either a 0 (wall) or a 1 (path). That should be straightforward.\n\nNow, for Prim's algorithm in maze generation, I need to treat the grid as an undirected graph where each cell is a node, and the edges connect to the neighboring cells. The goal is to create a spanning tree that covers all the cells, which will form the paths in the maze.\n\nHere's a rough outline of how Prim's algorithm works for maze generation:\n\n1. Start with a grid where all cells are considered walls.\n\n2. Pick a starting cell and add it to the maze.\n\n3. Add all the walls of the starting cell to a frontier list.\n\n4. While the frontier is not empty:\n\na. Pick a random wall from the frontier.\n\nb. If the cell on the other side of the wall hasn't been visited yet:\n\ni. Remove the wall.\n\nii. Add the new cell to the maze.\n\niii. Add the walls of the new cell to the frontier, if they are not already in the frontier and not in the maze.\n\nc. Remove the wall from the frontier.\n\n5. Repeat until the frontier is empty.\n\nThis should leave me with a maze that has a single path between any two cells.\n\nI need to think about how to implement this in code. First, I need to define the grid and initialize all cells as walls. Then, select a starting cell and mark it as a path. I'll need a way to represent walls between cells, so perhaps I'll need to keep track of the walls separately.\n\nWait, in maze generation, it's common to think of the cells as nodes and the walls as edges. Removing a wall connects two cells, effectively merging their sets in the spanning tree.\n\nI should consider using a set to keep track of which cells have been visited and are part of the maze. The frontier can be a list of walls that are potential candidates for removal.\n\nLet me think about the grid coordinates. I'll use (row, column) notation, with (0,0) being the top-left cell.\n\nI need to define the possible directions for neighboring cells, probably up, down, left, right.\n\nI should also consider that some cells have walls only on certain sides, depending on their position in the grid.\n\nAnother thing to consider is how to represent the maze visually using ASCII characters. I need to decide on characters for paths, walls, and any other features like start and end points.\n\nMaybe I can use '#' for walls and ' ' (space) for paths. For the display, I can iterate through the grid and print the appropriate characters.\n\nI should also think about the boundaries of the maze. Typically, mazes have outer walls surrounding the grid to contain the paths.\n\nLet me sketch a small example on paper to visualize this.\n\nSuppose I have a 3x3 grid.\n\nInitialize all cells as walls:\n\n####\n\n####\n\n####\n\nChoose a starting cell, say (1,1):\n\n# # #\n\n#   #\n\n# # #\n\nNow, add the walls of (1,1) to the frontier: north, south, east, west.\n\nRandomly pick a wall from the frontier, say east.\n\nThe cell on the other side is (1,2). It's a wall, so remove the east wall of (1,1) and the west wall of (1,2), and add (1,2) to the maze.\n\nAlso, add the walls of (1,2) to the frontier: north, south, east, west.\n\nNow the maze looks like:\n\n# # #\n\n#     #\n\n# # #\n\nContinue this process until the frontier is empty.\n\nThis seems manageable.\n\nI need to think about how to implement this in code.\n\nFirst, define the grid size. Let's ask the user for the number of rows and columns.\n\nThen, initialize the grid with all walls.\n\nDefine the possible directions: north, south, east, west.\n\nEach direction corresponds to a change in row and column.\n\nFor example:\n\nnorth: (-1, 0)\n\nsouth: (1, 0)\n\neast: (0, 1)\n\nwest: (0, -1)\n\nI need to make sure that when moving in a direction, the new cell is within the grid bounds.\n\nI should use a set to keep track of visited cells.\n\nThe frontier can be a list of walls, where each wall is a tuple of (current_cell, direction).\n\nI need to pick a random wall from the frontier, so I'll need to import the random module.\n\nOnce the maze is generated, I need to display it using ASCII characters.\n\nI need to print the maze row by row, using '#' for walls and ' ' for paths.\n\nI should also print outer walls to enclose the maze.\n\nLet me start drafting some code.\n\nFirst, import necessary modules:\n\nimport random\n\nDefine grid dimensions:\n\nrows = int(input(\"Enter number of rows: \"))\n\ncols = int(input(\"Enter number of columns: \"))\n\nInitialize the grid:\n\ngrid = [['#' for _ in range(cols)] for _ in range(rows)]\n\nDefine possible directions:\n\ndirections = [(-1,0,'n'), (1,0,'s'), (0,1,'e'), (0,-1,'w')]\n\nHere, I'm including a character to represent the direction: 'n' for north, 's' for south, etc.\n\nThis might not be necessary, but it could be useful for debugging.\n\nInitialize visited set and frontier list:\n\nvisited = set()\n\nfrontier = []\n\nChoose a starting cell:\n\nstart_row = random.randint(0, rows-1)\n\nstart_col = random.randint(0, cols-1)\n\ngrid[start_row][start_col] = ' '\n\nvisited.add((start_row, start_col))\n\nAdd the walls of the starting cell to the frontier.\n\nFor each direction, calculate the new cell.\n\nIf the new cell is within bounds, add the wall to the frontier.\n\nBut in this implementation, since all cells start as walls, I need to make sure I'm only adding walls that are between the starting cell and unvisited cells.\n\nWait, perhaps it's better to think in terms of walls.\n\nAlternatively, I can think of the grid cells as being either part of the maze or not, and walls as boundaries between cells.\n\nActually, perhaps a better way is to consider each cell as having four walls: north, south, east, west.\n\nThen, when I add a cell to the maze, I remove the wall between it and the previous cell.\n\nBut this might be more complicated than necessary.\n\nLet me look up some resources on Prim's algorithm for maze generation to get a better understanding.\n\nAfter some research, I found that in maze generation using Prim's algorithm, it's common to keep track of the walls between cells and randomly select a wall that separates a visited cell from an unvisited one, remove that wall, and add the unvisited cell to the visited set.\n\nThis seems similar to the standard Prim's algorithm for minimum spanning trees, where you have a frontier of edges and you randomly select one that connects to an unvisited vertex.\n\nSo, in this case, the walls are the edges, and the cells are the vertices.\n\nI need to represent the walls in a way that I can keep track of which ones separate visited from unvisited cells.\n\nOne way to do this is to maintain a list of walls that are potential candidates for removal (i.e., walls between a visited and an unvisited cell).\n\nI can represent each wall by the cell it belongs to and the direction it points to.\n\nFor example, a wall can be represented as (row, col, direction), where direction is 'n', 's', 'e', or 'w'.\n\nThen, the cell on the other side of the wall would be (row + dr, col + dc), where (dr, dc) corresponds to the direction.\n\nI need to make sure that when I remove a wall, I mark the corresponding wall in the neighboring cell as removed as well, to avoid double-counting.\n\nWait, this might get too complicated.\n\nPerhaps a simpler way is to represent the maze as a grid of cells, each with four walls, and keep track of which walls have been removed.\n\nBut that might be overkill for this purpose.\n\nLet me try a different approach.\n\nI can represent the grid as a list of cells, where each cell is a set of walls that are still present.\n\nInitially, all cells have all four walls.\n\nAs I build the maze, I remove walls between cells.\n\nI can use a set to keep track of visited cells.\n\nThe frontier can be a list of walls that separate a visited cell from an unvisited one.\n\nTo implement this efficiently, I need a way to iterate through the frontier and check which walls are valid for removal.\n\nAlternatively, I can use a list of walls and randomly select one that meets the criteria.\n\nBut managing this could be time-consuming.\n\nMaybe there's a simpler way.\n\nI recall that in some maze generation algorithms, like depth-first search or recursive backtracking, it's easier to think in terms of carving paths between cells.\n\nBut since the task is specifically to use Prim's algorithm, I need to stick with that.\n\nWait, perhaps I can simplify my representation.\n\nLet's consider each cell to be either part of the maze (path) or not (wall).\n\nInitially, all cells are walls except for the starting cell.\n\nI can maintain a list of walls that are potential candidates for removal.\n\nEach wall entry contains the coordinates of the wall and the two cells it separates.\n\nBut this might be too abstract.\n\nLet me try to implement it step by step.\n\n1. Initialize the grid with all cells as walls.\n\n2. Choose a starting cell and mark it as a path.\n\n3. Add all the walls of the starting cell to the frontier list.\n\n   - Each wall is represented by its position and direction.\n\n4. While the frontier is not empty:\n\n   a. Randomly select a wall from the frontier.\n\n   b. Let's say the wall is between cell A (part of the maze) and cell B (not part of the maze).\n\n   c. If cell B is not yet part of the maze:\n\n      i. Remove the wall between A and B.\n\n      ii. Add cell B to the maze.\n\n      iii. Add the walls of cell B to the frontier.\n\n   d. Remove the wall from the frontier.\n\n5. Repeat until the frontier is empty.\n\nThis seems manageable.\n\nI need to represent the walls in a way that I can easily access and remove them.\n\nPerhaps I can maintain a list of wall tuples, where each tuple contains the coordinates of the wall and the direction.\n\nFor example, a wall can be represented as (row, col, direction), where direction is 'n', 's', 'e', or 'w'.\n\nThen, when I remove a wall, I can mark it as removed and update the grid accordingly.\n\nI need to make sure that when I add the walls of a new cell to the frontier, I don't add walls that are already in the frontier or that lead to cells already in the maze.\n\nThis requires keeping track of which walls are in the frontier and which cells are visited.\n\nTo make this efficient, I can use a set for the visited cells and a list for the frontier.\n\nEach entry in the frontier list would be a wall tuple (row, col, direction).\n\nWhen I remove a wall, I need to:\n\n- Set the wall in the grid to ' ', indicating it's open.\n\n- Mark the neighboring cell as visited.\n\n- Add the walls of the neighboring cell to the frontier, provided they meet the criteria.\n\nI need to define a function to get the neighboring cells given a cell and a direction.\n\nAlso, I need to ensure that when I add a wall to the frontier, it's not already in the frontier and that the neighboring cell is within bounds and not yet visited.\n\nLet me start by defining the grid and initializing it with walls.\n\nThen, choose a starting cell randomly.\n\nMark the starting cell as a path.\n\nAdd the walls of the starting cell to the frontier.\n\nNow, in each iteration:\n\n- Randomly select a wall from the frontier.\n\n- Determine the neighboring cell in that direction.\n\n- If the neighboring cell is not visited:\n\n- Remove the wall between the current cell and the neighboring cell.\n\n- Mark the neighboring cell as a path.\n\n- Add the walls of the neighboring cell to the frontier.\n\n- Remove the wall from the frontier.\n\nContinue until the frontier is empty.\n\nThis should generate a perfect maze, meaning there are no loops and exactly one path between any two cells.\n\nNow, for the ASCII display, I need to print the maze with walls as '#' and paths as ' '.\n\nI also need to print the outer walls to enclose the maze properly.\n\nLet me think about how to represent the walls in the grid.\n\nEach cell has four walls: north, south, east, west.\n\nBut if I remove a wall between two cells, I need to ensure that both cells have that wall removed.\n\nWait, perhaps it's better to represent walls independently rather than attached to cells.\n\nAlternatively, I can represent the grid such that each cell corresponds to a path cell, and the walls are the spaces between them.\n\nBut this might complicate things.\n\nLet me try to stick with the initial approach.\n\nI'll represent the grid as a 2D list of cells, where each cell is either '#' (wall) or ' ' (path).\n\nWalls between cells will be represented by setting the corresponding sides of adjacent cells to ' '.\n\nFor example, to remove the wall between cell (r,c) and (r+1,c), I need to set the south wall of (r,c) and the north wall of (r+1,c) to ' '.\n\nBut this seems redundant.\n\nMaybe a better way is to have a grid where each cell is a path, and walls are the spaces between them.\n\nThis is called a \"border grid\" representation.\n\nIn this representation, the grid dimensions are (rows*2+1) x (cols*2+1), where paths are at (2i,2j) positions, and walls are at the odd indices.\n\nThis way, I can easily represent walls by setting the odd-indexed positions to '#'.\n\nThen, to remove a wall between two path cells, I set the corresponding wall position to ' '.\n\nThis seems like a cleaner approach.\n\nLet me adjust my plan accordingly.\n\n1. Define the grid size as (2*rows + 1) by (2*cols + 1), initialized with '#' for walls.\n\n2. Mark the starting cell (1,1) as ' '.\n\n3. Add the walls of the starting cell to the frontier list.\n\n4. While the frontier is not empty:\n\na. Randomly select a wall from the frontier.\n\nb. Determine the neighboring cell across the wall.\n\nc. If the neighboring cell is a wall:\n\ni. Remove the wall by setting the wall position to ' '.\n\nii. Mark the neighboring cell as ' '.\n\niii. Add the walls of the neighboring cell to the frontier.\n\nd. Remove the wall from the frontier.\n\n5. Repeat until the frontier is empty.\n\nThis should work.\n\nI need to map the directions to wall positions.\n\nFor example, from a cell (r,c), the walls are:\n\n- North: (r-1,c)\n\n- South: (r+1,c)\n\n- East: (r,c+1)\n\n- West: (r,c-1)\n\nBut in the border grid, positions are shifted.\n\nWait, in the border grid, paths are at even indices, and walls are at odd indices.\n\nFor example, for a 3x3 grid:\n\nPositions:\n\n(0,0) (0,1) (0,2) (0,3) (0,4)\n\n(1,0) (1,1) (1,2) (1,3) (1,4)\n\n(2,0) (2,1) (2,2) (2,3) (2,4)\n\n(3,0) (3,1) (3,2) (3,3) (3,4)\n\n(4,0) (4,1) (4,2) (4,3) (4,4)\n\nHere, paths are at (2i,2j), and walls are at the odd indices.\n\nWait, actually, for a maze, it's common to have paths at (2i+1,2j+1), and walls at the other positions.\n\nLet me correct that.\n\nFor a maze with rows x cols path cells, the grid size is (2*rows+1) x (2*cols+1).\n\nPaths are at positions (2i+1,2j+1), and walls are at the remaining positions.\n\nSo, for a 2x2 maze:\n\nGrid size: 5x5\n\nPaths at (1,1), (1,3), (3,1), (3,3)\n\nWalls at all other positions.\n\nTo remove the wall between (1,1) and (1,3), I would set position (1,2) to ' '.\n\nSimilarly, to remove the wall between (1,1) and (3,1), I would set position (2,1) to ' '.\n\nThis makes sense.\n\nSo, in code, I need to:\n\n- Define grid_size_rows = 2*rows + 1\n\n- Define grid_size_cols = 2*cols + 1\n\n- Initialize grid with '#' for walls.\n\n- Mark the starting cell (1,1) as ' '.\n\n- Add the walls of the starting cell to the frontier list.\n\n- Implement the algorithm as described earlier.\n\nI need to map the directions to wall positions in this grid.\n\nLet me define the possible directions:\n\n- North: (r-1, c), wall position (r-1, c)\n\n- South: (r+1, c), wall position (r+1, c)\n\n- East: (r, c+1), wall position (r, c+1)\n\n- West: (r, c-1), wall position (r, c-1)\n\nBut in the border grid, the wall positions are at the odd indices.\n\nWait, perhaps it's better to think in terms of path cells and wall cells.\n\nPath cells are at (2i+1, 2j+1), and walls are in between.\n\nSo, to remove the wall to the east of a path cell (r,c), I need to set grid[r][c+1] to ' '.\n\nWait, no.\n\nActually, in the border grid, paths are at (2i+1,2j+1), and walls are at (2i+1,2j), (2i,2j+1), etc.\n\nWait, perhaps I need to think differently.\n\nLet me define functions to get the wall positions between two cells.\n\nFor example, between (r,c) and (r+1,c), the wall is at (r*2+2, c*2+1).\n\nI need to figure out the exact mapping.\n\nThis might require some calculation.\n\nAlternatively, I can represent the grid in such a way that each cell corresponds to a path, and walls are the boundaries between them.\n\nBut this is getting too confusing.\n\nMaybe I should look for a code example or a library that can help with this.\n\nAfter some research, I found that the popular approach for maze generation using Prim's algorithm involves treating the grid as a set of cells and walls, and iteratively removing walls between cells.\n\nI also found some code examples that implement this.\n\nOne approach is to represent the grid as a 2D list, where each cell contains information about its walls and whether it's been visited.\n\nBut I want to keep it simple and use a 2D list of characters: '#' for walls and ' ' for paths.\n\nI can proceed with the border grid approach, where paths are at (2i+1,2j+1) and walls are in between.\n\nLet's define:\n\n- grid_size_rows = 2*rows + 1\n\n- grid_size_cols = 2*cols + 1\n\n- Initialize grid with '#' for walls.\n\n- Mark the starting cell (1,1) as ' '.\n\n- Add the walls of the starting cell to the frontier list.\n\n- Implement the algorithm as previously described.\n\nI need to make sure that when I remove a wall, I set the corresponding position in the grid to ' ', and mark the neighboring cell as ' ' as well.\n\nI need to handle the indexing correctly to map the wall positions between cells.\n\nLet me define the possible directions with their corresponding wall positions.\n\nFor example:\n\n- North: wall position is (r*2, c*2+1)\n\n- South: wall position is (r*2+2, c*2+1)\n\n- East: wall position is (r*2+1, c*2+2)\n\n- West: wall position is (r*2+1, c*2)\n\nI think this mapping should work.\n\nLet me test it with a small example.\n\nSuppose rows=1, cols=1.\n\nThen grid_size_rows=3, grid_size_cols=3.\n\nGrid:\n\n[ ['#', '#', '#'],\n\n['#', ' ', '#'],\n\n['#', '#', '#'] ]\n\nStarting at (1,1).\n\nFrontier walls: north (0,1), south (2,1), east (1,2), west (1,0)\n\nIf I remove the north wall (0,1), set grid[0][1]=' ', and mark grid[1][1]=' ' (already is), and add the walls of the new cell (0,1).\n\nBut (0,1) is a wall cell, not a path cell. Maybe I need to adjust my approach.\n\nWait, perhaps I need to distinguish between path cells and wall cells.\n\nPath cells are at (2i+1,2j+1), and wall cells are in between.\n\nMaybe I need to only add walls that separate path cells from non-path cells.\n\nThis is getting too tangled.\n\nLet me try a different strategy.\n\nI can represent the grid where each cell is a path or a wall, and keep track of the walls around each path cell.\n\nWhen I remove a wall between two path cells, I set that wall position to ' '.\n\nBut in the border grid, walls are between path cells.\n\nSo, perhaps I should represent the grid with path cells and walls in between.\n\nInitialize all walls are present, then remove walls as per Prim's algorithm.\n\nThis seems similar to what I was thinking earlier.\n\nLet me try to implement this step by step.\n\n1. Define grid size: grid_size_rows = 2*rows + 1, grid_size_cols = 2*cols + 1\n\n2. Initialize grid with '#' for walls.\n\n3. Mark the starting cell (1,1) as ' '.\n\n4. Add the walls of the starting cell to the frontier list.\n\n   - Walls are the positions surrounding the starting cell.\n\n5. While frontier is not empty:\n\n   a. Randomly select a wall from the frontier.\n\n   b. Determine the neighboring cell across the wall.\n\n   c. If the neighboring cell is a wall:\n\n      i. Remove the wall by setting grid[wall_row][wall_col] = ' '\n\n      ii. Mark the neighboring cell as ' '\n\n      iii. Add the walls of the neighboring cell to the frontier.\n\n   d. Remove the wall from the frontier.\n\n6. Repeat until the frontier is empty.\n\nI need to define how to get the neighboring cell across a wall.\n\nFor example, if the wall is to the north of a cell, the neighboring cell is (r-1,c).\n\nSimilarly for south, east, and west.\n\nI need to make sure that the neighboring cell is within bounds.\n\nAlso, I need to ensure that when I add the walls of the new cell to the frontier, I don't add walls that are already in the frontier or that lead to already visited cells.\n\nTo manage this, I can keep the frontier as a list of wall positions, and check if the neighboring cell is a wall before adding its walls to the frontier.\n\nI need to be careful with the indices to avoid index errors.\n\nLet me think about the starting point.\n\nFor a maze with rows=2, cols=2:\n\ngrid_size_rows=5, grid_size_cols=5\n\nGrid:\n\n[ ['#', '#', '#', '#', '#'],\n\n['#', ' ', '#', ' ', '#'],\n\n['#', '#', '#', '#', '#'],\n\n['#', ' ', '#', ' ', '#'],\n\n['#', '#', '#', '#', '#'] ]\n\nWait, no.\n\nActually, in the border grid, path cells are at (1,1), (1,3), (3,1), (3,3), etc.\n\nSo, for rows=2, cols=2:\n\nGrid:\n\n[ ['#', '#', '#', '#', '#'],\n\n['#', ' ', '#', ' ', '#'],\n\n['#', '#', '#', '#', '#'],\n\n['#', ' ', '#', ' ', '#'],\n\n['#', '#', '#', '#', '#'] ]\n\nStarting at (1,1), which is a path cell.\n\nFrontier walls: (0,1), (1,0), (1,2), (2,1)\n\nNow, randomly select one, say (1,2).\n\nThe neighboring cell across this wall is (1,3), which is a wall.\n\nSo, remove the wall at (1,2), set grid[1][2]=' ', and mark (1,3) as ' '.\n\nThen, add the walls of (1,3) to the frontier: (0,3), (1,4), (2,3)\n\nContinue this process until the frontier is empty.\n\nThis seems to make sense.\n\nI need to implement this logic in code.\n\nI need to map the wall positions to the corresponding neighboring cells.\n\nFor example:\n\n- Wall to the north of (r,c) is at (r-1,c), neighboring cell is (r-2,c)\n\n- Wall to the south is at (r+1,c), neighboring cell is (r+2,c)\n\n- Wall to the east is at (r,c+1), neighboring cell is (r,c+2)\n\n- Wall to the west is at (r,c-1), neighboring cell is (r,c-2)\n\nWait, in the border grid, path cells are at odd indices, and walls are at even indices.\n\nWait, actually, in the border grid, path cells are at (2i+1,2j+1), and walls are in between.\n\nSo, to get the neighboring cell across a wall, I need to move two steps in the corresponding direction.\n\nFor example, from (1,1):\n\n- North wall is at (0,1), neighboring cell is (1-2,1)=( -1,1), which is out of bounds.\n\n- South wall is at (2,1), neighboring cell is (1+2,1)=(3,1)\n\n- East wall is at (1,2), neighboring cell is (1,1+2)=(1,3)\n\n- West wall is at (1,0), neighboring cell is (1,1-2)=(1,-1), out of bounds.\n\nSo, only south and east walls lead to valid neighboring cells.\n\nThis makes sense.\n\nI need to ensure that when I add walls to the frontier, I check if the neighboring cell is within bounds and is a wall.\n\nIf it is, then I can add that wall to the frontier.\n\nWhen removing a wall, I set grid[wall_row][wall_col]=' ' and mark the neighboring cell as ' '.\n\nThen, add the walls of the neighboring cell to the frontier, provided they meet the criteria.\n\nI think this approach will work.\n\nNow, I need to implement this in Python.\n\nI should also consider optimizing the frontier list to avoid duplicates, but since we're dealing with a grid, it might not be a big issue.\n\nAlternatively, I can use a set for the frontier to avoid duplicates, but since tuples are hashable, I can use a set of wall positions.\n\nBut lists are easier to work with when randomly selecting elements, so maybe I'll stick with a list and accept some duplicates.\n\nNow, for displaying the maze, I need to print the grid row by row, with '#' for walls and ' ' for paths.\n\nI should also ensure that the outer walls are present to enclose the maze.\n\nIn the grid, the outer walls are already set to '#', so no problem there.\n\nLet me try writing some pseudocode.\n\nDefine function generate_maze(rows, cols):\n\ngrid_size_rows = 2*rows + 1\n\ngrid_size_cols = 2*cols + 1\n\ngrid = [ ['#'] * grid_size_cols for _ in range(grid_size_rows) ]\n\nvisited = set()\n\nfrontier = []\n\nstart_row = 1\n\nstart_col = 1\n\ngrid[start_row][start_col] = ' '\n\nvisited.add((start_row, start_col))\n\n# Add the walls of the starting cell to the frontier\n\nfor dr, dc, dir in directions:\n\nwall_row = start_row + dr\n\nwall_col = start_col + dc\n\nif 0 < wall_row < grid_size_rows and 0 < wall_col < grid_size_cols:\n\nfrontier.append((wall_row, wall_col, dir))\n\nwhile frontier:\n\n# Randomly select a wall from the frontier\n\nwall = random.choice(frontier)\n\nwall_row, wall_col, dir = wall\n\n# Determine the neighboring cell across the wall\n\nif dir == 'n':\n\nnei_row = wall_row - 1\n\nnei_col = wall_col\n\nelif dir == 's':\n\nnei_row = wall_row + 1\n\nnei_col = wall_col\n\nelif dir == 'e':\n\nnei_row = wall_row\n\nnei_col = wall_col + 1\n\nelif dir == 'w':\n\nnei_row = wall_row\n\nnei_col = wall_col - 1\n\n# Check if the neighboring cell is a wall and within bounds\n\nif 0 < nei_row < grid_size_rows and 0 < nei_col < grid_size_cols and grid[nei_row][nei_col] == '#':\n\n# Remove the wall\n\ngrid[wall_row][wall_col] = ' '\n\n# Add the neighboring cell to the maze\n\ngrid[nei_row][nei_col] = ' '\n\nvisited.add((nei_row, nei_col))\n\n# Add the walls of the neighboring cell to the frontier\n\nfor dr, dc, dir in directions:\n\nnew_wall_row = nei_row + dr\n\nnew_wall_col = nei_col + dc\n\nif 0 < new_wall_row < grid_size_rows and 0 < new_wall_col < grid_size_cols:\n\nfrontier.append((new_wall_row, new_wall_col, dir))\n\n# Remove the wall from the frontier\n\nfrontier.remove(wall)\n\nreturn grid\n\nThis seems like a good start.\n\nI need to adjust the indices to ensure they are within bounds and correctly map to the neighboring cells.\n\nI should also make sure that when adding walls to the frontier, I don't add walls that are already in the frontier or that lead to already visited cells.\n\nTo optimize, I can check if the neighboring cell is not in visited before adding its walls to the frontier.\n\nBut since we're randomly selecting walls, it should still work even with duplicates in the frontier.\n\nNow, I need to test this logic with a small maze to see if it generates correctly.\n\nLet's take rows=1, cols=1.\n\ngrid_size_rows=3, grid_size_cols=3\n\nGrid:\n\n[ ['#', '#', '#'],\n\n['#', ' ', '#'],\n\n['#', '#', '#'] ]\n\nStart at (1,1).\n\nFrontier walls: (0,1,'n'), (1,0,'w'), (1,2,'e'), (2,1,'s')\n\nRandomly pick one, say (1,2,'e').\n\nNeighboring cell is (1,3), which is out of bounds. So skip.\n\nPick another wall, say (2,1,'s').\n\nNeighboring cell is (3,1), which is out of bounds. Skip.\n\nPick (1,0,'w'), neighboring cell (1,-1), out of bounds. Skip.\n\nPick (0,1,'n'), neighboring cell (-1,1), out of bounds. Skip.\n\nFrontier is now empty, so maze generation stops.\n\nBut this is a trivial maze with only one path cell.\n\nMaybe I need to adjust the starting point or the way I handle boundaries.\n\nAlternatively, perhaps I need to include the outer walls differently.\n\nWait, perhaps I need to adjust the way I handle the frontier and neighboring cells.\n\nLet me try with rows=2, cols=2.\n\ngrid_size_rows=5, grid_size_cols=5\n\nGrid:\n\n[ ['#', '#', '#', '#', '#'],\n\n['#', ' ', '#', ' ', '#'],\n\n['#', '#', '#', '#', '#'],\n\n['#', ' ', '#', ' ', '#'],\n\n['#', '#', '#', '#', '#'] ]\n\nStart at (1,1).\n\nFrontier walls: (0,1,'n'), (1,0,'w'), (1,2,'e'), (2,1,'s')\n\nPick (1,2,'e'), neighboring cell (1,3).\n\nGrid[1][2] = ' '\n\nGrid[1][3] = ' '\n\nAdd walls of (1,3): (0,3,'n'), (1,4,'e'), (2,3,'s')\n\nFrontier now: [(0,3,'n'), (1,4,'e'), (2,3,'s')]\n\nPick (0,3,'n'), neighboring cell (-1,3), out of bounds. Skip.\n\nPick (1,4,'e'), neighboring cell (1,5), out of bounds. Skip.\n\nPick (2,3,'s'), neighboring cell (3,3).\n\nSet grid[2][3] = ' '\n\nSet grid[3][3] = ' '\n\nAdd walls of (3,3): (2,3,'n'), (3,4,'e'), (4,3,'s'), (3,2,'w')\n\nBut grid[2,3] is already in the frontier, so maybe check if the wall is already in the frontier.\n\nTo avoid duplicates, perhaps I should use a set for the frontier.\n\nBut for simplicity, I can proceed with a list and accept some duplicates.\n\nContinuing:\n\nFrontier now: [(2,3,'s'), (3,3,'n'), (3,3,'e'), (3,3,'s'), (3,3,'w')]\n\nPick (2,3,'s'), already processed.\n\nPick (3,3,'n'), which is (2,3), already processed.\n\nPick (3,3,'e'), which is (3,4).\n\nSet grid[3][4] = ' '\n\nSet grid[3][5] = ' ' (out of bounds, skip)\n\nAdd walls of (3,5), out of bounds.\n\nFrontier now: [(3,3,'s'), (3,3,'w'), (4,3,'s'), (3,4,'e'), (3,4,'s'), (3,4,'w')]\n\nPick (3,3,'s'), which is (4,3).\n\nSet grid[4][3] = ' '\n\nSet grid[5][3] = ' ' (out of bounds)\n\nAdd walls of (5,3), out of bounds.\n\nFrontier now: [(4,3,'s'), (3,4,'e'), (3,4,'s'), (3,4,'w')]\n\nPick (4,3,'s'), out of bounds.\n\nPick (3,4,'e'), out of bounds.\n\nPick (3,4,'s'), out of bounds.\n\nPick (3,4,'w'), which is (3,2).\n\nSet grid[3][2] = ' '\n\nSet grid[3][1] = ' '\n\nAdd walls of (3,1): (2,1,'n'), (3,0,'w'), (3,2,'e'), (4,1,'s')\n\nFrontier now: [(2,1,'n'), (3,0,'w'), (3,2,'e'), (4,1,'s')]\n\nPick (2,1,'n'), which is (1,1), already visited.\n\nSkip.\n\nPick (3,0,'w'), out of bounds.\n\nPick (3,2,'e'), which is (3,3), already visited.\n\nSkip.\n\nPick (4,1,'s'), which is (5,1), out of bounds.\n\nSkip.\n\nFrontier is now empty, so maze generation stops.\n\nFinal grid:\n\n[ ['#', '#', '#', '#', '#'],\n\n['#', ' ', '#', ' ', '#'],\n\n['#', '#', '#', '#', '#'],\n\n['#', ' ', ' ', ' ', '#'],\n\n['#', '#', '#', '#', '#'] ]\n\nThis doesn't look like a fully connected maze.\n\nThere should be a path from any cell to any other cell.\n\nMaybe I need to adjust the way I handle the frontier and ensure that all cells are connected.\n\nAlternatively, perhaps I need to use a different approach to represent the walls and cells.\n\nThis is getting too time-consuming.\n\nLet me look for a more straightforward implementation of Prim's algorithm for maze generation.\n\nAfter some research, I found a different way to implement Prim's algorithm for maze generation.\n\nIn this approach, cells are represented as nodes in a graph, and walls between them as edges.\n\nWe start with all cells being walls, except for the starting cell.\n\nWe maintain a list of walls that separate a visited cell from an unvisited one.\n\nIn each iteration, we randomly select a wall from this list.\n\nIf the neighboring cell beyond that wall has not been visited, we remove the wall and add the neighboring cell to the visited set.\n\nWe then add the new walls of the neighboring cell to the list.\n\nThis continues until there are no more walls in the list.\n\nThis seems similar to what I was trying earlier, but perhaps I can implement it more cleanly.\n\nTo make this work, I need to represent the grid in a way that allows me to easily access and remove walls.\n\nI'll represent the grid as a 2D list of cells, where each cell can be either a wall ('#') or a path (' ').\n\nI'll maintain a set of visited cells and a list of walls that are potential candidates for removal.\n\nEach wall entry will contain the position of the wall and the direction it points to.\n\nLet's define the directions as tuples:\n\ndirections = [(-1,0,'n'), (1,0,'s'), (0,1,'e'), (0,-1,'w')]\n\nWhere 'n' stands for north, 's' for south, etc.\n\nEach wall can be represented as a tuple: (row, col, direction)\n\nSo, for example, a wall to the north of cell (r,c) would be (r,c,'n')\n\nBut perhaps it's better to represent walls based on their position in the grid.\n\nWait, in the border grid approach, path cells are at (2i+1,2j+1), and walls are in between.\n\nMaybe I should stick with that.\n\nAlternatively, I can represent walls independently.\n\nLet me try to simplify.\n\nDefine the grid size as (rows, cols), where each cell can be '#' or ' '.\n\nInitialize all cells as '#', except for the starting cell, which is ' '.\n\nInitialize the frontier with the walls of the starting cell.\n\nIn each iteration:\n\n- Randomly select a wall from the frontier.\n\n- Determine the neighboring cell beyond that wall.\n\n- If the neighboring cell is a wall:\n\n- Remove the wall by setting it to ' '.\n\n- Mark the neighboring cell as ' '.\n\n- Add the walls of the neighboring cell to the frontier.\n\n- Remove the wall from the frontier.\n\nRepeat until the frontier is empty.\n\nThis should generate a perfect maze.\n\nI need to implement this carefully to handle the wall positions correctly.\n\nI need to map the wall positions to the neighboring cells.\n\nFor example, a wall to the north of cell (r,c) separates it from cell (r-1,c).\n\nSimilarly for south, east, and west.\n\nI need to ensure that when I remove a wall, I set the corresponding position in the grid to ' '.\n\nBut in the border grid approach, walls are at specific positions.\n\nPerhaps I need to switch to a different representation.\n\nLet me consider representing the maze as a list of cells, where each cell has information about its walls.\n\nEach cell can have a dictionary of walls, e.g., {'n': True, 's': True, 'e': True, 'w': True}, where True means the wall is present.\n\nThen, as I build the maze, I remove walls between connected cells.\n\nThis might be a more straightforward approach.\n\nSo, for each cell, I store which walls are present.\n\nInitially, all walls are present.\n\nI choose a starting cell and mark it as visited.\n\nI add the walls of the starting cell to the frontier list.\n\nIn each iteration:\n\n- Randomly select a wall from the frontier.\n\n- Determine the neighboring cell beyond that wall.\n\n- If the neighboring cell is a wall:\n\n- Remove the wall between the current cell and the neighboring cell.\n\n- Mark the neighboring cell as visited.\n\n- Add the walls of the neighboring cell to the frontier.\n\n- Remove the wall from the frontier.\n\nThis should work.\n\nI need to represent the grid as a dictionary where keys are (row, col) tuples, and values are dictionaries of walls.\n\nFor example:\n\ngrid = {\n\n(0,0): {'n': True, 's': True, 'e': True, 'w': True},\n\n(0,1): {'n': True, 's': True, 'e': True, 'w': True},\n\n...\n\n}\n\nThis could be memory-intensive for large mazes, but for now, it's acceptable.\n\nAlternatively, I can use a list of lists, where each cell contains a string of four characters representing the walls.\n\nFor example, 'nswe' means all walls are present.\n\nWhen I remove a wall, I remove the corresponding character from the string.\n\nThis is more space-efficient.\n\nI think this is a good approach.\n\nLet me proceed with this.\n\nDefine grid as a list of lists of strings, initialized to 'nswe' for all cells.\n\nvisited = set()\n\nfrontier = []\n\nChoose a starting cell, say (0,0).\n\nMark it as visited.\n\nRemove the walls of the starting cell that are within bounds and add them to the frontier.\n\nFor example, for (0,0):\n\n- North wall: out of bounds, skip\n\n- South wall: (0,0) to (0,1), add to frontier\n\n- East wall: (0,0) to (1,0), add to frontier\n\n- West wall: out of bounds, skip\n\nSo, frontier = [(0,0,'s'), (0,0,'e')]\n\nIn each iteration:\n\n- Randomly select a wall from the frontier, say (0,0,'s')\n\n- Determine the neighboring cell: (0,1)\n\n- If (0,1) is not visited:\n\n- Remove the south wall of (0,0) and the north wall of (0,1)\n\n- Mark (0,1) as visited\n\n- Add the walls of (0,1) to the frontier: (0,1,'s'), (0,1,'e'), (0,1,'w')\n\n- Remove the wall (0,0,'s') from the frontier\n\nContinue this process until the frontier is empty.\n\nThis seems correct.\n\nNow, for displaying the maze, I need to convert this grid representation to ASCII characters.\n\nI need to print the maze with walls as '#' and paths as ' ', ensuring that the outer walls are present.\n\nThis requires iterating through the grid and printing the walls accordingly.\n\nThis might be a bit tricky, but manageable.\n\nLet me try to implement this step by step.\n\nFirst, define the grid with all walls present.\n\nThen, implement the Prim's algorithm to remove walls and create paths.\n\nFinally, render the grid as ASCII art.\n\nI need to make sure that the maze is enclosed by outer walls.\n\nAlso, I need to handle the boundaries correctly to avoid index errors.\n\nThis seems feasible.\n\nLet me proceed to write the code accordingly.\n\n## Final Solution\nTo generate a random maze using Prim's algorithm and display it using ASCII characters, follow the steps below.\n\n### Approach\n\n1. **Grid Initialization**: \n   - Represent the maze as a 2D grid where each cell can have walls in four directions: north, south, east, and west.\n   - Initialize the grid so that all cells have all their walls intact.\n\n2. **Maze Generation using Prim's Algorithm**:\n   - Start from a random cell and mark it as visited.\n   - Add the walls of the starting cell to a frontier list.\n   - While the frontier is not empty:\n     - Pick a random wall from the frontier.\n     - If the cell on the other side of the wall hasn't been visited:\n       - Remove the wall between the current cell and the neighboring cell.\n       - Mark the neighboring cell as visited.\n       - Add the walls of the neighboring cell to the frontier.\n     - Remove the wall from the frontier.\n\n3. **Display the Maze**:\n   - Represent walls with '#' and paths with spaces.\n   - Print the grid to display the maze.\n\n### Solution Code\n\n```python\nimport random\n\ndef initialize_grid(rows, cols):\n    # Initialize grid with all walls present\n    grid = {}\n    for r in range(rows):\n        for c in range(cols):\n            grid[(r, c)] = 'nswe'\n    return grid\n\ndef get_frontier Walls(grid, visited):\n    frontier = []\n    for cell in visited:\n        r, c = cell\n        for direction, (dr, dc) in [('n', (-1, 0)), ('s', (1, 0)), ('w', (0, -1)), ('e', (0, 1))]:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < rows and 0 <= nc < cols:\n                if 'nswe'.index(direction) < 4 and direction in grid[(r, c)] and grid[(nr, nc)]:\n                    frontier.append((r, c, direction))\n    return frontier\n\ndef remove_wall(grid, r, c, direction):\n    opposite = {'n': 's', 's': 'n', 'w': 'e', 'e': 'w'}\n    od = opposite[direction]\n    grid[(r, c)] = grid[(r, c)].replace(direction, '')\n    nr, nc = r + {'n': -1, 's': 1, 'w': 0, 'e': 0}[direction], c + {'n': 0, 's': 0, 'w': -1, 'e': 1}[direction]\n    grid[(nr, nc)] = grid[(nr, nc)].replace(od, '')\n\ndef generate_maze(rows, cols):\n    grid = initialize_grid(rows, cols)\n    visited = set()\n    frontier = []\n    \n    start_r, start_c = random.randint(0, rows-1), random.randint(0, cols-1)\n    visited.add((start_r, start_c))\n    frontier = get_frontier_walls(grid, visited)\n    \n    while frontier:\n        wall = random.choice(frontier)\n        r, c, direction = wall\n        nr, nc = r + {'n': -1, 's': 1, 'w': 0, 'e': 0}[direction], c + {'n': 0, 's': 0, 'w': -1, 'e': 1}[direction]\n        \n        if 0 <= nr < rows and 0 <= nc < cols and (nr, nc) not in visited:\n            remove_wall(grid, r, c, direction)\n            visited.add((nr, nc))\n            frontier.extend(get_frontier_walls(grid, visited))\n        frontier.remove(wall)\n    \n    return grid\n\ndef display_maze(grid, rows, cols):\n    for r in range(rows):\n        row = []\n        for c in range(cols):\n            cell = grid[(r, c)]\n            if 'n' in cell:\n                row.append('+---')\n            else:\n                row.append('+   ')\n        print(''.join(row) + '+')\n        row = []\n        for c in range(cols):\n            cell = grid[(r, c)]\n            if 'w' in cell:\n                row.append('|   ')\n            else:\n                row.append('    ')\n        print(''.join(row) + '|')\n    row = []\n    for c in range(cols):\n        row.append('+---')\n    print(''.join(row) + '+')\n\nif __name__ == \"__main__\":\n    rows = int(input(\"Enter number of rows: \"))\n    cols = int(input(\"Enter number of columns: \"))\n    maze = generate_maze(rows, cols)\n    display_maze(maze, rows, cols)\n```\n\n### Explanation\n\n1. **Grid Initialization**:\n   - Create a dictionary where each key is a tuple `(row, col)` representing a cell, and the value is a string of letters 'n', 's', 'e', 'w' indicating the presence of walls in the north, south, east, and west directions.\n\n2. **Maze Generation**:\n   - Start from a random cell, mark it as visited, and add its walls to the frontier.\n   - Randomly select a wall from the frontier. If the adjacent cell is unvisited, remove the wall and add the adjacent cell's walls to the frontier.\n   - Repeat until no walls are left in the frontier.\n\n3. **Display the Maze**:\n   - Print the grid by iterating through each cell and printing walls where they are present, using ASCII characters to form the maze visually."
    }
]