[
    {
        "role": "user",
        "content": "Develop a Golang RESTful API that interacts with Azure Blob Storage. The API should have endpoints to upload files to the storage, list all files, and download a file by its ID."
    },
    {
        "role": "assistant",
        "content": "Alright, I have this task to create a RESTful API using Golang that interacts with Azure Blob Storage. The API needs to have three main endpoints: one for uploading files, another for listing all files, and a third for downloading a file by its ID. I've never worked with Azure Blob Storage before, so I'll need to learn about that as well.\n\nFirst, I need to set up a basic Golang web server. I'm familiar with the net/http package, so I'll use that to handle HTTP requests. For a RESTful API, it's important to have clean and logical endpoints. So, for uploading files, I might have a POST endpoint at /files. For listing all files, a GET request to /files should suffice. And for downloading a file by its ID, a GET request to /files/{id} seems appropriate.\n\nBut wait, in Azure Blob Storage, files are called blobs, and they are stored in containers. So, I need to make sure I understand the concepts. A storage account contains one or more containers, and each container contains blobs. I think for simplicity, I'll assume there's one container for this API, and all operations are performed within that container.\n\nI need to figure out how to authenticate with Azure Blob Storage from my Go application. Azure uses Shared Key authentication or Shared Access Signatures (SAS) for accessing storage resources. I think using Shared Key authentication would be straightforward for this scenario, but I need to confirm.\n\nLet me look into the Azure SDK for Go. I believe there's an official Azure SDK that provides packages for interacting with Azure services, including Blob Storage. I should probably use that to make my life easier.\n\nOkay, I found that there's an azure-storage-blob package in the Azure SDK for Go. I need to install that. I'll use Go modules to manage dependencies.\n\nSo, in my go.mod file, I'll add:\n\nrequire (\n\n\u00a0\u00a0\u00a0\u00a0github.com/Azure/azure-storage-blob-go v0.9.0\n\n)\n\nNow, I need to import the necessary packages in my Go code. I think I'll need \"github.com/Azure/azure-storage-blob-go/azblob\" for working with Blob Storage.\n\nBefore I start writing code, I need to set up the connection to Azure Blob Storage. I'll need the storage account name and the account key for Shared Key authentication. I should probably store these as environment variables for security reasons.\n\nSo, in my Go code, I'll read the storage account name and key from environment variables.\n\nI need to create a NewPipeline with the storage account key and then create a NewServiceClient from that pipeline.\n\nOnce I have the service client, I can get a ContainerURL for the specific container I want to work with.\n\nWait, but first, I need to make sure the container exists. Maybe I should have an initialization function that checks if the container exists and creates it if it doesn't.\n\nFor uploading files, I'll need to handle file uploads via HTTP. In Go, I can use the multipart/form-data format to handle file uploads. I'll need to parse the request body to extract the file and then upload it to Blob Storage.\n\nWhen uploading, I need to assign a unique ID to each file. Maybe I can use UUIDs for that. I'll generate a UUID for each uploaded file and use that as the blob name.\n\nFor listing all files, I need to list all blobs in the container. The azblob package should have a function for listing blobs.\n\nI should consider pagination if there are a lot of files, but for now, I'll assume the number of files is manageable.\n\nFor downloading a file by its ID, I'll need to construct the blob URL using the provided ID and download the blob content, then send it back as the HTTP response.\n\nI also need to handle errors appropriately and return proper HTTP status codes.\n\nLet me sketch out the basic structure of the API.\n\nFirst, define the routes:\n\n- POST /files: Upload a file\n\n- GET /files: List all files\n\n- GET /files/{id}: Download a file by ID\n\nI'll use net/http to handle these routes.\n\nStarting with the upload endpoint:\n\n- Handle a POST request to /files\n\n- Parse the request body to extract the file\n\n- Generate a unique ID (UUID) for the file\n\n- Upload the file to Blob Storage with the generated ID as the blob name\n\n- Return the unique ID in the response\n\nFor listing files:\n\n- Handle a GET request to /files\n\n- List all blobs in the container\n\n- Extract the blob names (which are the file IDs)\n\n- Return a list of file IDs as JSON\n\nFor downloading a file:\n\n- Handle a GET request to /files/{id}\n\n- Construct the blob URL using the provided {id}\n\n- Download the blob content\n\n- Set the appropriate content type and content disposition headers\n\n- Return the file content in the response\n\nI need to make sure that the file IDs are URL-safe. Using UUIDs should be fine since they don't contain special characters that need to be encoded.\n\nI should also consider adding error handling for cases like:\n\n- Failed to connect to Blob Storage\n\n- Failed to upload/download a file\n\n- File not found when downloading\n\n- Invalid file ID\n\n- Too large files (need to handle file size limits)\n\nAdditionally, for production use, I should think about security aspects, such as:\n\n- Ensuring that only authorized users can upload and download files\n\n- Validating file types and sizes\n\n- Preventing directory traversal attacks\n\nBut for this initial implementation, I'll focus on getting the basic functionality working.\n\nLet me start by setting up the basic HTTP server.\n\nI'll create a main.go file and define the main function.\n\nIn the main function, I'll set up the routes using net/http.HandleFunc.\n\nFor example:\n\nfunc main() {\n\n\u00a0\u00a0\u00a0\u00a0http.HandleFunc(\"/files\", handleFiles)\n\n\u00a0\u00a0\u00a0\u00a0http.HandleFunc(\"/files/\", handleFile)\n\n\u00a0\u00a0\u00a0\u00a0log.Fatal(http.ListenAndServe(\":8080\", nil))\n\n}\n\nHere, handleFiles would handle both POST and GET requests for uploading and listing files, while handleFile would handle GET requests for downloading a specific file.\n\nWait, but in Go, HandleFunc doesn't support HTTP methods natively. I need to check the request method inside the handler function and handle accordingly.\n\nAlternatively, I can use a third-party package like Gorilla Mux for better routing capabilities, but for simplicity, I'll stick with net/http for now.\n\nSo, in handleFiles:\n\n- If the request method is POST, handle file upload\n\n- If the request method is GET, list all files\n\nIn handleFile:\n\n- Handle GET request to download a file by ID\n\nBut actually, I need to capture the {id} parameter in the URL. With net/http, I can't do dynamic routing easily, so I'll have to parse the URL path to extract the {id}.\n\nMaybe using Gorilla Mux would be better after all. It's a popular package for routing in Go.\n\nI can add it as a dependency:\n\nrequire (\n\n\u00a0\u00a0\u00a0\u00a0github.com/Azure/azure-storage-blob-go v0.9.0\n\n\u00a0\u00a0\u00a0\u00a0github.com/gorilla/mux v1.8.0\n\n)\n\nThen, I can define routes with placeholders for {id}.\n\nSo, in main:\n\nrouter := mux.NewRouter()\n\nrouter.HandleFunc(\"/files\", handleFiles).Methods(\"POST\", \"GET\")\n\nrouter.HandleFunc(\"/files/{id}\", handleFile).Methods(\"GET\")\n\nlog.Fatal(http.ListenAndServe(\":8080\", router))\n\nThis way, in handleFile, I can get the {id} from the request URL using:\n\nparams := mux.Vars(request)\n\nid := params[\"id\"]\n\nNow, I need to set up the connection to Azure Blob Storage.\n\nI'll create a separate function to initialize the Blob Service Client.\n\nI need to read the storage account name and key from environment variables.\n\nIn Go, I can use os.Getenv to read environment variables.\n\nSo, something like:\n\naccountName := os.Getenv(\"AZURE_STORAGE_ACCOUNT\")\n\naccountKey := os.Getenv(\"AZURE_STORAGE_KEY\")\n\nThen, create a NewSharedKeyCredential:\n\ncredential, _ := azblob.NewSharedKeyCredential(accountName, accountKey)\n\nThen, create a NewPipeline:\n\npipeline := azblob.NewPipeline(credential, azblob.PipelineOptions{})\n\nThen, create a NewServiceURL:\n\nurl := azblob.NewServiceURL(\n\n\u00a0\u00a0\u00a0\u00a0*azblob.NewBlobServiceEndpoint(accountName, azure.Public),\n\n\u00a0\u00a0\u00a0\u00a0pipeline,\n\n)\n\nThen, get a ContainerURL:\n\ncontainerURL := url.NewContainerURL(containerName)\n\nI should probably wrap this initialization in a function and call it once when the application starts.\n\nI need to make sure that the container exists. Maybe I can create it if it doesn't exist.\n\nAzblob has a method to create a container:\n\nresp, err := containerURL.Create(context.Background(), azblob.Metadata{}, azblob.PublicAccessNone)\n\nBut I need to handle the case where the container already exists.\n\nI should check if the container exists before trying to create it.\n\nAzblob has a method to check if a container exists:\n\nresp, err := containerURL.Exists(context.Background())\n\nif !resp.Exists() {\n\n\u00a0\u00a0\u00a0\u00a0// Create the container\n\n}\n\nOkay, now, for uploading a file.\n\nIn the handleFiles function, if the method is POST, I need to handle file upload.\n\nIn Go, to handle file uploads, I need to parse the multipart form data.\n\nFirst, I need to parse the request body:\n\nerr := request.ParseMultipartForm(maxMemory)\n\nif err != nil {\n\n\u00a0\u00a0\u00a0\u00a0http.Error(w, \"Error parsing form data\", http.StatusBadRequest)\n\n\u00a0\u00a0\u00a0\u00a0return\n\n}\n\nThen, get the file from the form data:\n\nfile, handler, err := request.FormFile(\"file\")\n\nif err != nil {\n\n\u00a0\u00a0\u00a0\u00a0http.Error(w, \"Error retrieving file\", http.StatusBadRequest)\n\n\u00a0\u00a0\u00a0\u00a0return\n\n}\n\ndefer file.Close()\n\nNow, I need to generate a unique ID for the file. I'll use UUIDs.\n\nI can use the github.com/satori/go.uuid package to generate UUIDs.\n\nFirst, add it as a dependency:\n\nrequire (\n\n\u00a0\u00a0\u00a0\u00a0github.com/Azure/azure-storage-blob-go v0.9.0\n\n\u00a0\u00a0\u00a0\u00a0github.com/gorilla/mux v1.8.0\n\n\u00a0\u00a0\u00a0\u00a0github.com/satori/go.uuid v1.2.0\n\n)\n\nThen, import it:\n\nimport \"github.com/satori/go.uuid\"\n\nGenerate a UUID:\n\nuuid := uuid.NewV4()\n\nNow, I need to upload the file to Blob Storage with this UUID as the blob name.\n\nUsing azblob, I can create a BlockBlobURL:\n\nblockBlobURL := containerURL.NewBlockBlobURL(uuid.String())\n\nThen, upload the file:\n\nctx := context.Background()\n\n_, err = azblob.NewBlockBlobClient(blockBlobURL.URL(), pipeline).Upload(ctx, file, azblob.BlobHTTPHeaders{}, azblob.Metadata{}, azblob.BlobAccessConditions{})\n\nif err != nil {\n\n\u00a0\u00a0\u00a0\u00a0http.Error(w, \"Error uploading file\", http.StatusInternalServerError)\n\n\u00a0\u00a0\u00a0\u00a0return\n\n}\n\nFinally, return the UUID in the response:\n\nw.WriteHeader(http.StatusCreated)\n\njson.NewEncoder(w).Encode(map[string]string{\"id\": uuid.String()})\n\nFor listing all files, I need to list all blobs in the container.\n\nAzblob has a ListBlobsFlatSegmentListing function:\n\nmarker := azblob.Marker{}\n\nfor marker.NotDone() {\n\n\u00a0\u00a0\u00a0\u00a0listBlob, err := containerURL.ListBlobsFlatSegment(context.Background(), marker, azblob.ListBlobsSegmentOptions{})\n\n\u00a0\u00a0\u00a0\u00a0if err != nil {\n\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0http.Error(w, \"Error listing blobs\", http.StatusInternalServerError)\n\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\n\n\u00a0\u00a0\u00a0\u00a0}\n\n\u00a0\u00a0\u00a0\u00a0for _, blobInfo := range listBlob.Segment.BlobItems {\n\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Collect blob names\n\n\u00a0\u00a0\u00a0\u00a0}\n\n\u00a0\u00a0\u00a0\u00a0marker = listBlob.NextMarker\n\n}\n\nBut maybe for simplicity, I'll assume that the number of blobs is small and don't worry about pagination.\n\nSo, listBlob, err := containerURL.ListBlobsFlatSegment(context.Background(), azblob.Marker{}, azblob.ListBlobsSegmentOptions{})\n\nif err != nil {\n\n\u00a0\u00a0\u00a0\u00a0http.Error(w, \"Error listing blobs\", http.StatusInternalServerError)\n\n\u00a0\u00a0\u00a0\u00a0return\n\n}\n\nvar fileIDs []string\n\nfor _, blobInfo := range listBlob.Segment.BlobItems {\n\n\u00a0\u00a0\u00a0\u00a0fileIDs = append(fileIDs, blobInfo.Name)\n\n}\n\njson.NewEncoder(w).Encode(fileIDs)\n\nFor downloading a file by ID, I need to construct the blob URL using the provided ID and download the blob content.\n\nFirst, get the {id} from the URL parameters.\n\nThen, create a BlockBlobURL:\n\nblockBlobURL := containerURL.NewBlockBlobURL(id)\n\nThen, download the blob:\n\nresp, err := blockBlobURL.Download(context.Background(), 0, azblob.CountToEnd, azblob.BlobAccessConditions{}, false)\n\nif err != nil {\n\n\u00a0\u00a0\u00a0\u00a0http.Error(w, \"Error downloading file\", http.StatusNotFound)\n\n\u00a0\u00a0\u00a0\u00a0return\n\n}\n\n// Read the downloaded data\n\ndata, err := azblob.NTFRToReader(resp.Body(azblob.ReadAheadNone))\n\nif err != nil {\n\n\u00a0\u00a0\u00a0\u00a0http.Error(w, \"Error reading file data\", http.StatusInternalServerError)\n\n\u00a0\u00a0\u00a0\u00a0return\n\n}\n\n// Set content type and disposition headers\n\nw.Header().Set(\"Content-Type\", \"application/octet-stream\")\n\nw.Header().Set(\"Content-Disposition\", \"attachment; filename=\"+id)\n\n// Write the data to the response\n\nio.Copy(w, data)\n\nOkay, this is a basic outline of what needs to be done.\n\nI should also consider adding error handling for cases where the container doesn't exist or other Azure Storage errors.\n\nAdditionally, I need to make sure that the Azure Storage account and container are set up correctly and that the account name and key are provided via environment variables.\n\nI might also want to configure logging for the API to help with debugging.\n\nOverall, this seems manageable. I'll proceed to implement these functionalities step by step.\n\n## Final Solution\nTo create a RESTful API in Golang that interacts with Azure Blob Storage, follow these steps. This API will have endpoints to upload files, list all files, and download a file by its ID.\n\n### Prerequisites\n1. **Azure Storage Account**: Ensure you have an Azure Storage account and note down the account name and account key.\n2. **Go Modules**: Use Go modules to manage dependencies.\n3. **Environment Variables**: Set environment variables for the storage account name and key.\n\n### Solution Code\n\n```go\npackage main\n\nimport (\n    \"context\"\n    \"encoding/json\"\n    \"io\"\n    \"log\"\n    \"net/http\"\n\n    \"github.com/Azure/azure-storage-blob-go/azblob\"\n    \"github.com/gorilla/mux\"\n    \"github.com/satori/go.uuid\"\n    \"github.com/joho/godotenv\"\n    \"os\"\n)\n\nvar containerURL *azblob.ContainerURL\n\nfunc main() {\n    // Load environment variables from .env file\n    err := godotenv.Load()\n    if err != nil {\n        log.Println(\"No .env file found\")\n    }\n\n    accountName := os.Getenv(\"AZURE_STORAGE_ACCOUNT\")\n    accountKey := os.Getenv(\"AZURE_STORAGE_KEY\")\n    containerName := os.Getenv(\"AZURE_STORAGE_CONTAINER\")\n\n    credential, _ := azblob.NewSharedKeyCredential(accountName, accountKey)\n    pipeline := azblob.NewPipeline(credential, azblob.PipelineOptions{})\n    url := azblob.NewServiceURL(\n        *azblob.NewBlobServiceEndpoint(accountName, azblob.Public),\n        pipeline,\n    )\n    containerURL = &url.NewContainerURL(containerName)\n\n    // Ensure the container exists\n    exists, err := containerURL.Exists(context.Background())\n    if !exists {\n        _, err := containerURL.Create(context.Background(), azblob.Metadata{}, azblob.PublicAccessNone)\n        if err != nil {\n            log.Fatalf(\"Failed to create container: %v\", err)\n        }\n    }\n\n    router := mux.NewRouter()\n    router.HandleFunc(\"/files\", handleFiles).Methods(\"POST\", \"GET\")\n    router.HandleFunc(\"/files/{id}\", handleFile).Methods(\"GET\")\n\n    log.Fatal(http.ListenAndServe(\":8080\", router))\n}\n\nfunc handleFiles(w http.ResponseWriter, r *http.Request) {\n    switch r.Method {\n    case \"POST\":\n        handleFileUpload(w, r)\n    case \"GET\":\n        listFiles(w, r)\n    default:\n        http.Error(w, \"Invalid request method\", http.StatusMethodNotAllowed)\n    }\n}\n\nfunc handleFileUpload(w http.ResponseWriter, r *http.Request) {\n    if err := r.ParseMultipartForm(10 << 20); err != nil {\n        http.Error(w, \"Error parsing form data\", http.StatusBadRequest)\n        return\n    }\n\n    file, handler, err := r.FormFile(\"file\")\n    if err != nil {\n        http.Error(w, \"Error retrieving file\", http.StatusBadRequest)\n        return\n    }\n    defer file.Close()\n\n    uuid := uuid.NewV4()\n    blockBlobURL := containerURL.NewBlockBlobURL(uuid.String())\n\n    _, err = azblob.NewBlockBlobClient(blockBlobURL.URL(), containerURL.Pipeline()).Upload(context.Background(), file, azblob.BlobHTTPHeaders{}, azblob.Metadata{}, azblob.BlobAccessConditions{})\n    if err != nil {\n        http.Error(w, \"Error uploading file\", http.StatusInternalServerError)\n        return\n    }\n\n    w.WriteHeader(http.StatusCreated)\n    json.NewEncoder(w).Encode(map[string]string{\"id\": uuid.String()})\n}\n\nfunc listFiles(w http.ResponseWriter, r *http.Request) {\n    listBlob, err := containerURL.ListBlobsFlatSegment(context.Background(), azblob.Marker{}, azblob.ListBlobsSegmentOptions{})\n    if err != nil {\n        http.Error(w, \"Error listing blobs\", http.StatusInternalServerError)\n        return\n    }\n\n    var fileIDs []string\n    for _, blobInfo := range listBlob.Segment.BlobItems {\n        fileIDs = append(fileIDs, blobInfo.Name)\n    }\n\n    json.NewEncoder(w).Encode(fileIDs)\n}\n\nfunc handleFile(w http.ResponseWriter, r *http.Request) {\n    params := mux.Vars(r)\n    id := params[\"id\"]\n\n    blockBlobURL := containerURL.NewBlockBlobURL(id)\n    resp, err := blockBlobURL.Download(context.Background(), 0, azblob.CountToEnd, azblob.BlobAccessConditions{}, false)\n    if err != nil {\n        http.Error(w, \"Error downloading file\", http.StatusNotFound)\n        return\n    }\n\n    data, err := azblob.NTFRToReader(resp.Body(azblob.ReadAheadNone))\n    if err != nil {\n        http.Error(w, \"Error reading file data\", http.StatusInternalServerError)\n        return\n    }\n\n    w.Header().Set(\"Content-Type\", \"application/octet-stream\")\n    w.Header().Set(\"Content-Disposition\", \"attachment; filename=\"+id)\n    io.Copy(w, data)\n}\n```\n\n### Explanation\n\n1. **Setup**:\n   - Load environment variables using `godotenv`.\n   - Initialize Azure Blob Storage client with account name and key.\n   - Ensure the specified container exists, creating it if necessary.\n\n2. **Routing**:\n   - Use `Gorilla Mux` for routing.\n   - Define routes for file operations: upload, list, and download.\n\n3. **File Upload**:\n   - Parse multipart form data to extract the file.\n   - Generate a unique ID (UUID) for the file.\n   - Upload the file to Azure Blob Storage using the generated ID as the blob name.\n   - Respond with the file ID.\n\n4. **List Files**:\n   - List all blobs in the container.\n   - Extract and return the blob names (file IDs) as a JSON array.\n\n5. **Download File**:\n   - Construct the blob URL using the provided file ID.\n   - Download the blob content.\n   - Set appropriate headers and return the file content.\n\nThis solution provides a basic implementation and can be extended with additional features like authentication, file type validation, and error handling as per requirements."
    }
]