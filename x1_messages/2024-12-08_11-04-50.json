[
    {
        "role": "user",
        "content": "Create a C++ program that implements Dijkstra's shortest path algorithm on a directed graph represented by an adjacency matrix."
    },
    {
        "role": "assistant",
        "content": "Certainly! Implementing Dijkstra's shortest path algorithm in C++ for a directed graph represented by an adjacency matrix is a great way to understand both graph theory and algorithmic problem-solving. Dijkstra's algorithm is used to find the shortest path from a source vertex to all other vertices in a graph with non-negative edge weights.\n\n## Approach\n\n1. **Graph Representation**: Use a 2D vector to represent the adjacency matrix of the graph. The value `graph[i][j]` will represent the weight of the edge from vertex `i` to vertex `j`. If there is no edge, it can be represented by a large value (e.g., `INF`).\n\n2. **Priority Queue**: Use a priority queue to always pick the vertex with the minimum distance.\n\n3. **Distance Array**: Keep an array to store the shortest distances from the source to each vertex.\n\n4. **Visited Array**: Track vertices that have been processed to avoid processing them multiple times.\n\n## Solution Code\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n\nusing namespace std;\n\n// Define INF as a large value to represent infinity\nconst int INF = INT_MAX;\n\nvector<int> dijkstra(int src, const vector<vector<int>>& graph) {\n    int V = graph.size();\n    vector<int> dist(V, INF);\n    vector<bool> visited(V, false);\n\n    // Priority queue to store vertices distances, smaller distance has higher priority\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n\n    dist[src] = 0;\n    pq.push(make_pair(0, src));\n\n    while (!pq.empty()) {\n        // Get the vertex with the minimum distance value, and it is not yet included in the shortest path tree\n        int u = pq.top().second;\n        pq.pop();\n\n        // Mark the picked vertex as processed\n        if (visited[u])\n            continue;\n        visited[u] = true;\n\n        // Update dist value of the adjacent vertices of the picked vertex\n        for (int v = 0; v < V; v++) {\n            if (!visited[v] && graph[u][v] && dist[u] != INF && dist[u] + graph[u][v] < dist[v]) {\n                dist[v] = dist[u] + graph[u][v];\n                pq.push(make_pair(dist[v], v));\n            }\n        }\n    }\n\n    return dist;\n}\n\nint main() {\n    int V, E;\n    cout << \"Enter the number of vertices: \";\n    cin >> V;\n    cout << \"Enter the number of edges: \";\n    cin >> E;\n\n    vector<vector<int>> graph(V, vector<int>(V, 0));\n\n    cout << \"Enter the edges (u v w):\" << endl;\n    for (int i = 0; i < E; i++) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        graph[u][v] = w;\n    }\n\n    int src;\n    cout << \"Enter the source vertex: \";\n    cin >> src;\n\n    vector<int> dist = dijkstra(src, graph);\n\n    cout << \"Vertex\\tDistance from Source\" << endl;\n    for (int i = 0; i < V; i++)\n        cout << i << \"\\t\" << (dist[i] == INF ? \"INF\" : to_string(dist[i])) << endl;\n\n    return 0;\n}\n```\n\n## Explanation\n\n1. **Graph Input**: The user is prompted to enter the number of vertices and edges. Then, they input the edges in the format `u v w`, where `u` and `v` are the vertices connected by an edge with weight `w`.\n\n2. **Dijkstra's Algorithm**:\n   - Initialize the distance to the source as 0 and to all other vertices as `INF`.\n   - Use a priority queue to always select the vertex with the smallest distance.\n   - For the current vertex, update the distances of its adjacent vertices if a shorter path is found.\n   - Mark vertices as visited once their shortest distances are confirmed.\n\n3. **Output**: The program prints the shortest distances from the source vertex to all other vertices. If a vertex is not reachable, it prints \"INF\".\n\nThis implementation ensures that you understand how Dijkstra's algorithm works and how to implement it efficiently in C++."
    }
]