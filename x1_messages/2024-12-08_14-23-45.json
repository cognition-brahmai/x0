[
    {
        "role": "user",
        "content": "Write a Golang web server using the Echo framework that has endpoints for creating, reading, updating, and deleting notes stored in a SQLite database. Each note should have a title, content, and timestamp.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Alright, I've got this task to create a Golang web server using the Echo framework that handles CRUD operations for notes stored in a SQLite database. Each note needs to have a title, content, and a timestamp. I'm going to break this down step by step.\n\nFirst things first, I need to set up a new Go project. I'll create a new directory for this project and initialize it with `go mod init`. Let's assume I'll name the module \"noteapp\".\n\nNext, I need to install the necessary packages. I'll need the Echo framework for the web server and a library to handle SQLite databases. For Echo, I can use \"github.com/labstack/echo/v4\", and for SQLite, I can use the built-in \"database/sql\" package along with the \"github.com/mattn/go-sqlite3\" driver.\n\nSo, in my terminal, I'll run:\n\n```\nmkdir noteapp\ncd noteapp\ngo mod init noteapp\ngo get github.com/labstack/echo/v4\ngo get github.com/mattn/go-sqlite3\n```\n\nNow, I need to design the structure of the notes. Each note will have an ID (auto-incremented), title, content, and a timestamp. I'll define a struct for this.\n\n```go\ntype Note struct {\n    ID        int       `json:\"id\"`\n    Title     string    `json:\"title\"`\n    Content   string    `json:\"content\"`\n    Timestamp time.Time `json:\"timestamp\"`\n}\n```\n\nI need to set up the database connection and create the notes table if it doesn't exist. I'll write a function to handle this.\n\n```go\nfunc setupDB() *sql.DB {\n    db, err := sql.Open(\"sqlite3\", \"./notes.db\")\n    if err != nil {\n        log.Fatal(err)\n    }\n    _, err = db.Exec(`CREATE TABLE IF NOT EXISTS notes (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        title TEXT NOT NULL,\n        content TEXT NOT NULL,\n        timestamp DATETIME DEFAULT CURRENT_TIMESTAMP\n    )`)\n    if err != nil {\n        log.Fatal(err)\n    }\n    return db\n}\n```\n\nNow, I'll set up the Echo server.\n\n```go\ne := echo.New()\ndb := setupDB()\n// Define routes here\ne.Logger.Fatal(e.Start(\":8080\"))\n```\n\nI need to create endpoints for CRUD operations.\n\n1. **Create Note** - POST /notes\n\n   - Accepts JSON with title and content.\n\n   - Inserts a new note into the database with the current timestamp.\n\n   - Returns the newly created note.\n\n2. **Read Notes** - GET /notes\n\n   - Retrieves all notes from the database.\n\n   - Optionally, accept a query parameter to filter by title.\n\n3. **Update Note** - PUT /notes/:id\n\n   - Accepts JSON with title and content.\n\n   - Updates the note with the specified ID.\n\n   - Returns the updated note.\n\n4. **Delete Note** - DELETE /notes/:id\n\n   - Deletes the note with the specified ID.\n\n   - Returns a success message.\n\nLet's start with the Create Note endpoint.\n\n```go\nfunc createNote(c echo.Context) error {\n    note := new(Note)\n    if err := c.Bind(note); err != nil {\n        return err\n    }\n    stmt, err := db.Prepare(\"INSERT INTO notes(title, content) VALUES(?, ?)\")\n    if err != nil {\n        return err\n    }\n    res, err := stmt.Exec(note.Title, note.Content)\n    if err != nil {\n        return err\n    }\n    noteID, _ := res.LastInsertId()\n    note.ID = int(noteID)\n    stmt.QueryRow(noteID).Scan(&note.ID, &note.Title, &note.Content, &note.Timestamp)\n    return c.JSON(http.StatusCreated, note)\n}\n```\n\nNext, the Read Notes endpoint.\n\n```go\nfunc getNotes(c echo.Context) error {\n    title := c.QueryParam(\"title\")\n    var notes []Note\n    if title != \"\" {\n        rows, err := db.Query(\"SELECT id, title, content, timestamp FROM notes WHERE title LIKE ?\", \"%\"+title+\"%\")\n        if err != nil {\n            return err\n        }\n        defer rows.Close()\n        for rows.Next() {\n            var note Note\n            if err := rows.Scan(&note.ID, &note.Title, &note.Content, &note.Timestamp); err != nil {\n                return err\n            }\n            notes = append(notes, note)\n        }\n    } else {\n        rows, err := db.Query(\"SELECT id, title, content, timestamp FROM notes\")\n        if err != nil {\n            return err\n        }\n        defer rows.Close()\n        for rows.Next() {\n            var note Note\n            if err := rows.Scan(&note.ID, &note.Title, &note.Content, &note.Timestamp); err != nil {\n                return err\n            }\n            notes = append(notes, note)\n        }\n    }\n    return c.JSON(http.StatusOK, notes)\n}\n```\n\nThen, the Update Note endpoint.\n\n```go\nfunc updateNote(c echo.Context) error {\n    note := new(Note)\n    if err := c.Bind(note); err != nil {\n        return err\n    }\n    id := c.Param(\"id\")\n    stmt, err := db.Prepare(\"UPDATE notes SET title=?, content=? WHERE id=?\")\n    if err != nil {\n        return err\n    }\n    _, err = stmt.Exec(note.Title, note.Content, id)\n    if err != nil {\n        return err\n    }\n    stmt, err = db.Prepare(\"SELECT id, title, content, timestamp FROM notes WHERE id=?\")\n    if err != nil {\n        return err\n    }\n    defer stmt.Close()\n    note.ID, _ = strconv.Atoi(id)\n    err = stmt.QueryRow(id).Scan(&note.ID, &note.Title, &note.Content, &note.Timestamp)\n    if err != nil {\n        return err\n    }\n    return c.JSON(http.StatusOK, note)\n}\n```\n\nFinally, the Delete Note endpoint.\n\n```go\nfunc deleteNote(c echo.Context) error {\n    id := c.Param(\"id\")\n    stmt, err := db.Prepare(\"DELETE FROM notes WHERE id=?\")\n    if err != nil {\n        return err\n    }\n    _, err = stmt.Exec(id)\n    if err != nil {\n        return err\n    }\n    return c.JSON(http.StatusOK, map[string]string{\"message\": \"Note deleted\"})\n}\n```\n\nNow, I need to register these handlers with Echo.\n\n```go\ne.POST(\"/notes\", createNote)\ne.GET(\"/notes\", getNotes)\ne.PUT(\"/notes/:id\", updateNote)\ne.DELETE(\"/notes/:id\", deleteNote)\n```\n\nI should also handle any potential errors and make sure to close the database connection when the server shuts down.\n\nTo do this, I can use Echo's shutdown hook.\n\n```go\ne.ShutdownHooks(func() {\n    db.Close()\n})\n```\n\nAlso, I need to make sure that the Note struct properly handles JSON marshaling and timestamp formatting.\n\nI can use the \"time\" package to handle timestamps.\n\n```go\nimport (\n    \"database/sql\"\n    \"encoding/json\"\n    \"net/http\"\n    \"strconv\"\n    \"time\"\n\n    \"github.com/labstack/echo/v4\"\n    _ \"github.com/mattn/go-sqlite3\"\n)\n\ntype Note struct {\n    ID        int       `json:\"id\"`\n    Title     string    `json:\"title\"`\n    Content   string    `json:\"content\"`\n    Timestamp time.Time `json:\"timestamp\"`\n}\n\nfunc setupDB() *sql.DB {\n    db, err := sql.Open(\"sqlite3\", \"./notes.db\")\n    if err != nil {\n        log.Fatal(err)\n    }\n    _, err = db.Exec(`CREATE TABLE IF NOT EXISTS notes (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        title TEXT NOT NULL,\n        content TEXT NOT NULL,\n        timestamp DATETIME DEFAULT CURRENT_TIMESTAMP\n    )`)\n    if err != nil {\n        log.Fatal(err)\n    }\n    return db\n}\n\nfunc createNote(c echo.Context) error {\n    note := new(Note)\n    if err := c.Bind(note); err != nil {\n        return err\n    }\n    stmt, err := db.Prepare(\"INSERT INTO notes(title, content) VALUES(?, ?)\")\n    if err != nil {\n        return err\n    }\n    res, err := stmt.Exec(note.Title, note.Content)\n    if err != nil {\n        return err\n    }\n    noteID, _ := res.LastInsertId()\n    note.ID = int(noteID)\n    stmt.QueryRow(noteID).Scan(&note.ID, &note.Title, &note.Content, &note.Timestamp)\n    return c.JSON(http.StatusCreated, note)\n}\n\nfunc getNotes(c echo.Context) error {\n    title := c.QueryParam(\"title\")\n    var notes []Note\n    if title != \"\" {\n        rows, err := db.Query(\"SELECT id, title, content, timestamp FROM notes WHERE title LIKE ?\", \"%\"+title+\"%\")\n        if err != nil {\n            return err\n        }\n        defer rows.Close()\n        for rows.Next() {\n            var note Note\n            if err := rows.Scan(&note.ID, &note.Title, &note.Content, &note.Timestamp); err != nil {\n                return err\n            }\n            notes = append(notes, note)\n        }\n    } else {\n        rows, err := db.Query(\"SELECT id, title, content, timestamp FROM notes\")\n        if err != nil {\n            return err\n        }\n        defer rows.Close()\n        for rows.Next() {\n            var note Note\n            if err := rows.Scan(&note.ID, &note.Title, &note.Content, &note.Timestamp); err != nil {\n                return err\n            }\n            notes = append(notes, note)\n        }\n    }\n    return c.JSON(http.StatusOK, notes)\n}\n\nfunc updateNote(c echo.Context) error {\n    note := new(Note)\n    if err := c.Bind(note); err != nil {\n        return err\n    }\n    id := c.Param(\"id\")\n    stmt, err := db.Prepare(\"UPDATE notes SET title=?, content=? WHERE id=?\")\n    if err != nil {\n        return err\n    }\n    _, err = stmt.Exec(note.Title, note.Content, id)\n    if err != nil {\n        return err\n    }\n    stmt, err = db.Prepare(\"SELECT id, title, content, timestamp FROM notes WHERE id=?\")\n    if err != nil {\n        return err\n    }\n    defer stmt.Close()\n    note.ID, _ = strconv.Atoi(id)\n    err = stmt.QueryRow(id).Scan(&note.ID, &note.Title, &note.Content, &note.Timestamp)\n    if err != nil {\n        return err\n    }\n    return c.JSON(http.StatusOK, note)\n}\n\nfunc deleteNote(c echo.Context) error {\n    id := c.Param(\"id\")\n    stmt, err := db.Prepare(\"DELETE FROM notes WHERE id=?\")\n    if err != nil {\n        return err\n    }\n    _, err = stmt.Exec(id)\n    if err != nil {\n        return err\n    }\n    return c.JSON(http.StatusOK, map[string]string{\"message\": \"Note deleted\"})\n}\n\nfunc main() {\n    e := echo.New()\n    db := setupDB()\n    defer db.Close()\n\n    e.POST(\"/notes\", createNote)\n    e.GET(\"/notes\", getNotes)\n    e.PUT(\"/notes/:id\", updateNote)\n    e.DELETE(\"/notes/:id\", deleteNote)\n\n    e.Logger.Fatal(e.Start(\":8080\"))\n}\n```\n\nI should also consider adding some validation to ensure that the title and content are not empty when creating or updating notes.\n\nI can use Echo's validator for this.\n\nFirst, I need to define a Note struct with validation tags.\n\n```go\ntype Note struct {\n    ID        int       `json:\"id\" validate:\"omitempty\"`\n    Title     string    `json:\"title\" validate:\"required\"`\n    Content   string    `json:\"content\" validate:\"required\"`\n    Timestamp time.Time `json:\"timestamp\" validate:\"omitempty\"`\n}\n```\n\nThen, in the createNote and updateNote functions, I can validate the note struct.\n\n```go\nif err := e.Validate(note); err != nil {\n    return err\n}\n```\n\nI need to make sure that the validator is installed.\n\n```\ngo get github.com/go-playground/validator/v10\n```\n\nAnd initialize it in the main function.\n\n```go\nvalidate := validator.New()\ne.Validator = validate\n```\n\nAlso, in the updateNote function, I should only update the fields that are present in the request JSON, not overwrite with empty values.\n\nTo handle this, I can check if the title and content are empty and only update the fields that are provided.\n\nAlternatively, I can use a partial update approach.\n\nBut for simplicity, I'll assume that the client provides all fields in the update request.\n\nLastly, I should handle cases where the note ID does not exist in the database, returning a proper error message.\n\nFor example, in the updateNote and deleteNote functions, I can check if the note exists before performing the operation.\n\n```go\nrow := db.QueryRow(\"SELECT id FROM notes WHERE id=?\", id)\nvar noteID int\nerr := row.Scan(&noteID)\nif err == sql.ErrNoRows {\n    return echo.NewHTTPError(http.StatusNotFound, \"Note not found\")\n} else if err != nil {\n    return err\n}\n```\n\nI'll add this check in both updateNote and deleteNote functions.\n\nAlso, in the getNotes function, if no notes are found, I can return an empty array instead of an error.\n\nSimilarly, in createNote, I should handle any database errors that may occur during insertion.\n\nI should also make sure to handle closing database statements to prevent leaks.\n\nI can use `defer stmt.Close()` where appropriate.\n\nAdditionally, I can improve the timestamp handling by formatting it to a string in the JSON response.\n\nI can customize the JSON marshaling for the Note struct to format the timestamp.\n\nI can achieve this by implementing the json.Marshaler interface.\n\n```go\nfunc (n Note) MarshalJSON() ([]byte, error) {\n    type NoteType Note // indirection to avoid infinite loop\n    ts := n.Timestamp.Format(\"2006-01-02 15:04:05\")\n    return json.Marshal(&struct {\n        Timestamp string\n        NoteType\n    }{\n        Timestamp: ts,\n        NoteType:  NoteType(n),\n    })\n}\n```\n\nThis way, the timestamp will be formatted as a string in the JSON response.\n\nI should also handle the case where the client sends an invalid ID in the URL.\n\nFor example, if the ID is not a valid integer, I should return a bad request error.\n\nI can add a check in the updateNote and deleteNote functions to ensure that the ID is a valid integer.\n\n```go\nid := c.Param(\"id\")\nnoteID, err := strconv.Atoi(id)\nif err != nil {\n    return echo.NewHTTPError(http.StatusBadRequest, \"Invalid note ID\")\n}\n```\n\nFurthermore, I can add middleware for CORS if needed, especially if this API is going to be used with a frontend running on a different domain.\n\nI can use Echo's built-in CORS middleware.\n\n```go\ne.Use(middleware.CORSWithConfig(middleware.CORSConfig{\n    AllowOrigins: []string{\"*\"},\n    AllowMethods: []string{echo.GET, echo.PUT, echo.POST, echo.DELETE},\n}))\n```\n\nI should also consider logging requests for debugging purposes.\n\nEcho has a built-in logger that can be enabled.\n\nI can customize the logger if needed.\n\nMoreover, I can add error handling middleware to handle errors consistently across all endpoints.\n\nEcho has a `Use` function where I can add global middleware.\n\nFor example:\n\n```go\ne.Use(middleware.Recover())\ne.Use(middleware.Logger())\n```\n\nThis will recover from any panics and log each request.\n\nLastly, I should ensure that the database connection is properly closed when the server shuts down.\n\nI've already added a defer db.Close() in the main function, which should handle this.\n\nHowever, in some cases, it's better to use Echo's shutdown hooks to ensure proper cleanup.\n\nI can do something like:\n\n```go\ne.ShutdownHooks(func() {\n    db.Close()\n})\n```\n\nBut in the current Echo version, ShutdownHooks might not be directly available.\n\nI can refer to the Echo documentation for the correct way to add shutdown hooks.\n\nAlternatively, I can use a context to handle shutdowns properly.\n\nBut for simplicity, the defer db.Close() should suffice for this example.\n\nIn summary, here's the complete code with the aforementioned improvements:\n\n```go\npackage main\n\nimport (\n    \"database/sql\"\n    \"encoding/json\"\n    \"net/http\"\n    \"strconv\"\n    \"time\"\n\n    \"github.com/go-playground/validator/v10\"\n    \"github.com/labstack/echo/v4\"\n    _ \"github.com/mattn/go-sqlite3\"\n)\n\ntype Note struct {\n    ID        int       `json:\"id\" validate:\"omitempty\"`\n    Title     string    `json:\"title\" validate:\"required\"`\n    Content   string    `json:\"content\" validate:\"required\"`\n    Timestamp time.Time `json:\"timestamp\" validate:\"omitempty\"`\n}\n\nfunc (n Note) MarshalJSON() ([]byte, error) {\n    type NoteType Note // indirection to avoid infinite loop\n    ts := n.Timestamp.Format(\"2006-01-02 15:04:05\")\n    return json.Marshal(&struct {\n        Timestamp string\n        NoteType\n    }{\n        Timestamp: ts,\n        NoteType:  NoteType(n),\n    })\n}\n\nvar db *sql.DB\n\nfunc setupDB() {\n    var err error\n    db, err = sql.Open(\"sqlite3\", \"./notes.db\")\n    if err != nil {\n        panic(err)\n    }\n    _, err = db.Exec(`CREATE TABLE IF NOT EXISTS notes (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        title TEXT NOT NULL,\n        content TEXT NOT NULL,\n        timestamp DATETIME DEFAULT CURRENT_TIMESTAMP\n    )`)\n    if err != nil {\n        panic(err)\n    }\n}\n\nfunc createNote(c echo.Context) error {\n    note := new(Note)\n    if err := c.Bind(note); err != nil {\n        return err\n    }\n    if err := c.Validate(note); err != nil {\n        return err\n    }\n    stmt, err := db.Prepare(\"INSERT INTO notes(title, content) VALUES(?, ?)\")\n    if err != nil {\n        return err\n    }\n    defer stmt.Close()\n    res, err := stmt.Exec(note.Title, note.Content)\n    if err != nil {\n        return err\n    }\n    noteID, err := res.LastInsertId()\n    if err != nil {\n        return err\n    }\n    note.ID = int(noteID)\n    row := db.QueryRow(\"SELECT title, content, timestamp FROM notes WHERE id=?\", noteID)\n    err = row.Scan(&note.Title, &note.Content, &note.Timestamp)\n    if err != nil {\n        return err\n    }\n    return c.JSON(http.StatusCreated, note)\n}\n\nfunc getNotes(c echo.Context) error {\n    title := c.QueryParam(\"title\")\n    var notes []Note\n    if title != \"\" {\n        rows, err := db.Query(\"SELECT id, title, content, timestamp FROM notes WHERE title LIKE ?\", \"%\"+title+\"%\")\n        if err != nil {\n            return err\n        }\n        defer rows.Close()\n        for rows.Next() {\n            var note Note\n            if err := rows.Scan(&note.ID, &note.Title, &note.Content, &note.Timestamp); err != nil {\n                return err\n            }\n            notes = append(notes, note)\n        }\n    } else {\n        rows, err := db.Query(\"SELECT id, title, content, timestamp FROM notes\")\n        if err != nil {\n            return err\n        }\n        defer rows.Close()\n        for rows.Next() {\n            var note Note\n            if err := rows.Scan(&note.ID, &note.Title, &note.Content, &note.Timestamp); err != nil {\n                return err\n            }\n            notes = append(notes, note)\n        }\n    }\n    return c.JSON(http.StatusOK, notes)\n}\n\nfunc updateNote(c echo.Context) error {\n    id := c.Param(\"id\")\n    noteID, err := strconv.Atoi(id)\n    if err != nil {\n        return echo.NewHTTPError(http.StatusBadRequest, \"Invalid note ID\")\n    }\n    row := db.QueryRow(\"SELECT id FROM notes WHERE id=?\", noteID)\n    var existsID int\n    err = row.Scan(&existsID)\n    if err == sql.ErrNoRows {\n        return echo.NewHTTPError(http.StatusNotFound, \"Note not found\")\n    } else if err != nil {\n        return err\n    }\n    note := new(Note)\n    if err := c.Bind(note); err != nil {\n        return err\n    }\n    if err := c.Validate(note); err != nil {\n        return err\n    }\n    stmt, err := db.Prepare(\"UPDATE notes SET title=?, content=? WHERE id=?\")\n    if err != nil {\n        return err\n    }\n    defer stmt.Close()\n    _, err = stmt.Exec(note.Title, note.Content, noteID)\n    if err != nil {\n        return err\n    }\n    row = db.QueryRow(\"SELECT title, content, timestamp FROM notes WHERE id=?\", noteID)\n    err = row.Scan(&note.Title, &note.Content, &note.Timestamp)\n    if err != nil {\n        return err\n    }\n    note.ID = noteID\n    return c.JSON(http.StatusOK, note)\n}\n\nfunc deleteNote(c echo.Context) error {\n    id := c.Param(\"id\")\n    noteID, err := strconv.Atoi(id)\n    if err != nil {\n        return echo.NewHTTPError(http.StatusBadRequest, \"Invalid note ID\")\n    }\n    row := db.QueryRow(\"SELECT id FROM notes WHERE id=?\", noteID)\n    var existsID int\n    err = row.Scan(&existsID)\n    if err == sql.ErrNoRows {\n        return echo.NewHTTPError(http.StatusNotFound, \"Note not found\")\n    } else if err != nil {\n        return err\n    }\n    stmt, err := db.Prepare(\"DELETE FROM notes WHERE id=?\")\n    if err != nil {\n        return err\n    }\n    defer stmt.Close()\n    _, err = stmt.Exec(noteID)\n    if err != nil {\n        return err\n    }\n    return c.JSON(http.StatusOK, map[string]string{\"message\": \"Note deleted\"})\n}\n\nfunc main() {\n    e := echo.New()\n    validate := validator.New()\n    e.Validator = validate\n\n    setupDB()\n    defer db.Close()\n\n    e.POST(\"/notes\", createNote)\n    e.GET(\"/notes\", getNotes)\n    e.PUT(\"/notes/:id\", updateNote)\n    e.DELETE(\"/notes/:id\", deleteNote)\n\n    e.Logger.Fatal(e.Start(\":8080\"))\n}\n```\n\nThis should cover all the requirements for a basic notes API using Echo and SQLite in Go.\n\n**Final Solution**\nTo create a Golang web server using the Echo framework that handles CRUD operations for notes stored in a SQLite database, follow these steps:\n\n1. **Set up the project:**\n\n    ```sh\n    mkdir noteapp\n    cd noteapp\n    go mod init noteapp\n    go get github.com/labstack/echo/v4\n    go get github.com/mattn/go-sqlite3\n    go get github.com/go-playground/validator/v10\n    ```\n\n2. **Define the Note struct:**\n\n    ```go\n    type Note struct {\n        ID        int       `json:\"id\" validate:\"omitempty\"`\n        Title     string    `json:\"title\" validate:\"required\"`\n        Content   string    `json:\"content\" validate:\"required\"`\n        Timestamp time.Time `json:\"timestamp\" validate:\"omitempty\"`\n    }\n    ```\n\n3. **Set up the database connection:**\n\n    ```go\n    func setupDB() *sql.DB {\n        db, err := sql.Open(\"sqlite3\", \"./notes.db\")\n        if err != nil {\n            log.Fatal(err)\n        }\n        _, err = db.Exec(`CREATE TABLE IF NOT EXISTS notes (\n            id INTEGER PRIMARY KEY AUTOINCREMENT,\n            title TEXT NOT NULL,\n            content TEXT NOT NULL,\n            timestamp DATETIME DEFAULT CURRENT_TIMESTAMP\n        )`)\n        if err != nil {\n            log.Fatal(err)\n        }\n        return db\n    }\n    ```\n\n4. **Implement CRUD operations:**\n\n    - **Create Note (POST /notes):**\n\n        ```go\n        func createNote(c echo.Context) error {\n            note := new(Note)\n            if err := c.Bind(note); err != nil {\n                return err\n            }\n            if err := c.Validate(note); err != nil {\n                return err\n            }\n            stmt, err := db.Prepare(\"INSERT INTO notes(title, content) VALUES(?, ?)\")\n            if err != nil {\n                return err\n            }\n            defer stmt.Close()\n            res, err := stmt.Exec(note.Title, note.Content)\n            if err != nil {\n                return err\n            }\n            noteID, err := res.LastInsertId()\n            if err != nil {\n                return err\n            }\n            note.ID = int(noteID)\n            row := db.QueryRow(\"SELECT title, content, timestamp FROM notes WHERE id=?\", noteID)\n            err = row.Scan(&note.Title, &note.Content, &note.Timestamp)\n            if err != nil {\n                return err\n            }\n            return c.JSON(http.StatusCreated, note)\n        }\n        ```\n\n    - **Read Notes (GET /notes):**\n\n        ```go\n        func getNotes(c echo.Context) error {\n            title := c.QueryParam(\"title\")\n            var notes []Note\n            if title != \"\" {\n                rows, err := db.Query(\"SELECT id, title, content, timestamp FROM notes WHERE title LIKE ?\", \"%\"+title+\"%\")\n                if err != nil {\n                    return err\n                }\n                defer rows.Close()\n                for rows.Next() {\n                    var note Note\n                    if err := rows.Scan(&note.ID, &note.Title, &note.Content, &note.Timestamp); err != nil {\n                        return err\n                    }\n                    notes = append(notes, note)\n                }\n            } else {\n                rows, err := db.Query(\"SELECT id, title, content, timestamp FROM notes\")\n                if err != nil {\n                    return err\n                }\n                defer rows.Close()\n                for rows.Next() {\n                    var note Note\n                    if err := rows.Scan(&note.ID, &note.Title, &note.Content, &note.Timestamp); err != nil {\n                        return err\n                    }\n                    notes = append(notes, note)\n                }\n            }\n            return c.JSON(http.StatusOK, notes)\n        }\n        ```\n\n    - **Update Note (PUT /notes/:id):**\n\n        ```go\n        func updateNote(c echo.Context) error {\n            id := c.Param(\"id\")\n            noteID, err := strconv.Atoi(id)\n            if err != nil {\n                return echo.NewHTTPError(http.StatusBadRequest, \"Invalid note ID\")\n            }\n            row := db.QueryRow(\"SELECT id FROM notes WHERE id=?\", noteID)\n            var existsID int\n            err = row.Scan(&existsID)\n            if err == sql.ErrNoRows {\n                return echo.NewHTTPError(http.StatusNotFound, \"Note not found\")\n            } else if err != nil {\n                return err\n            }\n            note := new(Note)\n            if err := c.Bind(note); err != nil {\n                return err\n            }\n            if err := c.Validate(note); err != nil {\n                return err\n            }\n            stmt, err := db.Prepare(\"UPDATE notes SET title=?, content=? WHERE id=?\")\n            if err != nil {\n                return err\n            }\n            defer stmt.Close()\n            _, err = stmt.Exec(note.Title, note.Content, noteID)\n            if err != nil {\n                return err\n            }\n            row = db.QueryRow(\"SELECT title, content, timestamp FROM notes WHERE id=?\", noteID)\n            err = row.Scan(&note.Title, &note.Content, &note.Timestamp)\n            if err != nil {\n                return err\n            }\n            note.ID = noteID\n            return c.JSON(http.StatusOK, note)\n        }\n        ```\n\n    - **Delete Note (DELETE /notes/:id):**\n\n        ```go\n        func deleteNote(c echo.Context) error {\n            id := c.Param(\"id\")\n            noteID, err := strconv.Atoi(id)\n            if err != nil {\n                return echo.NewHTTPError(http.StatusBadRequest, \"Invalid note ID\")\n            }\n            row := db.QueryRow(\"SELECT id FROM notes WHERE id=?\", noteID)\n            var existsID int\n            err = row.Scan(&existsID)\n            if err == sql.ErrNoRows {\n                return echo.NewHTTPError(http.StatusNotFound, \"Note not found\")\n            } else if err != nil {\n                return err\n            }\n            stmt, err := db.Prepare(\"DELETE FROM notes WHERE id=?\")\n            if err != nil {\n                return err\n            }\n            defer stmt.Close()\n            _, err = stmt.Exec(noteID)\n            if err != nil {\n                return err\n            }\n            return c.JSON(http.StatusOK, map[string]string{\"message\": \"Note deleted\"})\n        }\n        ```\n\n5. **Set up the Echo server:**\n\n    ```go\n    func main() {\n        e := echo.New()\n        validate := validator.New()\n        e.Validator = validate\n\n        db := setupDB()\n        defer db.Close()\n\n        e.POST(\"/notes\", createNote)\n        e.GET(\"/notes\", getNotes)\n        e.PUT(\"/notes/:id\", updateNote)\n        e.DELETE(\"/notes/:id\", deleteNote)\n\n        e.Logger.Fatal(e.Start(\":8080\"))\n    }\n    ```\n\nThis code provides a basic notes API with Echo and SQLite in Go, handling creation, retrieval, updating, and deletion of notes."
    }
]