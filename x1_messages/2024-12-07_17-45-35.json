[
    {
        "role": "user",
        "content": "Implement a simple LRU (Least Recently Used) cache in Python with the following features:\n   - Set a maximum capacity for the cache.\n   - Add and retrieve items from the cache.\n   - Automatically remove the least recently used item when the cache reaches its capacity. PLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Sure! Implementing an LRU (Least Recently Used) cache in Python can be efficiently done using the `OrderedDict` class from the `collections` module. The `OrderedDict` maintains the order of insertion, which makes it perfect for tracking the usage order of cache items.\n\nHere's a step-by-step guide to creating a simple LRU cache:\n\n1. **Import Necessary Modules**:\n   - We need `OrderedDict` from the `collections` module.\n\n2. **Define the LRUCache Class**:\n   - Initialize the cache with a maximum capacity.\n   - Implement methods to add and retrieve items.\n   - Ensure that the least recently used item is removed when the cache exceeds its capacity.\n\n3. **Implement the Put Method**:\n   - Add a new item or update an existing one.\n   - Move the item to the end to mark it as recently used.\n   - Remove the least recently used item if the cache exceeds capacity.\n\n4. **Implement the Get Method**:\n   - Retrieve an item and move it to the end to mark it as recently used.\n   - Return the item's value or None if not found.\n\nHere's the complete code:\n\n```python\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.cache = OrderedDict()\n        self.capacity = capacity\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        else:\n            # Move the accessed item to the end to mark it as recently used\n            self.cache.move_to_end(key)\n            return self.cache[key]\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            # Update the value and move to the end to mark as recently used\n            self.cache[key] = value\n            self.cache.move_to_end(key)\n        else:\n            # Add the new item to the cache\n            self.cache[key] = value\n            # If the cache exceeds capacity, remove the first item (least recently used)\n            if len(self.cache) > self.capacity:\n                oldest_key = next(iter(self.cache))\n                del self.cache[oldest_key]\n\n# Example usage:\ncache = LRUCache(2)\ncache.put(1, 1)\ncache.put(2, 2)\nprint(cache.get(1))       # returns 1\ncache.put(3, 3)           # evicts key 2\nprint(cache.get(2))       # returns -1 (not found)\ncache.put(4, 4)           # evicts key 1\nprint(cache.get(1))       # returns -1 (not found)\nprint(cache.get(3))       # returns 3\nprint(cache.get(4))       # returns 4\n```\n\n### Explanation:\n- **Initialization**: The cache is initialized with a given capacity and uses an `OrderedDict` to store items.\n- **Get Operation**: If the key exists, it moves the key to the end of the dictionary (marking it as recently used) and returns its value. If the key doesn't exist, it returns -1.\n- **Put Operation**: If the key already exists, it updates the value and moves the key to the end. If the key doesn't exist, it adds the key-value pair. If the cache exceeds its capacity, it removes the least recently used item (the first item in the ordered dictionary).\n\nThis implementation ensures that both get and put operations run in O(1) time complexity, making it efficient for cache operations."
    }
]