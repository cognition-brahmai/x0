[
    {
        "role": "user",
        "content": "Create a C++ program that opens a TCP socket, listens for incoming connections, and sends a custom welcome message to each connected client. The program should also log the IP address and port number of each connected client to a file.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Okay, I'm going to try to create a C++ program that does what you've asked. I need to make a TCP server that listens for incoming connections and sends a welcome message to each client that connects. Also, it should log the IP address and port number of each connected client to a file.\n\nFirst, I need to remember how to work with sockets in C++. Sockets are a way for programs to communicate over a network. In C++, we can use the BSD socket library to create and manage sockets.\n\nI think I need to include the `<sys/socket.h>`, `<netinet/in.h>`, and `<arpa/inet.h>` headers for socket functions and structures. Also, I'll need `<iostream>`, `<fstream>`, and maybe `<string>` for input/output and file operations.\n\nLet me outline the steps I need to follow:\n\n1. Create a socket using `socket()` function.\n\n2. Bind the socket to a specific IP address and port using `bind()`.\n\n3. Start listening for incoming connections with `listen()`.\n\n4. Accept incoming connections using `accept()`, which will give me a new socket for each client.\n\n5. Send a welcome message to each connected client using `send()` or `write()`.\n\n6. Log the client's IP address and port number to a file.\n\nI should also handle errors properly, like checking if the socket was created successfully, if binding was successful, and so on.\n\nLet me think about the data structures I'll need. For the socket address, I'll use `struct sockaddr_in` from `<netinet/in.h>`. This structure holds the IP address and port number.\n\nI need to specify the IP address and port number that the server will listen on. For the IP, I can use INADDR_ANY to bind to all available network interfaces. For the port, I'll choose a port number that's not already in use, maybe something above 1024.\n\nNow, for logging the client's IP and port to a file, I'll open a file in append mode, write the IP and port, and then close the file.\n\nI should also consider that multiple clients might connect at the same time. In a simple implementation, I can handle one client at a time, but for a more advanced version, I might need to use multi-threading or some form of concurrency.\n\nBut for now, let's keep it simple and handle one client at a time.\n\nLet me sketch a rough code structure:\n\n```cpp\n#include <sys/socket.h>\n\n#include <netinet/in.h>\n\n#include <arpa/inet.h>\n\n#include <iostream>\n\n#include <fstream>\n\n#include <string>\n\nint main() {\n\n    // Create socket\n\n    int server_socket = socket(AF_INET, SOCK_STREAM, 0);\n\n    if (server_socket == -1) {\n\n        std::cerr << \"Error creating socket\" << std::endl;\n\n        return 1;\n\n    }\n\n    // Set up address structure\n\n    struct sockaddr_in server_addr;\n\n    server_addr.sin_family = AF_INET;\n\n    server_addr.sin_port = htons(12345); // Choose a port\n\n    server_addr.sin_addr.s_addr = INADDR_ANY;\n\n    // Bind socket to address\n\n    if (bind(server_socket, (struct sockaddr*)&server_addr, sizeof(server_addr)) == -1) {\n\n        std::cerr << \"Error binding socket\" << std::endl;\n\n        close(server_socket);\n\n        return 1;\n\n    }\n\n    // Listen for connections\n\n    if (listen(server_socket, 5) == -1) { // 5 is the backlog size\n\n        std::cerr << \"Error listening\" << std::endl;\n\n        close(server_socket);\n\n        return 1;\n\n    }\n\n    std::cout << \"Server listening on port 12345\" << std::endl;\n\n    // Accept incoming connection\n\n    struct sockaddr_in client_addr;\n\n    socklen_t client_len = sizeof(client_addr);\n\n    int client_socket = accept(server_socket, (struct sockaddr*)&client_addr, &client_len);\n\n    if (client_socket == -1) {\n\n        std::cerr << \"Error accepting connection\" << std::endl;\n\n        close(server_socket);\n\n        return 1;\n\n    }\n\n    // Log client's IP and port to a file\n\n    char client_ip[INET_ADDRSTRLEN];\n\n    inet_ntop(AF_INET, &(client_addr.sin_addr), client_ip, INET_ADDRSTRLEN);\n\n    unsigned int client_port = ntohs(client_addr.sin_port);\n\n    std::ofstream log_file(\"connections.log\", std::ios::app);\n\n    if (log_file.is_open()) {\n\n        log_file << \"Client connected: \" << client_ip << \":\" << client_port << std::endl;\n\n        log_file.close();\n\n    } else {\n\n        std::cerr << \"Unable to open log file\" << std::endl;\n\n    }\n\n    // Send welcome message\n\n    const char* welcome_msg = \"Welcome to the server!\";\n\n    if (send(client_socket, welcome_msg, strlen(welcome_msg), 0) == -1) {\n\n        std::cerr << \"Error sending welcome message\" << std::endl;\n\n    }\n\n    // Close sockets\n\n    close(client_socket);\n\n    close(server_socket);\n\n    return 0;\n\n}\n```\n\nThis seems like a basic structure. I need to compile this with a C++ compiler that supports these headers. On Linux, this should work fine, but on Windows, it might require some adjustments since Windows has its own WinSock library.\n\nWait, on Windows, I need to use `WSAStartup` and `WSACleanup` for socket initialization and cleanup. Maybe I should make the code cross-platform compatible.\n\nLet me look into that. For cross-platform socket programming in C++, I might need to conditionally include different headers and handle socket functions differently based on the platform.\n\nAlternatively, I can specify that this program is for Linux only, since socket programming can be more straightforward there.\n\nFor now, I'll assume a Linux environment.\n\nI should also consider handling multiple clients in a loop, so the server doesn't exit after handling one client.\n\nLet me modify the code to have an infinite loop that accepts connections and handles each client one by one.\n\nHere's an updated structure:\n\n```cpp\n#include <sys/socket.h>\n\n#include <netinet/in.h>\n\n#include <arpa/inet.h>\n\n#include <iostream>\n\n#include <fstream>\n\n#include <string>\n\n#include <cstring> // For strlen\n\nint main() {\n\n    // Create socket\n\n    int server_socket = socket(AF_INET, SOCK_STREAM, 0);\n\n    if (server_socket == -1) {\n\n        std::cerr << \"Error creating socket\" << std::endl;\n\n        return 1;\n\n    }\n\n    // Set up address structure\n\n    struct sockaddr_in server_addr;\n\n    server_addr.sin_family = AF_INET;\n\n    server_addr.sin_port = htons(12345); // Choose a port\n\n    server_addr.sin_addr.s_addr = INADDR_ANY;\n\n    // Bind socket to address\n\n    if (bind(server_socket, (struct sockaddr*)&server_addr, sizeof(server_addr)) == -1) {\n\n        std::cerr << \"Error binding socket\" << std::endl;\n\n        close(server_socket);\n\n        return 1;\n\n    }\n\n    // Listen for connections\n\n    if (listen(server_socket, 5) == -1) { // 5 is the backlog size\n\n        std::cerr << \"Error listening\" << std::endl;\n\n        close(server_socket);\n\n        return 1;\n\n    }\n\n    std::cout << \"Server listening on port 12345\" << std::endl;\n\n    while (true) {\n\n        struct sockaddr_in client_addr;\n\n        socklen_t client_len = sizeof(client_addr);\n\n        int client_socket = accept(server_socket, (struct sockaddr*)&client_addr, &client_len);\n\n        if (client_socket == -1) {\n\n            std::cerr << \"Error accepting connection\" << std::endl;\n\n            continue; // Continue to the next iteration\n\n        }\n\n        // Log client's IP and port to a file\n\n        char client_ip[INET_ADDRSTRLEN];\n\n        inet_ntop(AF_INET, &(client_addr.sin_addr), client_ip, INET_ADDRSTRLEN);\n\n        unsigned int client_port = ntohs(client_addr.sin_port);\n\n        std::ofstream log_file(\"connections.log\", std::ios::app);\n\n        if (log_file.is_open()) {\n\n            log_file << \"Client connected: \" << client_ip << \":\" << client_port << std::endl;\n\n            log_file.close();\n\n        } else {\n\n            std::cerr << \"Unable to open log file\" << std::endl;\n\n        }\n\n        // Send welcome message\n\n        const char* welcome_msg = \"Welcome to the server!\";\n\n        if (send(client_socket, welcome_msg, strlen(welcome_msg), 0) == -1) {\n\n            std::cerr << \"Error sending welcome message\" << std::endl;\n\n        }\n\n        // Close client socket\n\n        close(client_socket);\n\n    }\n\n    // Close server socket\n\n    close(server_socket);\n\n    return 0;\n\n}\n```\n\nIn this version, the server runs in an infinite loop, accepting connections one by one. After handling a client, it goes back to listening for new connections.\n\nI should test this code to see if it works as expected. I can compile it with g++ and run it on a Linux machine.\n\nLet me think about potential issues:\n\n- Making sure that the port I choose is not already in use by another process.\n\n- Handling errors properly, especially in the accept loop.\n\n- Ensuring that the log file is appended to correctly each time a client connects.\n\n- Considering that multiple clients might try to connect at the same time, but since we're handling one at a time, others might have to wait.\n\nTo handle multiple clients concurrently, I would need to use multi-threading or some form of asynchronous I/O, but that complicates things, so for now, I'll stick with this simple approach.\n\nAlso, I should consider adding a way to stop the server, maybe by pressing Ctrl+C or checking for some kind of shutdown command.\n\nAdditionally, I might want to handle the case where the client disconnects unexpectedly, but in this simple implementation, I'm not expecting any data from the client; I'm just sending a welcome message and logging the connection.\n\nI should also think about IPv6 support, but for simplicity, I'll stick with IPv4 for now.\n\nLet me consider if there are any security implications. Since this is a basic server that only sends a welcome message and logs IP addresses, the risk is low. However, in a real-world scenario, I should be cautious about buffer overflows and other vulnerabilities.\n\nAlso, logging IP addresses might have privacy implications, so I should be mindful of that.\n\nFor educational purposes, this should suffice.\n\nLet me try to compile this code and see if it works.\n\nI'll save it to a file, say `server.cpp`, and then run:\n\n```sh\n\ng++ -o server server.cpp\n\n./server\n\n```\n\nAssuming it compiles and runs without errors, I can then use a tool like `telnet` or `nc` (netcat) to connect to the server and see if it sends the welcome message.\n\nFor example, on another terminal, I can run:\n\n```sh\n\ntelnet localhost 12345\n\n```\n\nOr using netcat:\n\n```sh\n\nnc localhost 12345\n\n```\n\nI should see the welcome message printed in the terminal.\n\n\u540c\u65f6\uff0c\u68c0\u67e5`connections.log`\u6587\u4ef6\u662f\u5426\u6b63\u786e\u8bb0\u5f55\u4e86\u8fde\u63a5\u7684\u5ba2\u6237\u7aef\u7684IP\u5730\u5740\u548c\u7aef\u53e3\u53f7\u3002\n\n\u5982\u679c\u4e00\u5207\u6b63\u5e38\uff0c\u90a3\u4e48\u8fd9\u4e2a\u7b80\u5355\u7684TCP\u670d\u52a1\u5668\u5c31\u6210\u529f\u5b9e\u73b0\u4e86\u3002\n\n\u4e0d\u8fc7\uff0c\u6211\u8fd8\u60f3\u6dfb\u52a0\u4e00\u4e9b\u6539\u8fdb\uff0c\u6bd4\u5982\uff1a\n\n- \u5141\u8bb8\u901a\u8fc7\u547d\u4ee4\u884c\u53c2\u6570\u6307\u5b9a\u7aef\u53e3\u53f7\u3002\n\n- \u6dfb\u52a0\u4e00\u4e2a\u9009\u9879\u6765\u6307\u5b9a\u65e5\u5fd7\u6587\u4ef6\u7684\u540d\u79f0\u3002\n\n- \u5904\u7406\u5173\u95ed\u670d\u52a1\u5668\u7684\u4fe1\u53f7\uff0c\u6bd4\u5982Ctrl+C\u3002\n\n\u8ba9\u6211\u9010\u6b65\u5b9e\u73b0\u8fd9\u4e9b\u6539\u8fdb\u3002\n\n\u9996\u5148\uff0c\u6dfb\u52a0\u547d\u4ee4\u884c\u53c2\u6570\u6765\u6307\u5b9a\u7aef\u53e3\u53f7\u3002\u6211\u53ef\u4ee5\u671f\u671b\u7528\u6237\u5728\u8fd0\u884c\u7a0b\u5e8f\u65f6\u63d0\u4f9b\u7aef\u53e3\u53f7\u4f5c\u4e3a\u7b2c\u4e00\u4e2a\u53c2\u6570\u3002\n\n\u4f8b\u5982\uff1a\n\n```sh\n\n./server 12345\n\n```\n\n\u6211\u9700\u8981\u4ece`main`\u51fd\u6570\u7684`argc`\u548c`argv`\u4e2d\u8bfb\u53d6\u8fd9\u4e2a\u53c2\u6570\uff0c\u5e76\u5c06\u5176\u8f6c\u6362\u4e3a\u6574\u6570\u7aef\u53e3\u53f7\u3002\n\n\u5982\u679c\u7528\u6237\u6ca1\u6709\u63d0\u4f9b\u7aef\u53e3\u53f7\uff0c\u6211\u53ef\u4ee5\u8bbe\u7f6e\u4e00\u4e2a\u9ed8\u8ba4\u503c\uff0c\u6bd4\u598212345\u3002\n\n\u63a5\u4e0b\u6765\uff0c\u5141\u8bb8\u7528\u6237\u6307\u5b9a\u65e5\u5fd7\u6587\u4ef6\u7684\u540d\u79f0\uff0c\u53ef\u4ee5\u4f5c\u4e3a\u7b2c\u4e8c\u4e2a\u53c2\u6570\u3002\n\n\u4f8b\u5982\uff1a\n\n```sh\n\n./server 12345 connections.log\n\n```\n\n\u5982\u679c\u7528\u6237\u6ca1\u6709\u63d0\u4f9b\u6587\u4ef6\u540d\uff0c\u6211\u53ef\u4ee5\u4f7f\u7528\u9ed8\u8ba4\u7684\u201cconnections.log\u201d\u3002\n\n\u53e6\u5916\uff0c\u6211\u9700\u8981\u5904\u7406\u7a0b\u5e8f\u7684\u9000\u51fa\uff0c\u6bd4\u5982\u5f53\u7528\u6237\u6309\u4e0bCtrl+C\u65f6\uff0c\u670d\u52a1\u5668\u5e94\u8be5\u5173\u95ed\u5957\u63a5\u5b57\u5e76\u9000\u51fa\u3002\n\n\u4e3a\u4e86\u5b9e\u73b0\u8fd9\u4e00\u70b9\uff0c\u6211\u53ef\u4ee5\u6355\u83b7`SIGINT`\u4fe1\u53f7\uff0c\u5e76\u8bbe\u7f6e\u4e00\u4e2a\u6807\u5fd7\u6765\u9000\u51fa\u4e3b\u5faa\u73af\u3002\n\n\u4e0d\u8fc7\uff0c\u5728C++\u4e2d\u6355\u83b7\u4fe1\u53f7\u7a0d\u5fae\u6709\u4e9b\u590d\u6742\uff0c\u6211\u53ef\u4ee5\u4f7f\u7528`signal`\u51fd\u6570\u6765\u8bbe\u7f6e\u4fe1\u53f7\u5904\u7406\u7a0b\u5e8f\u3002\n\n\u8ba9\u6211\u9010\u6b65\u5b9e\u73b0\u8fd9\u4e9b\u529f\u80fd\u3002\n\n\u9996\u5148\uff0c\u4fee\u6539`main`\u51fd\u6570\u4ee5\u63a5\u53d7\u547d\u4ee4\u884c\u53c2\u6570\uff1a\n\n```cpp\n\n#include <sys/socket.h>\n\n#include <netinet/in.h>\n\n#include <arpa/inet.h>\n\n#include <iostream>\n\n#include <fstream>\n\n#include <string>\n\n#include <cstring> // For strlen\n\n#include <cstdlib> // For atoi\n\nint main(int argc, char *argv[]) {\n\n    int port = 12345;\n\n    std::string log_file_name = \"connections.log\";\n\n\n\n    if (argc > 1) {\n\n        port = atoi(argv[1]);\n\n        if (argc > 2) {\n\n            log_file_name = argv[2];\n\n        }\n\n    }\n\n\n\n    // Create socket\n\n    int server_socket = socket(AF_INET, SOCK_STREAM, 0);\n\n    if (server_socket == -1) {\n\n        std::cerr << \"Error creating socket\" << std::endl;\n\n        return 1;\n\n    }\n\n\n\n    // Set up address structure\n\n    struct sockaddr_in server_addr;\n\n    server_addr.sin_family = AF_INET;\n\n    server_addr.sin_port = htons(port);\n\n    server_addr.sin_addr.s_addr = INADDR_ANY;\n\n\n\n    // Bind socket to address\n\n    if (bind(server_socket, (struct sockaddr*)&server_addr, sizeof(server_addr)) == -1) {\n\n        std::cerr << \"Error binding socket\" << std::endl;\n\n        close(server_socket);\n\n        return 1;\n\n    }\n\n\n\n    // Listen for connections\n\n    if (listen(server_socket, 5) == -1) { // 5 is the backlog size\n\n        std::cerr << \"Error listening\" << std::endl;\n\n        close(server_socket);\n\n        return 1;\n\n    }\n\n\n\n    std::cout << \"Server listening on port \" << port << std::endl;\n\n\n\n    while (true) {\n\n        struct sockaddr_in client_addr;\n\n        socklen_t client_len = sizeof(client_addr);\n\n        int client_socket = accept(server_socket, (struct sockaddr*)&client_addr, &client_len);\n\n        if (client_socket == -1) {\n\n            std::cerr << \"Error accepting connection\" << std::endl;\n\n            continue; // Continue to the next iteration\n\n        }\n\n\n\n        // Log client's IP and port to a file\n\n        char client_ip[INET_ADDRSTRLEN];\n\n        inet_ntop(AF_INET, &(client_addr.sin_addr), client_ip, INET_ADDRSTRLEN);\n\n        unsigned int client_port = ntohs(client_addr.sin_port);\n\n\n\n        std::ofstream log(log_file_name, std::ios::app);\n\n        if (log.is_open()) {\n\n            log << \"Client connected: \" << client_ip << \":\" << client_port << std::endl;\n\n            log.close();\n\n        } else {\n\n            std::cerr << \"Unable to open log file: \" << log_file_name << std::endl;\n\n        }\n\n\n\n        // Send welcome message\n\n        const char* welcome_msg = \"Welcome to the server!\";\n\n        if (send(client_socket, welcome_msg, strlen(welcome_msg), 0) == -1) {\n\n            std::cerr << \"Error sending welcome message\" << std::endl;\n\n        }\n\n\n\n        // Close client socket\n\n        close(client_socket);\n\n    }\n\n\n\n    // Close server socket\n\n    close(server_socket);\n\n    return 0;\n\n}\n```\n\n\u73b0\u5728\uff0c\u7a0b\u5e8f\u53ef\u4ee5\u6839\u636e\u547d\u4ee4\u884c\u53c2\u6570\u63a5\u53d7\u4e0d\u540c\u7684\u7aef\u53e3\u53f7\u548c\u65e5\u5fd7\u6587\u4ef6\u540d\u3002\n\n\u63a5\u4e0b\u6765\uff0c\u6211\u9700\u8981\u5904\u7406\u7a0b\u5e8f\u7684\u9000\u51fa\u3002\u5f53\u7528\u6237\u6309\u4e0bCtrl+C\u65f6\uff0c\u7a0b\u5e8f\u5e94\u8be5\u5e72\u51c0\u5730\u5173\u95ed\u5957\u63a5\u5b57\u5e76\u9000\u51fa\u3002\n\n\u4e3a\u4e86\u5b9e\u73b0\u8fd9\u4e00\u70b9\uff0c\u6211\u53ef\u4ee5\u8bbe\u7f6e\u4e00\u4e2a\u4fe1\u53f7\u5904\u7406\u7a0b\u5e8f\u6765\u6355\u83b7`SIGINT`\u4fe1\u53f7\uff0c\u5e76\u8bbe\u7f6e\u4e00\u4e2a\u6807\u5fd7\u6765\u9000\u51fa\u4e3b\u5faa\u73af\u3002\n\n\u9996\u5148\uff0c\u5305\u542b`<csignal>`\u5934\u6587\u4ef6\uff0c\u5e76\u5b9a\u4e49\u4e00\u4e2a\u5168\u5c40\u53d8\u91cf\u6765\u8ddf\u8e2a\u662f\u5426\u63a5\u6536\u5230\u4e2d\u65ad\u4fe1\u53f7\u3002\n\n\u7136\u540e\uff0c\u5728\u4fe1\u53f7\u5904\u7406\u7a0b\u5e8f\u4e2d\u8bbe\u7f6e\u8fd9\u4e2a\u6807\u5fd7\u3002\n\n\u5728\u4e3b\u5faa\u73af\u4e2d\uff0c\u5b9a\u671f\u68c0\u67e5\u8fd9\u4e2a\u6807\u5fd7\uff0c\u5982\u679c\u88ab\u8bbe\u7f6e\uff0c\u5219\u9000\u51fa\u5faa\u73af\u5e76\u5173\u95ed\u5957\u63a5\u5b57\u3002\n\n\u8fd9\u91cc\u662f\u4e00\u4e2a\u793a\u4f8b\uff1a\n\n```cpp\n\n#include <sys/socket.h>\n\n#include <netinet/in.h>\n\n#include <arpa/inet.h>\n\n#include <iostream>\n\n#include <fstream>\n\n#include <string>\n\n#include <cstring> // For strlen\n\n#include <cstdlib> // For atoi\n\n#include <csignal> // For signal handling\n\n#include <unistd.h> // For sleep\n\n\n\nvolatile bool shutdown_server = false;\n\n\n\nvoid sigint_handler(int sig) {\n\n    shutdown_server = true;\n\n}\n\n\n\nint main(int argc, char *argv[]) {\n\n    int port = 12345;\n\n    std::string log_file_name = \"connections.log\";\n\n\n\n    if (argc > 1) {\n\n        port = atoi(argv[1]);\n\n        if (argc > 2) {\n\n            log_file_name = argv[2];\n\n        }\n\n    }\n\n\n\n    // Set up signal handling\n\n    signal(SIGINT, sigint_handler);\n\n\n\n    // Create socket\n\n    int server_socket = socket(AF_INET, SOCK_STREAM, 0);\n\n    if (server_socket == -1) {\n\n        std::cerr << \"Error creating socket\" << std::endl;\n\n        return 1;\n\n    }\n\n\n\n    // Set up address structure\n\n    struct sockaddr_in server_addr;\n\n    server_addr.sin_family = AF_INET;\n\n    server_addr.sin_port = htons(port);\n\n    server_addr.sin_addr.s_addr = INADDR_ANY;\n\n\n\n    // Bind socket to address\n\n    if (bind(server_socket, (struct sockaddr*)&server_addr, sizeof(server_addr)) == -1) {\n\n        std::cerr << \"Error binding socket\" << std::endl;\n\n        close(server_socket);\n\n        return 1;\n\n    }\n\n\n\n    // Listen for connections\n\n    if (listen(server_socket, 5) == -1) { // 5 is the backlog size\n\n        std::cerr << \"Error listening\" << std::endl;\n\n        close(server_socket);\n\n        return 1;\n\n    }\n\n\n\n    std::cout << \"Server listening on port \" << port << \". Press Ctrl+C to stop.\" << std::endl;\n\n\n\n    while (!shutdown_server) {\n\n        struct sockaddr_in client_addr;\n\n        socklen_t client_len = sizeof(client_addr);\n\n        int client_socket = accept(server_socket, (struct sockaddr*)&client_addr, &client_len);\n\n        if (client_socket == -1) {\n\n            std::cerr << \"Error accepting connection\" << std::endl;\n\n            continue; // Continue to the next iteration\n\n        }\n\n\n\n        // Log client's IP and port to a file\n\n        char client_ip[INET_ADDRSTRLEN];\n\n        inet_ntop(AF_INET, &(client_addr.sin_addr), client_ip, INET_ADDRSTRLEN);\n\n        unsigned int client_port = ntohs(client_addr.sin_port);\n\n\n\n        std::ofstream log(log_file_name, std::ios::app);\n\n        if (log.is_open()) {\n\n            log << \"Client connected: \" << client_ip << \":\" << client_port << std::endl;\n\n            log.close();\n\n        } else {\n\n            std::cerr << \"Unable to open log file: \" << log_file_name << std::endl;\n\n        }\n\n\n\n        // Send welcome message\n\n        const char* welcome_msg = \"Welcome to the server!\";\n\n        if (send(client_socket, welcome_msg, strlen(welcome_msg), 0) == -1) {\n\n            std::cerr << \"Error sending welcome message\" << std::endl;\n\n        }\n\n\n\n        // Close client socket\n\n        close(client_socket);\n\n    }\n\n\n\n    // Close server socket\n\n    close(server_socket);\n\n    std::cout << \"Server shut down.\" << std::endl;\n\n    return 0;\n\n}\n```\n\n\u5728\u8fd9\u4e2a\u7248\u672c\u4e2d\uff0c\u6211\u6dfb\u52a0\u4e86\u4e00\u4e2a`shutdown_server`\u6807\u5fd7\uff0c\u5e76\u5b9a\u4e49\u4e86\u4e00\u4e2a\u4fe1\u53f7\u5904\u7406\u7a0b\u5e8f`sigint_handler`\uff0c\u5f53\u63a5\u6536\u5230`SIGINT`\u4fe1\u53f7\u65f6\uff0c\u5c06\u8fd9\u4e2a\u6807\u5fd7\u8bbe\u7f6e\u4e3a`true`\u3002\n\n\u5728\u4e3b\u5faa\u73af\u4e2d\uff0c\u68c0\u67e5\u8fd9\u4e2a\u6807\u5fd7\uff0c\u5982\u679c\u4e3a`true`\uff0c\u5219\u9000\u51fa\u5faa\u73af\u5e76\u5173\u95ed\u5957\u63a5\u5b57\u3002\n\n\u8fd9\u6837\uff0c\u5f53\u7528\u6237\u6309\u4e0bCtrl+C\u65f6\uff0c\u670d\u52a1\u5668\u4f1a\u5e72\u51c0\u5730\u5173\u95ed\u3002\n\n\u6211\u8fd8\u6dfb\u52a0\u4e86\u4e00\u4e2a\u6d88\u606f\uff0c\u63d0\u793a\u7528\u6237\u6309Ctrl+C\u505c\u6b62\u670d\u52a1\u5668\u3002\n\n\u4e3a\u4e86\u4f7f\u7a0b\u5e8f\u66f4\u5065\u58ee\uff0c\u6211\u8fd8\u53ef\u4ee5\u6dfb\u52a0\u5bf9\u5176\u4ed6\u4fe1\u53f7\u7684\u5904\u7406\uff0c\u6bd4\u5982`SIGTERM`\uff0c\u4ee5\u4fbf\u5728\u7cfb\u7edf\u5173\u95ed\u65f6\u6b63\u786e\u5173\u95ed\u670d\u52a1\u5668\u3002\n\n\u6b64\u5916\uff0c\u6211\u53ef\u4ee5\u5728\u4fe1\u53f7\u5904\u7406\u7a0b\u5e8f\u4e2d\u6267\u884c\u66f4\u591a\u7684\u6e05\u7406\u64cd\u4f5c\uff0c\u4f46\u5982\u679c\u53ea\u662f\u8bbe\u7f6e\u4e00\u4e2a\u6807\u5fd7\uff0c\u901a\u5e38\u5c31\u8db3\u591f\u4e86\u3002\n\n\u73b0\u5728\uff0c\u8fd9\u4e2a\u670d\u52a1\u5668\u7a0b\u5e8f\u5e94\u8be5\u80fd\u591f\u6839\u636e\u547d\u4ee4\u884c\u53c2\u6570\u76d1\u542c\u6307\u5b9a\u7684\u7aef\u53e3\uff0c\u8bb0\u5f55\u8fde\u63a5\u5230\u6307\u5b9a\u7684\u65e5\u5fd7\u6587\u4ef6\uff0c\u5e76\u4e14\u53ef\u4ee5\u54cd\u5e94Ctrl+C\u4fe1\u53f7\u5e72\u51c0\u5730\u5173\u95ed\u3002\n\n\u6211\u53ef\u4ee5\u7f16\u8bd1\u5e76\u6d4b\u8bd5\u8fd9\u4e2a\u7a0b\u5e8f\uff0c\u786e\u4fdd\u5b83\u6309\u9884\u671f\u5de5\u4f5c\u3002\n\n## \u6700\u7ec8\u89e3\u51b3\u65b9\u6848\n\u8981\u521b\u5efa\u4e00\u4e2a\u7b80\u5355\u7684TCP\u670d\u52a1\u5668\uff0c\u8be5\u670d\u52a1\u5668\u76d1\u542c\u4f20\u5165\u8fde\u63a5\uff0c\u5411\u6bcf\u4e2a\u8fde\u63a5\u7684\u5ba2\u6237\u7aef\u53d1\u9001\u81ea\u5b9a\u4e49\u6b22\u8fce\u6d88\u606f\uff0c\u5e76\u5c06\u5ba2\u6237\u7aef\u7684IP\u5730\u5740\u548c\u7aef\u53e3\u53f7\u8bb0\u5f55\u5230\u6587\u4ef6\u4e2d\uff0c\u53ef\u4ee5\u4f7f\u7528C++\u548cBSD socket API\u3002\u4ee5\u4e0b\u662f\u5b9e\u73b0\u8fd9\u4e00\u529f\u80fd\u7684\u6b65\u9aa4\u548c\u4ee3\u7801\u3002\n\n### \u5b9e\u73b0\u601d\u8def\n\n1. **\u521b\u5efa\u5957\u63a5\u5b57**\uff1a\u4f7f\u7528`socket()`\u51fd\u6570\u521b\u5efa\u4e00\u4e2aTCP\u5957\u63a5\u5b57\u3002\n2. **\u7ed1\u5b9a\u5957\u63a5\u5b57**\uff1a\u4f7f\u7528`bind()`\u51fd\u6570\u5c06\u5957\u63a5\u5b57\u7ed1\u5b9a\u5230\u6307\u5b9a\u7684IP\u5730\u5740\u548c\u7aef\u53e3\u3002\n3. **\u76d1\u542c\u8fde\u63a5**\uff1a\u4f7f\u7528`listen()`\u51fd\u6570\u4f7f\u5957\u63a5\u5b57\u5f00\u59cb\u76d1\u542c\u4f20\u5165\u8fde\u63a5\u3002\n4. **\u63a5\u53d7\u8fde\u63a5**\uff1a\u4f7f\u7528`accept()`\u51fd\u6570\u63a5\u53d7\u4f20\u5165\u8fde\u63a5\uff0c\u5e76\u4e3a\u6bcf\u4e2a\u5ba2\u6237\u7aef\u521b\u5efa\u4e00\u4e2a\u65b0\u7684\u5957\u63a5\u5b57\u3002\n5. **\u53d1\u9001\u6b22\u8fce\u6d88\u606f**\uff1a\u4f7f\u7528`send()`\u51fd\u6570\u5411\u5ba2\u6237\u7aef\u53d1\u9001\u6b22\u8fce\u6d88\u606f\u3002\n6. **\u8bb0\u5f55\u8fde\u63a5**\uff1a\u5c06\u5ba2\u6237\u7aef\u7684IP\u5730\u5740\u548c\u7aef\u53e3\u53f7\u8bb0\u5f55\u5230\u65e5\u5fd7\u6587\u4ef6\u4e2d\u3002\n7. **\u5904\u7406\u591a\u4e2a\u5ba2\u6237\u7aef**\uff1a\u5728\u5faa\u73af\u4e2d\u63a5\u53d7\u591a\u4e2a\u5ba2\u6237\u7aef\u8fde\u63a5\u3002\n8. **\u4fe1\u53f7\u5904\u7406**\uff1a\u6355\u83b7Ctrl+C\u4fe1\u53f7\uff0c\u4f18\u96c5\u5730\u5173\u95ed\u670d\u52a1\u5668\u3002\n\n### \u89e3\u51b3\u65b9\u6848\u4ee3\u7801\n\n```cpp\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <cstring> // For strlen\n#include <cstdlib> // For atoi\n#include <csignal> // For signal handling\n\nvolatile bool shutdown_server = false;\n\nvoid sigint_handler(int sig) {\n    shutdown_server = true;\n}\n\nint main(int argc, char *argv[]) {\n    int port = 12345;\n    std::string log_file_name = \"connections.log\";\n\n    if (argc > 1) {\n        port = atoi(argv[1]);\n        if (argc > 2) {\n            log_file_name = argv[2];\n        }\n    }\n\n    // Set up signal handling\n    signal(SIGINT, sigint_handler);\n\n    // Create socket\n    int server_socket = socket(AF_INET, SOCK_STREAM, 0);\n    if (server_socket == -1) {\n        std::cerr << \"Error creating socket\" << std::endl;\n        return 1;\n    }\n\n    // Set up address structure\n    struct sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(port);\n    server_addr.sin_addr.s_addr = INADDR_ANY;\n\n    // Bind socket to address\n    if (bind(server_socket, (struct sockaddr*)&server_addr, sizeof(server_addr)) == -1) {\n        std::cerr << \"Error binding socket\" << std::endl;\n        close(server_socket);\n        return 1;\n    }\n\n    // Listen for connections\n    if (listen(server_socket, 5) == -1) { // 5 is the backlog size\n        std::cerr << \"Error listening\" << std::endl;\n        close(server_socket);\n        return 1;\n    }\n\n    std::cout << \"Server listening on port \" << port << \". Press Ctrl+C to stop.\" << std::endl;\n\n    while (!shutdown_server) {\n        struct sockaddr_in client_addr;\n        socklen_t client_len = sizeof(client_addr);\n        int client_socket = accept(server_socket, (struct sockaddr*)&client_addr, &client_len);\n        if (client_socket == -1) {\n            std::cerr << \"Error accepting connection\" << std::endl;\n            continue; // Continue to the next iteration\n        }\n\n        // Log client's IP and port to a file\n        char client_ip[INET_ADDRSTRLEN];\n        inet_ntop(AF_INET, &(client_addr.sin_addr), client_ip, INET_ADDRSTRLEN);\n        unsigned int client_port = ntohs(client_addr.sin_port);\n\n        std::ofstream log(log_file_name, std::ios::app);\n        if (log.is_open()) {\n            log << \"Client connected: \" << client_ip << \":\" << client_port << std::endl;\n            log.close();\n        } else {\n            std::cerr << \"Unable to open log file: \" << log_file_name << std::endl;\n        }\n\n        // Send welcome message\n        const char* welcome_msg = \"Welcome to the server!\";\n        if (send(client_socket, welcome_msg, strlen(welcome_msg), 0) == -1) {\n            std::cerr << \"Error sending welcome message\" << std::endl;\n        }\n\n        // Close client socket\n        close(client_socket);\n    }\n\n    // Close server socket\n    close(server_socket);\n    std::cout << \"Server shut down.\" << std::endl;\n    return 0;\n}\n```\n\n### \u7528\u6cd5\n\n1. **\u7f16\u8bd1\u7a0b\u5e8f**\uff1a\n   ```sh\n   g++ -o server server.cpp\n   ```\n\n2. **\u8fd0\u884c\u7a0b\u5e8f**\uff1a\n   ```sh\n   ./server [port] [log_file]\n   ```\n   - `port`\uff1a\u53ef\u9009\uff0c\u6307\u5b9a\u670d\u52a1\u5668\u76d1\u542c\u7684\u7aef\u53e3\u53f7\uff0c\u9ed8\u8ba4\u662f12345\u3002\n   - `log_file`\uff1a\u53ef\u9009\uff0c\u6307\u5b9a\u65e5\u5fd7\u6587\u4ef6\u7684\u540d\u79f0\uff0c\u9ed8\u8ba4\u662f\"connections.log\"\u3002\n\n3. **\u8fde\u63a5\u5230\u670d\u52a1\u5668**\uff1a\n   \u4f7f\u7528`telnet`\u6216`nc`\u5de5\u5177\u8fde\u63a5\u5230\u670d\u52a1\u5668\uff0c\u4f8b\u5982\uff1a\n   ```sh\n   telnet localhost 12345\n   ```\n\n4. **\u505c\u6b62\u670d\u52a1\u5668**\uff1a\n   \u6309\u4e0bCtrl+C\uff0c\u670d\u52a1\u5668\u5c06\u4f18\u96c5\u5730\u5173\u95ed\u5957\u63a5\u5b57\u5e76\u9000\u51fa\u3002"
    }
]