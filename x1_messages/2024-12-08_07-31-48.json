[
    {
        "role": "user",
        "content": "Implement a Golang server that serves a simple REST API for managing a to-do list. The server should support creating, updating, deleting, and listing tasks. Store the tasks in a local JSON file.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Implementing a Golang server that serves a simple REST API for managing a to-do list, with tasks stored in a local JSON file, involves several steps. Below is a guide to help you achieve this.\n\n### Prerequisites\n\n1. **Go installed** on your machine. You can download it from [https://golang.org/dl/](https://golang.org/dl/).\n2. **Basic understanding** of Go, JSON, and REST APIs.\n\n### Project Structure\n\nCreate a new directory for your project and set up the following structure:\n\n```\ntodo-api/\n\u251c\u2500\u2500 main.go\n\u251c\u2500\u2500 todo.json\n```\n\n### Step 1: Define the Task Structure\n\nIn `main.go`, define the structure for a task.\n\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"strconv\"\n\n\t\"github.com/gorilla/mux\"\n)\n\ntype Task struct {\n\tID      int    `json:\"id\"`\n\tTitle   string `json:\"title\"`\n\t_done   bool   `json:\"done\"`\n}\n\ntype Tasks []Task\n```\n\n### Step 2: Load and Save Tasks\n\nFunctions to load tasks from and save tasks to a JSON file.\n\n```go\nfunc loadTasks() (Tasks, error) {\n\tdata, err := ioutil.ReadFile(\"todo.json\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tvar tasks Tasks\n\terr = json.Unmarshal(data, &tasks)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn tasks, nil\n}\n\nfunc saveTasks(tasks Tasks) error {\n\tdata, err := json.MarshalIndent(tasks, \"\", \"  \")\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn ioutil.WriteFile(\"todo.json\", data, 0644)\n}\n```\n\n### Step 3: API Handlers\n\nDefine handlers for creating, updating, deleting, and listing tasks.\n\n#### List Tasks\n\n```go\nfunc listTasks(w http.ResponseWriter, r *http.Request) {\n\ttasks, err := loadTasks()\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\tjson.NewEncoder(w).Encode(tasks)\n}\n```\n\n#### Create Task\n\n```go\nfunc createTask(w http.ResponseWriter, r *http.Request) {\n\tvar task Task\n\terr := json.NewDecoder(r.Body).Decode(&task)\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n\t\treturn\n\t}\n\ttasks, err := loadTasks()\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\ttask.ID = len(tasks) + 1\n\ttasks = append(tasks, task)\n\terr = saveTasks(tasks)\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(w).Encode(task)\n}\n```\n\n#### Update Task\n\n```go\nfunc updateTask(w http.ResponseWriter, r *http.Request) {\n\tparams := mux.Vars(r)\n\tid, err := strconv.Atoi(params[\"id\"])\n\tif err != nil {\n\t\thttp.Error(w, \"Invalid task ID\", http.StatusBadRequest)\n\t\treturn\n\t}\n\ttasks, err := loadTasks()\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\tfor i, task := range tasks {\n\t\tif task.ID == id {\n\t\t\tvar updatedTask Task\n\t\t\terr := json.NewDecoder(r.Body).Decode(&updatedTask)\n\t\t\tif err != nil {\n\t\t\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tupdatedTask.ID = id\n\t\t\ttasks[i] = updatedTask\n\t\t\terr = saveTasks(tasks)\n\t\t\tif err != nil {\n\t\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\t\tjson.NewEncoder(w).Encode(updatedTask)\n\t\t\treturn\n\t\t}\n\t}\n\thttp.Error(w, \"Task not found\", http.StatusNotFound)\n}\n```\n\n#### Delete Task\n\n```go\nfunc deleteTask(w http.ResponseWriter, r *http.Request) {\n\tparams := mux.Vars(r)\n\tid, err := strconv.Atoi(params[\"id\"])\n\tif err != nil {\n\t\thttp.Error(w, \"Invalid task ID\", http.StatusBadRequest)\n\t\treturn\n\t}\n\ttasks, err := loadTasks()\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\tvar newTasks Tasks\n\tfor _, task := range tasks {\n\t\tif task.ID != id {\n\t\t\tnewTasks = append(newTasks, task)\n\t\t}\n\t}\n\terr = saveTasks(newTasks)\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\tw.WriteHeader(http.StatusNoContent)\n}\n```\n\n### Step 4: Set Up Routes\n\nUse `gorilla/mux` for routing.\n\nFirst, install the package:\n\n```sh\ngo get -u github.com/gorilla/mux\n```\n\nThen, set up the routes in `main.go`:\n\n```go\nfunc main() {\n\tr := mux.NewRouter()\n\n\tr.HandleFunc(\"/tasks\", listTasks).Methods(\"GET\")\n\tr.HandleFunc(\"/tasks\", createTask).Methods(\"POST\")\n\tr.HandleFunc(\"/tasks/{id}\", updateTask).Methods(\"PUT\")\n\tr.HandleFunc(\"/tasks/{id}\", deleteTask).Methods(\"DELETE\")\n\n\tfmt.Println(\"Server running on port 8000\")\n\thttp.ListenAndServe(\":8000\", r)\n}\n```\n\n### Step 5: Initialize `todo.json`\n\nCreate an empty JSON array in `todo.json`:\n\n```json\n[]\n```\n\n### Running the Server\n\n1. Navigate to your project directory.\n2. Run the server:\n\n```sh\ngo run main.go\n```\n\n3. The server should now be running on [http://localhost:8000](http://localhost:8000).\n\n### Testing the API\n\nYou can use tools like `curl` or Postman to test the API endpoints.\n\n#### List Tasks\n\n```sh\ncurl -X GET http://localhost:8000/tasks\n```\n\n#### Create Task\n\n```sh\ncurl -X POST -H \"Content-Type: application/json\" -d '{\"title\":\"Sample Task\",\"done\":false}' http://localhost:8000/tasks\n```\n\n#### Update Task\n\n```sh\ncurl -X PUT -H \"Content-Type: application/json\" -d '{\"title\":\"Updated Task\",\"done\":true}' http://localhost:8000/tasks/1\n```\n\n#### Delete Task\n\n```sh\ncurl -X DELETE http://localhost:8000/tasks/1\n```\n\n### Conclusion\n\nThis simple Go server uses `gorilla/mux` for routing and manages a to-do list stored in a local JSON file. It provides basic CRUD operations for tasks. You can expand this by adding more features, improving error handling, or using a database for better scalability."
    }
]