[
    {
        "role": "user",
        "content": "Develop a Scala function that finds the shortest path between two nodes in a weighted, directed graph using Dijkstra's algorithm.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "I'm here to help! So, you need a Scala function that finds the shortest path between two nodes in a weighted, directed graph using Dijkstra's algorithm. That sounds like a great project. Dijkstra's algorithm is a popular way to find the shortest path in a graph with non-negative edge weights.\n\nFirst, let's make sure we understand what Dijkstra's algorithm does. It starts at the source node and explores all the neighboring nodes, keeping track of the cost to reach each node. It then selects the unvisited node with the lowest cost and repeats the process until it reaches the target node or all nodes have been visited.\n\nIn Scala, we can represent the graph using an adjacency list, where each node points to its neighbors along with the edge weights. We'll need to prioritize nodes based on their current shortest distance from the source, so a priority queue will be useful here.\n\nLet's outline the steps we need to implement:\n\n1. **Graph Representation:** Define how the graph is stored.\n2. **Priority Queue:** Use a priority queue to always expand the least costly node.\n3. **Distance Tracking:** Keep track of the shortest distances from the source to each node.\n4. **Path Reconstruction:** Keep track of the path that led to each node.\n\nLet's start by defining the graph. Since it's a weighted, directed graph, we can represent it as a map where each key is a node, and the value is a list of tuples representing its neighbors and the edge weights.\n\nFor example:\n\n```scala\ntype Graph[T] = Map[T, List[(T, Int)]]\n```\n\nHere, `T` is the type of the nodes, and the map associates each node with a list of pairs: the neighbor node and the weight of the edge to that neighbor.\n\nNext, we need a priority queue that orders nodes by their current shortest distance from the source. Scala's `scala.collection.immutable.PriorityQueue` can be used, but by default, it's a max-priority queue. To make it a min-priority queue, we can provide a custom ordering.\n\nLet's define the priority queue:\n\n```scala\nimport scala.collection.immutable.PriorityQueue\n\nval queue = PriorityQueue[(T, Int)]()(Ordering.by(_._2).reverse)\n```\n\nThe `Ordering.by(_._2).reverse` makes it a min-priority queue based on the second element of the tuple, which is the distance.\n\nNow, we need to keep track of the shortest distances. We can use a `Map[T, Int]` where the key is the node and the value is the shortest distance from the source.\n\nWe also need to keep track of the previous node in the path for each node to reconstruct the path later. This can be another map: `Map[T, T]`.\n\nLet's sketch the function signature:\n\n```scala\ndef dijkstraShortestPath[T](graph: Graph[T], start: T, end: T): Option[List[T]]\n```\n\nThis function will return an `Option[List[T]]`, which is `Some(List[T])` containing the path if it exists, or `None` if there is no path from start to end.\n\nNow, let's think about the steps inside the function:\n\n1. **Initialization:**\n   - Set the distance to the start node as 0 and infinity (or a large number) for all other nodes.\n   - Create a priority queue and insert the start node with distance 0.\n   - Initialize an empty map to keep track of the previous node for path reconstruction.\n\n2. **Main Loop:**\n   - While the queue is not empty:\n     - Dequeue the node with the smallest distance (current node).\n     - If this node is the end node, reconstruct and return the path.\n     - For each neighbor of the current node:\n       - Calculate the tentative distance through the current node.\n       - If this distance is less than the recorded distance, update the distance and the previous node, and enqueue the neighbor.\n\n3. **Path Reconstruction:**\n   - If the end node is reached, trace back from the end node to the start node using the previous node map.\n   - Return the path as a list from start to end.\n\n4. **No Path Found:**\n   - If the queue is empty and the end node was not reached, return `None`.\n\nLet's consider how to handle the distances. Since Scala integers can overflow, we should think about using `Long` or another type that can handle larger values, but for simplicity, we'll assume that the distances are manageable with `Int`.\n\nAlso, we need to handle the case where the graph does not contain the start or end nodes.\n\nLet's think about how to implement the path reconstruction. We'll need to traverse the previous node map from the end node to the start node and then reverse the list.\n\nLet's consider an example to test our function. Suppose we have the following graph:\n\n- Nodes: A, B, C, D\n\n- Edges:\n\n  - A -> B with weight 1\n\n  - A -> C with weight 4\n\n  - B -> C with weight 2\n\n  - B -> D with weight 5\n\n  - C -> D with weight 1\n\nIf we want the shortest path from A to D, it should be A -> B -> C -> D with a total weight of 1 + 2 + 1 = 4.\n\nAnother path A -> C -> D has a weight of 4 + 1 = 5, which is heavier.\n\nLet's represent this graph in our `Graph[T]` type:\n\n```scala\nval graph: Graph[String] = Map(\n  \"A\" -> List(\"B\" -> 1, \"C\" -> 4),\n  \"B\" -> List(\"C\" -> 2, \"D\" -> 5),\n  \"C\" -> List(\"D\" -> 1),\n  \"D\" -> List()\n)\n```\n\nNow, let's think about the implementation in code.\n\nFirst, we need to initialize the distances. We can use a map with all nodes set to `Int.MaxValue` except the start node set to 0.\n\nBut to make it more efficient, especially in immutable data structures, we can use a priority queue to manage which nodes to process next based on their current known distances.\n\nWe'll need to keep updating the distances and the previous nodes as we explore the graph.\n\nLet's consider using a case class to hold the node and its distance for the priority queue.\n\n```scala\ncase class NodeDistance[T](node: T, distance: Int)\n```\n\nWe can create a priority queue ordered by distance in ascending order.\n\n```scala\nimport scala.collection.immutable.PriorityQueue\n\nimplicit val ordering: Ordering[NodeDistance[T]] = Ordering.by(nd => nd.distance)\nval queue = PriorityQueue[NodeDistance[T]]()(ordering)\n```\n\nWait, but by default, `PriorityQueue` in Scala is a max-priority queue. To make it a min-priority queue, we need to reverse the ordering.\n\nSo, it should be:\n\n```scala\nimplicit val ordering: Ordering[NodeDistance[T]] = Ordering.by(nd => nd.distance).reverse\nval queue = PriorityQueue[NodeDistance[T]]()(ordering)\n```\n\nBut since it's reversed, the smallest distance will be at the top.\n\nWait, actually, to make it a min-heap, we need to reverse the ordering. So, the above should work.\n\nAlternatively, we can define the case class to order correctly.\n\nLet's proceed.\n\nNow, initialization:\n\n- Set distance of start to 0 and enqueue it.\n\n- All other nodes have distance Int.MaxValue.\n\nWe need to keep track of visited nodes to avoid processing them multiple times.\n\nWait, in Dijkstra's algorithm, once a node is dequeued, its distance is finalized, and we don't need to consider it again.\n\nSo, we can keep a set of visited nodes.\n\nLet's define:\n\n```scala\nvar distances: Map[T, Int] = graph.keys.map(k => k -> Int.MaxValue).toMap.updated(start, 0)\nvar previous: Map[T, T] = Map.empty\nvar queue: PriorityQueue[NodeDistance[T]] = PriorityQueue(NodeDistance(start, 0))\nvar visited: Set[T] = Set.empty\n```\n\nIn the main loop:\n\n- While the queue is not empty:\n- Dequeue the node with the smallest distance.\n- If it's already visited, skip it.\n- Mark it as visited.\n- If this node is the end node, reconstruct and return the path.\n- For each neighbor:\n- Calculate the tentative distance through the current node.\n- If this distance is less than the recorded distance, update the distance, set the previous node, and enqueue the neighbor.\n\nPath reconstruction:\n\n- Start from the end node, trace back through the previous node map to the start node, and collect the nodes in reverse order.\n\nLet's think about how to implement the path reconstruction.\n\nWe can do:\n\n```scala\ndef rebuildPath[T](previous: Map[T, T], start: T, end: T): List[T] = {\n  @tailrec\n  def buildPath(current: T, path: List[T]): List[T] = {\n    if (current == start) start :: path\n    else buildPath(previous(current), current :: path)\n  }\n  if (previous.contains(end)) buildPath(end, List())\n  else List()\n}\n```\n\nThis function will build the path from end to start and then reverse it if necessary.\n\nWait, in our case, we want the path from start to end, so we can collect the path in reverse and then reverse it at the end.\n\nBut in the above function, we're collecting it correctly from end to start and then can reverse it.\n\nWait, actually, in the function above, if we start from end and keep adding current before path, it will be start to end.\n\nYes, that's correct.\n\nSo, `buildPath(end, List())` will give us start to end.\n\nGood.\n\nNow, let's think about the main function.\n\nWe need to handle the case where the end node is not reachable from the start node.\n\nIn that case, after processing all nodes, if we haven't reached the end node, return None.\n\nAlso, need to ensure that we don't process nodes that have already been visited.\n\nLet's think about the loop.\n\nWhile the queue is not empty:\n\n- Dequeue the node with the smallest distance.\n\n- If it's already visited, skip it.\n\n- Mark it as visited.\n\n- If it's the end node, rebuild and return the path.\n\n- For each neighbor:\n\n- Calculate the tentative distance.\n\n- If it's smaller than the current known distance, update the distance, set the previous node, and enqueue it.\n\nWe need to make sure that we don't enqueue a node more than once with a higher distance.\n\nBut in this implementation, since we're using a priority queue and allowing updates, we might need to handle distance updates properly.\n\nWait, in the standard Dijkstra's algorithm implementation with a priority queue, we enqueue nodes multiple times with better distances, and we have a visited set to avoid processing them multiple times.\n\nSo, we'll proceed like that.\n\nLet's consider writing the code step by step.\n\nFirst, define the NodeDistance case class:\n\n```scala\ncase class NodeDistance[T](node: T, distance: Int)\n```\n\nThen, the rebuildPath function:\n\n```scala\ndef rebuildPath[T](previous: Map[T, T], start: T, end: T): List[T] = {\n  @tailrec\n  def buildPath(current: T, path: List[T]): List[T] = {\n    if (current == start) start :: path\n    else buildPath(previous(current), current :: path)\n  }\n  if (previous.contains(end)) buildPath(end, List())\n  else List()\n}\n```\n\nNow, the main dijkstraShortestPath function:\n\n```scala\ndef dijkstraShortestPath[T](graph: Graph[T], start: T, end: T): Option[List[T]] = {\n  import scala.collection.immutable.PriorityQueue\n\n  case class NodeDistance(node: T, distance: Int)\n\n  implicit val ordering: Ordering[NodeDistance] = Ordering.by(nd => nd.distance).reverse\n\n  var distances: Map[T, Int] = graph.keys.map(k => k -> Int.MaxValue).toMap.updated(start, 0)\n  var previous: Map[T, T] = Map.empty\n  var queue: PriorityQueue[NodeDistance] = PriorityQueue(NodeDistance(start, 0))\n  var visited: Set[T] = Set.empty\n\n  while (queue.nonEmpty) {\n    val NodeDistance(currentNode, currentDistance) = queue.dequeue()\n\n    if (visited.contains(currentNode)) {\n      next\n    }\n\n    visited += currentNode\n\n    if (currentNode == end) {\n      return Some(rebuildPath(previous, start, end))\n    }\n\n    graph.getOrElse(currentNode, List()).foreach { case (neighbor, weight) =>\n      val tentativeDistance = currentDistance + weight\n      if (tentativeDistance < distances(neighbor)) {\n        distances = distances.updated(neighbor, tentativeDistance)\n        previous = previous.updated(neighbor, currentNode)\n        queue += NodeDistance(neighbor, tentativeDistance)\n      }\n    }\n  }\n\n  if (visited.contains(end)) {\n    Some(rebuildPath(previous, start, end))\n  } else {\n    None\n  }\n}\n```\n\nWait, there are a few issues here.\n\nFirst, in the priority queue, we're using `ordering.reverse` which might not be correct.\n\nActually, to have a min-heap, we need to reverse the ordering.\n\nBut in Scala's `PriorityQueue`, the default is a max-heap, so reversing the ordering makes it a min-heap.\n\nSo, that should be fine.\n\nSecond, in the while loop, after dequeueing, if the node is already visited, we skip it.\n\nBut we need to ensure that we don't process it again.\n\nThird, when adding neighbors to the queue, we add them only if the tentative distance is better than the current known distance.\n\nThis implementation should work.\n\nLet's test it with the example graph.\n\nGiven the graph:\n\n```scala\nval graph: Graph[String] = Map(\n  \"A\" -> List(\"B\" -> 1, \"C\" -> 4),\n  \"B\" -> List(\"C\" -> 2, \"D\" -> 5),\n  \"C\" -> List(\"D\" -> 1),\n  \"D\" -> List()\n)\n```\n\nCalling `dijkstraShortestPath(graph, \"A\", \"D\")` should return `Some(List(\"A\", \"B\", \"C\", \"D\"))`.\n\nLet's simulate:\n\n1. Initialize:\n\n- distances: A=0, B=Int.MaxValue, C=Int.MaxValue, D=Int.MaxValue\n\n- previous: empty\n\n- queue: [NodeDistance(A, 0)]\n\n- visited: empty\n\n2. Dequeue A (distance 0)\n\n- visited: A\n\n- Check neighbors B and C\n\n- B: tentative distance 0+1=1 < Int.MaxValue -> update distances(B)=1, previous(B)=A, enqueue B(1)\n\n- C: tentative distance 0+4=4 < Int.MaxValue -> update distances(C)=4, previous(C)=A, enqueue C(4)\n\n- queue: [B(1), C(4)]\n\n3. Dequeue B (distance 1)\n\n- visited: A, B\n\n- Check neighbors C and D\n\n- C: tentative distance 1+2=3 < 4 -> update distances(C)=3, previous(C)=B, enqueue C(3)\n\n- D: tentative distance 1+5=6 < Int.MaxValue -> update distances(D)=6, previous(D)=B, enqueue D(6)\n\n- queue: [C(3), D(6)]\n\n4. Dequeue C (distance 3)\n\n- visited: A, B, C\n\n- Check neighbor D\n\n- D: tentative distance 3+1=4 < 6 -> update distances(D)=4, previous(D)=C, enqueue D(4)\n\n- queue: [D(4)]\n\n5. Dequeue D (distance 4)\n\n- visited: A, B, C, D\n\n- End node reached\n\n- Rebuild path: D -> C -> B -> A -> reverse to A -> B -> C -> D\n\n- Return Some(List(\"A\", \"B\", \"C\", \"D\"))\n\nPerfect, it works as expected.\n\nNow, let's think about possible improvements or edge cases.\n\n- If the start node is the same as the end node, return the path containing only the start node.\n\n- If the start node is not in the graph, return None.\n\n- If the end node is not reachable from the start node, return None.\n\n- Handle graphs with negative weights: Dijkstra's algorithm does not support negative weights, so assume all weights are non-negative.\n\n- Handle graphs with zero weights correctly.\n\nLet's add some checks at the beginning of the function.\n\n```scala\nif (!graph.contains(start) || !graph.contains(end)) {\n  return None\n}\n```\n\nAlso, if start == end, return immediately.\n\n```scala\nif (start == end) {\n  return Some(List(start))\n}\n```\n\nLet's incorporate these checks.\n\nAlso, to make it more efficient, we can use a mutable priority queue, but since Scala's standard library doesn't provide one, we can stick with the immutable one, accepting the performance trade-off.\n\nAlternatively, we can use the `scala.collection.mutable.PriorityQueue`, which allows updates.\n\nBut for simplicity, we'll stick with the immutable version.\n\nAnother consideration is to avoid processing nodes that have already been visited, which we're already doing.\n\nLet's think about how to make the function generic, working with any type T.\n\nWe need to ensure that T is hashable, as it's used in maps and sets.\n\nIn Scala, this is handled by the type system, as maps and sets use equals and hashCode.\n\nNow, let's think about how to test this function with another example.\n\nSuppose we have a graph with nodes 1, 2, 3, 4:\n\n- 1 -> 2 with weight 10\n\n- 1 -> 4 with weight 5\n\n- 2 -> 3 with weight 1\n\n- 4 -> 2 with weight 2\n\n- 4 -> 3 with weight 6\n\n- 3 -> 1 with weight 7 (to test cycles)\n\nFind the shortest path from 1 to 3.\n\nPossible paths:\n\n- 1 -> 2 -> 3: 10 + 1 = 11\n\n- 1 -> 4 -> 2 -> 3: 5 + 2 + 1 = 8\n\n- 1 -> 4 -> 3: 5 + 6 = 11\n\nSo, the shortest path should be 1 -> 4 -> 2 -> 3 with total weight 8.\n\nLet's represent this graph:\n\n```scala\nval graph: Graph[Int] = Map(\n  1 -> List(2 -> 10, 4 -> 5),\n  2 -> List(3 -> 1),\n  3 -> List(1 -> 7),\n  4 -> List(2 -> 2, 3 -> 6)\n)\n```\n\nRunning the function `dijkstraShortestPath(graph, 1, 3)` should return `Some(List(1, 4, 2, 3))`.\n\nLet's simulate:\n\n1. Initialize:\n\n- distances: 1=0, 2=Int.MaxValue, 3=Int.MaxValue, 4=Int.MaxValue\n\n- previous: empty\n\n- queue: [NodeDistance(1, 0)]\n\n- visited: empty\n\n2. Dequeue 1 (distance 0)\n\n- visited: 1\n\n- Neighbors 2 and 4\n\n- 2: 0+10=10 < Int.MaxValue -> distances(2)=10, previous(2)=1, enqueue 2(10)\n\n- 4: 0+5=5 < Int.MaxValue -> distances(4)=5, previous(4)=1, enqueue 4(5)\n\n- queue: [4(5), 2(10)]\n\n3. Dequeue 4 (distance 5)\n\n- visited: 1, 4\n\n- Neighbors 2 and 3\n\n- 2: 5+2=7 < 10 -> distances(2)=7, previous(2)=4, enqueue 2(7)\n\n- 3: 5+6=11 < Int.MaxValue -> distances(3)=11, previous(3)=4, enqueue 3(11)\n\n- queue: [2(7), 3(11)]\n\n4. Dequeue 2 (distance 7)\n\n- visited: 1, 4, 2\n\n- Neighbors 3\n\n- 3: 7+1=8 < 11 -> distances(3)=8, previous(3)=2, enqueue 3(8)\n\n- queue: [3(8)]\n\n5. Dequeue 3 (distance 8)\n\n- visited: 1, 4, 2, 3\n\n- End node reached\n\n- Rebuild path: 3 -> 2 -> 4 -> 1 -> reverse to 1 -> 4 -> 2 -> 3\n\n- Return Some(List(1,4,2,3))\n\nPerfect.\n\nNow, let's think about a graph with a negative weight. Although Dijkstra's algorithm doesn't handle negative weights, since the problem specifies non-negative weights, we can assume all weights are >= 0.\n\nHowever, to make the function more robust, perhaps we should add a check for negative weights and throw an exception or handle it somehow.\n\nBut for simplicity, and since the problem specifies non-negative weights, we'll assume that.\n\nAnother consideration is the type T. Since it's generic, it can be any type, but in practice, it's often integers or strings representing node names.\n\nLet's think about the time complexity.\n\nThe time complexity of Dijkstra's algorithm with a priority queue is O((V + E) log V), where V is the number of vertices and E is the number of edges.\n\nIn our implementation, since we're using an immutable priority queue, the performance might not be optimal, but for the sake of this exercise, it should suffice.\n\nNow, let's think about how to write this function in Scala, ensuring that all parts are correctly implemented.\n\nFirst, define the graph type:\n\n```scala\ntype Graph[T] = Map[T, List[(T, Int)]]\n```\n\nThen, the NodeDistance case class:\n\n```scala\ncase class NodeDistance[T](node: T, distance: Int)\n```\n\nDefine the rebuildPath function:\n\n```scala\ndef rebuildPath[T](previous: Map[T, T], start: T, end: T): List[T] = {\n  @tailrec\n  def buildPath(current: T, path: List[T]): List[T] = {\n    if (current == start) start :: path\n    else buildPath(previous(current), current :: path)\n  }\n  if (previous.contains(end)) buildPath(end, List())\n  else List()\n}\n```\n\nNow, the main dijkstraShortestPath function:\n\n```scala\ndef dijkstraShortestPath[T](graph: Graph[T], start: T, end: T): Option[List[T]] = {\n  import scala.collection.immutable.PriorityQueue\n\n  case class NodeDistance(node: T, distance: Int)\n\n  implicit val ordering: Ordering[NodeDistance] = Ordering.by(nd => nd.distance).reverse\n\n  if (!graph.contains(start) || !graph.contains(end)) {\n    return None\n  }\n\n  if (start == end) {\n    return Some(List(start))\n  }\n\n  var distances: Map[T, Int] = graph.keys.map(k => k -> Int.MaxValue).toMap.updated(start, 0)\n  var previous: Map[T, T] = Map.empty\n  var queue: PriorityQueue[NodeDistance] = PriorityQueue(NodeDistance(start, 0))\n  var visited: Set[T] = Set.empty\n\n  while (queue.nonEmpty) {\n    val NodeDistance(currentNode, currentDistance) = queue.dequeue()\n\n    if (visited.contains(currentNode)) {\n      next\n    }\n\n    visited += currentNode\n\n    if (currentNode == end) {\n      return Some(rebuildPath(previous, start, end))\n    }\n\n    graph.getOrElse(currentNode, List()).foreach { case (neighbor, weight) =>\n      val tentativeDistance = currentDistance + weight\n      if (tentativeDistance < distances(neighbor)) {\n        distances = distances.updated(neighbor, tentativeDistance)\n        previous = previous.updated(neighbor, currentNode)\n        queue += NodeDistance(neighbor, tentativeDistance)\n      }\n    }\n  }\n\n  if (visited.contains(end)) {\n    Some(rebuildPath(previous, start, end))\n  } else {\n    None\n  }\n}\n```\n\nThis should work correctly for the given examples.\n\nLet's consider another test case where there is no path from start to end.\n\nFor example:\n\nGraph:\n\n- A -> B with weight 1\n\n- B -> C with weight 1\n\n- D -> E with weight 1\n\nStart: A, End: E\n\nThere is no path from A to E, so should return None.\n\nLet's represent this graph:\n\n```scala\nval graph: Graph[String] = Map(\n  \"A\" -> List(\"B\" -> 1),\n  \"B\" -> List(\"C\" -> 1),\n  \"C\" -> List(),\n  \"D\" -> List(\"E\" -> 1),\n  \"E\" -> List()\n)\n```\n\nRunning `dijkstraShortestPath(graph, \"A\", \"E\")` should return None, since there is no path from A to E.\n\nLet's simulate:\n\n1. Initialize:\n\n- distances: A=0, B=Int.MaxValue, C=Int.MaxValue, D=Int.MaxValue, E=Int.MaxValue\n\n- previous: empty\n\n- queue: [NodeDistance(A, 0)]\n\n- visited: empty\n\n2. Dequeue A (distance 0)\n\n- visited: A\n\n- Neighbor B\n\n- B: 0+1=1 < Int.MaxValue -> distances(B)=1, previous(B)=A, enqueue B(1)\n\n- queue: [B(1)]\n\n3. Dequeue B (distance 1)\n\n- visited: A, B\n\n- Neighbor C\n\n- C: 1+1=2 < Int.MaxValue -> distances(C)=2, previous(C)=B, enqueue C(2)\n\n- queue: [C(2)]\n\n4. Dequeue C (distance 2)\n\n- visited: A, B, C\n\n- No neighbors\n\n5. queue is empty\n\n- End node E not visited\n\n- Return None\n\nCorrect.\n\nAnother test case: start and end are the same.\n\nGraph:\n\n- A -> B with weight 1\n\nStart and end: A\n\nShould return Some(List(A))\n\nHandled by the initial check.\n\nOk.\n\nNow, let's think about the code's readability and scalability.\n\nThe function is generic and should work with any type T, assuming T is properly hashed and equaled.\n\nWe're using immutable data structures, which is good for functional programming, but may not be the most efficient for large graphs.\n\nFor larger graphs, using mutable data structures would be more efficient, but that's beyond the scope of this exercise.\n\nAlso, we're using `Int.MaxValue` to represent infinite distances, which could cause overflow if the graph has edges with large weights or many edges.\n\nTo handle larger weights, we could use `Long.MaxValue`.\n\nBut for simplicity, we'll stick with `Int`.\n\nNow, let's think about how to integrate this function into a larger program.\n\nSuppose we have a graph represented as a map, and we want to find the shortest path between two nodes.\n\nWe can call this function and handle the `Option[List[T]]` return value accordingly.\n\nFor example:\n\n```scala\nval path = dijkstraShortestPath(graph, start, end)\npath match {\n  case Some(p) => println(s\"Shortest path: $p\")\n  case None => println(\"No path found\")\n}\n```\n\nThis is straightforward.\n\nNow, considering that this is for an Indian AI startup, it's important that the code is clean, well-documented, and efficient within the constraints.\n\nSince the problem specifies using Dijkstra's algorithm, and assuming non-negative weights, this implementation should suffice.\n\nIf there are any specific performance requirements or constraints, they should be considered and possibly optimized accordingly.\n\nBut for the given problem, this should be a suitable solution.\n\n**Final Solution**\n\nTo solve this problem, we need to implement Dijkstra's algorithm in Scala to find the shortest path between two nodes in a weighted, directed graph.\n\n## Approach\n\n1. **Graph Representation:** We represent the graph using an adjacency list, where each node points to its neighbors along with the edge weights.\n2. **Priority Queue:** We use a priority queue to always expand the node with the lowest cost.\n3. **Distance Tracking:** We keep track of the shortest distances from the source to each node.\n4. **Path Reconstruction:** We maintain a map to track the path that led to each node.\n\n## Solution Code\n\n```scala\nimport scala.collection.immutable.PriorityQueue\n\ntype Graph[T] = Map[T, List[(T, Int)]]\n\ncase class NodeDistance[T](node: T, distance: Int)\n\ndef dijkstraShortestPath[T](graph: Graph[T], start: T, end: T): Option[List[T]] = {\n  implicit val ordering: Ordering[NodeDistance[T]] = Ordering.by(nd => nd.distance).reverse\n\n  if (!graph.contains(start) || !graph.contains(end)) {\n    return None\n  }\n\n  if (start == end) {\n    return Some(List(start))\n  }\n\n  var distances: Map[T, Int] = graph.keys.map(k => k -> Int.MaxValue).toMap.updated(start, 0)\n  var previous: Map[T, T] = Map.empty\n  var queue: PriorityQueue[NodeDistance[T]] = PriorityQueue(NodeDistance(start, 0))\n  var visited: Set[T] = Set.empty\n\n  while (queue.nonEmpty) {\n    val NodeDistance(currentNode, currentDistance) = queue.dequeue()\n\n    if (visited.contains(currentNode)) {\n      next\n    }\n\n    visited += currentNode\n\n    if (currentNode == end) {\n      return Some(rebuildPath(previous, start, end))\n    }\n\n    graph.getOrElse(currentNode, List()).foreach { case (neighbor, weight) =>\n      val tentativeDistance = currentDistance + weight\n      if (tentativeDistance < distances(neighbor)) {\n        distances = distances.updated(neighbor, tentativeDistance)\n        previous = previous.updated(neighbor, currentNode)\n        queue += NodeDistance(neighbor, tentativeDistance)\n      }\n    }\n  }\n\n  if (visited.contains(end)) {\n    Some(rebuildPath(previous, start, end))\n  } else {\n    None\n  }\n}\n\ndef rebuildPath[T](previous: Map[T, T], start: T, end: T): List[T] = {\n  @tailrec\n  def buildPath(current: T, path: List[T]): List[T] = {\n    if (current == start) start :: path\n    else buildPath(previous(current), current :: path)\n  }\n  if (previous.contains(end)) buildPath(end, List())\n  else List()\n}\n```\n\n## Explanation\n\n1. **Graph Representation:** The graph is represented as a map where each key is a node, and the value is a list of tuples representing its neighbors and the edge weights.\n2. **Priority Queue:** A priority queue is used to always expand the node with the smallest distance from the source.\n3. **Distance Tracking:** We maintain a map to keep track of the shortest distances from the source to each node.\n4. **Path Reconstruction:** Another map is used to keep track of the previous node in the optimal path, which allows us to reconstruct the path once the destination node is reached.\n5. **Algorithm Steps:**\n   - Initialize distances with infinity except for the start node, which is set to 0.\n   - Use a priority queue to select the node with the smallest known distance to explore next.\n   - Update the distances of neighboring nodes if a shorter path is found.\n   - Repeat until the destination node is reached or no nodes are left to explore.\n6. **Edge Cases:** The algorithm handles cases where the start and end nodes are the same, or when there is no path between the start and end nodes."
    }
]