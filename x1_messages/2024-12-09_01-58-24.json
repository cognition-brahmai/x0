[
    {
        "role": "user",
        "content": "Create a GoLang program that simulates a parking lot. The parking lot has small slots, compact slots, and large slots. The parking lot can park motorcycles, cars, and buses. When a vehicle gets parked, it must be assigned the smallest slot that can accommodate it. PLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Sure, I can help you with that! Let's dive into creating a GoLang program that simulates a parking lot with different slot sizes and vehicle types. We need to make sure that each vehicle is assigned the smallest possible slot that can accommodate it.\n\nFirst, let's outline the requirements:\n\n1. **Slot Types:**\n   - Small slots: for motorcycles.\n   - Compact slots: for cars.\n   - Large slots: for buses.\n\n2. **Vehicle Types:**\n   - Motorcycles: can park in any slot size.\n   - Cars: can park in compact or large slots.\n   - Buses: can only park in large slots.\n\n3. **Assignment Rule:**\n   - Each vehicle should be assigned the smallest available slot that can accommodate it.\n\nTo achieve this, we need to:\n\n- Define the slot types and vehicle types.\n- Keep track of available slots for each type.\n- Implement a system to assign the smallest possible slot to a vehicle based on its type.\n\nLet's start by defining constants for slot sizes and vehicle types.\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n)\n\n// Define constants for slot sizes\nconst (\n\tSmall = iota\n\tCompact\n\tLarge\n)\n\n// Define constants for vehicle types\nconst (\n\tMotorcycle = iota\n\tCar\n\tBus\n)\n```\n\nNext, we need to create structures to represent slots and vehicles.\n\n```go\n// Slot represents a parking slot\ntype Slot struct {\n\tsize  int\n\tempty bool\n}\n\n// Vehicle represents a vehicle to be parked\ntype Vehicle struct {\n\ttypee int\n}\n```\n\nNow, we need to manage the parking lot. We'll create a ParkingLot struct to hold the slots and provide methods to park vehicles.\n\n```go\n// ParkingLot manages the parking slots\ntype ParkingLot struct {\n\tslots map[int][]*Slot // map from slot size to slice of slots\n}\n\nfunc NewParkingLot() *ParkingLot {\n\treturn &ParkingLot{\n\t\tslots: make(map[int][]*Slot),\n\t}\n}\n\nfunc (pl *ParkingLot) AddSlot(size int) {\n\tpl.slots[size] = append(pl.slots[size], &Slot{size: size, empty: true})\n}\n```\n\nWe need a way to park vehicles. The park method should find the smallest available slot that can accommodate the vehicle.\n\n```go\nfunc (pl *ParkingLot) Park(vehicleType int) (int, error) {\n\tvar suitableSizes []int\n\tswitch vehicleType {\n\tcase Motorcycle:\n\t\tsuitableSizes = []int{Small, Compact, Large}\n\tcase Car:\n\t\tsuitableSizes = []int{Compact, Large}\n\tcase Bus:\n\t\tsuitableSizes = []int{Large}\n\tdefault:\n\t\treturn -1, fmt.Errorf(\"invalid vehicle type\")\n\t}\n\n\t// Find the smallest suitable slot\n\tfor _, size := range suitableSizes {\n\t\tfor _, slot := range pl.slots[size] {\n\t\t\tif slot.empty {\n\t\t\t\tslot.empty = false\n\t\t\t\treturn slot.size, nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn -1, fmt.Errorf(\"no available slot for vehicle type %d\", vehicleType)\n}\n```\n\nTo test this, let's create a main function to set up the parking lot and park some vehicles.\n\n```go\nfunc main() {\n\tparkingLot := NewParkingLot()\n\n\t// Add some slots\n\tparkingLot.AddSlot(Small)\n\tparkingLot.AddSlot(Compact)\n\tparkingLot.AddSlot(Large)\n\tparkingLot.AddSlot(Small)\n\tparkingLot.AddSlot(Compact)\n\tparkingLot.AddSlot(Large)\n\n\t// Park some vehicles\n\tvehicles := []int{Motorcycle, Car, Bus, Motorcycle, Car, Bus}\n\n\tfor _, vehicle := range vehicles {\n\t\tslotSize, err := parkingLot.Park(vehicle)\n\t\tif err != nil {\n\t\t\tfmt.Println(err)\n\t\t} else {\n\t\t\tfmt.Printf(\"Parked vehicle type %d in slot size %d\\n\", vehicle, slotSize)\n\t\t}\n\t}\n}\n```\n\nThis is a basic implementation. To make it more efficient, especially with a large number of slots, we can:\n\n- Keep the slots sorted by size.\n- Use a data structure to quickly find the smallest available slot for a given vehicle type.\n\nLet's enhance the ParkingLot struct to keep track of available slots for each size.\n\n```go\n// ParkingLot manages the parking slots\ntype ParkingLot struct {\n\tslots map[int][]*Slot // map from slot size to slice of slots\n\tavailable map[int][]int // map from slot size to indices of available slots\n}\n\nfunc NewParkingLot() *ParkingLot {\n\treturn &ParkingLot{\n\t\tslots:      make(map[int][]*Slot),\n\t\tavailable:  make(map[int][]int),\n\t}\n}\n\nfunc (pl *ParkingLot) AddSlot(size int) {\n\tindices, ok := pl.available[size]\n\tif !ok {\n\t\tindices = make([]int, 0)\n\t}\n\tslot := &Slot{size: size, empty: true}\n\tpl.slots[size] = append(pl.slots[size], slot)\n\tindices = append(indices, len(pl.slots[size])-1)\n\tpl.available[size] = indices\n}\n```\n\nNow, update the Park method to use the available slots.\n\n```go\nfunc (pl *ParkingLot) Park(vehicleType int) (int, error) {\n\tvar suitableSizes []int\n\tswitch vehicleType {\n\tcase Motorcycle:\n\t\tsuitableSizes = []int{Small, Compact, Large}\n\tcase Car:\n\t\tsuitableSizes = []int{Compact, Large}\n\tcase Bus:\n\t\tsuitableSizes = []int{Large}\n\tdefault:\n\t\treturn -1, fmt.Errorf(\"invalid vehicle type\")\n\t}\n\n\tfor _, size := range suitableSizes {\n\t\tindices, ok := pl.available[size]\n\t\tif !ok || len(indices) == 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Find the smallest available slot index\n\t\tsmallestIndex := indices[0]\n\t\tfor _, idx := range indices[1:] {\n\t\t\tif pl.slots[size][idx].size < pl.slots[size][smallestIndex].size {\n\t\t\t\tsmallestIndex = idx\n\t\t\t}\n\t\t}\n\n\t\t// Assign the slot\n\t\tslot := pl.slots[size][smallestIndex]\n\t\tslot.empty = false\n\n\t\t// Remove the slot from available list\n\t\tfor i, idx := range indices {\n\t\t\tif idx == smallestIndex {\n\t\t\t\tpl.available[size] = append(indices[:i], indices[i+1:]...)\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\treturn slot.size, nil\n\t}\n\n\treturn -1, fmt.Errorf(\"no available slot for vehicle type %d\", vehicleType)\n}\n```\n\nThis approach ensures that we always assign the smallest available slot that can accommodate the vehicle.\n\nTo make it even more efficient, we can use a min-heap for the available slots of each size, so that the smallest slot is always at the front.\n\nFirst, implement a min-heap for slot indices.\n\n```go\nimport (\n\t\"container/heap\"\n)\n\ntype IndexHeap []int\n\nfunc (h IndexHeap) Len() int           { return len(h) }\nfunc (h IndexHeap) Less(i, j int) bool { return pl.slots[size][h[i]].size < pl.slots[size][h[j]].size }\nfunc (h IndexHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }\n\nfunc (h *IndexHeap) Push(x interface{}) {\n\t*h = append(*h, x.(int))\n}\n\nfunc (h *IndexHeap) Pop() interface{} {\n\told := *h\n\tn := len(old)\n\tx := old[n-1]\n\t*h = old[0 : n-1]\n\treturn x\n}\n```\n\nUpdate the ParkingLot struct to use heaps.\n\n```go\n// ParkingLot manages the parking slots\ntype ParkingLot struct {\n\tslots map[int][]*Slot // map from slot size to slice of slots\n\tavailable map[int]*IndexHeap // map from slot size to heap of available slot indices\n}\n\nfunc NewParkingLot() *ParkingLot {\n\treturn &ParkingLot{\n\t\tslots:      make(map[int][]*Slot),\n\t\tavailable:  make(map[int]*IndexHeap),\n\t}\n}\n\nfunc (pl *ParkingLot) AddSlot(size int) {\n\theap := &IndexHeap{}\n\theap.Init(heap)\n\tpl.available[size] = heap\n\tslot := &Slot{size: size, empty: true}\n\tpl.slots[size] = append(pl.slots[size], slot)\n\theap.Push(len(pl.slots[size])-1)\n}\n```\n\nUpdate the Park method to use the heaps.\n\n```go\nfunc (pl *ParkingLot) Park(vehicleType int) (int, error) {\n\tvar suitableSizes []int\n\tswitch vehicleType {\n\tcase Motorcycle:\n\t\tsuitableSizes = []int{Small, Compact, Large}\n\tcase Car:\n\t\tsuitableSizes = []int{Compact, Large}\n\tcase Bus:\n\t\tsuitableSizes = []int{Large}\n\tdefault:\n\t\treturn -1, fmt.Errorf(\"invalid vehicle type\")\n\t}\n\n\tfor _, size := range suitableSizes {\n\t\theap := pl.available[size]\n\t\tif heap == nil || heap.Len() == 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Get the smallest available slot\n\t\tsmallestIndex := heap.Pop().(int)\n\t\tslot := pl.slots[size][smallestIndex]\n\t\tslot.empty = false\n\n\t\treturn slot.size, nil\n\t}\n\n\treturn -1, fmt.Errorf(\"no available slot for vehicle type %d\", vehicleType)\n}\n```\n\nThis implementation ensures efficient assignment of the smallest available slot for each vehicle type using min-heaps.\n\nFinally, let's update the main function to test this enhanced parking lot.\n\n```go\nfunc main() {\n\tparkingLot := NewParkingLot()\n\n\t// Add some slots\n\tparkingLot.AddSlot(Small)\n\tparkingLot.AddSlot(Compact)\n\tparkingLot.AddSlot(Large)\n\tparkingLot.AddSlot(Small)\n\tparkingLot.AddSlot(Compact)\n\tparkingLot.AddSlot(Large)\n\n\t// Park some vehicles\n\tvehicles := []int{Motorcycle, Car, Bus, Motorcycle, Car, Bus}\n\n\tfor _, vehicle := range vehicles {\n\t\tslotSize, err := parkingLot.Park(vehicle)\n\t\tif err != nil {\n\t\t\tfmt.Println(err)\n\t\t} else {\n\t\t\tfmt.Printf(\"Parked vehicle type %d in slot size %d\\n\", vehicle, slotSize)\n\t\t}\n\t}\n}\n```\n\nThis should output the assignment of slots to vehicles based on the rules specified.\n\n## Final Solution\nTo simulate a parking lot in Go that assigns the smallest possible slot to vehicles based on their type, we can follow these steps:\n\n1. **Define Constants and Structures:**\n   - Define constants for slot sizes and vehicle types.\n   - Create structures to represent parking slots and vehicles.\n\n2. **Manage Parking Slots:**\n   - Use a `ParkingLot` struct to manage slots, organized by size.\n   - Implement methods to add slots and park vehicles.\n\n3. **Efficient Slot Assignment:**\n   - Use min-heaps to efficiently assign the smallest available slot to each vehicle.\n\n### Solution Code\n\n```go\npackage main\n\nimport (\n\t\"container/heap\"\n\t\"fmt\"\n)\n\n// Define constants for slot sizes\nconst (\n\tSmall = iota\n\tCompact\n\tLarge\n)\n\n// Define constants for vehicle types\nconst (\n\tMotorcycle = iota\n\tCar\n\tBus\n)\n\n// Slot represents a parking slot\ntype Slot struct {\n\tsize  int\n\tempty bool\n}\n\n// ParkingLot manages the parking slots\ntype ParkingLot struct {\n\tslots     map[int][]*Slot        // map from slot size to slice of slots\n\tavailable map[int]*IndexHeap     // map from slot size to heap of available slot indices\n}\n\n// IndexHeap is a min-heap of slot indices\ntype IndexHeap []int\n\nfunc (h IndexHeap) Len() int           { return len(h) }\nfunc (h IndexHeap) Less(i, j int) bool { return pl.slots[size][h[i]].size < pl.slots[size][h[j]].size }\nfunc (h IndexHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }\n\nfunc (h *IndexHeap) Push(x interface{}) {\n\t*h = append(*h, x.(int))\n}\n\nfunc (h *IndexHeap) Pop() interface{} {\n\told := *h\n\tn := len(old)\n\tx := old[n-1]\n\t*h = old[0 : n-1]\n\treturn x\n}\n\nfunc NewParkingLot() *ParkingLot {\n\treturn &ParkingLot{\n\t\tslots:     make(map[int][]*Slot),\n\t\tavailable: make(map[int]*IndexHeap),\n\t}\n}\n\nfunc (pl *ParkingLot) AddSlot(size int) {\n\theap := &IndexHeap{}\n\theap.Init(heap)\n\tpl.available[size] = heap\n\tslot := &Slot{size: size, empty: true}\n\tpl.slots[size] = append(pl.slots[size], slot)\n\theap.Push(len(pl.slots[size]) - 1)\n}\n\nfunc (pl *ParkingLot) Park(vehicleType int) (int, error) {\n\tvar suitableSizes []int\n\tswitch vehicleType {\n\tcase Motorcycle:\n\t\tsuitableSizes = []int{Small, Compact, Large}\n\tcase Car:\n\t\tsuitableSizes = []int{Compact, Large}\n\tcase Bus:\n\t\tsuitableSizes = []int{Large}\n\tdefault:\n\t\treturn -1, fmt.Errorf(\"invalid vehicle type\")\n\t}\n\n\tfor _, size := range suitableSizes {\n\t\theap := pl.available[size]\n\t\tif heap == nil || heap.Len() == 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Get the smallest available slot\n\t\tsmallestIndex := heap.Pop().(int)\n\t\tslot := pl.slots[size][smallestIndex]\n\t\tslot.empty = false\n\n\t\treturn slot.size, nil\n\t}\n\n\treturn -1, fmt.Errorf(\"no available slot for vehicle type %d\", vehicleType)\n}\n\nfunc main() {\n\tparkingLot := NewParkingLot()\n\n\t// Add some slots\n\tparkingLot.AddSlot(Small)\n\tparkingLot.AddSlot(Compact)\n\tparkingLot.AddSlot(Large)\n\tparkingLot.AddSlot(Small)\n\tparkingLot.AddSlot(Compact)\n\tparkingLot.AddSlot(Large)\n\n\t// Park some vehicles\n\tvehicles := []int{Motorcycle, Car, Bus, Motorcycle, Car, Bus}\n\n\tfor _, vehicle := range vehicles {\n\t\tslotSize, err := parkingLot.Park(vehicle)\n\t\tif err != nil {\n\t\t\tfmt.Println(err)\n\t\t} else {\n\t\t\tfmt.Printf(\"Parked vehicle type %d in slot size %d\\n\", vehicle, slotSize)\n\t\t}\n\t}\n}\n```\n\n### Explanation\n\n1. **Constants and Structures:**\n   - Defined constants for slot sizes and vehicle types.\n   - Created `Slot` and `Vehicle` structures to represent parking slots and vehicles.\n\n2. **Parking Lot Management:**\n   - `ParkingLot` struct manages slots using maps for easy access.\n   - `AddSlot` method adds new slots to the parking lot and maintains a heap of available slots for each size.\n\n3. **Efficient Slot Assignment:**\n   - Used min-heaps (`IndexHeap`) to efficiently manage and assign the smallest available slot to each vehicle.\n   - `Park` method assigns the smallest suitable slot to the vehicle based on its type.\n\nThis solution ensures that vehicles are always assigned the smallest possible slot that can accommodate them, using efficient data structures for management and assignment."
    }
]