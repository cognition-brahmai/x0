[
    {
        "role": "user",
        "content": "Build a Node.js RESTful API that interacts with a PostgreSQL database to perform CRUD operations on a \"books\" table containing fields such as title, author, genre, and publication date. Implement proper validation for incoming requests and return appropriate HTTP status codes.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Alright, I've got this task to build a Node.js RESTful API that interacts with a PostgreSQL database to perform CRUD operations on a \"books\" table. The table should have fields like title, author, genre, and publication date. I need to make sure that I implement proper validation for incoming requests and return appropriate HTTP status codes.\n\nFirst, I need to set up my project environment. I'll start by creating a new directory for my project and initializing it with npm.\n\n```\nmkdir book-api\ncd book-api\nnpm init -y\n```\n\nNext, I need to install the necessary dependencies. For Node.js, I'll need Express for setting up the API routes, and pg for connecting to the PostgreSQL database. I'll also install body-parser to handle JSON data in requests, and celebrate for request validation.\n\n```\nnpm install express pg body-parser celebrate\n```\n\nNow, I need to set up my PostgreSQL database. I'll create a new database and a \"books\" table with the required fields.\n\n```sql\nCREATE DATABASE bookdb;\n\n\\c bookdb\n\nCREATE TABLE books (\n    id SERIAL PRIMARY KEY,\n    title VARCHAR(255) NOT NULL,\n    author VARCHAR(255) NOT NULL,\n    genre VARCHAR(100),\n    publication_date DATE\n);\n```\n\nWith the database set up, I'll create a config file to store my database connection settings. I'll use environment variables to keep my credentials secure.\n\nFirst, I'll install the dotenv package to load environment variables from a .env file.\n\n```\nnpm install dotenv\n```\n\nThen, I'll create a .env file in my project root:\n\n```\nDB_HOST=localhost\nDB_PORT=5432\nDB_USER=your_username\nDB_PASSWORD=your_password\nDB_NAME=bookdb\n```\n\nAnd a config.js file to establish the database connection:\n\n```javascript\nrequire('dotenv').config();\nconst { Pool } = require('pg');\n\nconst pool = new Pool({\n    host: process.env.DB_HOST,\n    port: process.env.DB_PORT,\n    user: process.env.DB_USER,\n    password: process.env.DB_PASSWORD,\n    database: process.env.DB_NAME\n});\n\nmodule.exports = pool;\n```\n\nNow, I'll set up my Express server. I'll create an index.js file and set up the basic server structure.\n\n```javascript\nconst express = require('express');\nconst bodyParser = require('body-parser');\nconst celebrate = require('celebrate');\nconst pool = require('./config');\n\nconst app = express();\nconst port = 3000;\n\napp.use(bodyParser.json());\n\n// Routes will be defined here\n\napp.listen(port, () => {\n    console.log(`Server is running on port ${port}`);\n});\n```\n\nI need to define the CRUD operations for the \"books\" table. Let's start with creating a book (POST /books).\n\nFirst, I'll define the validation schema for the request body using celebrate.\n\n```javascript\nconst { body } = celebrate;\n```\n\nFor creating a book, I need to validate that the title and author are provided, and that the publication date is in the correct format.\n\n```javascript\nconst createBookValidator = celebrate({\n    body: {\n        title: body().exists({ checkFalsy: true }).withMessage('Title is required'),\n        author: body().exists({ checkFalsy: true }).withMessage('Author is required'),\n        genre: body().optional(),\n        publication_date: body().isDate({ format: 'YYYY-MM-DD' }).withMessage('Publication date must be in YYYY-MM-DD format')\n    }\n});\n```\n\nNow, I'll write the route handler for creating a book.\n\n```javascript\napp.post('/books', createBookValidator, async (req, res) => {\n    const { title, author, genre, publication_date } = req.body;\n\n    try {\n        const result = await pool.query(\n            'INSERT INTO books (title, author, genre, publication_date) VALUES ($1, $2, $3, $4) RETURNING *',\n            [title, author, genre, publication_date]\n        );\n        res.status(201).json(result.rows[0]);\n    } catch (error) {\n        console.error(error);\n        res.status(500).json({ error: 'Internal server error' });\n    }\n});\n```\n\nNext, I'll implement getting all books (GET /books).\n\n```javascript\napp.get('/books', async (req, res) => {\n    try {\n        const result = await pool.query('SELECT * FROM books');\n        res.json(result.rows);\n    } catch (error) {\n        console.error(error);\n        res.status(500).json({ error: 'Internal server error' });\n    }\n});\n```\n\nNow, getting a single book by ID (GET /books/:id).\n\n```javascript\napp.get('/books/:id', async (req, res) => {\n    const id = req.params.id;\n\n    try {\n        const result = await pool.query('SELECT * FROM books WHERE id = $1', [id]);\n        if (result.rows.length === 0) {\n            return res.status(404).json({ error: 'Book not found' });\n        }\n        res.json(result.rows[0]);\n    } catch (error) {\n        console.error(error);\n        res.status(500).json({ error: 'Internal server error' });\n    }\n});\n```\n\nUpdating a book (PUT /books/:id).\n\nI'll need to validate the update request body similarly to the create request.\n\n```javascript\nconst updateBookValidator = celebrate({\n    body: {\n        title: body().optional(),\n        author: body().optional(),\n        genre: body().optional(),\n        publication_date: body().optional().isDate({ format: 'YYYY-MM-DD' }).withMessage('Publication date must be in YYYY-MM-DD format')\n    }\n});\n```\n\nAnd the route handler:\n\n```javascript\napp.put('/books/:id', updateBookValidator, async (req, res) => {\n    const id = req.params.id;\n    const { title, author, genre, publication_date } = req.body;\n\n    try {\n        const result = await pool.query(\n            'UPDATE books SET title = COALESCE($1, title), author = COALESCE($2, author), genre = COALESCE($3, genre), publication_date = COALESCE($4, publication_date) WHERE id = $5 RETURNING *',\n            [title, author, genre, publication_date, id]\n        );\n        if (result.rows.length === 0) {\n            return res.status(404).json({ error: 'Book not found' });\n        }\n        res.json(result.rows[0]);\n    } catch (error) {\n        console.error(error);\n        res.status(500).json({ error: 'Internal server error' });\n    }\n});\n```\n\nDeleting a book (DELETE /books/:id).\n\n```javascript\napp.delete('/books/:id', async (req, res) => {\n    const id = req.params.id;\n\n    try {\n        const result = await pool.query('DELETE FROM books WHERE id = $1 RETURNING *', [id]);\n        if (result.rows.length === 0) {\n            return res.status(404).json({ error: 'Book not found' });\n        }\n        res.status(204).json({ message: 'Book deleted successfully' });\n    } catch (error) {\n        console.error(error);\n        res.status(500).json({ error: 'Internal server error' });\n    }\n});\n```\n\nI should also handle any validation errors from celebrate.\n\n```javascript\napp.use((err, req, res, next) => {\n    if (err && err.details) {\n        res.status(400).json({ error: err.details });\n    } else {\n        next(err);\n    }\n});\n\napp.use((err, req, res, next) => {\n    console.error(err);\n    res.status(500).json({ error: 'Internal server error' });\n});\n```\n\nFinally, I'll make sure to close the database connection when the server is shut down.\n\n```javascript\nprocess.on('SIGINT', () => {\n    pool.end();\n    process.exit();\n});\n```\n\nPutting it all together, my index.js file should look like this:\n\n```javascript\nconst express = require('express');\nconst bodyParser = require('body-parser');\nconst celebrate = require('celebrate');\nconst pool = require('./config');\n\nconst app = express();\nconst port = 3000;\n\napp.use(bodyParser.json());\n\n// Validation schemas\nconst { body } = celebrate;\nconst createBookValidator = celebrate({\n    body: {\n        title: body().exists({ checkFalsy: true }).withMessage('Title is required'),\n        author: body().exists({ checkFalsy: true }).withMessage('Author is required'),\n        genre: body().optional(),\n        publication_date: body().isDate({ format: 'YYYY-MM-DD' }).withMessage('Publication date must be in YYYY-MM-DD format')\n    }\n});\n\nconst updateBookValidator = celebrate({\n    body: {\n        title: body().optional(),\n        author: body().optional(),\n        genre: body().optional(),\n        publication_date: body().optional().isDate({ format: 'YYYY-MM-DD' }).withMessage('Publication date must be in YYYY-MM-DD format')\n    }\n});\n\n// Routes\napp.post('/books', createBookValidator, async (req, res) => {\n    const { title, author, genre, publication_date } = req.body;\n\n    try {\n        const result = await pool.query(\n            'INSERT INTO books (title, author, genre, publication_date) VALUES ($1, $2, $3, $4) RETURNING *',\n            [title, author, genre, publication_date]\n        );\n        res.status(201).json(result.rows[0]);\n    } catch (error) {\n        console.error(error);\n        res.status(500).json({ error: 'Internal server error' });\n    }\n});\n\napp.get('/books', async (req, res) => {\n    try {\n        const result = await pool.query('SELECT * FROM books');\n        res.json(result.rows);\n    } catch (error) {\n        console.error(error);\n        res.status(500).json({ error: 'Internal server error' });\n    }\n});\n\napp.get('/books/:id', async (req, res) => {\n    const id = req.params.id;\n\n    try {\n        const result = await pool.query('SELECT * FROM books WHERE id = $1', [id]);\n        if (result.rows.length === 0) {\n            return res.status(404).json({ error: 'Book not found' });\n        }\n        res.json(result.rows[0]);\n    } catch (error) {\n        console.error(error);\n        res.status(500).json({ error: 'Internal server error' });\n    }\n});\n\napp.put('/books/:id', updateBookValidator, async (req, res) => {\n    const id = req.params.id;\n    const { title, author, genre, publication_date } = req.body;\n\n    try {\n        const result = await pool.query(\n            'UPDATE books SET title = COALESCE($1, title), author = COALESCE($2, author), genre = COALESCE($3, genre), publication_date = COALESCE($4, publication_date) WHERE id = $5 RETURNING *',\n            [title, author, genre, publication_date, id]\n        );\n        if (result.rows.length === 0) {\n            return res.status(404).json({ error: 'Book not found' });\n        }\n        res.json(result.rows[0]);\n    } catch (error) {\n        console.error(error);\n        res.status(500).json({ error: 'Internal server error' });\n    }\n});\n\napp.delete('/books/:id', async (req, res) => {\n    const id = req.params.id;\n\n    try {\n        const result = await pool.query('DELETE FROM books WHERE id = $1 RETURNING *', [id]);\n        if (result.rows.length === 0) {\n            return res.status(404).json({ error: 'Book not found' });\n        }\n        res.status(204).json({ message: 'Book deleted successfully' });\n    } catch (error) {\n        console.error(error);\n        res.status(500).json({ error: 'Internal server error' });\n    }\n});\n\n// Error handling\napp.use((err, req, res, next) => {\n    if (err && err.details) {\n        res.status(400).json({ error: err.details });\n    } else {\n        next(err);\n    }\n});\n\napp.use((err, req, res, next) => {\n    console.error(err);\n    res.status(500).json({ error: 'Internal server error' });\n});\n\n// Start server\napp.listen(port, () => {\n    console.log(`Server is running on port ${port}`);\n});\n\n// Close database connection on server shutdown\nprocess.on('SIGINT', () => {\n    pool.end();\n    process.exit();\n});\n```\n\nThis should cover all the CRUD operations for the \"books\" table with proper validation and HTTP status codes."
    }
]