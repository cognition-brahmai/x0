[
    {
        "role": "user",
        "content": "Implement a binary search tree data structure in C# with insert, delete, and search operations.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Alright, I'm going to help you implement a binary search tree (BST) in C# with insert, delete, and search operations. I'll walk you through each step, explaining what we're doing along the way.\n\nFirst, what's a binary search tree? It's a data structure that keeps data in a hierarchical way, where each node has at most two children, referred to as the left child and the right child. For a BST, the key in each node must be greater than all keys in its left subtree and less than all keys in its right subtree. This property allows for efficient search, insert, and delete operations.\n\n### Step 1: Define the Node Class\n\nWe need to create a class to represent each node in the BST. Each node will hold a key (for this example, we'll use integers) and references to its left and right children.\n\n```csharp\npublic class TreeNode\n{\n    public int Key { get; set; }\n    public TreeNode Left { get; set; }\n    public TreeNode Right { get; set; }\n\n    public TreeNode(int key)\n    {\n        Key = key;\n        Left = null;\n        Right = null;\n    }\n}\n```\n\n### Step 2: Define the BinarySearchTree Class\n\nNow, we'll create the BinarySearchTree class that will manage the nodes. This class will have methods to insert, delete, and search for nodes.\n\n```csharp\npublic class BinarySearchTree\n{\n    public TreeNode Root { get; set; }\n\n    public BinarySearchTree()\n    {\n        Root = null;\n    }\n\n    // Insert method\n    public void Insert(int key)\n    {\n        Root = InsertRecursive(Root, key);\n    }\n\n    private TreeNode InsertRecursive(TreeNode current, int key)\n    {\n        if (current == null)\n        {\n            return new TreeNode(key);\n        }\n\n        if (key < current.Key)\n        {\n            current.Left = InsertRecursive(current.Left, key);\n        }\n        else if (key > current.Key)\n        {\n            current.Right = InsertRecursive(current.Right, key);\n        }\n        else\n        {\n            // Duplicate keys are not allowed in this implementation\n            return current;\n        }\n\n        return current;\n    }\n\n    // Search method\n    public bool Search(int key)\n    {\n        return SearchRecursive(Root, key);\n    }\n\n    private bool SearchRecursive(TreeNode current, int key)\n    {\n        if (current == null)\n        {\n            return false;\n        }\n\n        if (key == current.Key)\n        {\n            return true;\n        }\n        else if (key < current.Key)\n        {\n            return SearchRecursive(current.Left, key);\n        }\n        else\n        {\n            return SearchRecursive(current.Right, key);\n        }\n    }\n\n    // Delete method\n    public void Delete(int key)\n    {\n        Root = DeleteRecursive(Root, key);\n    }\n\n    private TreeNode DeleteRecursive(TreeNode current, int key)\n    {\n        if (current == null)\n        {\n            return null;\n        }\n\n        if (key < current.Key)\n        {\n            current.Left = DeleteRecursive(current.Left, key);\n        }\n        else if (key > current.Key)\n        {\n            current.Right = DeleteRecursive(current.Right, key);\n        }\n        else\n        {\n            // Node to delete found\n\n            // Case 1: No children\n            if (current.Left == null && current.Right == null)\n            {\n                return null;\n            }\n            // Case 2: One child\n            else if (current.Left == null)\n            {\n                return current.Right;\n            }\n            else if (current.Right == null)\n            {\n                return current.Left;\n            }\n            // Case 3: Two children\n            else\n            {\n                // Find the in-order successor (smallest in the right subtree)\n                TreeNode successor = FindMin(current.Right);\n                // Copy the successor's key to this node\n                current.Key = successor.Key;\n                // Delete the successor\n                current.Right = DeleteRecursive(current.Right, successor.Key);\n            }\n        }\n\n        return current;\n    }\n\n    private TreeNode FindMin(TreeNode node)\n    {\n        while (node.Left != null)\n        {\n            node = node.Left;\n        }\n        return node;\n    }\n}\n```\n\n### Explanation\n\n1. **Insertion**:\n   - We recursively find the correct position for the new key based on the BST properties.\n   - If the key already exists, we do not insert it again (this can be modified if needed).\n\n2. **Search**:\n   - We recursively search for the key starting from the root.\n   - If the key is found, we return true; otherwise, false.\n\n3. **Deletion**:\n   - We find the node to delete.\n   - Handle three cases:\n     - The node has no children.\n     - The node has one child.\n     - The node has two children. In this case, we find the in-order successor (the smallest key in the right subtree), replace the node's key with the successor's key, and then delete the successor node.\n\n### Usage Example\n\nHere's how you can use the BinarySearchTree class:\n\n```csharp\nclass Program\n{\n    static void Main()\n    {\n        BinarySearchTree bst = new BinarySearchTree();\n\n        bst.Insert(50);\n        bst.Insert(30);\n        bst.Insert(20);\n        bst.Insert(40);\n        bst.Insert(70);\n        bst.Insert(60);\n        bst.Insert(80);\n\n        Console.WriteLine(\"Is 40 in the tree? \" + bst.Search(40));\n        Console.WriteLine(\"Is 90 in the tree? \" + bst.Search(90));\n\n        bst.Delete(20);\n        Console.WriteLine(\"Is 20 in the tree after deletion? \" + bst.Search(20));\n\n        bst.Delete(30);\n        Console.WriteLine(\"Is 30 in the tree after deletion? \" + bst.Search(30));\n\n        bst.Delete(50);\n        Console.WriteLine(\"Is 50 in the tree after deletion? \" + bst.Search(50));\n    }\n}\n```\n\nThis should give you a basic implementation of a binary search tree in C# with insert, delete, and search operations. You can expand upon this by adding more features like traversal methods (in-order, pre-order, post-order), finding the minimum and maximum keys, etc.\n\nI hope this helps! Let me know if you have any questions or need further assistance."
    }
]