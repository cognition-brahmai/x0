[
    {
        "role": "user",
        "content": "Implement a C++ class called \"Fraction\" that represents a rational number (i.e., a fraction). The class should include methods for addition, subtraction, multiplication, division, simplification, and comparison of fractions. Additionally, overload the standard arithmetic and comparison operators for the Fraction class."
    },
    {
        "role": "assistant",
        "content": "Implementing a `Fraction` class in C++ that represents rational numbers involves several steps. We need to handle operations like addition, subtraction, multiplication, division, simplification, and comparison, and also overload the standard arithmetic and comparison operators for these operations.\n\n### Approach\n\n1. **Class Definition**: Define a class `Fraction` with private members for numerator and denominator.\n2. **Constructors**: Implement constructors to initialize fractions, including a default constructor and a parameterized constructor.\n3. **Simplification**: Implement a method to simplify fractions to their lowest terms.\n4. **Arithmetic Operations**: Implement methods for addition, subtraction, multiplication, and division.\n5. **Comparison Operations**: Implement methods for comparing fractions (equal, not equal, less than, etc.).\n6. **Operator Overloading**: Overload arithmetic operators (+, -, *, /) and comparison operators (==, !=, <, >, <=, >=) for convenient usage.\n7. **Helper Functions**: Implement helper functions for calculating the greatest common divisor (GCD) for simplification.\n\n### Solution Code\n\n```cpp\n#include <iostream>\n#include <utility> // For std::pair\n\nclass Fraction {\nprivate:\n    int numerator;\n    int denominator;\n\n    // Helper function to calculate GCD\n    static int gcd(int a, int b) {\n        while (b != 0) {\n            int temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return a;\n    }\n\n    // Method to simplify the fraction\n    void simplify() {\n        if (denominator < 0) {\n            numerator = -numerator;\n            denominator = -denominator;\n        }\n        int common_divisor = gcd(std::abs(numerator), std::abs(denominator));\n        numerator /= common_divisor;\n        denominator /= common_divisor;\n    }\n\npublic:\n    // Default constructor\n    Fraction() : numerator(0), denominator(1) {}\n\n    // Parameterized constructor\n    Fraction(int num, int den) : numerator(num), denominator(den != 0 ? den : 1) {\n        simplify();\n    }\n\n    // Getter for numerator\n    int getNumerator() const {\n        return numerator;\n    }\n\n    // Getter for denominator\n    int getDenominator() const {\n        return denominator;\n    }\n\n    // Addition\n    Fraction operator+(const Fraction& other) const {\n        int new_num = numerator * other.denominator + other.numerator * denominator;\n        int new_den = denominator * other.denominator;\n        return Fraction(new_num, new_den);\n    }\n\n    // Subtraction\n    Fraction operator-(const Fraction& other) const {\n        int new_num = numerator * other.denominator - other.numerator * denominator;\n        int new_den = denominator * other.denominator;\n        return Fraction(new_num, new_den);\n    }\n\n    // Multiplication\n    Fraction operator*(const Fraction& other) const {\n        int new_num = numerator * other.numerator;\n        int new_den = denominator * other.denominator;\n        return Fraction(new_num, new_den);\n    }\n\n    // Division\n    Fraction operator/(const Fraction& other) const {\n        if (other.numerator == 0) {\n            throw std::invalid_argument(\"Cannot divide by zero.\");\n        }\n        int new_num = numerator * other.denominator;\n        int new_den = denominator * other.numerator;\n        return Fraction(new_num, new_den);\n    }\n\n    // Equality comparison\n    bool operator==(const Fraction& other) const {\n        return numerator == other.numerator && denominator == other.denominator;\n    }\n\n    // Inequality comparison\n    bool operator!=(const Fraction& other) const {\n        return !(*this == other);\n    }\n\n    // Less than comparison\n    bool operator<(const Fraction& other) const {\n        return numerator * other.denominator < other.numerator * denominator;\n    }\n\n    // Greater than comparison\n    bool operator>(const Fraction& other) const {\n        return other < *this;\n    }\n\n    // Less than or equal to comparison\n    bool operator<=(const Fraction& other) const {\n        return !(*this > other);\n    }\n\n    // Greater than or equal to comparison\n    bool operator>=(const Fraction& other) const {\n        return !(*this < other);\n    }\n\n    // Stream insertion operator\n    friend std::ostream& operator<<(std::ostream& os, const Fraction& frac) {\n        os << frac.numerator << \"/\" << frac.denominator;\n        return os;\n    }\n\n    // Stream extraction operator\n    friend std::istream& operator>>(std::istream& is, Fraction& frac) {\n        char ch;\n        is >> frac.numerator >> ch >> frac.denominator;\n        if (is && ch == '/') {\n            frac.simplify();\n        }\n        return is;\n    }\n};\n\nint main() {\n    Fraction f1(1, 2);\n    Fraction f2(3, 4);\n\n    std::cout << \"f1: \" << f1 << \", f2: \" << f2 << std::endl;\n\n    Fraction sum = f1 + f2;\n    std::cout << \"Sum: \" << sum << std::endl;\n\n    Fraction diff = f1 - f2;\n    std::cout << \"Difference: \" << diff << std::endl;\n\n    Fraction prod = f1 * f2;\n    std::cout << \"Product: \" << prod << std::endl;\n\n    Fraction quot = f1 / f2;\n    std::cout << \"Quotient: \" << quot << std::endl;\n\n    std::cout << \"Are f1 and f2 equal? \" << (f1 == f2 ? \"Yes\" : \"No\") << std::endl;\n    std::cout << \"Is f1 less than f2? \" << (f1 < f2 ? \"Yes\" : \"No\") << std::endl;\n\n    return 0;\n}\n```\n\n### Explanation\n\n1. **Class Definition and Constructors**:\n   - `Fraction` class has private members `numerator` and `denominator`.\n   - Constructors initialize fractions, with a default constructor and a parameterized constructor that simplifies the fraction upon creation.\n\n2. **Simplification**:\n   - The `simplify` method reduces the fraction to its lowest terms using the greatest common divisor (GCD).\n\n3. **Arithmetic Operations**:\n   - Overloaded operators (+, -, *, /) perform the respective arithmetic operations and return a new `Fraction` object.\n\n4. **Comparison Operations**:\n   - Overloaded comparison operators (==, !=, <, >, <=, >=) compare fractions based on their numerical value.\n\n5. **Input and Output**:\n   - Overloaded `<<` and `>>` operators allow easy input and output of `Fraction` objects.\n\nThis implementation ensures that fractions are always stored in their simplest form and that operations on fractions are both efficient and intuitive."
    }
]