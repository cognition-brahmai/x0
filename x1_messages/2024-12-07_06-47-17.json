[
    {
        "role": "user",
        "content": "Write a Golang program that monitors a specified directory for changes (file creation, modification, or deletion) and logs these events to a file. The program should use filesystem watchers to detect changes efficiently and accept command line arguments for the target directory and log file path.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Alright, I've got this task to create a Go program that watches a directory for any changes like when files are created, modified, or deleted, and then logs these events into a specified log file. I need to make sure that it uses filesystem watchers to do this efficiently, and also that it accepts command-line arguments for the target directory and the log file path.\n\nFirst, I need to understand what filesystem watchers are in Go. I know that Go has a package called `fsnotify` which is commonly used for watching filesystem events. I should probably import that.\n\nSo, the plan is:\n\n1. Accept command-line arguments for the target directory and the log file.\n\n2. Set up a watcher on the target directory using `fsnotify`.\n\n3. Log any events (create, modify, delete) to the specified log file.\n\nI should also think about error handling, like what if the directory doesn't exist, or if there are permissions issues with writing to the log file.\n\nLet me start by looking at how to use `fsnotify`. I think I need to create a new watcher, add the directory to it, and then set up a loop to listen for events.\n\nAlso, I need to make sure that the program runs continuously, so it should keep watching for events indefinitely unless interrupted.\n\nFor logging, I can use Go's `log` package, and direct the output to the specified log file.\n\nLet me sketch a rough structure of the program:\n\n- Check and parse command-line arguments.\n\n- Set up logging to the specified file.\n\n- Create a new `fsnotify` watcher.\n\n- Add the target directory to the watcher.\n\n- Set up a loop to receive events from the watcher.\n\n- Log each event with the type of change and the file name.\n\n- Handle any errors that occur, like failing to add the directory or write to the log.\n\nI should also consider what happens if there are a lot of events coming in quickly. Does `fsnotify` buffer them, or do I need to handle that?\n\nAdditionally, I should think about how to stop the program gracefully, maybe by catching interrupt signals like Ctrl+C.\n\nLet me look up the `fsnotify` package to see exactly how to use it.\n\nOkay, from the `fsnotify` docs, it seems straightforward. I can create a new watcher with `fsnotify.NewWatcher()`, then add the directory with `Watcher.Add(directory)`, and then listen for events on `Watcher.Events`.\n\nErrors can be caught from `Watcher.Errors`.\n\nI need to run this in a loop, probably with a select statement to handle both events and errors.\n\nFor logging, I can use `log.New` to create a logger that writes to the specified file.\n\nI should also set the log format to include timestamps, so I can see when each event occurred.\n\nLet me think about the command-line arguments. I'll expect two arguments: the target directory and the log file path.\n\nI can use the `flag` package to parse these arguments, or perhaps `kingpin` or `cobra` for more sophisticated argument handling, but to keep it simple, I'll use the standard `flag` package.\n\nWait, actually, the standard `flag` package is okay for this purpose.\n\nSo, I'll define two flags: one for the directory and one for the log file.\n\nI should also add some help text to explain how to use the program.\n\nError handling is crucial here. For example, if the directory doesn't exist, I should inform the user and exit.\n\nSimilarly, if there's a problem writing to the log file, I need to handle that gracefully.\n\nLet me think about how to structure the code.\n\nProbably, I'll have a main function that:\n\n- Parses the flags.\n\n- Checks if the directory exists.\n\n- Sets up the log file.\n\n- Creates and configures the fsnotify watcher.\n\n- Starts a loop to watch for events and log them.\n\n- Handles interrupts to close the watcher properly.\n\nI should also consider if the user wants to watch subdirectories recursively. fsnotify supports this with the `Watcher.Add` method, but I need to decide if I want to enable that by default or make it an option.\n\nFor now, I'll keep it simple and watch only the specified directory, not recursively.\n\nBut maybe I should make it an option. I can add a flag to enable recursive watching.\n\nThat would be useful.\n\nSo, I'll have three flags:\n\n- Directory to watch.\n\n- Log file path.\n\n- A boolean flag to enable recursive watching.\n\nI'll use the `flag` package to define these.\n\nNow, regarding logging: I should open the log file in append mode, so that if the program is run multiple times, it doesn't overwrite the previous log entries.\n\nAlso, I should handle the case where the log file cannot be written to, perhaps due to permission issues.\n\nIn such cases, I should print an error message to stderr and exit.\n\nSimilarly, if adding the directory to the watcher fails, I should handle that.\n\nfsnotify can raise permission errors or other issues, so I need to catch those from `Watcher.Errors`.\n\nIn the event loop, I need to handle both events and errors.\n\nI can use a select statement with two cases: one for events and one for errors.\n\nFor each event, I'll log the time, the type of event, and the file name.\n\nThe event types are defined in `fsnotify`, like `fsnotify.Create`, `fsnotify.Write`, `fsnotify.Remove`, etc.\n\nI should map these to human-readable strings for the log.\n\nAlso, I need to consider that some events might come in bursts, especially during operations like copying large files.\n\nfsnotify might coalesce events in such cases, but I should still log each one individually.\n\nI should also think about performance. If there are a lot of events, writing to the log file frequently might become a bottleneck.\n\nMaybe I can buffer the logs before writing them to the file, but that might complicate things, and for now, I'll keep it simple.\n\nAnother thing to consider is that when a file is modified, fsnotify might send multiple `Write` events in quick succession.\n\nPerhaps I can coalesce these into a single log entry if they occur within a short time frame, but that might be overkill for this example.\n\nI'll keep it straightforward: log each event as it comes.\n\nI should also think about how to handle rename events, where a file is renamed from one name to another.\n\nfsnotify provides `Rename` events, which I should handle appropriately in the log.\n\nIn the log, I should indicate the old and new file names for rename events.\n\nAlright, I think I have a good plan now.\n\nLet me start writing some code.\n\nFirst, import the necessary packages:\n\n```go\npackage main\n\nimport (\n\t\"flag\"\n\t\"log\"\n\t\"os\"\n\n\t\"github.com/fsnotify/fsnotify\"\n)\n```\n\nNext, define the flags:\n\n```go\nvar (\n\tdir       string\n\tlogFile   string\n recursive bool\n)\n```\n\nIn the `init` function, set up the flags with descriptions:\n\n```go\nfunc init() {\n\tflag.StringVar(&dir, \"dir\", \"\", \"Directory to watch\")\n\tflag.StringVar(&logFile, \"log\", \"watch.log\", \"Log file path\")\n\tflag.BoolVar(&recursive, \"recursive\", false, \"Watch subdirectories recursively\")\n}\n```\n\nIn the `main` function, parse the flags and check if the directory exists:\n\n```go\nfunc main() {\n\tflag.Parse()\n\n\tif dir == \"\" {\n\t\tlog.Fatal(\"Directory not specified\")\n\t}\n\n\tinfo, err := os.Stat(dir)\n\tif err != nil {\n\t\tlog.Fatalf(\"Error accessing directory: %v\", err)\n\t}\n\n\tif !info.IsDir() {\n\t\tlog.Fatal(\"Specified path is not a directory\")\n\t}\n```\n\nSet up the log file:\n\n```go\n\tlogFileHandle, err := os.OpenFile(logFile, os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0644)\n\tif err != nil {\n\t\tlog.Fatalf(\"Error opening log file: %v\", err)\n\t}\n\tdefer logFileHandle.Close()\n\n\tlog.SetOutput(logFileHandle)\n\tlog.SetFlags(log.LstdFlags | log.Lmicroseconds)\n```\n\nCreate and configure the fsnotify watcher:\n\n```go\n\twatcher, err := fsnotify.NewWatcher()\n\tif err != nil {\n\t\tlog.Fatalf(\"Error creating watcher: %v\", err)\n\t}\n\tdefer watcher.Close()\n\n\terr = watcher.Add(dir)\n\tif err != nil {\n\t\tlog.Fatalf(\"Error adding directory to watcher: %v\", err)\n\t}\n\n\tif recursive {\n\t\t// Add subdirectories recursively\n\t\terr = filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif info.IsDir() {\n\t\t\t\terr = watcher.Add(path)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Printf(\"Error adding directory: %v\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nil\n\t\t})\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"Error walking directory: %v\", err)\n\t\t}\n\t}\n```\n\nSet up the event loop:\n\n```go\n\tfor {\n\t\tselect {\n\t\tcase event := <-watcher.Events:\n\t\t\tlogEvent(event)\n\t\tcase err := <-watcher.Errors:\n\t\t\tlog.Printf(\"Error: %v\", err)\n\t\t}\n\t}\n}\n```\n\nDefine the `logEvent` function to log the events appropriately:\n\n```go\nfunc logEvent(event fsnotify.Event) {\n\tvar action string\n\tswitch event.Op {\n\tcase fsnotify.Create:\n\t\taction = \"Created\"\n\tcase fsnotify.Write:\n\t\taction = \"Modified\"\n\tcase fsnotify.Remove:\n\t\taction = \"Deleted\"\n\tcase fsnotify.Rename:\n\t\taction = \"Renamed\"\n\t\t// Log both old and new names for rename events\n\t\tlog.Printf(\"%s: %s -> %s\", action, event.Name, event.NameNew)\n\t\treturn\n\tdefault:\n\t\taction = \"Unknown\"\n\t}\n\tlog.Printf(\"%s: %s\", action, event.Name)\n}\n```\n\nI need to import `filepath` for recursive directory walking:\n\n```go\nimport (\n\t\"flag\"\n\t\"log\"\n\t\"os\"\n\t\"path/filepath\"\n\n\t\"github.com/fsnotify/fsnotify\"\n)\n```\n\nI should also handle the case where `event.NameNew` is empty for non-rename events.\n\nWait, in fsnotify, for rename events, `event.Name` is the old name, and `event.NameNew` is the new name.\n\nI need to ensure that `event.NameNew` is available for rename events.\n\nAccording to the fsnotify documentation, `event.NameNew` is set for rename events.\n\nSo, in the `logEvent` function, I can handle rename events separately and log both names.\n\nFor other events, just log the `event.Name`.\n\nI should also consider that some events might have multiple operations, like `Create` and `Write` combined.\n\nfsnotify represents combined operations with bitwise OR, so I need to handle that.\n\nLet me check the fsnotify documentation for event operations.\n\nYes, operations are combined with bitwise OR, so I might need to check for multiple operations in a single event.\n\nFor example, an event could be `Create | Write` if a new file is created and written to in one operation.\n\nI should adjust the `logEvent` function to handle combined operations.\n\nHere's an improved version of `logEvent`:\n\n```go\nfunc logEvent(event fsnotify.Event) {\n\tvar actions []string\n\tif event.Op&fsnotify.Create == fsnotify.Create {\n\t\tactions = append(actions, \"Created\")\n\t}\n\tif event.Op&fsnotify.Write == fsnotify.Write {\n\t\tactions = append(actions, \"Modified\")\n\t}\n\tif event.Op&fsnotify.Remove == fsnotify.Remove {\n\t\tactions = append(actions, \"Deleted\")\n\t}\n\tif event.Op&fsnotify.Rename == fsnotify.Rename {\n\t\tactions = append(actions, \"Renamed\")\n\t}\n\n\tif len(actions) == 0 {\n\t\tlog.Printf(\"Unknown event: %s\", event.Name)\n\t\treturn\n\t}\n\n\tif event.Op&fsnotify.Rename == fsnotify.Rename {\n\t\tlog.Printf(\"%s: %s -> %s\", actions[0], event.Name, event.NameNew)\n\t} else {\n\t\tlog.Printf(\"%s: %s\", actions[0], event.Name)\n\t}\n}\n```\n\nThis way, it handles combined operations by listing the first action and logging the appropriate information.\n\nI should consider logging all actions if there are multiple, but to keep it simple, I'll just log the first action for now.\n\nMaybe I can join all actions with a comma if there are multiple.\n\nLet me adjust that:\n\n```go\nfunc logEvent(event fsnotify.Event) {\n\tvar actions []string\n\tif event.Op&fsnotify.Create == fsnotify.Create {\n\t\tactions = append(actions, \"Created\")\n\t}\n\tif event.Op&fsnotify.Write == fsnotify.Write {\n\t\tactions = append(actions, \"Modified\")\n\t}\n\tif event.Op&fsnotify.Remove == fsnotify.Remove {\n\t\tactions = append(actions, \"Deleted\")\n\t}\n\tif event.Op&fsnotify.Rename == fsnotify.Rename {\n\t\tactions = append(actions, \"Renamed\")\n\t}\n\n\tif len(actions) == 0 {\n\t\tlog.Printf(\"Unknown event: %s\", event.Name)\n\t\treturn\n\t}\n\n\tactionStr := actions[0]\n\tif len(actions) > 1 {\n\t\tactionStr += \" (with \"\n\t\tactionStr += strings.Join(actions[1:], \", \")\n\t\tactionStr += \")\"\n\t}\n\n\tif event.Op&fsnotify.Rename == fsnotify.Rename {\n\t\tlog.Printf(\"%s: %s -> %s\", actionStr, event.Name, event.NameNew)\n\t} else {\n\t\tlog.Printf(\"%s: %s\", actionStr, event.Name)\n\t}\n}\n```\n\nThis makes the log more informative when multiple operations occur in a single event.\n\nI need to import the `strings` package for `strings.Join`:\n\n```go\nimport (\n\t\"flag\"\n\t\"log\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"github.com/fsnotify/fsnotify\"\n)\n```\n\nAlso, I should think about how to handle errors in the `filepath.Walk` function when adding subdirectories recursively.\n\nIn the current code, if there's an error adding a subdirectory, it just logs the error and continues.\n\nThat's probably fine, but I should make sure that critical errors are handled appropriately.\n\nAdditionally, I should consider if the program should exit if there's an error adding the main directory.\n\nIn the current code, it fatals and exits, which is appropriate.\n\nI should also think about signal handling to allow the program to exit gracefully when receiving an interrupt signal like Ctrl+C.\n\nI can use `os.Interrupt` to catch SIGINT and close the watcher before exiting.\n\nHere's how I can do that:\n\nAdd a channel to capture os signals:\n\n```go\ndone := make(chan bool)\ngo func() {\n\tselect {\n\tcase <-os.Interrupt:\n\t\twatcher.Close()\n\t\tdone <- true\n\t}\n}()\n```\n\nThen, in the event loop, also listen on the `done` channel:\n\n```go\n\tfor {\n\t\tselect {\n\t\tcase event := <-watcher.Events:\n\t\t\tlogEvent(event)\n\t\tcase err := <-watcher.Errors:\n\t\t\tlog.Printf(\"Error: %v\", err)\n\t\tcase <-done:\n\t\t\treturn\n\t\t}\n\t}\n```\n\nThis way, when the program receives a SIGINT, it closes the watcher and exits cleanly.\n\nI need to make sure that the `done` channel is set up after the watcher is created.\n\nSo, in the `main` function, after creating the watcher and before the event loop, add:\n\n```go\n\tdone := make(chan bool)\n\tgo func() {\n\t\tselect {\n\t\tcase <-os.Interrupt:\n\t\t\twatcher.Close()\n\t\t\tdone <- true\n\t\t}\n\t}()\n```\n\nAnd then modify the event loop to include the `done` channel:\n\n```go\n\tfor {\n\t\tselect {\n\t\tcase event := <-watcher.Events:\n\t\t\tlogEvent(event)\n\t\tcase err := <-watcher.Errors:\n\t\t\tlog.Printf(\"Error: %v\", err)\n\t\tcase <-done:\n\t\t\treturn\n\t\t}\n\t}\n```\n\nThis should handle graceful shutdown on interrupt signals.\n\nI should also think about other possible signals, like SIGTERM, but for simplicity, handling SIGINT should suffice for now.\n\nAnother consideration is that on some systems, multiple SIGINT signals might be sent, so I need to make sure that the program exits after receiving the first one.\n\nIn the current setup, since `watcher.Close()` is called and `done` is signaled, the program should exit after handling the first SIGINT.\n\nI think that's adequate.\n\nLet me also think about logging rotate. If the log file is rotated while the program is running, it might continue writing to the old file.\n\nTo handle log rotation, I could reopen the log file periodically or when a signal is received, but that complicates things.\n\nFor this simple program, I'll assume that log rotation is handled externally, and the program can be restarted after rotation.\n\nAlternatively, I could open the log file with append mode and rely on the operating system to handle the file being moved or replaced.\n\nIn practice, this should work fine for basic use cases.\n\nI should also consider adding a timestamp to each log entry.\n\nIn the current code, I'm using `log.SetFlags(log.LstdFlags | log.Lmicroseconds)`, which includes the date and time with microsecond precision.\n\nThat should be sufficient.\n\nLet me also think about the permission requirements.\n\nThe program needs read permission on the directory to watch it, and write permission on the log file.\n\nIf the user doesn't have the necessary permissions, appropriate errors should be raised.\n\nIn the current error handling, it should catch permission errors when adding the directory or writing to the log file.\n\nI should make sure that these errors are logged appropriately.\n\nAnother feature to consider is verbose mode, where more detailed information is logged.\n\nBut for now, I'll keep it simple and only log the basic event information.\n\nI should also think about the performance impact of logging each event immediately.\n\nIn Go, the `log` package buffers logs internally, so it shouldn't be a problem for most use cases.\n\nIf performance becomes an issue, I could look into using a faster logging library or buffering logs in memory before writing them to disk.\n\nBut again, for this simple program, the standard logging should be sufficient.\n\nLet me also consider if I need to handle different types of files, like directories versus regular files.\n\nFsnotify events include the file type, but in this program, I'm just logging the file name and the event type, so I don't need to differentiate based on file type.\n\nHowever, for delete events, if it's a directory being deleted, I might want to log that differently, but for now, I'll keep it uniform.\n\nI should also think about symbolic links.\n\nIf the watched directory contains symbolic links, fsnotify should handle them appropriately, but I need to make sure that the program doesn't fail in such cases.\n\nIn the recursive watching scenario, `filepath.Walk` should handle symbolic links by not following them by default, which is usually desirable to avoid infinite loops.\n\nI can check the `filepath.Walk` documentation to confirm.\n\nYes, `filepath.Walk` skips symbolic links by default, which is good.\n\nIf I need to follow symbolic links, I can adjust the walk function accordingly, but for now, I'll keep it as is.\n\nI should also consider that on some filesystems, fsnotify might not catch all types of events, especially on older NFS mounts or other network filesystems.\n\nBut within the capabilities of fsnotify, this program should work fine.\n\nAnother thing to think about is that fsnotify might not be available on all operating systems.\n\nFsnotify supports Linux, macOS, and Windows, which covers the main platforms.\n\nIf someone tries to run this on an unsupported platform, it will fail to import fsnotify, but since it's a common package, it's likely to be available where Go is supported.\n\nI should also add a check to make sure that fsnotify is installed.\n\nBut generally, users will install dependencies using `go get` or a similar method.\n\nIn the project's README, I can include instructions for installing dependencies.\n\nBut in the code itself, assuming fsnotify is imported, Go will handle the rest.\n\nLet me think about testing this program.\n\nI can create a test directory, watch it, and perform create, modify, and delete operations to see if the logs are recorded correctly.\n\nI should also test recursive watching by creating subdirectories and performing operations within them.\n\nAdditionally, I should test edge cases, like watching a non-existent directory, watching a file instead of a directory, permission issues, etc.\n\nI can write a simple script to automate some of these tests.\n\nFor example, create a directory, watch it, then create a file, modify it, delete it, and rename it, and check if all events are logged correctly.\n\nI should also check if the program handles multiple events in quick succession without missing any.\n\nFsnotify should take care of buffering events, but it's good to test.\n\nI should also test the program's behavior when the log file is full or has permission issues.\n\nFor example, if the log file is not writable, the program should fail to start.\n\nSimilarly, if the log file runs out of disk space, the logging should handle that gracefully without crashing the program.\n\nIn Go's log package, writing to a file that's not writable will cause log calls to fail, but the program will continue running.\n\nHowever, in this program, since logging is critical, perhaps I should add additional checks to make sure that logs are being written successfully.\n\nBut that might be overkill for this example.\n\nI should also consider that if the watched directory is moved or deleted while the program is running.\n\nFsnotify should raise an error in such cases, which I can handle by logging the error and possibly attempting to re-add the directory.\n\nBut for simplicity, I'll just log the error and continue.\n\nAnother consideration is that fsnotify might sometimes send duplicate events or miss some events, depending on the filesystem and system load.\n\nI should inform users in the documentation that the program strives to catch most events but might not catch all of them due to these limitations.\n\nNow, let me think about how to package and distribute this program.\n\nSince it's a command-line tool, I can compile it into a binary and provide instructions for downloading or building from source.\n\nI can also host it on GitHub and use Go's module system for dependency management.\n\nIn the `go.mod` file, I'll define the module path and require fsnotify.\n\nI need to make sure that all dependencies are properly managed.\n\nI should also write a README file explaining how to install and use the program, including examples of command-line usage.\n\nI can also include a license file, perhaps MIT or Apache 2.0, to open-source the code.\n\nI should also consider adding command-line help, which can be generated by the `flag` package.\n\nBy default, the `flag` package provides a `-help` flag that lists all flags and their descriptions.\n\nI can customize this if needed, but for now, the default behavior should suffice.\n\nLet me also think about versioning the program.\n\nI can use Git tags for versioning and include the version in the program's output, perhaps with a `-version` flag.\n\nBut for this initial version, I'll skip that and focus on getting the core functionality working.\n\nI should also consider adding unit tests for the logging and event handling functions.\n\nHowever, testing filesystem events is tricky, so I'll focus on integration tests for now.\n\nIn summary, the steps to complete this task are:\n\n1. Set up the Go environment and create a new module.\n\n2. Define command-line flags for the directory, log file, and recursive watching.\n\n3. Implement the main function to parse flags, check directory existence, set up logging, create and configure the fsnotify watcher, and start the event loop.\n\n4. Implement the event logging function to handle different event types and operations.\n\n5. Add signal handling to allow graceful shutdown on interrupt signals.\n\n6. Write a README file with installation and usage instructions.\n\n7. Test the program with various scenarios to ensure correctness.\n\n8. Compile the program into a binary and distribute it if needed.\n\nI think that covers the essential parts.\n\nLet me proceed to write the code accordingly.\n\n## Final Solution\nTo create a Go program that monitors a specified directory for changes and logs these events to a file, follow the steps below. This solution uses the `fsnotify` package for efficient filesystem watching and accepts command-line arguments for the target directory and log file path.\n\n### Solution Code\n\n```go\npackage main\n\nimport (\n\t\"flag\"\n\t\"log\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"github.com/fsnotify/fsnotify\"\n)\n\nvar (\n\tdir       string\n\tlogFile   string\n\trecursive bool\n)\n\nfunc main() {\n\tflag.StringVar(&dir, \"dir\", \"\", \"Directory to watch\")\n\tflag.StringVar(&logFile, \"log\", \"watch.log\", \"Log file path\")\n\tflag.BoolVar(&recursive, \"recursive\", false, \"Watch subdirectories recursively\")\n\tflag.Parse()\n\n\tif dir == \"\" {\n\t\tlog.Fatal(\"Directory not specified\")\n\t}\n\n\tinfo, err := os.Stat(dir)\n\tif err != nil {\n\t\tlog.Fatalf(\"Error accessing directory: %v\", err)\n\t}\n\n\tif !info.IsDir() {\n\t\tlog.Fatal(\"Specified path is not a directory\")\n\t}\n\n\tlogFileHandle, err := os.OpenFile(logFile, os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0644)\n\tif err != nil {\n\t\tlog.Fatalf(\"Error opening log file: %v\", err)\n\t}\n\tdefer logFileHandle.Close()\n\n\tlog.SetOutput(logFileHandle)\n\tlog.SetFlags(log.LstdFlags | log.Lmicroseconds)\n\n\twatcher, err := fsnotify.NewWatcher()\n\tif err != nil {\n\t\tlog.Fatalf(\"Error creating watcher: %v\", err)\n\t}\n\tdefer watcher.Close()\n\n\terr = watcher.Add(dir)\n\tif err != nil {\n\t\tlog.Fatalf(\"Error adding directory to watcher: %v\", err)\n\t}\n\n\tif recursive {\n\t\terr = filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif info.IsDir() {\n\t\t\t\terr = watcher.Add(path)\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Printf(\"Error adding directory: %v\", err)\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nil\n\t\t})\n\t\tif err != nil {\n\t\t\tlog.Fatalf(\"Error walking directory: %v\", err)\n\t\t}\n\t}\n\n\tdone := make(chan bool)\n\tgo func() {\n\t\tselect {\n\t\tcase <-os.Interrupt:\n\t\t\twatcher.Close()\n\t\t\tdone <- true\n\t\t}\n\t}()\n\n\tfor {\n\t\tselect {\n\t\tcase event := <-watcher.Events:\n\t\t\tlogEvent(event)\n\t\tcase err := <-watcher.Errors:\n\t\t\tlog.Printf(\"Error: %v\", err)\n\t\tcase <-done:\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc logEvent(event fsnotify.Event) {\n\tvar actions []string\n\tif event.Op&fsnotify.Create == fsnotify.Create {\n\t\tactions = append(actions, \"Created\")\n\t}\n\tif event.Op&fsnotify.Write == fsnotify.Write {\n\t\tactions = append(actions, \"Modified\")\n\t}\n\tif event.Op&fsnotify.Remove == fsnotify.Remove {\n\t\tactions = append(actions, \"Deleted\")\n\t}\n\tif event.Op&fsnotify.Rename == fsnotify.Rename {\n\t\tactions = append(actions, \"Renamed\")\n\t}\n\n\tif len(actions) == 0 {\n\t\tlog.Printf(\"Unknown event: %s\", event.Name)\n\t\treturn\n\t}\n\n\tactionStr := actions[0]\n\tif len(actions) > 1 {\n\t\tactionStr += \" (with \"\n\t\tactionStr += strings.Join(actions[1:], \", \")\n\t\tactionStr += \")\"\n\t}\n\n\tif event.Op&fsnotify.Rename == fsnotify.Rename {\n\t\tlog.Printf(\"%s: %s -> %s\", actionStr, event.Name, event.NameNew)\n\t} else {\n\t\tlog.Printf(\"%s: %s\", actionStr, event.Name)\n\t}\n}\n```\n\n### Explanation\n\n1. **Dependencies**: The program uses the `fsnotify` package for watching filesystem events. Ensure it is installed:\n   ```sh\n   go get github.com/fsnotify/fsnotify\n   ```\n\n2. **Command-Line Arguments**:\n   - `-dir`: specifies the directory to watch.\n   - `-log`: specifies the log file path (defaults to `watch.log`).\n   - `-recursive`: a flag to watch subdirectories recursively.\n\n3. **Setup**:\n   - Parse command-line flags.\n   - Validate the target directory.\n   - Set up logging to the specified log file with timestamps.\n\n4. **Watching Directory**:\n   - Create a watcher and add the target directory.\n   - If recursive watching is enabled, add all subdirectories.\n\n5. **Event Handling**:\n   - Log created, modified, deleted, and renamed events with timestamps.\n   - Handle multiple operations in a single event.\n\n6. **Graceful Shutdown**:\n   - Capture interrupt signals to close the watcher and exit cleanly.\n\nThis program efficiently monitors directory changes and logs them, providing a robust file-watching utility."
    }
]