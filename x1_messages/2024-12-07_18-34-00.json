[
    {
        "role": "user",
        "content": "Build a simple REST API in Golang that allows users to create, read, update, and delete notes, storing the data in a MariaDB database.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "To build a simple REST API in Golang that allows users to perform CRUD operations on notes, stored in a MariaDB database, we'll need to follow several steps. This guide will walk you through setting up the project, connecting to the database, defining the models, and implementing the API endpoints.\n\n### Prerequisites\n\n1. **Go installed** on your machine. You can download it from [https://golang.org/dl/](https://golang.org/dl/).\n2. **MariaDB** installed and running. You can download it from [https://mariadb.org/download/](https://mariadb.org/download/).\n3. **Basic understanding** of Go and SQL.\n\n### Project Structure\n\n```\nnote-api/\n\u251c\u2500\u2500 migrations/\n\u2502   \u2514\u2500\u2500 001_initial.sql\n\u251c\u2500\u2500 models/\n\u2502   \u2514\u2500\u2500 note.go\n\u251c\u2500\u2500 handlers/\n\u2502   \u2514\u2500\u2500 note_handler.go\n\u251c\u2500\u2500 main.go\n\u251c\u2500\u2500 go.mod\n\u2514\u2500\u2500 go.sum\n```\n\n### Step 1: Set up the Go module\n\nFirst, create a new directory for your project and initialize a Go module.\n\n```sh\nmkdir note-api\ncd note-api\ngo mod init note-api\n```\n\n### Step 2: Install dependencies\n\nWe'll need the following dependencies:\n\n- `github.com/gorilla/mux` for routing.\n- `github.com/jmoiron/sqlx` for interacting with the database.\n- `github.com/lib/pq` as the PostgreSQL driver (since MariaDB is compatible with PostgreSQL drivers).\n\nRun the following command to install them:\n\n```sh\ngo get -u github.com/gorilla/mux\ngo get -u github.com/jmoiron/sqlx\ngo get -u github.com/lib/pq\n```\n\n### Step 3: Set up the database\n\nFirst, create a new database and a table for notes.\n\n#### 001_initial.sql\n\n```sql\nCREATE DATABASE IF NOT EXISTS note_api;\n\nUSE note_api;\n\nCREATE TABLE notes (\n    id INT AUTO_INCREMENT PRIMARY KEY,\n    title VARCHAR(255) NOT NULL,\n    content TEXT\n);\n```\n\nRun this script using the MariaDB command line or any MariaDB client.\n\n### Step 4: Define the Note model\n\nCreate a `models` package and define the `Note` struct.\n\n#### models/note.go\n\n```go\npackage models\n\ntype Note struct {\n    ID      int    `json:\"id\"`\n    Title   string `json:\"title\"`\n    Content string `json:\"content\"`\n}\n```\n\n### Step 5: Implement the handlers\n\nCreate a `handlers` package and define functions to handle CRUD operations.\n\n#### handlers/note_handler.go\n\n```go\npackage handlers\n\nimport (\n    \"encoding/json\"\n    \"net/http\"\n\n    \"note-api/models\"\n    \"github.com/jmoiron/sqlx\"\n    _ \"github.com/lib/pq\"\n)\n\ntype NoteHandler struct {\n    db *sqlx.DB\n}\n\nfunc NewNoteHandler(db *sqlx.DB) *NoteHandler {\n    return &NoteHandler{db: db}\n}\n\nfunc (h *NoteHandler) CreateNote(w http.ResponseWriter, r *http.Request) {\n    var note models.Note\n    err := json.NewDecoder(r.Body).Decode(&note)\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusBadRequest)\n        return\n    }\n\n    query := \"INSERT INTO notes (title, content) VALUES (?, ?)\"\n    result, err := h.db.Exec(query, note.Title, note.Content)\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n        return\n    }\n\n    id, err := result.LastInsertId()\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n        return\n    }\n    note.ID = int(id)\n\n    w.Header().Set(\"Content-Type\", \"application/json\")\n    json.NewEncoder(w).Encode(note)\n}\n\nfunc (h *NoteHandler) GetNotes(w http.ResponseWriter, r *http.Request) {\n    var notes []models.Note\n    query := \"SELECT id, title, content FROM notes\"\n    err := h.db.Select(&notes, query)\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n        return\n    }\n\n    w.Header().Set(\"Content-Type\", \"application/json\")\n    json.NewEncoder(w).Encode(notes)\n}\n\nfunc (h *NoteHandler) GetNote(w http.ResponseWriter, r *http.Request) {\n    params := mux.Vars(r)\n    id := params[\"id\"]\n\n    var note models.Note\n    query := \"SELECT id, title, content FROM notes WHERE id = ?\"\n    err := h.db.Get(&note, query, id)\n    if err != nil {\n        if err == sqlx.ErrNoRows {\n            http.Error(w, \"Note not found\", http.StatusNotFound)\n        } else {\n            http.Error(w, err.Error(), http.StatusInternalServerError)\n        }\n        return\n    }\n\n    w.Header().Set(\"Content-Type\", \"application/json\")\n    json.NewEncoder(w).Encode(note)\n}\n\nfunc (h *NoteHandler) UpdateNote(w http.ResponseWriter, r *http.Request) {\n    params := mux.Vars(r)\n    id := params[\"id\"]\n\n    var note models.Note\n    err := json.NewDecoder(r.Body).Decode(&note)\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusBadRequest)\n        return\n    }\n\n    query := \"UPDATE notes SET title = ?, content = ? WHERE id = ?\"\n    result, err := h.db.Exec(query, note.Title, note.Content, id)\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n        return\n    }\n\n    rowsAffected, err := result.RowsAffected()\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n        return\n    }\n    if rowsAffected == 0 {\n        http.Error(w, \"Note not found\", http.StatusNotFound)\n        return\n    }\n\n    note.ID = intFromString(id)\n    w.Header().Set(\"Content-Type\", \"application/json\")\n    json.NewEncoder(w).Encode(note)\n}\n\nfunc (h *NoteHandler) DeleteNote(w http.ResponseWriter, r *http.Request) {\n    params := mux.Vars(r)\n    id := params[\"id\"]\n\n    query := \"DELETE FROM notes WHERE id = ?\"\n    result, err := h.db.Exec(query, id)\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n        return\n    }\n\n    rowsAffected, err := result.RowsAffected()\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n        return\n    }\n    if rowsAffected == 0 {\n        http.Error(w, \"Note not found\", http.StatusNotFound)\n        return\n    }\n\n    w.WriteHeader(http.StatusNoContent)\n}\n\nfunc intFromString(s string) int {\n    id, err := strconv.Atoi(s)\n    if err != nil {\n        return 0\n    }\n    return id\n}\n```\n\n### Step 6: Set up the main server\n\nIn `main.go`, set up the router and database connection.\n\n#### main.go\n\n```go\npackage main\n\nimport (\n    \"log\"\n    \"net/http\"\n\n    \"github.com/gorilla/mux\"\n    _ \"github.com/lib/pq\"\n    \"github.com/jmoiron/sqlx\"\n\n    \"note-api/models\"\n    \"note-api/handlers\"\n)\n\nconst (\n    host     = \"localhost\"\n    port     = 3306\n    user     = \"your_db_user\"\n    password = \"your_db_password\"\n    dbname   = \"note_api\"\n)\n\nfunc main() {\n    db, err := sqlx.Open(\"mysql\", fmt.Sprintf(\"%s:%s@tcp(%s:%d)/%s\", user, password, host, port, dbname))\n    if err != nil {\n        log.Fatal(err)\n    }\n    defer db.Close()\n\n    handler := handlers.NewNoteHandler(db)\n    router := mux.NewRouter()\n    router.HandleFunc(\"/notes\", handler.CreateNote).Methods(\"POST\")\n    router.HandleFunc(\"/notes\", handler.GetNotes).Methods(\"GET\")\n    router.HandleFunc(\"/notes/{id}\", handler.GetNote).Methods(\"GET\")\n    router.HandleFunc(\"/notes/{id}\", handler.UpdateNote).Methods(\"PUT\")\n    router.HandleFunc(\"/notes/{id}\", handler.DeleteNote).Methods(\"DELETE\")\n\n    log.Println(\"Starting server at port 8000\")\n    log.Fatal(http.ListenAndServe(\":8000\", router))\n}\n```\n\n### Step 7: Run the application\n\nMake sure your MariaDB server is running and the database is set up correctly. Then, run your Go application:\n\n```sh\ngo run main.go\n```\n\nYour REST API should now be running at `http://localhost:8000`. You can test the endpoints using tools like `curl` or Postman.\n\n### Conclusion\n\nYou've successfully created a simple REST API in Golang for managing notes, with data stored in a MariaDB database. This API allows users to create, read, update, and delete notes through HTTP requests. This is a basic example, and in a production environment, you would need to add more features like input validation, error handling, and possibly user authentication."
    }
]