[
    {
        "role": "user",
        "content": "Develop a Node.js application that serves as a RESTful API for managing a simple task management system. The API should support endpoints for creating, updating, deleting, and listing tasks. Each task should have a title, description, due date, and status (completed or not). Store the tasks in a MariaDB database."
    },
    {
        "role": "assistant",
        "content": "Alright, I'm going to tackle this task of building a RESTful API for a task management system using Node.js and MariaDB. I've got some experience with Node.js and databases, but I've never used MariaDB before, so this should be a good learning experience.\n\nFirst things first, I need to set up my environment. I'll need to make sure I have Node.js installed, and I'll need to install MariaDB as well. I think most operating systems have MariaDB available via their package managers, so that should be straightforward.\n\nOnce I have both installed, I need to plan out my database schema. Since each task has a title, description, due date, and status, I'll create a table in MariaDB with columns for these fields. I should also include a unique identifier for each task, probably an auto-incrementing integer ID.\n\nSo, the table might look something like this:\n\n- id (int, primary key, auto-increment)\n\n- title (varchar)\n\n- description (text)\n\n- due_date (date)\n\n- status (boolean - true for completed, false for not)\n\nI need to make sure that the due_date field is of type date, so I can handle dates properly. I might need to format the dates when sending them to the database and when retrieving them.\n\nNext, I need to set up the Node.js application. I'll use Express.js as the framework for building the API, since it's lightweight and very flexible. I'll also need a package to handle the database connections, probably MariaDB's own connector for Node.js.\n\nSo, I'll initialize a new Node.js project, install Express and the MariaDB connector, and set up the basic structure of the application.\n\nI should organize my code into modules or files for better maintainability. For example, I can have a separate file for database connections, another for the task model, and another for the API routes.\n\nLet me think about the endpoints I need to implement:\n\n- GET /tasks: to list all tasks\n\n- POST /tasks: to create a new task\n\n- GET /tasks/:id: to get a specific task by ID\n\n- PUT /tasks/:id: to update a task\n\n- DELETE /tasks/:id: to delete a task\n\nI should also consider adding some error handling and validation to make sure that the data being sent to the API is correct. For example, the title should be a string, the due_date should be a valid date, and the status should be a boolean.\n\nI need to think about how to handle database connections. Should I use a connection pool? MariaDB's connector probably has built-in support for connection pooling, which is efficient for handling multiple requests.\n\nI should also consider how to handle transactions, especially for operations that involve multiple database operations, but for this simple task management system, I think single operations per request will suffice.\n\nSecurity is also important. I need to make sure that I'm not vulnerable to SQL injection attacks. Since I'll be using parameterized queries with the MariaDB connector, that should help mitigate that risk.\n\nI should also think about how to handle dates in different time zones. Since the due_date is just a date without time, I might not need to worry too much about time zones, but I should still be consistent in how I handle dates.\n\nLet me outline the steps I need to take:\n\n1. Set up the MariaDB database and create the tasks table.\n\n2. Initialize a new Node.js project and install necessary packages (Express, MariaDB connector).\n\n3. Create a database connection module.\n\n4. Create a task model module to handle database operations related to tasks.\n\n5. Create an API routes module to define the endpoints.\n\n6. Implement each endpoint with the necessary logic.\n\n7. Test the API to make sure it works as expected.\n\nI should also consider adding some form of authentication if this were a real application, but for the sake of this exercise, I'll keep it simple and without authentication.\n\nLet me start by setting up the database.\n\nFirst, I need to install MariaDB. Since I'm on Ubuntu, I can use apt-get to install it.\n\n```\n\nsudo apt-get update\n\nsudo apt-get install mariadb-server\n\n```\n\nAfter installation, I need to secure the installation and set a root password.\n\n```\n\nsudo mysql_secure_installation\n\n```\n\nThen, I can log into the MariaDB shell using the root credentials.\n\n```\n\nsudo mysql -u root -p\n\n```\n\nOnce inside the MariaDB shell, I'll create a new database for my task management system.\n\n```\n\nCREATE DATABASE task_manager;\n\n```\n\nThen, I'll create the tasks table within that database.\n\n```\n\nUSE task_manager;\n\nCREATE TABLE tasks (\n\n id INT AUTO_INCREMENT PRIMARY KEY,\n\n title VARCHAR(255) NOT NULL,\n\n description TEXT,\n\n due_date DATE,\n\n status BOOLEAN DEFAULT FALSE\n\n);\n\n```\n\nI should also create a user with appropriate privileges for my Node.js application to connect to the database.\n\n```\n\nCREATE USER 'taskuser'@'localhost' IDENTIFIED BY 'password';\n\nGRANT ALL PRIVILEGES ON task_manager.* TO 'taskuser'@'localhost';\n\nFLUSH PRIVILEGES;\n\n```\n\nOkay, database setup is done. Now, I'll set up the Node.js project.\n\nI'll create a new directory for my project and initialize it with npm.\n\n```\n\nmkdir task-manager-api\n\ncd task-manager-api\n\nnpm init -y\n\n```\n\nThen, I'll install Express and the MariaDB connector.\n\n```\n\nnpm install express mariadb\n\n```\n\nNow, I'll create the basic structure of my application.\n\nI'll create the following files and folders:\n\n- db.js: for database connections\n\n- models/task.js: for task-related database operations\n\n- routes/tasks.js: for defining the API endpoints\n\n- app.js: the main application file\n\nLet me start by creating db.js. This file will handle the connection to the MariaDB database.\n\nI need to require the mariadb module and set up a connection pool.\n\n```javascript\n\nconst mariadb = require('mariadb');\n\nconst pool = mariadb.createPool({\n\n host: 'localhost',\n\n user: 'taskuser',\n\n password: 'password',\n\n database: 'task_manager'\n\n});\n\nmodule.exports = pool;\n\n```\n\nI'll export the pool so that other modules can use it to get connections.\n\nNext, I'll create models/task.js. This file will contain functions for interacting with the tasks table.\n\nFor example, I can have functions like getAllTasks, getTaskById, createTask, updateTask, and deleteTask.\n\nLet me start by writing the getAllTasks function.\n\n```javascript\n\nconst db = require('./db');\n\nasync function getAllTasks() {\n\n let conn;\n\n try {\n\n conn = await db.getConnection();\n\n const rows = await conn.query('SELECT * FROM tasks');\n\n return rows;\n\n } catch (err) {\n\n console.error('Error selecting tasks:', err);\n\n throw err;\n\n } finally {\n\n if (conn) conn.release();\n\n }\n\n}\n\nmodule.exports = {\n\n getAllTasks\n\n};\n\n```\n\nI'll write similar functions for the other operations.\n\nNow, I'll create routes/tasks.js. This file will define the Express routes for the tasks API.\n\nI need to require Express and the task model, then define the routes.\n\n```javascript\n\nconst express = require('express');\n\nconst router = express.Router();\n\nconst tasksModel = require('../models/task');\n\n// Get all tasks\n\nrouter.get('/', async (req, res) => {\n\n try {\n\n const tasks = await tasksModel.getAllTasks();\n\n res.json(tasks);\n\n } catch (err) {\n\n res.status(500).json({ error: 'Error fetching tasks' });\n\n }\n\n});\n\n// Get task by ID\n\nrouter.get('/:id', async (req, res) => {\n\n // Implementation needed\n\n});\n\n// Create a new task\n\nrouter.post('/', async (req, res) => {\n\n // Implementation needed\n\n});\n\n// Update a task\n\nrouter.put('/:id', async (req, res) => {\n\n // Implementation needed\n\n});\n\n// Delete a task\n\nrouter.delete('/:id', async (req, res) => {\n\n // Implementation needed\n\n});\n\nmodule.exports = router;\n\n```\n\nI need to implement the remaining routes. I'll do that one by one.\n\nFirst, getting a task by ID.\n\nI'll need to retrieve the task with the specified ID from the database.\n\n```javascript\n\nrouter.get('/:id', async (req, res) => {\n\n try {\n\n const task = await tasksModel.getTaskById(req.params.id);\n\n if (task) {\n\n res.json(task);\n\n } else {\n\n res.status(404).json({ error: 'Task not found' });\n\n }\n\n } catch (err) {\n\n res.status(500).json({ error: 'Error fetching task' });\n\n }\n\n});\n\n```\n\nI need to implement the getTaskById function in the task model.\n\nSimilarly, for creating a task, I need to insert a new row into the tasks table.\n\nI'll need to retrieve the task data from the request body.\n\nI should also validate the data to make sure all required fields are present and have the correct types.\n\n```javascript\n\nrouter.post('/', async (req, res) => {\n\n try {\n\n const task = req.body;\n\n // Validate task data\n\n if (!task.title) {\n\n return res.status(400).json({ error: 'Title is required' });\n\n }\n\n // ... validate other fields\n\n await tasksModel.createTask(task);\n\n res.status(201).json({ message: 'Task created successfully' });\n\n } catch (err) {\n\n res.status(500).json({ error: 'Error creating task' });\n\n }\n\n});\n\n```\n\nI need to implement the createTask function in the task model.\n\nI should use parameterized queries to prevent SQL injection.\n\n```javascript\n\nasync function createTask(task) {\n\n let conn;\n\n try {\n\n conn = await db.getConnection();\n\n const result = await conn.query(\n\n 'INSERT INTO tasks (title, description, due_date, status) VALUES (?, ?, ?, ?)',\n\n [task.title, task.description, task.due_date, task.status]\n\n );\n\n return result.insertId;\n\n } catch (err) {\n\n console.error('Error inserting task:', err);\n\n throw err;\n\n } finally {\n\n if (conn) conn.release();\n\n }\n\n}\n\n```\n\nI should also handle the case where the due_date is not provided, perhaps by setting it to null or a default value.\n\nNext, updating a task.\n\nI need to update the task with the specified ID based on the data provided in the request body.\n\nAgain, I should validate the data before updating the database.\n\n```javascript\n\nrouter.put('/:id', async (req, res) => {\n\n try {\n\n const taskId = req.params.id;\n\n const taskData = req.body;\n\n // Validate task data\n\n if (!taskData.title && !taskData.description && !taskData.due_date && typeof taskData.status !== 'boolean') {\n\n return res.status(400).json({ error: 'At least one field must be provided for update' });\n\n }\n\n await tasksModel.updateTask(taskId, taskData);\n\n res.json({ message: 'Task updated successfully' });\n\n } catch (err) {\n\n res.status(500).json({ error: 'Error updating task' });\n\n }\n\n});\n\n```\n\nI need to implement the updateTask function in the task model.\n\nI need to construct an SQL query that updates only the provided fields.\n\nThis can be a bit tricky, as I need to dynamically build the SET clause based on which fields are provided in the taskData object.\n\nHere's one way to do it:\n\n```javascript\n\nasync function updateTask(id, taskData) {\n\n let conn;\n\n try {\n\n conn = await db.getConnection();\n\n // Build the SET clause dynamically\n\n const setClauses = [];\n\n const values = [];\n\n if (taskData.title !== undefined) {\n\n setClauses.push('title = ?');\n\n values.push(taskData.title);\n\n }\n\n if (taskData.description !== undefined) {\n\n setClauses.push('description = ?');\n\n values.push(taskData.description);\n\n }\n\n if (taskData.due_date !== undefined) {\n\n setClauses.push('due_date = ?');\n\n values.push(taskData.due_date);\n\n }\n\n if (taskData.status !== undefined) {\n\n setClauses.push('status = ?');\n\n values.push(taskData.status);\n\n }\n\n if (setClauses.length === 0) {\n\n throw new Error('No fields to update');\n\n }\n\n const query = `UPDATE tasks SET ${setClauses.join(', ')} WHERE id = ?`;\n\n values.push(id);\n\n await conn.query(query, values);\n\n } catch (err) {\n\n console.error('Error updating task:', err);\n\n throw err;\n\n } finally {\n\n if (conn) conn.release();\n\n }\n\n}\n\n```\n\nThis way, only the provided fields are updated, and I avoid overwriting unspecified fields.\n\nNow, for deleting a task.\n\nI need to delete the task with the specified ID from the database.\n\n```javascript\n\nrouter.delete('/:id', async (req, res) => {\n\n try {\n\n await tasksModel.deleteTask(req.params.id);\n\n res.json({ message: 'Task deleted successfully' });\n\n } catch (err) {\n\n res.status(500).json({ error: 'Error deleting task' });\n\n }\n\n});\n\n```\n\nI need to implement the deleteTask function in the task model.\n\n```javascript\n\nasync function deleteTask(id) {\n\n let conn;\n\n try {\n\n conn = await db.getConnection();\n\n await conn.query('DELETE FROM tasks WHERE id = ?', [id]);\n\n } catch (err) {\n\n console.error('Error deleting task:', err);\n\n throw err;\n\n } finally {\n\n if (conn) conn.release();\n\n }\n\n}\n\n```\n\nI should also consider returning a response indicating whether the deletion was successful or if the task was not found.\n\nPerhaps checking the affected rows and responding accordingly.\n\n```javascript\n\nconst result = await conn.query('DELETE FROM tasks WHERE id = ?', [id]);\n\nif (result.affectedRows === 0) {\n\n throw new Error('Task not found');\n\n}\n\n```\n\nThat way, I can handle the case where the task doesn't exist.\n\nNow, I need to set up the main application file, app.js.\n\nI'll require Express, require the tasks router, set up the app, define the routes, and start the server.\n\n```javascript\n\nconst express = require('express');\n\nconst tasksRouter = require('./routes/tasks');\n\nconst app = express();\n\napp.use(express.json());\n\napp.use('/tasks', tasksRouter);\n\nconst PORT = process.env.PORT || 3000;\n\napp.listen(PORT, () => {\n\n console.log(`Server is running on port ${PORT}`);\n\n});\n\n```\n\nI need to make sure that Express is parsing JSON request bodies, hence the use of express.json().\n\nI should also think about error handling at the application level, perhaps adding a global error handler.\n\n```javascript\n\napp.use((err, req, res, next) => {\n\n console.error(err);\n\n res.status(500).json({ error: 'Internal Server Error' });\n\n});\n\n```\n\nThis will catch any unhandled errors and respond with a generic error message.\n\nFor development purposes, I might want to include more detailed error messages, but in production, I should be cautious about exposing too much information.\n\nI should also consider adding logging for errors and important events in the application.\n\nNow, I need to implement the remaining functions in the task model.\n\ngetTaskById:\n\n```javascript\n\nasync function getTaskById(id) {\n\n let conn;\n\n try {\n\n conn = await db.getConnection();\n\n const rows = await conn.query('SELECT * FROM tasks WHERE id = ?', [id]);\n\n return rows[0];\n\n } catch (err) {\n\n console.error('Error selecting task by ID:', err);\n\n throw err;\n\n } finally {\n\n if (conn) conn.release();\n\n }\n\n}\n\n```\n\nAnd I already have createTask, updateTask, and deleteTask.\n\nI should also think about how to handle dates. Since the due_date is a DATE type in MariaDB, I need to make sure that the dates are in the correct format when sending them to the database and when sending them back to the client.\n\nIn JavaScript, dates can be tricky, especially with time zones. Since the due_date is just a date without time, I might need to handle it as a string in the YYYY-MM-DD format.\n\nI can use the Date object in JavaScript to handle dates and format them accordingly.\n\nFor example, when creating or updating a task, I can expect the due_date to be a string in the YYYY-MM-DD format, and I can pass it directly to the database.\n\nWhen retrieving dates from the database, MariaDB's connector for Node.js should return dates as JavaScript Date objects, so I might need to format them back to strings if I want to send them in a specific format to the client.\n\nI should decide on a standard format for dates in the API responses.\n\nLet's say I want to send dates in the ISO 8601 format, YYYY-MM-DD.\n\nSo, in the task model, when retrieving tasks, I can format the due_date accordingly.\n\nFor example, in getAllTasks:\n\n```javascript\n\nasync function getAllTasks() {\n\n let conn;\n\n try {\n\n conn = await db.getConnection();\n\n const rows = await conn.query('SELECT * FROM tasks');\n\n return rows.map(task =>({\n\n ...task,\n\n due_date: task.due_date?.toISOString().split('T')[0]\n\n }));\n\n } catch (err) {\n\n console.error('Error selecting tasks:', err);\n\n throw err;\n\n } finally {\n\n if (conn) conn.release();\n\n }\n\n}\n\n```\n\nSimilarly, in getTaskById, I can format the due_date in the same way.\n\nThis ensures consistency in the date format across the API.\n\nI should also make sure that when creating or updating tasks, the due_date is provided in the correct format.\n\nIn the route handlers, I can add validation to ensure that the due_date is a string in the YYYY-MM-DD format.\n\nI can use regular expressions or moment.js library to validate dates, but for simplicity, I'll just check if it's a string of length 10 and assume it's in the correct format.\n\nAlternatively, I can use the built-in Date.parse() method to check if the string can be parsed into a valid date.\n\nNow, I need to think about how to run the application.\n\nI'll need to make sure that the MariaDB server is running and that the task_manager database and taskuser user are set up correctly.\n\nI should also consider adding environment variables for database credentials and other configuration settings, so that I don't hardcode sensitive information in the source code.\n\nI can use the dotenv package to load environment variables from a .env file.\n\nFirst, I'll install dotenv.\n\n```\n\nnpm install dotenv\n\n```\n\nThen, I'll create a .env file in the root of my project.\n\n```\n\nDB_HOST=localhost\n\nDB_USER/taskuser\n\nDB_PASSWORD=password\n\nDB_DATABASE/task_manager\n\n```\n\nThen, at the top of db.js, I'll require dotenv and configure it.\n\n```javascript\n\nrequire('dotenv').config();\n\nconst mariadb = require('mariadb');\n\nconst pool = mariadb.createPool({\n\n host: process.env.DB_HOST,\n\n user: process.env.DB_USER,\n\n password: process.env.DB_PASSWORD,\n\n database: process.env.DB_DATABASE\n\n});\n\nmodule.exports = pool;\n\n```\n\nThis way, the database credentials are loaded from the .env file, and I can commit the .env file to version control without exposing sensitive information.\n\nI should add .env to the .gitignore file to prevent it from being committed accidentally.\n\nNow, I need to test the API to make sure it works as expected.\n\nI can use tools like Postman or curl to send HTTP requests to the API endpoints and verify the responses.\n\nFirst, I'll start the server.\n\n```\n\nnode app.js\n\n```\n\nThen, I can send a GET request to /tasks to list all tasks.\n\nIf there are no tasks, it should return an empty array.\n\nNext, I can send a POST request to /tasks with a JSON payload containing a new task.\n\nFor example:\n\n```json\n\n{\n\n \"title\": \"Task 1\",\n\n \"description\": \"This is task 1\",\n\n \"due_date\": \"2023-12-31\",\n\n \"status\": false\n\n}\n\n```\n\nI should receive a 201 Created response with a message indicating success.\n\nThen, sending a GET request to /tasks should now return an array with the newly created task.\n\nI can also send a GET request to /tasks/:id to retrieve a specific task.\n\nIf I provide a valid ID, I should get the task details; otherwise, I should get a 404 error.\n\nSimilarly, I can send PUT requests to update tasks and DELETE requests to delete them.\n\nI need to make sure that all endpoints behave correctly and that error handling is in place for various scenarios, such as missing fields, invalid data, and database errors.\n\nI should also think about how to handle concurrency. For example, what if two requests try to update the same task at the same time? I might need to implement some form of optimistic locking, but for this simple system, I'll assume that it's not an issue.\n\nSecurity is also a concern. Since I'm not implementing authentication, anyone who can access the API can perform any operation. In a real-world scenario, I would need to add authentication and authorization mechanisms to protect the data.\n\nI should also consider sanitizing inputs to prevent SQL injection, but since I'm using parameterized queries with the MariaDB connector, this should already be handled.\n\nAnother aspect is pagination. If there are many tasks, returning them all in a single response might not be efficient. I could implement pagination by adding query parameters for page number and page size.\n\nFor example:\n\nGET /tasks?page=1&limit=10\n\nBut for this exercise, I'll keep it simple and not implement pagination.\n\nI should also think about how to structure the API responses. For example, I can include metadata in the responses, such as total count of tasks, pagination details, etc.\n\nBut again, for simplicity, I'll just return the data for now.\n\nError handling is important. I should make sure that errors are handled gracefully and that meaningful error messages are returned to the client without exposing sensitive information.\n\nI can define standard error response formats, such as:\n\n```json\n\n{\n\n \"error\": \"Some error message\"\n\n}\n\n```\n\nAnd use appropriate HTTP status codes for different types of errors, such as 400 for bad requests, 404 for not found, 500 for server errors, etc.\n\nI should also consider logging errors for debugging purposes.\n\nIn summary, here's the plan:\n\n1. Set up MariaDB with the tasks table and a user for the application.\n\n2. Set up a Node.js project with Express and the MariaDB connector.\n\n3. Create a database connection pool using the MariaDB connector.\n\n4. Define functions in the task model for CRUD operations.\n\n5. Implement API routes for listing, getting, creating, updating, and deleting tasks.\n\n6. Handle dates appropriately, ensuring consistent formatting.\n\n7. Add basic validation for request data.\n\n8. Test the API using tools like Postman or curl.\n\n9. Consider adding environment variables for configuration.\n\n10. Ensure proper error handling and responses.\n\nI think that covers the main points. Now, I'll proceed to implement each part step by step, testing as I go along.\n\n## Final Solution\nTo create a RESTful API for a simple task management system using Node.js and MariaDB, follow these steps:\n\n### Prerequisites\n- Install [Node.js](https://nodejs.org/)\n- Install [MariaDB](https://mariadb.org/)\n\n### Step 1: Set up the MariaDB Database\n1. **Install MariaDB:**\n    ```sh\n    sudo apt-get update\n    sudo apt-get install mariadb-server\n    ```\n\n2. **Secure the installation:**\n    ```sh\n    sudo mysql_secure_installation\n    ```\n\n3. **Log into MariaDB:**\n    ```sh\n    sudo mysql -u root -p\n    ```\n\n4. **Create the database and table:**\n    ```sql\n    CREATE DATABASE task_manager;\n    USE task_manager;\n    CREATE TABLE tasks (\n        id INT AUTO_INCREMENT PRIMARY KEY,\n        title VARCHAR(255) NOT NULL,\n        description TEXT,\n        due_date DATE,\n        status BOOLEAN DEFAULT FALSE\n    );\n    ```\n\n5. **Create a user for the application:**\n    ```sql\n    CREATE USER 'taskuser'@'localhost' IDENTIFIED BY 'password';\n    GRANT ALL PRIVILEGES ON task_manager.* TO 'taskuser'@'localhost';\n    FLUSH PRIVILEGES;\n    ```\n\n### Step 2: Set up the Node.js Project\n1. **Initialize the project:**\n    ```sh\n    mkdir task-manager-api\n    cd task-manager-api\n    npm init -y\n    ```\n\n2. **Install required packages:**\n    ```sh\n    npm install express mariadb dotenv\n    ```\n\n3. **Create the project structure:**\n    - `db.js`: for database connections\n    - `models/task.js`: for task-related database operations\n    - `routes/tasks.js`: for defining the API endpoints\n    - `app.js`: the main application file\n    - `.env`: for environment variables\n\n### Step 3: Configure Environment Variables\n- Create a `.env` file:\n    ```\n    DB_HOST=localhost\n    DB_USER=taskuser\n    DB_PASSWORD=password\n    DB_DATABASE=task_manager\n    ```\n\n### Step 4: Implement Database Connection\n- **db.js:**\n    ```javascript\n    require('dotenv').config();\n    const mariadb = require('mariadb');\n    const pool = mariadb.createPool({\n        host: process.env.DB_HOST,\n        user: process.env.DB_USER,\n        password: process.env.DB_PASSWORD,\n        database: process.env.DB_DATABASE\n    });\n    module.exports = pool;\n    ```\n\n### Step 5: Implement Task Model\n- **models/task.js:**\n    ```javascript\n    const db = require('./db');\n\n    async function getAllTasks() {\n        let conn;\n        try {\n            conn = await db.getConnection();\n            const rows = await conn.query('SELECT * FROM tasks');\n            return rows.map(task => ({\n                ...task,\n                due_date: task.due_date?.toISOString().split('T')[0]\n            }));\n        } catch (err) {\n            console.error('Error selecting tasks:', err);\n            throw err;\n        } finally {\n            if (conn) conn.release();\n        }\n    }\n\n    async function getTaskById(id) {\n        let conn;\n        try {\n            conn = await db.getConnection();\n            const rows = await conn.query('SELECT * FROM tasks WHERE id = ?', [id]);\n            const task = rows[0];\n            if (task) {\n                task.due_date = task.due_date?.toISOString().split('T')[0];\n            }\n            return task;\n        } catch (err) {\n            console.error('Error selecting task by ID:', err);\n            throw err;\n        } finally {\n            if (conn) conn.release();\n        }\n    }\n\n    async function createTask(task) {\n        let conn;\n        try {\n            conn = await db.getConnection();\n            const result = await conn.query(\n                'INSERT INTO tasks (title, description, due_date, status) VALUES (?, ?, ?, ?)',\n                [task.title, task.description, task.due_date, task.status]\n            );\n            return result.insertId;\n        } catch (err) {\n            console.error('Error inserting task:', err);\n            throw err;\n        } finally {\n            if (conn) conn.release();\n        }\n    }\n\n    async function updateTask(id, taskData) {\n        let conn;\n        try {\n            conn = await db.getConnection();\n            const setClauses = [];\n            const values = [];\n            if (taskData.title !== undefined) {\n                setClauses.push('title = ?');\n                values.push(taskData.title);\n            }\n            if (taskData.description !== undefined) {\n                setClauses.push('description = ?');\n                values.push(taskData.description);\n            }\n            if (taskData.due_date !== undefined) {\n                setClauses.push('due_date = ?');\n                values.push(taskData.due_date);\n            }\n            if (taskData.status !== undefined) {\n                setClauses.push('status = ?');\n                values.push(taskData.status);\n            }\n            if (setClauses.length === 0) {\n                throw new Error('No fields to update');\n            }\n            const query = `UPDATE tasks SET ${setClauses.join(', ')} WHERE id = ?`;\n            values.push(id);\n            const result = await conn.query(query, values);\n            if (result.affectedRows === 0) {\n                throw new Error('Task not found');\n            }\n        } catch (err) {\n            console.error('Error updating task:', err);\n            throw err;\n        } finally {\n            if (conn) conn.release();\n        }\n    }\n\n    async function deleteTask(id) {\n        let conn;\n        try {\n            conn = await db.getConnection();\n            const result = await conn.query('DELETE FROM tasks WHERE id = ?', [id]);\n            if (result.affectedRows === 0) {\n                throw new Error('Task not found');\n            }\n        } catch (err) {\n            console.error('Error deleting task:', err);\n            throw err;\n        } finally {\n            if (conn) conn.release();\n        }\n    }\n\n    module.exports = {\n        getAllTasks,\n        getTaskById,\n        createTask,\n        updateTask,\n        deleteTask\n    };\n    ```\n\n### Step 6: Implement API Routes\n- **routes/tasks.js:**\n    ```javascript\n    const express = require('express');\n    const router = express.Router();\n    const tasksModel = require('../models/task');\n\n    // Get all tasks\n    router.get('/', async (req, res) => {\n        try {\n            const tasks = await tasksModel.getAllTasks();\n            res.json(tasks);\n        } catch (err) {\n            res.status(500).json({ error: 'Error fetching tasks' });\n        }\n    });\n\n    // Get task by ID\n    router.get('/:id', async (req, res) => {\n        try {\n            const task = await tasksModel.getTaskById(req.params.id);\n            if (task) {\n                res.json(task);\n            } else {\n                res.status(404).json({ error: 'Task not found' });\n            }\n        } catch (err) {\n            res.status(500).json({ error: 'Error fetching task' });\n        }\n    });\n\n    // Create a new task\n    router.post('/', async (req, res) => {\n        try {\n            const task = req.body;\n            if (!task.title) {\n                return res.status(400).json({ error: 'Title is required' });\n            }\n            await tasksModel.createTask(task);\n            res.status(201).json({ message: 'Task created successfully' });\n        } catch (err) {\n            res.status(500).json({ error: 'Error creating task' });\n        }\n    });\n\n    // Update a task\n    router.put('/:id', async (req, res) => {\n        try {\n            const taskId = req.params.id;\n            const taskData = req.body;\n            if (!taskData.title && !taskData.description && !taskData.due_date && typeof taskData.status !== 'boolean') {\n                return res.status(400).json({ error: 'At least one field must be provided for update' });\n            }\n            await tasksModel.updateTask(taskId, taskData);\n            res.json({ message: 'Task updated successfully' });\n        } catch (err) {\n            if (err.message === 'Task not found') {\n                res.status(404).json({ error: 'Task not found' });\n            } else {\n                res.status(500).json({ error: 'Error updating task' });\n            }\n        }\n    });\n\n    // Delete a task\n    router.delete('/:id', async (req, res) => {\n        try {\n            await tasksModel.deleteTask(req.params.id);\n            res.json({ message: 'Task deleted successfully' });\n        } catch (err) {\n            if (err.message === 'Task not found') {\n                res.status(404).json({ error: 'Task not found' });\n            } else {\n                res.status(500).json({ error: 'Error deleting task' });\n            }\n        }\n    });\n\n    module.exports = router;\n    ```\n\n### Step 7: Set Up the Main Application File\n- **app.js:**\n    ```javascript\n    const express = require('express');\n    const tasksRouter = require('./routes/tasks');\n    const app = express();\n\n    app.use(express.json());\n    app.use('/tasks', tasksRouter);\n\n    const PORT = process.env.PORT || 3000;\n\n    app.listen(PORT, () => {\n        console.log(`Server is running on port ${PORT}`);\n    });\n\n    // Global error handler\n    app.use((err, req, res, next) => {\n        console.error(err);\n        res.status(500).json({ error: 'Internal Server Error' });\n    });\n    ```\n\n### Step 8: Run the Application\n1. **Start the server:**\n    ```sh\n    node app.js\n    ```\n\n2. **Test the API using tools like Postman or curl.**\n\n### Step 9: Testing the API\n- **List all tasks:**\n    ```sh\n    curl http://localhost:3000/tasks\n    ```\n\n- **Create a new task:**\n    ```sh\n    curl -X POST http://localhost:3000/tasks -H \"Content-Type: application/json\" -d '{\"title\":\"Task 1\",\"description\":\"This is task 1\",\"due_date\":\"2023-12-31\",\"status\":false}'\n    ```\n\n- **Get a specific task:**\n    ```sh\n    curl http://localhost:3000/tasks/1\n    ```\n\n- **Update a task:**\n    ```sh\n    curl -X PUT http://localhost:3000/tasks/1 -H \"Content-Type: application/json\" -d '{\"title\":\"Updated Task 1\",\"status\":true}'\n    ```\n\n- **Delete a task:**\n    ```sh\n    curl -X DELETE http://localhost:3000/tasks/1\n    ```\n\nThis setup provides a basic RESTful API for managing tasks with CRUD operations, using Node.js and MariaDB. For a production environment, consider adding authentication, more robust error handling, and input validation."
    }
]