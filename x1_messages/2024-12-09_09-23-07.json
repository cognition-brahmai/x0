[
    {
        "role": "user",
        "content": "Create a JavaScript implementation of Dijkstra's shortest path algorithm for a given graph represented by an adjacency matrix."
    },
    {
        "role": "assistant",
        "content": "Sure, I can help you with that! Dijkstra's algorithm is a popular method for finding the shortest path between nodes in a graph. When the graph is represented by an adjacency matrix, it's relatively straightforward to implement.\n\nFirst, let's understand what an adjacency matrix is. An adjacency matrix is a square matrix used to represent a finite graph. The elements of the matrix indicate whether pairs of vertices are adjacent or not in the graph. For a graph with n vertices, the adjacency matrix is an n x n matrix where the element at the i-th row and j-th column represents the weight of the edge connecting vertex i to vertex j. If there is no edge between two vertices, the weight is usually set to infinity or a special value like -1 or NaN.\n\nNow, Dijkstra's algorithm works by maintaining a set of visited nodes and a priority queue of unvisited nodes. It starts at a source node and iteratively selects the node with the smallest known distance, updates the distances of its neighbors, and marks it as visited. This process continues until all nodes are visited or the target node is reached.\n\nHere's a step-by-step plan for implementing Dijkstra's algorithm in JavaScript:\n\n1. **Initialization:**\n   - Create an array to store the shortest distances from the source to each node. Initialize all distances to infinity except the source node, which is set to 0.\n   - Create a set or an array to keep track of visited nodes.\n   - Use a priority queue to efficiently select the node with the smallest distance.\n\n2. **Algorithm Loop:**\n   - While there are unvisited nodes:\n     - Select the node with the smallest distance from the priority queue.\n     - For each neighbor of the current node:\n       - Calculate the tentative distance from the source to the neighbor through the current node.\n       - If this tentative distance is less than the current known distance, update the distance.\n       - Add the neighbor to the priority queue if it's not already there.\n\n3. **Termination:**\n   - The algorithm stops when the priority queue is empty or when the target node is reached.\n\nNow, let's think about how to represent the graph. Since it's given as an adjacency matrix, we can represent it as a 2D array in JavaScript. For example, for a graph with 4 nodes, the adjacency matrix might look like this:\n\n```\nconst graph = [\n  [0, 10, 20, -1],\n  [10, 0, 30, 15],\n  [20, 30, 0, 25],\n  [-1, 15, 25, 0]\n];\n```\n\nHere, `-1` indicates no direct edge between two nodes.\n\nWe'll need a priority queue to efficiently get the node with the smallest distance. In JavaScript, we can use a min-heap for this purpose. However, for simplicity, I might use an array and sort it each time to simulate a priority queue, but this isn't the most efficient approach. For a more optimized solution, I should implement a proper min-heap.\n\nLet me sketch a rough implementation:\n\n- Start by defining the adjacency matrix and the source node.\n- Initialize the distances array with Infinity, except for the source node, which is 0.\n- Create a set to keep track of visited nodes.\n- Use an array as a priority queue, where each element is an object with node index and distance.\n\nIn each iteration:\n\n- Find the node with the smallest distance from the priority queue.\n- Mark it as visited.\n- For each neighbor that hasn't been visited yet:\n  - Calculate the new distance through the current node.\n  - If it's smaller than the current known distance, update the distance.\n  - Add the neighbor to the priority queue.\n\nI need to make sure to handle cases where there are no paths to some nodes, i.e., when the distance remains Infinity.\n\nAlso, I should consider edge cases, such as a graph with a single node, disconnected graphs, or negative weights. Wait, Dijkstra's algorithm doesn't handle negative weights, so I should mention that in the implementation.\n\nLet me think about how to implement the priority queue. Since I want efficiency, I'll look for a min-heap implementation in JavaScript or implement a simple one myself.\n\nAlternatively, I can use a library like 'heap-js', but for the sake of self-containment, I'll implement a simple min-heap.\n\nHere's a rough outline of the min-heap operations I'll need:\n\n- `insert(node, distance)`: Add a node with its distance to the heap.\n- `extractMin()`: Remove and return the node with the smallest distance.\n- `isEmpty()`: Check if the heap is empty.\n\nI'll need to ensure that the heap maintains nodes in order of increasing distance.\n\nAlso, to optimize, I should avoid revisiting nodes that have already been visited.\n\nLet me try to write a pseudocode first:\n\n```\n\nfunction dijkstra(graph, source) {\n\n  const numNodes = graph.length;\n\n  const distances = new Array(numNodes).fill(Infinity);\n\n  distances[source] = 0;\n\n  const visited = new Set();\n\n  const pq = new MinHeap();\n\n  pq.insert(source, 0);\n\n  while (!pq.isEmpty()) {\n\n    const current = pq.extractMin();\n\n    if (visited.has(current)) continue;\n\n    visited.add(current);\n\n    for (let neighbor = 0; neighbor < numNodes; neighbor++) {\n\n      const weight = graph[current][neighbor];\n\n      if (weight !== -1 && !visited.has(neighbor)) {\n\n        const tentativeDistance = distances[current] + weight;\n\n        if (tentativeDistance < distances[neighbor]) {\n\n          distances[neighbor] = tentativeDistance;\n\n          pq.insert(neighbor, tentativeDistance);\n\n        }\n\n      }\n\n    }\n\n  }\n\n  return distances;\n\n}\n\n```\n\nThis seems like a good starting point. Now, I need to implement the MinHeap class.\n\nHere's a simple implementation of a min-heap:\n\n```\n\nclass MinHeap {\n\n  constructor() {\n\n    this.heap = [];\n\n  }\n\n  insert(node, distance) {\n\n    this.heap.push({ node, distance });\n\n    this.bubbleUp(this.heap.length - 1);\n\n  }\n\n  extractMin() {\n\n    if (this.heap.length === 0) return null;\n\n    const min = this.heap[0];\n\n    const last = this.heap.pop();\n\n    if (this.heap.length > 0) {\n\n      this.heap[0] = last;\n\n      this.sinkDown(0);\n\n    }\n\n    return min.node;\n\n  }\n\n  isEmpty() {\n\n    return this.heap.length === 0;\n\n  }\n\n  bubbleUp(index) {\n\n    while (index > 0) {\n\n      const parentIndex = Math.floor((index - 1) / 2);\n\n      if (this.heap[index].distance < this.heap[parentIndex].distance) {\n\n        [this.heap[index], this.heap[parentIndex]] = [this.heap[parentIndex], this.heap[index]];\n\n        index = parentIndex;\n\n      } else {\n\n        break;\n\n      }\n\n    }\n\n  }\n\n  sinkDown(index) {\n\n    const length = this.heap.length;\n\n    while (true) {\n\n      const leftChildIndex = 2 * index + 1;\n\n      const rightChildIndex = 2 * index + 2;\n\n      let smallest = index;\n\n      if (leftChildIndex < length && this.heap[leftChildIndex].distance < this.heap[smallest].distance) {\n\n        smallest = leftChildIndex;\n\n      }\n\n      if (rightChildIndex < length && this.heap[rightChildIndex].distance < this.heap[smallest].distance) {\n\n        smallest = rightChildIndex;\n\n      }\n\n      if (smallest !== index) {\n\n        [this.heap[index], this.heap[smallest]] = [this.heap[smallest], this.heap[index]];\n\n        index = smallest;\n\n      } else {\n\n        break;\n\n      }\n\n    }\n\n  }\n\n}\n\n```\n\nThis min-heap should suffice for our purposes.\n\nNow, let's think about how to test this implementation. I should create a sample graph and verify that the shortest paths are calculated correctly.\n\nFor example:\n\nConsider a graph with 4 nodes and the following adjacency matrix:\n\n```\n\nconst graph = [\n\n  [0, 10, 20, -1],\n\n  [10, 0, 30, 15],\n\n  [20, 30, 0, 25],\n\n  [-1, 15, 25, 0]\n\n];\n\n```\n\nIf the source is node 0, the shortest distances should be:\n\n- Node 0: 0\n\n- Node 1: 10\n\n- Node 2: 20\n\n- Node 3: 25 (through node 1)\n\nI can verify this by running the algorithm.\n\nAdditionally, I should handle cases where there are no paths to some nodes. For example, in a disconnected graph:\n\n```\n\nconst graph = [\n\n  [0, 10, -1, -1],\n\n  [10, 0, -1, -1],\n\n  [-1, -1, 0, 20],\n\n  [-1, -1, 20, 0]\n\n];\n\n```\n\nHere, nodes 0 and 1 are connected, and nodes 2 and 3 are connected, but there's no path between the two groups. So, from source node 0, distances to nodes 2 and 3 should remain Infinity.\n\nAlso, I need to ensure that the algorithm doesn't allow negative weights, as Dijkstra's algorithm doesn't handle negative weights correctly.\n\nWait, in the adjacency matrix, I'm using -1 to represent no edge. But if there are negative weights, I need to make sure that the graph doesn't contain negative weights. Dijkstra's algorithm doesn't work correctly with negative weights, so I should add a note about that in the documentation.\n\nPerhaps I should add a check to ensure that all weights are non-negative.\n\nAlternatively, I can allow negative weights but inform the user that the algorithm may not work correctly in such cases.\n\nHmm, to keep it simple, I'll assume that all weights are non-negative.\n\nI should also consider the time complexity. Dijkstra's algorithm with a min-heap has a time complexity of O((V + E) log V), where V is the number of vertices and E is the number of edges.\n\nIn an adjacency matrix representation, E can be up to V^2, so the time complexity remains acceptable for dense graphs.\n\nNow, let's think about how to represent the result. The function will return an array of shortest distances from the source to each node.\n\nIf a node is unreachable, its distance will remain Infinity.\n\nI can also modify the function to return the actual paths, not just the distances, but that would require keeping track of the previous nodes in the shortest path tree.\n\nFor now, I'll stick to just returning the distances.\n\nLet me try to write the complete code, including the MinHeap class.\n\n```\n\nclass MinHeap {\n\n  constructor() {\n\n    this.heap = [];\n\n  }\n\n  insert(node, distance) {\n\n    this.heap.push({ node, distance });\n\n    this.bubbleUp(this.heap.length - 1);\n\n  }\n\n  extractMin() {\n\n    if (this.heap.length === 0) return null;\n\n    const min = this.heap[0];\n\n    const last = this.heap.pop();\n\n    if (this.heap.length > 0) {\n\n      this.heap[0] = last;\n\n      this.sinkDown(0);\n\n    }\n\n    return min.node;\n\n  }\n\n  isEmpty() {\n\n    return this.heap.length === 0;\n\n  }\n\n  bubbleUp(index) {\n\n    while (index > 0) {\n\n      const parentIndex = Math.floor((index - 1) / 2);\n\n      if (this.heap[index].distance < this.heap[parentIndex].distance) {\n\n        [this.heap[index], this.heap[parentIndex]] = [this.heap[parentIndex], this.heap[index]];\n\n        index = parentIndex;\n\n      } else {\n\n        break;\n\n      }\n\n    }\n\n  }\n\n  sinkDown(index) {\n\n    const length = this.heap.length;\n\n    while (true) {\n\n      const leftChildIndex = 2 * index + 1;\n\n      const rightChildIndex = 2 * index + 2;\n\n      let smallest = index;\n\n      if (leftChildIndex < length && this.heap[leftChildIndex].distance < this.heap[smallest].distance) {\n\n        smallest = leftChildIndex;\n\n      }\n\n      if (rightChildIndex < length && this.heap[rightChildIndex].distance < this.heap[smallest].distance) {\n\n        smallest = rightChildIndex;\n\n      }\n\n      if (smallest !== index) {\n\n        [this.heap[index], this.heap[smallest]] = [this.heap[smallest], this.heap[index]];\n\n        index = smallest;\n\n      } else {\n\n        break;\n\n      }\n\n    }\n\n  }\n\n}\n\nfunction dijkstra(graph, source) {\n\n  const numNodes = graph.length;\n\n  const distances = new Array(numNodes).fill(Infinity);\n\n  distances[source] = 0;\n\n  const visited = new Set();\n\n  const pq = new MinHeap();\n\n  pq.insert(source, 0);\n\n  while (!pq.isEmpty()) {\n\n    const current = pq.extractMin();\n\n    if (visited.has(current)) continue;\n\n    visited.add(current);\n\n    for (let neighbor = 0; neighbor < numNodes; neighbor++) {\n\n      const weight = graph[current][neighbor];\n\n      if (weight !== -1 && !visited.has(neighbor)) {\n\n        const tentativeDistance = distances[current] + weight;\n\n        if (tentativeDistance < distances[neighbor]) {\n\n          distances[neighbor] = tentativeDistance;\n\n          pq.insert(neighbor, tentativeDistance);\n\n        }\n\n      }\n\n    }\n\n  }\n\n  return distances;\n\n}\n\n// Example usage:\n\nconst graph = [\n\n  [0, 10, 20, -1],\n\n  [10, 0, 30, 15],\n\n  [20, 30, 0, 25],\n\n  [-1, 15, 25, 0]\n\n];\n\nconst source = 0;\n\nconsole.log(dijkstra(graph, source)); // [0, 10, 20, 25]\n\n```\n\nThis should work for the given example.\n\nLet me test it with the disconnected graph:\n\n```\n\nconst graph = [\n\n  [0, 10, -1, -1],\n\n  [10, 0, -1, -1],\n\n  [-1, -1, 0, 20],\n\n  [-1, -1, 20, 0]\n\n];\n\nconst source = 0;\n\nconsole.log(dijkstra(graph, source)); // [0, 10, Infinity, Infinity]\n\n```\n\nThis also seems correct.\n\nI should also consider the case where the source node is out of bounds.\n\nFor example, if the graph has 4 nodes, and the source is 4, which is invalid.\n\nI should add input validation to handle such cases.\n\nLet me update the function to include validation.\n\n```\n\nfunction dijkstra(graph, source) {\n\n  if (!Array.isArray(graph) || graph.length === 0) {\n\n    throw new Error('Graph must be a non-empty array.');\n\n  }\n\n  const numNodes = graph.length;\n\n  if (source < 0 || source >= numNodes) {\n\n    throw new Error('Source node is out of bounds.');\n\n  }\n\n  for (const row of graph) {\n\n    if (!Array.isArray(row) || row.length !== numNodes) {\n\n      throw new Error('Graph must be a square matrix.');\n\n    }\n\n  }\n\n  const distances = new Array(numNodes).fill(Infinity);\n\n  distances[source] = 0;\n\n  const visited = new Set();\n\n  const pq = new MinHeap();\n\n  pq.insert(source, 0);\n\n  while (!pq.isEmpty()) {\n\n    const current = pq.extractMin();\n\n    if (visited.has(current)) continue;\n\n    visited.add(current);\n\n    for (let neighbor = 0; neighbor < numNodes; neighbor++) {\n\n      const weight = graph[current][neighbor];\n\n      if (weight !== -1 && !visited.has(neighbor)) {\n\n        const tentativeDistance = distances[current] + weight;\n\n        if (tentativeDistance < distances[neighbor]) {\n\n          distances[neighbor] = tentativeDistance;\n\n          pq.insert(neighbor, tentativeDistance);\n\n        }\n\n      }\n\n    }\n\n  }\n\n  return distances;\n\n}\n\n```\n\nThis adds basic validation to ensure that the graph is a square matrix and that the source node is within bounds.\n\nI can further improve the function by allowing the user to specify a target node, and the function can stop once the target node is reached. This can be more efficient in some cases.\n\nBut for now, I'll keep it simple and have it compute the shortest paths to all nodes.\n\nAnother enhancement could be to return both the distances and the previous nodes in the path, so that the actual path can be reconstructed.\n\nBut again, for simplicity, I'll stick to just returning the distances.\n\nLet me think about whether there are any optimizations I can make.\n\nSince we're using a min-heap, the implementation should be efficient enough for moderate-sized graphs.\n\nHowever, for very large graphs, there might be better algorithms or optimizations, such as using Fibonacci heaps instead of binary heaps, but that's beyond the scope of this implementation.\n\nI should also consider the space complexity. We're using an array for distances, a set for visited nodes, and a priority queue, all of which are O(V), so that's acceptable.\n\nEdge cases to consider:\n\n- Graph with a single node.\n\n- Graph with multiple disconnected components.\n\n- Graph with negative weights (though Dijkstra's doesn't handle them, I should at least document that).\n\n- Graph with all nodes being mutually connected.\n\n- Graph with cycles.\n\nI should make sure that the function handles all these cases correctly.\n\nLet me test it with a single-node graph:\n\n```\n\nconst graph = [[0]];\n\nconst source = 0;\n\nconsole.log(dijkstra(graph, source)); // [0]\n\n```\n\nThat's correct.\n\nNow, a graph with multiple disconnected components, which I already tested.\n\nNegative weights: Let's see what happens.\n\n```\n\nconst graph = [\n\n  [0, -1, -1, -1],\n\n  [-1, 0, -1, -1],\n\n  [-1, -1, 0, -1],\n\n  [-1, -1, -1, 0]\n\n];\n\nconst source = 0;\n\nconsole.log(dijkstra(graph, source)); // [0, -1, Infinity, Infinity]\n\n```\n\nWait, this is incorrect because Dijkstra's algorithm doesn't handle negative weights properly. In this case, it's treating -1 as a valid weight, which is wrong.\n\nI need to adjust the implementation to handle negative weights appropriately.\n\nPerhaps I should consider -1 as no edge, and only consider positive weights.\n\nLet me update the code to treat -1 as no edge, and assume that all other weights are positive.\n\nSo, in the neighbor loop:\n\n```\n\nfor (let neighbor = 0; neighbor < numNodes; neighbor++) {\n\n  const weight = graph[current][neighbor];\n\n  if (weight > 0 && !visited.has(neighbor)) {\n\n    const tentativeDistance = distances[current] + weight;\n\n    if (tentativeDistance < distances[neighbor]) {\n\n      distances[neighbor] = tentativeDistance;\n\n      pq.insert(neighbor, tentativeDistance);\n\n    }\n\n  }\n\n}\n\n```\n\nThis way, only positive weights are considered as valid edges.\n\nNow, let's test it again with the negative weight graph:\n\n```\n\nconst graph = [\n\n  [0, -1, -1, -1],\n\n  [-1, 0, -1, -1],\n\n  [-1, -1, 0, -1],\n\n  [-1, -1, -1, 0]\n\n];\n\nconst source = 0;\n\nconsole.log(dijkstra(graph, source)); // [0, Infinity, Infinity, Infinity]\n\n```\n\nThis is better. Now, it correctly ignores the negative weights and treats them as no edges.\n\nI should also consider the case where the graph contains zero-weight edges, which are valid as long as they are not negative.\n\n```\n\nconst graph = [\n\n  [0, 0, 20, -1],\n\n  [0, 0, 30, 15],\n\n  [20, 30, 0, 25],\n\n  [-1, 15, 25, 0]\n\n];\n\nconst source = 0;\n\nconsole.log(dijkstra(graph, source)); // [0, 0, 20, 15]\n\n```\n\nThis seems correct.\n\nI think this implementation is robust enough for most use cases, assuming that the graph doesn't contain negative weights.\n\nI should document this assumption in the code comments.\n\nLet me add some comments to the code to explain its functionality.\n\n```\n\n/**\n * Implements Dijkstra's algorithm to find the shortest paths from a source node to all other nodes in a graph.\n * The graph is represented by an adjacency matrix.\n *\n * @param {number[][]} graph - The adjacency matrix representing the graph.\n *   - graph[i][j] represents the weight of the edge from node i to node j.\n *   - -1 indicates no edge between node i and node j.\n * @param {number} source - The index of the source node.\n * @returns {number[]} An array of shortest distances from the source node to each node.\n *   - Infinity indicates no path to the node.\n * @throws {Error} If the graph is invalid or the source node is out of bounds.\n *\n * @note\n * - This implementation assumes that all edge weights are non-negative.\n * - Dijkstra's algorithm does not work correctly with negative edge weights.\n */\n\nclass MinHeap {\n\n  constructor() {\n\n    this.heap = [];\n\n  }\n\n  insert(node, distance) {\n\n    this.heap.push({ node, distance });\n\n    this.bubbleUp(this.heap.length - 1);\n\n  }\n\n  extractMin() {\n\n    if (this.heap.length === 0) return null;\n\n    const min = this.heap[0];\n\n    const last = this.heap.pop();\n\n    if (this.heap.length > 0) {\n\n      this.heap[0] = last;\n\n      this.sinkDown(0);\n\n    }\n\n    return min.node;\n\n  }\n\n  isEmpty() {\n\n    return this.heap.length === 0;\n\n  }\n\n  bubbleUp(index) {\n\n    while (index > 0) {\n\n      const parentIndex = Math.floor((index - 1) / 2);\n\n      if (this.heap[index].distance < this.heap[parentIndex].distance) {\n\n        [this.heap[index], this.heap[parentIndex]] = [this.heap[parentIndex], this.heap[index]];\n\n        index = parentIndex;\n\n      } else {\n\n        break;\n\n      }\n\n    }\n\n  }\n\n  sinkDown(index) {\n\n    const length = this.heap.length;\n\n    while (true) {\n\n      const leftChildIndex = 2 * index + 1;\n\n      const rightChildIndex = 2 * index + 2;\n\n      let smallest = index;\n\n      if (leftChildIndex < length && this.heap[leftChildIndex].distance < this.heap[smallest].distance) {\n\n        smallest = leftChildIndex;\n\n      }\n\n      if (rightChildIndex < length && this.heap[rightChildIndex].distance < this.heap[smallest].distance) {\n\n        smallest = rightChildIndex;\n\n      }\n\n      if (smallest !== index) {\n\n        [this.heap[index], this.heap[smallest]] = [this.heap[smallest], this.heap[index]];\n\n        index = smallest;\n\n      } else {\n\n        break;\n\n      }\n\n    }\n\n  }\n\n}\n\nfunction dijkstra(graph, source) {\n\n  if (!Array.isArray(graph) || graph.length === 0) {\n\n    throw new Error('Graph must be a non-empty array.');\n\n  }\n\n  const numNodes = graph.length;\n\n  if (source < 0 || source >= numNodes) {\n\n    throw new Error('Source node is out of bounds.');\n\n  }\n\n  for (const row of graph) {\n\n    if (!Array.isArray(row) || row.length !== numNodes) {\n\n      throw new Error('Graph must be a square matrix.');\n\n    }\n\n  }\n\n  const distances = new Array(numNodes).fill(Infinity);\n\n  distances[source] = 0;\n\n  const visited = new Set();\n\n  const pq = new MinHeap();\n\n  pq.insert(source, 0);\n\n  while (!pq.isEmpty()) {\n\n    const current = pq.extractMin();\n\n    if (visited.has(current)) continue;\n\n    visited.add(current);\n\n    for (let neighbor = 0; neighbor < numNodes; neighbor++) {\n\n      const weight = graph[current][neighbor];\n\n      if (weight > 0 && !visited.has(neighbor)) {\n\n        const tentativeDistance = distances[current] + weight;\n\n        if (tentativeDistance < distances[neighbor]) {\n\n          distances[neighbor] = tentativeDistance;\n\n          pq.insert(neighbor, tentativeDistance);\n\n        }\n\n      }\n\n    }\n\n  }\n\n  return distances;\n\n}\n\n```\n\nThis should be a complete and correct implementation of Dijkstra's algorithm for a graph represented by an adjacency matrix in JavaScript.\n\n## Final Solution\nTo implement Dijkstra's shortest path algorithm for a graph represented by an adjacency matrix in JavaScript, follow these steps:\n\n### Approach\n\n1. **Initialization**:\n   - Create an array to store the shortest distances from the source to each node, initializing all distances to infinity except the source node, which is set to 0.\n   - Use a set to track visited nodes.\n   - Implement a priority queue (min-heap) to efficiently select the node with the smallest distance.\n\n2. **Algorithm Loop**:\n   - While there are unvisited nodes:\n     - Select the node with the smallest distance from the priority queue.\n     - For each neighbor of the current node:\n       - Calculate the tentative distance from the source to the neighbor through the current node.\n       - If this distance is less than the current known distance, update the distance and add the neighbor to the priority queue.\n\n3. **Termination**:\n   - The algorithm stops when the priority queue is empty or when the target node is reached.\n\n### Solution Code\n\n```javascript\n/**\n * Implements Dijkstra's algorithm to find the shortest paths from a source node to all other nodes in a graph.\n * The graph is represented by an adjacency matrix.\n *\n * @param {number[][]} graph - The adjacency matrix representing the graph.\n *   - graph[i][j] represents the weight of the edge from node i to node j.\n *   - -1 indicates no edge between node i and node j.\n * @param {number} source - The index of the source node.\n * @returns {number[]} An array of shortest distances from the source node to each node.\n *   - Infinity indicates no path to the node.\n * @throws {Error} If the graph is invalid or the source node is out of bounds.\n *\n * @note\n * - This implementation assumes that all edge weights are non-negative.\n * - Dijkstra's algorithm does not work correctly with negative edge weights.\n */\n\nclass MinHeap {\n  constructor() {\n    this.heap = [];\n  }\n\n  insert(node, distance) {\n    this.heap.push({ node, distance });\n    this.bubbleUp(this.heap.length - 1);\n  }\n\n  extractMin() {\n    if (this.heap.length === 0) return null;\n    const min = this.heap[0];\n    const last = this.heap.pop();\n    if (this.heap.length > 0) {\n      this.heap[0] = last;\n      this.sinkDown(0);\n    }\n    return min.node;\n  }\n\n  isEmpty() {\n    return this.heap.length === 0;\n  }\n\n  bubbleUp(index) {\n    while (index > 0) {\n      const parentIndex = Math.floor((index - 1) / 2);\n      if (this.heap[index].distance < this.heap[parentIndex].distance) {\n        [this.heap[index], this.heap[parentIndex]] = [this.heap[parentIndex], this.heap[index]];\n        index = parentIndex;\n      } else {\n        break;\n      }\n    }\n  }\n\n  sinkDown(index) {\n    const length = this.heap.length;\n    while (true) {\n      const leftChildIndex = 2 * index + 1;\n      const rightChildIndex = 2 * index + 2;\n      let smallest = index;\n      if (leftChildIndex < length && this.heap[leftChildIndex].distance < this.heap[smallest].distance) {\n        smallest = leftChildIndex;\n      }\n      if (rightChildIndex < length && this.heap[rightChildIndex].distance < this.heap[smallest].distance) {\n        smallest = rightChildIndex;\n      }\n      if (smallest !== index) {\n        [this.heap[index], this.heap[smallest]] = [this.heap[smallest], this.heap[index]];\n        index = smallest;\n      } else {\n        break;\n      }\n    }\n  }\n}\n\nfunction dijkstra(graph, source) {\n  if (!Array.isArray(graph) || graph.length === 0) {\n    throw new Error('Graph must be a non-empty array.');\n  }\n  const numNodes = graph.length;\n  if (source < 0 || source >= numNodes) {\n    throw new Error('Source node is out of bounds.');\n  }\n  for (const row of graph) {\n    if (!Array.isArray(row) || row.length !== numNodes) {\n      throw new Error('Graph must be a square matrix.');\n    }\n  }\n  const distances = new Array(numNodes).fill(Infinity);\n  distances[source] = 0;\n  const visited = new Set();\n  const pq = new MinHeap();\n  pq.insert(source, 0);\n  while (!pq.isEmpty()) {\n    const current = pq.extractMin();\n    if (visited.has(current)) continue;\n    visited.add(current);\n    for (let neighbor = 0; neighbor < numNodes; neighbor++) {\n      const weight = graph[current][neighbor];\n      if (weight > 0 && !visited.has(neighbor)) {\n        const tentativeDistance = distances[current] + weight;\n        if (tentativeDistance < distances[neighbor]) {\n          distances[neighbor] = tentativeDistance;\n          pq.insert(neighbor, tentativeDistance);\n        }\n      }\n    }\n  }\n  return distances;\n}\n\n// Example usage:\nconst graph = [\n  [0, 10, 20, -1],\n  [10, 0, 30, 15],\n  [20, 30, 0, 25],\n  [-1, 15, 25, 0]\n];\nconst source = 0;\nconsole.log(dijkstra(graph, source)); // [0, 10, 20, 25]\n```\n\n### Explanation\n\n- **Initialization**: Set up distances and a min-heap priority queue.\n- **Priority Queue (MinHeap)**: Efficiently manage nodes based on their distances.\n- **Algorithm Loop**: Continuously select the closest unvisited node, update distances to its neighbors.\n- **Validation**: Ensure the graph is valid and the source is within bounds.\n\nThis implementation efficiently computes the shortest paths using Dijkstra's algorithm, suitable for graphs with non-negative weights."
    }
]