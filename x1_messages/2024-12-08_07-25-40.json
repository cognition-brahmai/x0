[
    {
        "role": "user",
        "content": "Write a C++ program that implements a basic Huffman coding algorithm for compressing and decompressing text files.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Implementing a basic Huffman coding algorithm in C++ involves several steps, including building a frequency table, constructing the Huffman tree, generating codes, and then using these codes to compress and decompress the data. Below is a simple implementation of Huffman coding in C++.\n\n### Huffman Coding Program in C++\n\n```cpp\n#include <iostream>\n#include <queue>\n#include <unordered_map>\n#include <fstream>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nstruct Node {\n    char ch;\n    int freq;\n    Node* left;\n    Node* right;\n\n    Node(char ch, int freq) : ch(ch), freq(freq), left(nullptr), right(nullptr) {}\n};\n\nstruct Compare {\n    bool operator()(Node* l, Node* r) {\n        return l->freq > r->freq;\n    }\n};\n\nvoid frequencyTable(string text, unordered_map<char, int>& freq) {\n    for (char ch : text) {\n        freq[ch]++;\n    }\n}\n\nvoid buildHuffmanTree(priority_queue<Node*, vector<Node*>, Compare>& pq, unordered_map<char, int>& freq) {\n    for (auto pair : freq) {\n        pq.push(new Node(pair.first, pair.second));\n    }\n}\n\nstring encodeHuffmanTree(Node* root, string str, unordered_map<char, string>& huffmanCode) {\n    if (root == nullptr)\n        return \"\";\n\n    if (!root->left && !root->right) {\n        huffmanCode[root->ch] = str;\n    }\n\n    encodeHuffmanTree(root->left, str + \"0\", huffmanCode);\n    encodeHuffmanTree(root->right, str + \"1\", huffmanCode);\n\n    return \"\";\n}\n\nstring encodeText(string text, unordered_map<char, string>& huffmanCode) {\n    string encodedText = \"\";\n    for (char ch : text) {\n        encodedText += huffmanCode[ch];\n    }\n    return encodedText;\n}\n\nstring padEncodedText(string encodedText) {\n    int padding = 8 - (encodedText.length() % 8);\n    for (int i = 0; i < padding; i++) {\n        encodedText += \"0\";\n    }\n    return encodedText;\n}\n\nstring getPaddingInfo(int padding) {\n    string paddingInfo = bitset<8>(padding).to_string();\n    return paddingInfo;\n}\n\nvoid compress(string text, string outputFileName) {\n    unordered_map<char, int> freq;\n    frequencyTable(text, freq);\n\n    priority_queue<Node*, vector<Node*>, Compare> pq;\n    buildHuffmanTree(pq, freq);\n\n    while (pq.size() != 1) {\n        Node* left = pq.top();\n        pq.pop();\n        Node* right = pq.top();\n        pq.pop();\n        Node* temp = new Node('\\0', left->freq + right->freq);\n        temp->left = left;\n        temp->right = right;\n        pq.push(temp);\n    }\n\n    Node* root = pq.top();\n    unordered_map<char, string> huffmanCode;\n    encodeHuffmanTree(root, \"\", huffmanCode);\n\n    string encodedText = encodeText(text, huffmanCode);\n    int padding = 8 - (encodedText.length() % 8);\n    string paddedText = padEncodedText(encodedText);\n    string paddingInfo = getPaddingInfo(padding);\n\n    ofstream output(outputFileName, ios::binary);\n    if (!output) {\n        cerr << \"Error creating output file.\" << endl;\n        return;\n    }\n\n    // Write padding info\n    output.write(paddingInfo.c_str(), 1);\n\n    // Write frequency table\n    for (auto pair : freq) {\n        output << pair.first << \" \" << pair.second << \" \";\n    }\n    output << endl;\n\n    // Write padded text\n    bitset<8> bits;\n    for (size_t i = 0; i < paddedText.length(); i += 8) {\n        string byteStr = paddedText.substr(i, 8);\n        bits = bitset<8>(byteStr);\n        output.put(static_cast<char>(bits.to_ulong()));\n    }\n\n    output.close();\n}\n\nstring removePadding(string paddedText, int padding) {\n    string encodedText = paddedText.substr(0, paddedText.length() - padding);\n    return encodedText;\n}\n\nstring decodeHuffmanTree(Node* root, string encodedText, int& index) {\n    if (root == nullptr)\n        return \"\";\n\n    if (!root->left && !root->right) {\n        return string(1, root->ch);\n    }\n\n    index++;\n\n    if (encodedText[index] == '0')\n        return decodeHuffmanTree(root->left, encodedText, index);\n    else\n        return decodeHuffmanTree(root->right, encodedText, index);\n}\n\nstring decodeText(string encodedText, Node* root) {\n    string decodedText = \"\";\n    int index = -1;\n    while (index < (int)encodedText.length() - 1) {\n        decodedText += decodeHuffmanTree(root, encodedText, index);\n    }\n    return decodedText;\n}\n\nstring readBinaryFile(string inputFileName) {\n    ifstream input(inputFileName, ios::binary);\n    if (!input) {\n        cerr << \"Error opening input file.\" << endl;\n        return \"\";\n    }\n\n    string binaryData((istreambuf_iterator<char>(input)), istreambuf_iterator<char>());\n    input.close();\n    return binaryData;\n}\n\nstring readFrequencyTable(istream& input, unordered_map<char, int>& freq) {\n    string line;\n    getline(input, line);\n    stringstream ss(line);\n    char ch;\n    int freqVal;\n    while (ss >> ch >> freqVal) {\n        freq[ch] = freqVal;\n    }\n    return line;\n}\n\nstring readPaddedText(istream& input, int padding) {\n    string paddedText = \"\";\n    char c;\n    while (input.get(c)) {\n        bitset<8> bits(c);\n        string byteStr = bits.to_string();\n        paddedText += byteStr;\n    }\n    string encodedText = removePadding(paddedText, padding);\n    return encodedText;\n}\n\nvoid decompress(string inputFileName, string outputFileName) {\n    ifstream input(inputFileName, ios::binary);\n    if (!input) {\n        cerr << \"Error opening input file.\" << endl;\n        return;\n    }\n\n    string paddingInfo;\n    input.read(&paddingInfo[0], 1);\n    int padding = bitset<8>(paddingInfo).to_ulong();\n\n    unordered_map<char, int> freq;\n    readFrequencyTable(input, freq);\n\n    priority_queue<Node*, vector<Node*>, Compare> pq;\n    buildHuffmanTree(pq, freq);\n\n    while (pq.size() != 1) {\n        Node* left = pq.top();\n        pq.pop();\n        Node* right = pq.top();\n        pq.pop();\n        Node* temp = new Node('\\0', left->freq + right->freq);\n        temp->left = left;\n        temp->right = right;\n        pq.push(temp);\n    }\n\n    Node* root = pq.top();\n\n    string paddedText = readPaddedText(input, padding);\n    string encodedText = removePadding(paddedText, padding);\n    string decodedText = decodeText(encodedText, root);\n\n    ofstream output(outputFileName);\n    if (!output) {\n        cerr << \"Error creating output file.\" << endl;\n        return;\n    }\n\n    output << decodedText;\n    output.close();\n}\n\nint main() {\n    string inputText = \"Huffman coding is a data compression algorithm.\";\n    string compressedFile = \"compressed.bin\";\n    string decompressedFile = \"decompressed.txt\";\n\n    // Compress\n    compress(inputText, compressedFile);\n\n    // Decompress\n    decompress(compressedFile, decompressedFile);\n\n    return 0;\n}\n```\n\n### Explanation\n\n1. **Frequency Table**: Calculate the frequency of each character in the input text.\n2. **Huffman Tree**: Build a priority queue (min-heap) of nodes where each node represents a character and its frequency. Merge the two nodes with the lowest frequency into a new node until only one node remains (the root of the Huffman tree).\n3. **Huffman Codes**: Traverse the Huffman tree to generate binary codes for each character.\n4. **Encoding**: Replace each character in the input text with its corresponding Huffman code.\n5. **Padding**: Ensure the encoded text is a multiple of 8 bits for byte alignment.\n6. **Compress**: Write the padding information, frequency table, and padded text to the output file.\n7. **Decompress**: Read the padding information and frequency table from the compressed file, rebuild the Huffman tree, and decode the padded text back to the original text.\n\nThis basic implementation provides a foundation for understanding Huffman coding. For production use, consider optimizations and error handling."
    }
]