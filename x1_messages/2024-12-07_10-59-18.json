[
    {
        "role": "user",
        "content": "Write a Bash script that monitors the CPU usage of a given process ID (PID). If the CPU usage exceeds a certain threshold (say 50%), the script should send an email alert to a specified address. PLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Alright, I've got this task to create a Bash script that keeps an eye on the CPU usage of a specific process by its PID. If the CPU usage goes above 50%, it should send an email alert to a given address. Sounds straightforward, but I need to make sure I get all the parts right.\n\nFirst, I need to figure out how to get the CPU usage of a particular process in Bash. I know that the 'top' or 'ps' commands can give me process information, including CPU usage. Maybe 'ps' is easier to parse. Let me check the man page for 'ps'.\n\nLooking at 'ps', I see that 'ps -p PID -o %cpu' should give me the CPU usage percentage for that PID. For example, 'ps -p 1234 -o %cpu' would output the CPU usage of process 1234.\n\nBut I need to monitor it continuously, so I should probably put this in a loop that runs at regular intervals, say every minute. I can use a while loop with sleep to achieve that.\n\nNext, I need to compare the CPU usage to the threshold of 50%. If it's above 50%, I need to send an email. For sending emails from the command line, I can use the 'mail' command or 'mutt' if it's installed.\n\nAssuming 'mail' is available, I can use something like 'echo \"High CPU usage\" | mail -s \"Alert\" user@example.com' to send an email.\n\nBut I need to make sure that the email is only sent when the CPU usage goes above the threshold, and maybe not spam the user with emails if it stays above for multiple checks. Maybe include the current CPU usage in the email message.\n\nAlso, I should probably include some identification in the email, like the PID and the process name, so the user knows which process is causing the issue.\n\nTo get the process name, I can use 'ps -p PID -o comm+'. So, combining that with the CPU usage, I can gather all the necessary information.\n\nLet me think about the structure of the script:\n\n1. Take the PID and email address as input parameters.\n\n2. In a loop:\n\na. Get the CPU usage for the given PID.\n\nb. If CPU usage > 50%, construct an email message with PID, process name, and CPU usage, and send it to the specified email address.\n\nc. Wait for a certain interval before checking again.\n\nI should also handle cases where the process doesn't exist or if there are any errors in fetching the CPU usage.\n\nMaybe add some error checking, like verifying if the PID exists before proceeding.\n\nAlso, I need to make sure that the script can be run continuously, perhaps in the background.\n\nLet me consider using a shell script with bash.\n\nI'll start by writing a simple script to get the CPU usage and process name.\n\nSomething like:\n\nPID=$1\n\nEMAIL=$2\n\nTHRESHOLD=50\n\nwhile true; do\n\nCPU_USAGE=$(ps -p $PID -o %cpu --no-headers)\n\nPROCESS_NAME=$(ps -p $PID -o comm --no-headers)\n\nif [ $(echo \"$CPU_USAGE > $THRESHOLD\" | bc) -eq 1 ]; then\n\necho \"Alert: Process $PROCESS_NAME (PID $PID) is using $CPU_USAGE% CPU.\" | mail -s \"High CPU Usage Alert\" $EMAIL\n\nfi\n\nsleep 60\n\ndone\n\nThis seems basic. I need to test if 'ps' commands work as expected and if 'mail' is installed and configured properly.\n\nAlso, I should handle cases where 'ps' doesn't return any output, meaning the process might have exited.\n\nMaybe add some checks:\n\nif [ -z \"$CPU_USAGE\" ]; then\n\necho \"Process with PID $PID no longer exists.\"\n\nbreak\n\nfi\n\nThat way, if the process ends, the script stops monitoring.\n\nAdditionally, I can add some logging to keep track of when alerts are sent, maybe to a log file.\n\nLet's say I add a log file as a third parameter.\n\nThen, modify the script to log alert messages.\n\nPID=$1\n\nEMAIL=$2\n\nLOGFILE=$3\n\nTHRESHOLD=50\n\nwhile true; do\n\nCPU_USAGE=$(ps -p $PID -o %cpu --no-headers)\n\nPROCESS_NAME=$(ps -p $PID -o comm --no-headers)\n\nif [ -z \"$CPU_USAGE\" ]; then\n\necho \"$(date): Process with PID $PID no longer exists.\" >> $LOGFILE\n\nbreak\n\nfi\n\nif [ $(echo \"$CPU_USAGE > $THRESHOLD\" | bc) -eq 1 ]; then\n\nMESSAGE=\"Alert: Process $PROCESS_NAME (PID $PID) is using $CPU_USAGE% CPU.\"\n\necho \"$MESSAGE\" | mail -s \"High CPU Usage Alert\" $EMAIL\n\necho \"$(date): $MESSAGE\" >> $LOGFILE\n\nfi\n\nsleep 60\n\ndone\n\nThis way, I have a log of when alerts were sent.\n\nI should also make sure that the script doesn't send multiple alerts in quick succession if the CPU usage remains high.\n\nMaybe include a flag to send only one alert per alert state, until it goes below the threshold.\n\nTo do that, I can track the previous state and send an alert only when the state changes.\n\nLet me introduce a variable to track if an alert has already been sent.\n\nPID=$1\n\nEMAIL=$2\n\nLOGFILE=$3\n\nTHRESHOLD=50\n\nalert_sent=0\n\nwhile true; do\n\nCPU_USAGE=$(ps -p $PID -o %cpu --no-headers)\n\nPROCESS_NAME=$(ps -p $PID -o comm --no-headers)\n\nif [ -z \"$CPU_USAGE\" ]; then\n\necho \"$(date): Process with PID $PID no longer exists.\" >> $LOGFILE\n\nbreak\n\nfi\n\nif [ $(echo \"$CPU_USAGE > $THRESHOLD\" | bc) -eq 1 ]; then\n\nif [ $alert_sent -eq 0 ]; then\n\nMESSAGE=\"Alert: Process $PROCESS_NAME (PID $PID) is using $CPU_USAGE% CPU.\"\n\necho \"$MESSAGE\" | mail -s \"High CPU Usage Alert\" $EMAIL\n\necho \"$(date): $MESSAGE\" >> $LOGFILE\n\nalert_sent=1\n\nfi\n\nelse\n\nif [ $alert_sent -eq 1 ]; then\n\nMESSAGE=\"Alert cleared: Process $PROCESS_NAME (PID $PID) is now using $CPU_USAGE% CPU.\"\n\necho \"$MESSAGE\" | mail -s \"CPU Usage Back to Normal\" $EMAIL\n\necho \"$(date): $MESSAGE\" >> $LOGFILE\n\nalert_sent=0\n\nfi\n\nfi\n\nsleep 60\n\ndone\n\nThis way, alerts are sent only when the usage goes above or below the threshold, reducing spam.\n\nI should also consider making the sleep interval and threshold configurable via parameters.\n\nLet's make threshold and interval parameters as well.\n\nPID=$1\n\nEMAIL=$2\n\nLOGFILE=$3\n\nTHRESHOLD=$4\n\nINTERVAL=$5\n\nalert_sent=0\n\nwhile true; do\n\nCPU_USAGE=$(ps -p $PID -o %cpu --no-headers)\n\nPROCESS_NAME=$(ps -p $PID -o comm --no-headers)\n\nif [ -z \"$CPU_USAGE\" ]; then\n\necho \"$(date): Process with PID $PID no longer exists.\" >> $LOGFILE\n\nbreak\n\nfi\n\nif [ $(echo \"$CPU_USAGE > $THRESHOLD\" | bc) -eq 1 ]; then\n\nif [ $alert_sent -eq 0 ]; then\n\nMESSAGE=\"Alert: Process $PROCESS_NAME (PID $PID) is using $CPU_USAGE% CPU.\"\n\necho \"$MESSAGE\" | mail -s \"High CPU Usage Alert\" $EMAIL\n\necho \"$(date): $MESSAGE\" >> $LOGFILE\n\nalert_sent=1\n\nfi\n\nelse\n\nif [ $alert_sent -eq 1 ]; then\n\nMESSAGE=\"Alert cleared: Process $PROCESS_NAME (PID $PID) is now using $CPU_USAGE% CPU.\"\n\necho \"$MESSAGE\" | mail -s \"CPU Usage Back to Normal\" $EMAIL\n\necho \"$(date): $MESSAGE\" >> $LOGFILE\n\nalert_sent=0\n\nfi\n\nfi\n\nsleep $INTERVAL\n\ndone\n\nNow, the script is more flexible.\n\nI should add some checks to make sure all parameters are provided.\n\nAlso, ensure that 'bc' is installed since I'm using it for floating-point comparison.\n\nPerhaps add a check at the beginning of the script to verify that all required commands ('ps', 'mail', 'bc') are available.\n\nHere's an improved version with parameter checks and command existence checks.\n\n#!/bin/bash\n\nif [ $# -ne 5 ]; then\n\necho \"Usage: $0 PID EMAIL LOGFILE THRESHOLD INTERVAL\"\n\nexit 1\n\nfi\n\nPID=$1\n\nEMAIL=$2\n\nLOGFILE=$3\n\nTHRESHOLD=$4\n\nINTERVAL=$5\n\ncommands=(ps mail bc)\n\nfor cmd in \"${commands[@]}\"; do\n\nif ! command -v $cmd &> /dev/null; then\n\necho \"Error: $cmd is not installed.\"\n\nexit 1\n\nfi\n\ndone\n\nalert_sent=0\n\nwhile true; do\n\nCPU_USAGE=$(ps -p $PID -o %cpu --no-headers)\n\nPROCESS_NAME=$(ps -p $PID -o comm --no-headers)\n\nif [ -z \"$CPU_USAGE\" ]; then\n\necho \"$(date): Process with PID $PID no longer exists.\" >> $LOGFILE\n\nbreak\n\nfi\n\nif [ $(echo \"$CPU_USAGE > $THRESHOLD\" | bc) -eq 1 ]; then\n\nif [ $alert_sent -eq 0 ]; then\n\nMESSAGE=\"Alert: Process $PROCESS_NAME (PID $PID) is using $CPU_USAGE% CPU.\"\n\necho \"$MESSAGE\" | mail -s \"High CPU Usage Alert\" $EMAIL\n\necho \"$(date): $MESSAGE\" >> $LOGFILE\n\nalert_sent=1\n\nfi\n\nelse\n\nif [ $alert_sent -eq 1 ]; then\n\nMESSAGE=\"Alert cleared: Process $PROCESS_NAME (PID $PID) is now using $CPU_USAGE% CPU.\"\n\necho \"$MESSAGE\" | mail -s \"CPU Usage Back to Normal\" $EMAIL\n\necho \"$(date): $MESSAGE\" >> $LOGFILE\n\nalert_sent=0\n\nfi\n\nfi\n\nsleep $INTERVAL\n\ndone\n\nI think this covers the basic requirements.\n\nI should test this script with a sample PID and email address to make sure it works as expected.\n\nAlso, I need to make sure that the mail server is configured properly on the system where this script runs, so that emails can be sent out.\n\nAlternatively, I could use 'mutt' for sending emails, which might be more reliable in some environments.\n\nTo do that, I'd need to install 'mutt' and modify the script to use it instead of 'mail'.\n\nHere's how it might look with 'mutt':\n\nif [ $(echo \"$CPU_USAGE > $THRESHOLD\" | bc) -eq 1 ]; then\n\nif [ $alert_sent -eq 0 ]; then\n\nMESSAGE=\"Alert: Process $PROCESS_NAME (PID $PID) is using $CPU_USAGE% CPU.\"\n\necho \"$MESSAGE\" | mutt -s \"High CPU Usage Alert\" $EMAIL\n\necho \"$(date): $MESSAGE\" >> $LOGFILE\n\nalert_sent=1\n\nfi\n\nelse\n\nif [ $alert_sent -eq 1 ]; then\n\nMESSAGE=\"Alert cleared: Process $PROCESS_NAME (PID $PID) is now using $CPU_USAGE% CPU.\"\n\necho \"$MESSAGE\" | mutt -s \"CPU Usage Back to Normal\" $EMAIL\n\necho \"$(date): $MESSAGE\" >> $LOGFILE\n\nalert_sent=0\n\nfi\n\nfi\n\nI can make the mail command configurable as well, in case the system uses 'mailx' or another mail client.\n\nMaybe add a variable for the mail command and check which one is available.\n\nmail_cmd=\n\nif command -v mutt &> /dev/null; then\n\nmail_cmd=\"mutt\"\n\nelif command -v mail &> /dev/null; then\n\nmail_cmd=\"mail\"\n\nelse\n\necho \"Error: No mail sending command found. Install 'mutt' or 'mail'.\"\n\nexit 1\n\nfi\n\nThen, use $mail_cmd in the script.\n\necho \"$MESSAGE\" | $mail_cmd -s \"High CPU Usage Alert\" $EMAIL\n\nThis makes the script more adaptable to different environments.\n\nAlso, I should consider adding some error handling when sending emails, in case the mail server is down or configured incorrectly.\n\nMaybe redirect stderr to the log file or handle errors appropriately.\n\nAdditionally, I can make the script more efficient by using 'grep' to filter the 'ps' output, ensuring that only the correct PID is targeted.\n\nFor example:\n\nCPU_USAGE=$(ps -e -o pid,pcpu | grep $PID | awk '{print $2}')\n\nPROCESS_NAME=$(ps -p $PID -o comm --no-headers)\n\nThis way, I can ensure that only the desired process is being monitored.\n\nBut using 'ps -p PID' should be sufficient and more efficient.\n\nI should also consider that CPUUsageId might have decimal points, so the comparison should handle floating-point numbers properly.\n\n'bc' should handle that, but I need to make sure that the CPUUsageId is being captured correctly.\n\nLet me test the 'ps' command:\n\nps -p 1234 -o %cpu --no-headers\n\nAssuming 1234 is a valid PID, this should output something like \"0.5\" or \"2.3\".\n\nYes, it should work.\n\nAlso, I need to make sure that the log file has proper permissions so that the script can write to it.\n\nMaybe include a check to see if the log file is writable.\n\nif [ ! -w \"$LOGFILE\" ]; then\n\necho \"Error: Cannot write to log file $LOGFILE.\"\n\nexit 1\n\nfi\n\nAdding that would be beneficial.\n\nFurthermore, I can add a timestamp to each log entry for better tracking.\n\nI already have \"$(date):\" in the log messages, which is good.\n\nAnother thing to consider is that the script runs indefinitely until interrupted, so maybe add a way to stop it gracefully, like catching SIGINT or SIGTERM.\n\nBut for a simple monitoring script, it might be acceptable to just let it run in the background and kill it when needed.\n\nAlternatively, I can add a trap to handle interruptions.\n\ntrap exit SIGINT SIGTERM\n\nThis way, the script can exit cleanly when receives an interrupt signal.\n\nPutting it all together, here's the final script:\n\n#!/bin/bash\n\nif [ $# -ne 5 ]; then\n\necho \"Usage: $0 PID EMAIL LOGFILE THRESHOLD INTERVAL\"\n\nexit 1\n\nfi\n\nPID=$1\n\nEMAIL=$2\n\nLOGFILE=$3\n\nTHRESHOLD=$4\n\nINTERVAL=$5\n\ncommands=(ps bc)\n\nmail_cmd=\n\nif command -v mutt &> /dev/null; then\n\nmail_cmd=\"mutt\"\n\nelif command -v mail &> /dev/null; then\n\nmail_cmd=\"mail\"\n\nelse\n\necho \"Error: No mail sending command found. Install 'mutt' or 'mail'.\"\n\nexit 1\n\nfi\n\nfor cmd in \"${commands[@]}\"; do\n\nif ! command -v $cmd &> /dev/null; then\n\necho \"Error: $cmd is not installed.\"\n\nexit 1\n\nfi\n\ndone\n\nif [ ! -w \"$LOGFILE\" ]; then\n\necho \"Error: Cannot write to log file $LOGFILE.\"\n\nexit 1\n\nfi\n\nalert_sent=0\n\ntrap exit SIGINT SIGTERM\n\nwhile true; do\n\nCPU_USAGE=$(ps -p $PID -o %cpu --no-headers)\n\nPROCESS_NAME=$(ps -p $PID -o comm --no-headers)\n\nif [ -z \"$CPU_USAGE\" ]; then\n\necho \"$(date): Process with PID $PID no longer exists.\" >> $LOGFILE\n\nbreak\n\nfi\n\nif [ $(echo \"$CPU_USAGE > $THRESHOLD\" | bc) -eq 1 ]; then\n\nif [ $alert_sent -eq 0 ]; then\n\nMESSAGE=\"Alert: Process $PROCESS_NAME (PID $PID) is using $CPU_USAGE% CPU.\"\n\necho \"$MESSAGE\" | $mail_cmd -s \"High CPU Usage Alert\" $EMAIL\n\necho \"$(date): $MESSAGE\" >> $LOGFILE\n\nalert_sent=1\n\nfi\n\nelse\n\nif [ $alert_sent -eq 1 ]; then\n\nMESSAGE=\"Alert cleared: Process $PROCESS_NAME (PID $PID) is now using $CPUUsageId% CPU.\"\n\necho \"$MESSAGE\" | $mail_cmd -s \"CPU Usage Back to Normal\" $EMAIL\n\necho \"$(date): $MESSAGE\" >> $LOGFILE\n\nalert_sent=0\n\nfi\n\nfi\n\nsleep $INTERVAL\n\ndone\n\nI should test this script with a sample PID and email address to ensure it works correctly.\n\nAlso, I need to make sure that the mail configuration is set up properly on the system.\n\nThat should cover the requirements for monitoring CPU usage and sending email alerts when necessary.\n\n## Final Solution\nTo monitor the CPU usage of a specific process and send email alerts when it exceeds a certain threshold, you can use the following Bash script. This script continuously checks the CPU usage of the given Process ID (PID) and sends an email alert if the usage goes above the specified threshold.\n\n### Solution Code\n\n```bash\n#!/bin/bash\n\nif [ $# -ne 5 ]; then\n    echo \"Usage: $0 PID EMAIL LOGFILE THRESHOLD INTERVAL\"\n    exit 1\nfi\n\nPID=$1\nEMAIL=$2\nLOGFILE=$3\nTHRESHOLD=$4\nINTERVAL=$5\n\ncommands=(ps bc)\nmail_cmd=\n\nif command -v mutt &> /dev/null; then\n    mail_cmd=\"mutt\"\nelif command -v mail &> /dev/null; then\n    mail_cmd=\"mail\"\nelse\n    echo \"Error: No mail sending command found. Install 'mutt' or 'mail'.\"\n    exit 1\nfi\n\nfor cmd in \"${commands[@]}\"; do\n    if ! command -v $cmd &> /dev/null; then\n        echo \"Error: $cmd is not installed.\"\n        exit 1\n    fi\ndone\n\nif [ ! -w \"$LOGFILE\" ]; then\n    echo \"Error: Cannot write to log file $LOGFILE.\"\n    exit 1\nfi\n\nalert_sent=0\ntrap exit SIGINT SIGTERM\n\nwhile true; do\n    CPUUsageId=$(ps -p $PID -o %cpu --no-headers)\n    PROCESS_NAME=$(ps -p $PID -o comm --no-headers)\n\n    if [ -z \"$CPUUsageId\" ]; then\n        echo \"$(date): Process with PID $PID no longer exists.\" >> $LOGFILE\n        break\n    fi\n\n    if [ $(echo \"$CPUUsageId > $THRESHOLD\" | bc) -eq 1 ]; then\n        if [ $alert_sent -eq 0 ]; then\n            MESSAGE=\"Alert: Process $PROCESS_NAME (PID $PID) is using $CPUUsageId% CPU.\"\n            echo \"$MESSAGE\" | $mail_cmd -s \"High CPU Usage Alert\" $EMAIL\n            echo \"$(date): $MESSAGE\" >> $LOGFILE\n            alert_sent=1\n        fi\n    else\n        if [ $alert_sent -eq 1 ]; then\n            MESSAGE=\"Alert cleared: Process $PROCESS_NAME (PID $PID) is now using $CPUUsageId% CPU.\"\n            echo \"$MESSAGE\" | $mail_cmd -s \"CPU Usage Back to Normal\" $EMAIL\n            echo \"$(date): $MESSAGE\" >> $LOGFILE\n            alert_sent=0\n        fi\n    fi\n\n    sleep $INTERVAL\ndone\n```\n\n### Explanation\n\n1. **Parameters**:\n   - `PID`: The process ID to monitor.\n   - `EMAIL`: The email address to send alerts to.\n   - `LOGFILE`: The log file to record alert events.\n   - `THRESHOLD`: The CPU usage threshold (e.g., 50).\n   - `INTERVAL`: The time in seconds between checks (e.g., 60).\n\n2. **Dependencies**:\n   - `ps`: To get process information.\n   - `bc`: For floating-point comparison.\n   - `mail` or `mutt`: For sending emails.\n\n3. **Functionality**:\n   - Checks if the required commands are installed.\n   - Verifies that the log file is writable.\n   - Enters a loop to continuously monitor the process's CPU usage.\n   - Sends an email alert if the CPU usage exceeds the threshold and records the event in the log file.\n   - Sends a clearance email and logs the event when the CPU usage drops below the threshold.\n   - Exits the loop if the process no longer exists.\n\n4. **Error Handling**:\n   - Checks for the correct number of arguments.\n   - Ensures that necessary commands are installed.\n   - Verifies write permissions for the log file.\n   - Uses trap to handle interruptions gracefully.\n\nThis script provides a robust way to monitor process CPU usage and notify via email when usage exceeds predefined limits, helping in proactive system management."
    }
]