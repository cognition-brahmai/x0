[
    {
        "role": "user",
        "content": "Build a Java application that simulates a basic chat server using sockets. The server should be able to handle multiple clients concurrently and broadcast messages received from one client to all other connected clients.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Alright, I'm going to try to build a simple chat server using Java sockets. I've got some experience with Java, but I'm not an expert, so this might be a bit challenging. The goal is to create a server that can handle multiple clients at the same time and broadcast messages from one client to all others.\n\nFirst, I need to understand how sockets work in Java. Sockets are used for communication between two machines over the network. In this case, the server will listen for incoming connections from clients, accept those connections, and then manage communication with each client.\n\nSince the server needs to handle multiple clients concurrently, I'll probably need to use threading. Each client connection can be handled by a separate thread, allowing the server to manage multiple clients simultaneously.\n\nHere's a rough plan of how I think this should work:\n\n1. Create a ServerSocket that listens for incoming connections on a specific port.\n\n2. When a client connects, accept the connection and create a new thread to handle that client's communication.\n\n3. In each client handler thread, read messages from the client and broadcast those messages to all other connected clients.\n\n4. Make sure to handle disconnections gracefully, removing the client from the list of connected clients.\n\nI need to think about how to manage the list of connected clients. Maybe I can use a collection like a Vector or an ArrayList to store the client sockets or some representation of the clients.\n\nAlso, I need to ensure that the collection is thread-safe since multiple threads will be accessing it concurrently. Maybe using a synchronized list would be a good idea.\n\nLet me start by sketching out the basic structure of the server.\n\nFirst, the main class will create the ServerSocket and listen for connections.\n\nThen, for each connection, it will spawn a new thread, passing the client socket to it.\n\nEach client handler thread will read messages from its client and broadcast them to all other clients.\n\nI need to think about how to broadcast messages. Perhaps the client handler thread should notify the main server thread to broadcast the message, or maybe the client handler thread can broadcast directly.\n\nBroadcasting directly from the client handler thread might be simpler. It can iterate through the list of connected clients and send the message to each one.\n\nWait, but sending to each client individually might not be the most efficient way, especially if there are many clients. Maybe there's a better way to broadcast messages.\n\nAlternatively, I can have a separate broadcast thread that manages sending messages to all clients.\n\nBut that might be overkill for a simple chat server.\n\nLet me stick with having each client handler thread broadcast the message to all other clients.\n\nI need to make sure that the list of clients is thread-safe, so I should use synchronization when accessing it.\n\nAlso, I need to handle the case when a client disconnects. The client handler thread should remove the client from the list when the client disconnects.\n\nI should also send a message to all other clients indicating that this client has left the chat.\n\nSimilarly, when a new client connects, the server should broadcast a message to all existing clients that a new user has joined.\n\nI need to think about how to identify each client. Maybe each client can have a unique username or client ID.\n\nFor simplicity, I'll assume that when a client connects, it sends a username, and that will be used to identify the client in the chat.\n\nSo, the flow would be:\n\n- Client connects to the server.\n\n- Server requests the client to send its username.\n\n- Client sends the username.\n\n- Server adds the client to the list of connected clients and broadcasts a message to all other clients that the new user has joined.\n\n- The client can then send messages, which the server will broadcast to all other clients.\n\n- When the client disconnects, the server removes it from the list and broadcasts a message that the user has left.\n\nI need to think about how to handle the initial username exchange.\n\nMaybe I can have the client send the username immediately after connecting, and the server reads that first message as the username.\n\nAlternatively, the server can send a welcome message asking for the username, and the client responds with its username.\n\nI think it's simpler for the client to send the username right after connecting.\n\nSo, in the client handler thread, after accepting the connection, read the first message as the username.\n\nThen, welcome the user and inform other clients about the new user.\n\nNow, let's think about the messaging format.\n\nMessages should include the username and the text.\n\nPerhaps each message should start with the username followed by a colon, then the text.\n\nFor example: \"user1: Hello everyone!\"\n\nAlso, I need to handle special commands, like when a user wants to leave the chat.\n\nMaybe the client can send a specific message like \"/quit\" to disconnect.\n\nThe server should handle that by removing the client from the list and broadcasting that the user has left.\n\nI should also think about how to handle errors and exceptions.\n\nFor example, if a client sends invalid data or if there's a network error, the server should handle it gracefully without crashing.\n\nI need to make sure that each client handler thread is resilient to exceptions and can handle disconnections properly.\n\nLet me start by writing some pseudocode for the server.\n\nServer class:\n\n- Create a ServerSocket on a specified port.\n\n- Initialize a synchronized list to store connected clients.\n\n- In an infinite loop:\n\n- Accept incoming connections.\n\n- For each connection, get the Socket and create a new ClientHandler thread, passing the socket and the list of clients.\n\n- Start the ClientHandler thread.\n\nClientHandler class:\n\n- Constructor takes Socket and list of clients.\n\n- Initialize input and output streams.\n\n- Read the first message as the username.\n\n- Add the client to the list of clients.\n\n- Broadcast that the user has joined.\n\n- Enter a loop to read messages from the client.\n\n- For each message:\n\n- If the message is \"/quit\", remove the client from the list and broadcast that the user has left, then close the connection.\n\n- Otherwise, broadcast the message to all other clients.\n\n- Handle exceptions and ensure the client is removed from the list upon disconnection.\n\nNow, I need to think about how to implement the broadcasting.\n\nIn the ClientHandler thread, when a message needs to be broadcasted, it should iterate through the list of clients and send the message to each one except the sender.\n\nI need to make sure that the list is not modified while iterating through it, so I should synchronize access to the list.\n\nAlso, I need to handle the case where multiple threads are broadcasting messages at the same time.\n\nMaybe I should synchronize the broadcasting method to ensure that only one thread broadcasts at a time.\n\nWait, but that might not be necessary if each thread is broadcasting its own messages.\n\nI need to make sure that messages are sent correctly without getting mixed up.\n\nPerhaps each client handler thread should handle its own broadcasting without synchronization, as long as it synchronizes access to the list of clients when iterating through it.\n\nI should also consider buffering messages to avoid sending partial data.\n\nIn terms of I/O, using BufferedReader and PrintWriter might be convenient for reading and writing strings.\n\nLet me think about the client side.\n\nThe client needs to connect to the server using a Socket.\n\nIt should send the username immediately after connecting.\n\nThen, it can send messages to the server, which will broadcast them to other clients.\n\nThe client should also be able to receive messages from the server and display them.\n\nI need to decide on how the client will handle sending and receiving messages concurrently.\n\nPerhaps the client can have two threads: one for reading messages from the server and printing them to the console, and another for reading user input and sending it to the server.\n\nAlternatively, I can use non-blocking I/O, but that might be more complicated.\n\nFor simplicity, I'll use two threads in the client: one for reading from the server and one for reading from the user.\n\nNow, let's think about the client code.\n\nClient class:\n\n- Connect to the server using Socket.\n\n- Send the username to the server.\n\n- Create a Reader thread to read messages from the server and print them to the console.\n\n- Create a Writer thread to read user input from the console and send it to the server.\n\n- Wait for both threads to finish (though in practice, the client will run indefinitely until manually stopped).\n\nReader thread:\n\n- Read messages from the server using BufferedReader and print them to the console.\n\nWriter thread:\n\n- Read user input from the console using BufferedReader and send it to the server using PrintWriter.\n\nI need to think about how to handle the \"/quit\" command in the client.\n\nWhen the user types \"/quit\", the client should send the message to the server and then disconnect.\n\nI need to make sure that both threads handle the disconnection properly.\n\nPerhaps when the writer thread sends the \"/quit\" message, it can close the output stream, which will cause the reader thread to exit when it detects that the connection is closed.\n\nI need to handle exceptions in both threads to manage disconnections gracefully.\n\nNow, let's think about implementing the server and client classes.\n\nI need to decide on the port number for the server.\n\nI'll choose a port number above 1024 to avoid requiring administrative privileges.\n\nLet's say port 12345.\n\nI need to make sure that the server can handle multiple clients connecting and disconnecting concurrently.\n\nI should also think about limiting the number of connections to prevent overload, but for simplicity, I'll omit that for now.\n\nAnother consideration is handling large numbers of clients.\n\nWith one thread per client, there could be performance issues with a very large number of clients.\n\nBut for a basic implementation, I'll proceed with one thread per client.\n\nI should also think about how to handle messages that are too large.\n\nPerhaps I can set a maximum message size to prevent buffering issues.\n\nBut for now, I'll assume that messages are reasonable in size.\n\nI need to make sure that the server can handle messages of varying sizes without blocking or buffering issues.\n\nUsing BufferedReader with a appropriate buffer size should help with that.\n\nSimilarly, on the client side, using BufferedReader to read from the server should handle different message sizes.\n\nI need to ensure that messages are terminated with newlines so that BufferedReader's readLine() method works correctly.\n\nSo, both the server and client should use println() to send messages and readLine() to receive them.\n\nThis way, messages are delimited by newlines and can be read reliably.\n\nNow, let's start writing some actual code.\n\nFirst, the server class.\n\nI'll call it ChatServer.\n\nIt will have a main method that creates a ServerSocket and listens for connections.\n\nFor each connection, it will create a new ClientHandler thread.\n\nThe ClientHandler class will handle communication with one client.\n\nIt will read the username, add the client to the list, broadcast the arrival message, and then handle incoming messages.\n\nWhen a message is received, it will broadcast it to all other clients.\n\nIf the message is \"/quit\", it will remove the client from the list and broadcast the departure message.\n\nNow, I need to think about the data structures.\n\nI'll use a synchronized list to store the client's username and their PrintWriter for sending messages.\n\nWhy PrintWriter? Because it allows easy writing of strings over the network.\n\nSo, perhaps a list of pairs: username and PrintWriter.\n\nIn Java, I can use a List of Map.Entry or create a simple class to hold these.\n\nAlternatively, I can use a ConcurrentHashMap to store username to PrintWriter mappings.\n\nThat might be a good approach, as it's thread-safe and allows easy addition and removal of clients.\n\nSo, I'll use a ConcurrentHashMap<String, PrintWriter> where the key is the username and the value is the PrintWriter for that client.\n\nIn the ClientHandler thread, after reading the username, it will add the username and PrintWriter to the map.\n\nWhen broadcasting a message, it will iterate through the map and send the message to each PrintWriter except the sender's.\n\nI need to make sure that when a client disconnects, its entry is removed from the map.\n\nAlso, when adding a new client, check that the username is not already in use.\n\nIf the username is already taken, perhaps reject the connection or ask the client to choose another username.\n\nBut for simplicity, I'll assume that usernames are unique and handle collisions by rejecting the connection.\n\nNow, let's think about the broadcasting method.\n\nI can create a method in the server class that takes the sender's username and the message, and sends the message to all other clients.\n\nSince ConcurrentHashMap is thread-safe, I can iterate through the entries safely in multiple threads.\n\nBut to be safe, I'll iterate through a copy of the key set to prevent ConcurrentModificationException.\n\nWait, no, iterating through the key set of a ConcurrentHashMap should be safe.\n\nBut to be on the safe side, I can iterate through a copy of the key set.\n\nAlternatively, I can use the foreach loop on the entrySet().\n\nI need to test that.\n\nIn any case, I need to ensure that the iterator doesn't fail when another thread adds or removes an entry.\n\nI think that with ConcurrentHashMap, it should be safe.\n\nNow, let's think about the client side.\n\nThe client needs to connect to the server, send the username, and then start two threads: one for reading messages from the server and one for reading user input and sending it to the server.\n\nIn the reader thread, it will read messages from the server using BufferedReader and print them to the console.\n\nIn the writer thread, it will read user input from System.in using BufferedReader and send it to the server using PrintWriter.\n\nWhen the user types \"/quit\", the writer thread will send the message to the server and then close the connection.\n\nThe reader thread should handle the closed connection gracefully and exit.\n\nI need to make sure that both threads handle exceptions properly and exit when the connection is closed.\n\nI should also think about what happens if the user interrupts the client (e.g., presses Ctrl+C).\n\nI need to handle InterruptedExceptions and close resources properly.\n\nNow, let's start writing some code.\n\nFirst, the server.\n\nI'll create a class called ChatServer.\n\nIt will have a main method that creates a ServerSocket on port 12345.\n\nIt will have a ConcurrentHashMap to store username to PrintWriter mappings.\n\nIn the main method, it will listen for incoming connections and spawn a new ClientHandler thread for each connection.\n\nThe ClientHandler class will extend Thread.\n\nIn the constructor, it will take the Socket and the ConcurrentHashMap.\n\nIn the run method, it will:\n\n- Get the input and output streams.\n\n- Read the first message as the username.\n\n- Check if the username is already in use.\n\n- If not, add it to the map and broadcast the arrival message.\n\n- Then, enter a loop to read messages from the client.\n\n- For each message:\n\n- If it's \"/quit\", remove the client from the map and broadcast the departure message, then close the connection.\n\n- Otherwise, broadcast the message to all other clients.\n\n- Handle exceptions and ensure the client is removed from the map upon disconnection.\n\nNow, for the client side.\n\nI'll create a class called ChatClient.\n\nIt will have a main method that takes the server host and port as arguments.\n\nIt will connect to the server using Socket.\n\nIt will ask the user for their username.\n\nThen, it will create two threads:\n\n- Reader thread: reads messages from the server and prints them to the console.\n\n- Writer thread: reads user input from the console and sends it to the server.\n\nBoth threads will run in infinite loops, reading and writing messages.\n\nWhen the user types \"/quit\", the writer thread will send the message and then close the connection.\n\nThe reader thread should handle the closed connection and exit.\n\nI need to make sure that both threads handle IOExceptions gracefully.\n\nNow, let's think about error handling.\n\nIn the server, if a client sends an invalid username or sends malformed messages, the server should handle it without crashing.\n\nPerhaps log an error message and close the connection.\n\nIn the client, if there are network errors or the server closes the connection, the client should handle it and exit gracefully.\n\nI should also think about what happens if multiple clients try to connect with the same username.\n\nThe server should reject connections with usernames that are already in use.\n\nSimilarly, if a client tries to send a message that is too large or contains invalid characters, the server should handle it appropriately.\n\nFor now, I'll assume that clients behave correctly and handle only basic error cases.\n\nI need to test the application to make sure it works as expected.\n\nI'll need to run the server in one console window and multiple client instances in other windows.\n\nEach client should be able to send messages that are broadcast to all other clients.\n\nAlso, when a client connects or disconnects, the server should broadcast messages indicating those events.\n\nI should also think about how to display messages in the chat.\n\nPerhaps prefix each message with the username and the message text, like \"username: message\".\n\nAlso, for join and leave messages, use a different format, like \"* username has joined\" and \"* username has left\".\n\nThis will make it clear who has joined or left the chat.\n\nNow, let's think about implementing the broadcasting method.\n\nIn the server, I'll create a method called broadcastMessage that takes the sender's username and the message.\n\nIt will iterate through the map entries and send the message to each client's PrintWriter, except for the sender.\n\nI need to make sure that if a client disconnects while broadcasting, it doesn't cause an exception.\n\nPerhaps wrap each send operation in a try-catch block.\n\nAlso, I need to think about performance.\n\nIf there are many clients, broadcasting to all of them could take some time.\n\nBut for a basic implementation, I'll proceed without optimizing for performance.\n\nNow, let's think about the client threads.\n\nIn the reader thread, I'll read messages from the server using BufferedReader and print them to the console.\n\nIn the writer thread, I'll read user input from System.in using BufferedReader and send it to the server using PrintWriter.\n\nI need to make sure that the writer thread sends messages with newline termination so that the server's readLine() method works correctly.\n\nAlso, I need to flush the PrintWriter after each message to ensure that the message is sent immediately.\n\nNow, I need to think about how to handle the \"/quit\" command.\n\nWhen the user types \"/quit\", the writer thread should send the message to the server and then close the socket.\n\nThis should cause the reader thread to detect that the connection is closed and exit.\n\nI need to make sure that both threads handle the closure of the socket correctly.\n\nI should also think about what happens if the server closes the connection unexpectedly.\n\nThe reader thread should handle IOExceptions and exit gracefully.\n\nSimilarly, the writer thread should check if the socket is closed before writing to it.\n\nNow, let's start writing some code.\n\nFirst, the server.\n\nChatServer.java:\n\nimport java.io.*;\n\nimport java.net.*;\n\nimport java.util.concurrent.*;\n\npublic class ChatServer {\n\nprivate static final int PORT = 12345;\n\nprivate static ConcurrentHashMap<String, PrintWriter> clients = new ConcurrentHashMap<>();\n\npublic static void main(String[] args) throws IOException {\n\nServerSocket serverSocket = new ServerSocket(PORT);\n\nSystem.out.println(\"Chat server started on port \" + PORT);\n\nwhile (true) {\n\nSocket clientSocket = serverSocket.accept();\n\nnew ClientHandler(clientSocket).start();\n\n}\n\n}\n\nprivate static class ClientHandler extends Thread {\n\nprivate Socket socket;\n\nprivate String username;\n\nprivate PrintWriter out;\n\npublic ClientHandler(Socket socket) {\n\nthis.socket = socket;\n\n}\n\npublic void run() {\n\ntry {\n\nInputStreamReader inputStreamReader = new InputStreamReader(socket.getInputStream());\n\nBufferedReader in = new BufferedReader(inputStreamReader);\n\nOutputStreamWriter outputStreamWriter = new OutputStreamWriter(socket.getOutputStream());\n\nout = new PrintWriter(outputStreamWriter, true);\n\n// Read username\n\nusername = in.readLine();\n\nif (username == null || username.isEmpty() || clients.containsKey(username)) {\n\nout.println(\"Username is invalid or already in use. Disconnecting.\");\n\nreturn;\n\n}\n\nclients.put(username, out);\n\nbroadcastMessage(null, \"* \" + username + \" has joined the chat.\");\n\nString message;\n\nwhile ((message = in.readLine()) != null) {\n\nif (message.equalsIgnoreCase(\"/quit\")) {\n\nclients.remove(username);\n\nbroadcastMessage(null, \"* \" + username + \" has left the chat.\");\n\nbreak;\n\n} else {\n\nbroadcastMessage(username, message);\n\n}\n\n}\n\n} catch (IOException e) {\n\nSystem.err.println(\"Error handling client: \" + e.getMessage());\n\n} finally {\n\ntry {\n\nsocket.close();\n\n} catch (IOException e) {\n\nSystem.err.println(\"Error closing socket: \" + e.getMessage());\n\n}\n\n}\n\n}\n\nprivate void broadcastMessage(String from, String message) {\n\nfor (Map.Entry<String, PrintWriter> entry : clients.entrySet()) {\n\nif (from == null || !entry.getKey().equals(from)) {\n\nentry.getValue().println((from != null ? from + \": \" : \"\") + message);\n\n}\n\n}\n\n}\n\n}\n\n}\n\nNow, the client.\n\nChatClient.java:\n\nimport java.io.*;\n\nimport java.net.*;\n\npublic class ChatClient {\n\npublic static void main(String[] args) throws IOException {\n\nif (args.length != 2) {\n\nSystem.out.println(\"Usage: java ChatClient <host> <port>\");\n\nreturn;\n\n}\n\nString host = args[0];\n\nint port = Integer.parseInt(args[1]);\n\nSocket socket = new Socket(host, port);\n\nInputStreamReader inputStreamReader = new InputStreamReader(socket.getInputStream());\n\nBufferedReader fromServer = new BufferedReader(inputStreamReader);\n\nOutputStreamWriter outputStreamWriter = new OutputStreamWriter(socket.getOutputStream());\n\nPrintWriter toServer = new PrintWriter(outputStreamWriter, true);\n\n// Read username from user\n\nSystem.out.print(\"Enter your username: \");\n\nBufferedReader userInput = new BufferedReader(new InputStreamReader(System.in));\n\nString username = userInput.readLine();\n\ntoServer.println(username);\n\n// Start reader thread\n\nThread readerThread = new Thread(() -> {\n\nString message;\n\ntry {\n\nwhile ((message = fromServer.readLine()) != null) {\n\nSystem.out.println(message);\n\n}\n\n} catch (IOException e) {\n\nSystem.err.println(\"Error reading from server: \" + e.getMessage());\n\n} finally {\n\ntry {\n\nsocket.close();\n\n} catch (IOException e) {\n\nSystem.err.println(\"Error closing socket: \" + e.getMessage());\n\n}\n\n}\n\n});\n\nreaderThread.start();\n\n// Start writer thread\n\nThread writerThread = new Thread(() -> {\n\nString message;\n\ntry {\n\nwhile ((message = userInput.readLine()) != null) {\n\ntoServer.println(message);\n\nif (message.equalsIgnoreCase(\"/quit\")) {\n\nbreak;\n\n}\n\n}\n\n} catch (IOException e) {\n\nSystem.err.println(\"Error writing to server: \" + e.getMessage());\n\n} finally {\n\ntry {\n\nsocket.close();\n\n} catch (IOException e) {\n\nSystem.err.println(\"Error closing socket: \" + e.getMessage());\n\n}\n\n}\n\n});\n\nwriterThread.start();\n\ntry {\n\nreaderThread.join();\n\nwriterThread.join();\n\n} catch (InterruptedException e) {\n\nSystem.err.println(\"Thread interrupted: \" + e.getMessage());\n\n}\n\n}\n\n}\n\n}\n\nThis should be a basic implementation of a chat server and client using Java sockets.\n\nI need to test this code to make sure it works as expected.\n\nI'll run the ChatServer on my machine, then open multiple terminal windows and run ChatClient, connecting to the server's host and port.\n\nEach client should be able to send messages that are broadcast to all other clients.\n\nAlso, when a client connects or disconnects, the server should broadcast join and leave messages.\n\nI should also test edge cases, like multiple clients connecting with the same username, sending invalid messages, and abrupt disconnections.\n\nOverall, this should be a good starting point for a basic chat server using Java sockets.\n\n## Final Solution\nTo create a basic chat server using Java sockets that can handle multiple clients concurrently and broadcast messages among them, follow these steps:\n\n### Approach\n\n1. **Server Setup**:\n   - Use a `ServerSocket` to listen for incoming client connections.\n   - Maintain a list of connected clients using their usernames and output streams.\n   - Handle each client in a separate thread to manage concurrency.\n\n2. **Client Handling**:\n   - Read the username from the client upon connection.\n   - Broadcast join and leave messages to all clients.\n   - Broadcast messages from one client to all others.\n\n3. **Client Setup**:\n   - Connect to the server using a `Socket`.\n   - Send username and messages to the server.\n   - Receive and display messages from the server.\n\n### Solution Code\n\n#### Server Code: `ChatServer.java`\n\n```java\nimport java.io.*;\nimport java.net.*;\nimport java.util.concurrent.*;\n\npublic class ChatServer {\n\n    private static final int PORT = 12345;\n    private static ConcurrentHashMap<String, PrintWriter> clients = new ConcurrentHashMap<>();\n\n    public static void main(String[] args) throws IOException {\n        ServerSocket serverSocket = new ServerSocket(PORT);\n        System.out.println(\"Chat server started on port \" + PORT);\n        while (true) {\n            Socket clientSocket = serverSocket.accept();\n            new ClientHandler(clientSocket).start();\n        }\n    }\n\n    private static class ClientHandler extends Thread {\n        private Socket socket;\n        private String username;\n        private PrintWriter out;\n\n        public ClientHandler(Socket socket) {\n            this.socket = socket;\n        }\n\n        public void run() {\n            try {\n                InputStreamReader inputStreamReader = new InputStreamReader(socket.getInputStream());\n                BufferedReader in = new BufferedReader(inputStreamReader);\n                OutputStreamWriter outputStreamWriter = new OutputStreamWriter(socket.getOutputStream());\n                out = new PrintWriter(outputStreamWriter, true);\n                // Read username\n                username = in.readLine();\n                if (username == null || username.isEmpty() || clients.containsKey(username)) {\n                    out.println(\"Username is invalid or already in use. Disconnecting.\");\n                    return;\n                }\n                clients.put(username, out);\n                broadcastMessage(null, \"* \" + username + \" has joined the chat.\");\n                String message;\n                while ((message = in.readLine()) != null) {\n                    if (message.equalsIgnoreCase(\"/quit\")) {\n                        clients.remove(username);\n                        broadcastMessage(null, \"* \" + username + \" has left the chat.\");\n                        break;\n                    } else {\n                        broadcastMessage(username, message);\n                    }\n                }\n            } catch (IOException e) {\n                System.err.println(\"Error handling client: \" + e.getMessage());\n            } finally {\n                try {\n                    socket.close();\n                } catch (IOException e) {\n                    System.err.println(\"Error closing socket: \" + e.getMessage());\n                }\n            }\n        }\n\n        private void broadcastMessage(String from, String message) {\n            for (Map.Entry<String, PrintWriter> entry : clients.entrySet()) {\n                if (from == null || !entry.getKey().equals(from)) {\n                    entry.getValue().println((from != null ? from + \": \" : \"\") + message);\n                }\n            }\n        }\n    }\n}\n```\n\n#### Client Code: `ChatClient.java`\n\n```java\nimport java.io.*;\nimport java.net.*;\n\npublic class ChatClient {\n\n    public static void main(String[] args) throws IOException {\n        if (args.length != 2) {\n            System.out.println(\"Usage: java ChatClient <host> <port>\");\n            return;\n        }\n        String host = args[0];\n        int port = Integer.parseInt(args[1]);\n        Socket socket = new Socket(host, port);\n        InputStreamReader inputStreamReader = new InputStreamReader(socket.getInputStream());\n        BufferedReader fromServer = new BufferedReader(inputStreamReader);\n        OutputStreamWriter outputStreamWriter = new OutputStreamWriter(socket.getOutputStream());\n        PrintWriter toServer = new PrintWriter(outputStreamWriter, true);\n        // Read username from user\n        System.out.print(\"Enter your username: \");\n        BufferedReader userInput = new BufferedReader(new InputStreamReader(System.in));\n        String username = userInput.readLine();\n        toServer.println(username);\n        // Start reader thread\n        Thread readerThread = new Thread(() -> {\n            String message;\n            try {\n                while ((message = fromServer.readLine()) != null) {\n                    System.out.println(message);\n                }\n            } catch (IOException e) {\n                System.err.println(\"Error reading from server: \" + e.getMessage());\n            } finally {\n                try {\n                    socket.close();\n                } catch (IOException e) {\n                    System.err.println(\"Error closing socket: \" + e.getMessage());\n                }\n            }\n        });\n        readerThread.start();\n        // Start writer thread\n        Thread writerThread = new Thread(() -> {\n            String message;\n            try {\n                while ((message = userInput.readLine()) != null) {\n                    toServer.println(message);\n                    if (message.equalsIgnoreCase(\"/quit\")) {\n                        break;\n                    }\n                }\n            } catch (IOException e) {\n                System.err.println(\"Error writing to server: \" + e.getMessage());\n            } finally {\n                try {\n                    socket.close();\n                } catch (IOException e) {\n                    System.err.println(\"Error closing socket: \" + e.getMessage());\n                }\n            }\n        });\n        writerThread.start();\n        try {\n            readerThread.join();\n            writerThread.join();\n        } catch (InterruptedException e) {\n            System.err.println(\"Thread interrupted: \" + e.getMessage());\n        }\n    }\n}\n```\n\n### Explanation\n\n1. **Server**:\n   - Listens on port 12345 for incoming connections.\n   - Manages client connections using threads.\n   - Broadcasts messages and handles client join/leave notifications.\n\n2. **Client**:\n   - Connects to the server via specified host and port.\n   - Sends username and messages to the server.\n   - Receives and displays messages from the server.\n\nThis setup ensures that multiple clients can connect, send messages, and receive messages from other clients simultaneously. The server handles concurrent connections efficiently using threads and broadcasts messages appropriately."
    }
]