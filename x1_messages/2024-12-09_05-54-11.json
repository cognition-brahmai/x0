[
    {
        "role": "user",
        "content": "Develop a JavaScript single-page application (SPA) that displays real-time cryptocurrency prices using the CoinGecko API. The SPA should allow users to select which cryptocurrencies they want to track and display the selected cryptocurrencies' current price, 24-hour change, and market cap in a sortable table.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Alright, I'm going to try to build this single-page application that shows real-time cryptocurrency prices using the CoinGecko API. The app should let users pick which cryptocurrencies they want to track and then show those currencies' current price, the change over the last 24 hours, and their market capitalization in a table that users can sort.\n\nFirst, I need to understand what a single-page application (SPA) is. From what I know, an SPA is a web application that loads a single HTML page and dynamically updates that page as the user interacts with it, without reloading the entire page. This is usually achieved using JavaScript frameworks like React, Angular, or Vue.js. For this project, I think I'll use plain JavaScript without any framework to keep it simple.\n\nNow, I need to get data from the CoinGecko API. I should check out their documentation to see how to make requests and what endpoints to use. I visited coin gecko dot com and looked for their API section. It seems they have a public API that I can use without any authentication, which is great for this project.\n\nLooking at the endpoints, there's one that lists all coins with their market data, something like /coins/markets. I think this will be useful because it allows me to get multiple coins' data at once, and I can specify the currencies I'm interested in.\n\nI need to allow users to select which cryptocurrencies to track. Maybe I can provide a list of popular cryptocurrencies, and users can check the ones they want to see. Then, I'll make an API call with those ids to get their current data.\n\nFor displaying the data, I'll create an HTML table with columns for the cryptocurrency name, symbol, current price, 24-hour change, and market cap. Each row will represent one cryptocurrency.\n\nI also need to make sure that the table is sortable. That means users should be able to click on the table headers to sort the data based on that column, either ascending or descending.\n\nLet me think about the steps I need to implement:\n\n1. Fetch a list of popular cryptocurrencies from the API to display in the selection list.\n\n2. Create a user interface where users can select which cryptocurrencies to track.\n\n3. When users make their selection, fetch the current market data for those cryptocurrencies.\n\n4. Display the data in a table.\n\n5. Implement sorting functionality for the table columns.\n\nAlright, starting with step 1: fetching a list of popular cryptocurrencies.\n\nI'll need to make an API request to CoinGecko to get a list of coins. Maybe I can get the top N coins by market cap. Looking at the documentation, the /coins/markets endpoint seems suitable. I can set parameters like vs_currency to get prices in a specific currency, say USD, and specify the number of coins to retrieve.\n\nI need to make sure that the request is asynchronous, so I'll use the fetch API in JavaScript.\n\nOnce I have the list of coins, I can display them in a checkbox list, so users can select which ones they want to track.\n\nAfter users make their selection, I'll need to fetch the current market data for those specific coins. Again, using the /coins/markets endpoint, but this time passing the ids of the selected coins.\n\nOnce I have the data, I'll populate the table with the relevant information.\n\nFor sorting, I'll add event listeners to the table headers. When a header is clicked, I'll sort the data array based on that column and then re-render the table.\n\nI should also think about updating the data in real-time. Cryptocurrency prices change rapidly, so I might want to set up a timer to refresh the data every few minutes or so.\n\nBut for now, I'll focus on getting the initial data and displaying it correctly.\n\nLet me sketch out the HTML structure.\n\nI'll have a selection section where users can choose which coins to track. Then, a table to display the selected coins' data.\n\nSomething like this:\n\nHTML\n\n```\n\n<div id=\"selection\">\n\n<h2>Select Cryptocurrencies to Track:</h2>\n\n<div id=\"coin-list\"></div>\n\n<button id=\"submit\">Submit</button>\n\n</div>\n\n<table id=\"crypto-table\">\n\n<thead>\n\n<tr>\n\n<th onclick=\"sortTable(0)\">Name</th>\n\n<th onclick=\"sortTable(1)\">Symbol</th>\n\n<th onclick=\"sortTable(2)\">Price</th>\n\n<th onclick=\"sortTable(3)\">24h Change</th>\n\n<th onclick=\"sortTable(4)\">Market Cap</th>\n\n</tr>\n\n</thead>\n\n<tbody id=\"table-body\">\n\n</tbody>\n\n</table>\n\n```\n\nIn the coin-list div, I'll dynamically generate checkboxes for each coin.\n\nNow, in JavaScript, I need to fetch the list of coins and create checkboxes for each.\n\nJavaScript\n\n```\n\nasync function fetchCoins() {\n\nconst response = await fetch('https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&order=market_cap_desc&per_page=100&page=1&sparkline=false');\n\nconst coins = await response.json();\n\nconst coinList = document.getElementById('coin-list');\n\ncoins.forEach(coin => {\n\nconst checkbox = document.createElement('input');\n\ncheckbox.type = 'checkbox';\n\ncheckbox.id = coin.id;\n\ncheckbox.value = coin.id;\n\nconst label = document.createElement('label');\n\nlabel htmlFor = coin.id;\n\nlabel.textContent = coin.name;\n\ncoinList.appendChild(checkbox);\n\ncoinList.appendChild(label);\n\ncoinList.appendChild(document.createElement('br'));\n\n});\n\n}\n\nfetchCoins();\n\n```\n\nThis code fetches the top 100 coins by market cap and creates a checkbox for each.\n\nNext, when the user clicks the submit button, I need to collect the selected coin ids and fetch their current data.\n\nJavaScript\n\n```\n\ndocument.getElementById('submit').addEventListener('click', async () => {\n\nconst selectedCoins = Array.from(document.querySelectorAll('input[type=checkbox]:checked'))\n\n.map(checkbox => checkbox.value);\n\nif (selectedCoins.length === 0) {\n\nalert('Please select at least one cryptocurrency.');\n\nreturn;\n\n}\n\nconst marketData = await fetchMarketData(selectedCoins);\n\npopulateTable(marketData);\n\n});\n\nasync function fetchMarketData(coins) {\n\nconst ids = coins.join(',');\n\nconst response = await fetch(`https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&ids=${ids}&order=market_cap_desc&per_page=100&page=1&sparkline=false`);\n\nconst data = await response.json();\n\nreturn data;\n\n}\n\nfunction populateTable(data) {\n\nconst tableBody = document.getElementById('table-body');\n\ntableBody.innerHTML = '';\n\ndata.forEach(coin => {\n\nconst row = document.createElement('tr');\n\nrow.innerHTML = `\n\n<td>${coin.name}</td>\n\n<td>${coin.symbol.toUpperCase()}</td>\n\n<td>$${coin.current_price.toFixed(2)}</td>\n\n<td>${coin.price_change_percentage_24h.toFixed(2)}%</td>\n\n<td>$${coin.market_cap.toLocaleString()}</td>\n\n`;\n\ntableBody.appendChild(row);\n\n});\n\n}\n\n```\n\nHere, when the submit button is clicked, it gathers the ids of the selected coins, makes an API call to get their market data, and then populates the table with that data.\n\nI also need to handle the sorting functionality.\n\nI'll add a sortTable function that sorts the data based on the column index and then re-renders the table.\n\nJavaScript\n\n```\n\nlet sortDirection = 1; // 1 for ascending, -1 for descending\n\nfunction sortTable(columnIndex) {\n\ndata.sort((a, b) => {\n\nconst valA = parseFloat(a[columnIndex]) || a[columnIndex];\n\nconst valB = parseFloat(b[columnIndex]) || b[columnIndex];\n\nreturn sortDirection * (valA < valB ? -1 : valA > valB ? 1 : 0);\n\n});\n\nsortDirection *= -1; // toggle sort direction\n\npopulateTable(data);\n\n}\n\n```\n\nWait, this might not work as expected because the data is an array of objects, and the columns correspond to different properties.\n\nI need to map the column indices to the corresponding object properties.\n\nMaybe I can define an array that maps column indices to the property names.\n\nJavaScript\n\n```\n\nconst columns = [\n\n{name: 'name'}, // column 0\n\n{symbol: 'symbol'}, // column 1\n\n{price: 'current_price'}, // column 2\n\n{change: 'price_change_percentage_24h'}, // column 3\n\n{marketCap: 'market_cap'}, // column 4\n\n];\n\nfunction sortTable(columnIndex) {\n\nconst column = columns[columnIndex];\n\nconst property = Object.keys(column)[0];\n\ndata.sort((a, b) => {\n\nconst valA = a[property];\n\nconst valB = b[property];\n\nif (typeof valA === 'number' && typeof valB === 'number') {\n\nreturn sortDirection * (valA - valB);\n\n} else {\n\nreturn sortDirection * valA.localeCompare(valB);\n\n}\n\n});\n\nsortDirection *= -1;\n\npopulateTable(data);\n\n}\n\n```\n\nThis should handle both numeric and string values appropriately.\n\nI need to make sure that the sortDirection toggles correctly each time a header is clicked.\n\nAlso, I should probably set the initial sort direction to ascending.\n\nNow, putting it all together.\n\nI need to make sure that all the functions are defined properly and that the event listeners are attached correctly.\n\nAlso, I should consider error handling, like what if the API request fails?\n\nI can add try-catch blocks around the fetch calls and display an error message to the user.\n\nAdditionally, I should think about performance. Since Cryptocurrency prices can change rapidly, frequent API calls might be necessary, but I need to be careful not to overload the server or exceed any API rate limits.\n\nMaybe I can set a timer to refresh the data every 5 minutes or so, but for now, I'll focus on getting the initial data display working correctly.\n\nI should also style the table and the selection section to make it look presentable.\n\nPerhaps add some CSS for better readability.\n\nCSS\n\n```\n\nbody {\n\nfont-family: Arial, sans-serif;\n\n}\n\n#selection {\n\nmargin-bottom: 20px;\n\n}\n\ntable {\n\nwidth: 100%;\n\nborder-collapse: collapse;\n\n}\n\nth, td {\n\npadding: 8px;\n\ntext-align: left;\n\nborder-bottom: 1px solid #ddd;\n\n}\n\nth {\n\ncursor: pointer;\n\n}\n\n```\n\nThis should give a clean look to the table.\n\nAlso, I can add some styling to the checkboxes and labels.\n\nCSS\n\n```\n\ninput[type=checkbox] {\n\nmargin-right: 5px;\n\n}\n\n```\n\nNow, to test the application, I'll open the HTML file in a browser and see if it fetches the coin list, allows me to select coins, and displays the table correctly.\n\nI need to make sure that the API URLs are correct and that there are no typos in the code.\n\nAlso, since the API is cross-origin, browsers should handle it fine as long as the API allows CORS.\n\nI should also consider that some coins might not have all the data fields, so I need to handle possible undefined values.\n\nFor example, if a coin doesn't have a current price, I should display a message like \"N/A\" instead of NaN.\n\nI can add checks in the populateTable function to handle undefined or null values.\n\nJavaScript\n\n```\n\nfunction populateTable(data) {\n\nconst tableBody = document.getElementById('table-body');\n\ntableBody.innerHTML = '';\n\ndata.forEach(coin => {\n\nconst row = document.createElement('tr');\n\nrow.innerHTML = `\n\n<td>${coin.name || 'N/A'}</td>\n\n<td>${coin.symbol ? coin.symbol.toUpperCase() : 'N/A'}</td>\n\n<td>${coin.current_price !== undefined ? `$${coin.current_price.toFixed(2)}` : 'N/A'}</td>\n\n<td>${coin.price_change_percentage_24h !== undefined ? `${coin.price_change_percentage_24h.toFixed(2)}%` : 'N/A'}</td>\n\n<td>${coin.market_cap !== undefined ? `$${coin.market_cap.toLocaleString()}` : 'N/A'}</td>\n\n`;\n\ntableBody.appendChild(row);\n\n});\n\n}\n\n```\n\nThis should prevent any errors from undefined values.\n\nAlso, for the sorting function, I need to ensure that it correctly handles undefined or non-numeric values.\n\nIn the sortTable function, I'm already checking the types and using localeCompare for strings, which should handle undefined values gracefully.\n\nBut to be safe, I can add more checks.\n\nJavaScript\n\n```\n\nfunction sortTable(columnIndex) {\n\nconst column = columns[columnIndex];\n\nconst property = Object.keys(column)[0];\n\ndata.sort((a, b) => {\n\nconst valA = a[property];\n\nconst valB = b[property];\n\nif (valA === undefined || valB === undefined) {\n\nreturn sortDirection * (valA ? 1 : -1);\n\n}\n\nif (typeof valA === 'number' && typeof valB === 'number') {\n\nreturn sortDirection * (valA - valB);\n\n} else {\n\nreturn sortDirection * String(valA).localeCompare(String(valB));\n\n}\n\n});\n\nsortDirection *= -1;\n\npopulateTable(data);\n\n}\n\n```\n\nThis way, if a value is undefined, it will be sorted to the end of the list.\n\nI should also consider that market cap might have null values for some coins, so handling undefined is crucial.\n\nAnother thing to consider is that the user might select multiple coins, and the table should update accordingly whenever the selection changes.\n\nCurrently, the table is populated only when the submit button is clicked. If the user wants to change their selection, they need to click submit again.\n\nMaybe I can make it so that the table updates in real-time as the user checks or unchecks the boxes.\n\nTo do that, I can add event listeners to the checkboxes that call a function to fetch and update the table whenever there's a change.\n\nBut that might lead to too many API calls if the user is quickly checking and unchecking boxes.\n\nAlternatively, I can have a small delay before making the API call, so that if the user is still selecting, the call is postponed.\n\nThis can be achieved using the setTimeout and clearTimeout functions in JavaScript.\n\nLet me think about implementing that.\n\nI'll set a timeout when a checkbox is changed, and if another change occurs within a certain period, I clear the previous timeout and set a new one.\n\nThis way, the API call is only made after the user has finished selecting.\n\nJavaScript\n\n```\n\nlet timeoutId;\n\nconst selectionInputs = document.querySelectorAll('input[type=checkbox]');\n\nselectionInputs.forEach(input => {\n\ninput.addEventListener('change', () => {\n\nclearTimeout(timeoutId);\n\ntimeoutId = setTimeout(updateTable, 500); // delay of 500ms\n\n});\n\n});\n\nasync function updateTable() {\n\nconst selectedCoins = Array.from(document.querySelectorAll('input[type=checkbox]:checked'))\n\n.map(checkbox => checkbox.value);\n\nif (selectedCoins.length === 0) {\n\ndocument.getElementById('table-body').innerHTML = '';\n\nreturn;\n\n}\n\nconst marketData = await fetchMarketData(selectedCoins);\n\npopulateTable(marketData);\n\n}\n\n```\n\nThis way, the table updates 500 milliseconds after the user stops checking/unchecking boxes.\n\nI need to make sure that the initial table is empty until the user makes a selection.\n\nI can achieve this by hiding the table or clearing its content until the user submits their selection.\n\nWait, in this new implementation, the table updates automatically when the user selects coins, so I don't need the submit button anymore.\n\nI'll remove the submit button and just let the table update based on the user's selections.\n\nThis makes the interface more dynamic and user-friendly.\n\nI should also consider limiting the number of coins a user can select to avoid overloading the API or the table becoming too large.\n\nMaybe I can set a maximum limit, say 20 coins, and display a message if the user tries to select more.\n\nJavaScript\n\n```\n\nconst maxSelections = 20;\n\nselectionInputs.forEach(input => {\n\ninput.addEventListener('change', () => {\n\nif (Array.from(document.querySelectorAll('input[type=checkbox]:checked')).length > maxSelections) {\n\nalert(`You can only select up to ${maxSelections} cryptocurrencies.`);\n\ninput.checked = false;\n\n} else {\n\nclearTimeout(timeoutId);\n\ntimeoutId = setTimeout(updateTable, 500);\n\n}\n\n});\n\n});\n\n```\n\nThis way, if the user tries to select more than 20 coins, an alert is shown, and the extra checkbox is unchecked.\n\nI should also make sure that the table doesn't get too big; maybe set a maximum height and add scrolling if necessary.\n\nIn CSS:\n\n```\n\ntable {\n\nmax-height: 400px;\n\noverflow-y: auto;\n\n}\n\n```\n\nThis will add a scrollbar to the table if it exceeds 400 pixels in height.\n\nI should also think about mobile responsiveness. The table might look cramped on smaller screens, so I might need to adjust the styling accordingly.\n\nPerhaps use media queries to adjust the font size or make the table scroll horizontally.\n\nCSS\n\n```\n\n@media (max-width: 600px) {\n\ntable {\n\nfont-size: 14px;\n\n}\n\n}\n\n```\n\nThis should make the text smaller on smaller screens.\n\nAnother feature could be to allow users to search for specific cryptocurrencies in the selection list, especially since there might be hundreds of coins to choose from.\n\nI can add a search input field that filters the list of checkboxes based on the coin's name or symbol.\n\nThis would improve usability significantly.\n\nLet me add a search input above the coin list.\n\nHTML\n\n```\n\n<div id=\"selection\">\n\n<h2>Select Cryptocurrencies to Track:</h2>\n\n<input type=\"text\" id=\"search-input\" placeholder=\"Search for a cryptocurrency...\" />\n\n<div id=\"coin-list\"></div>\n\n</div>\n\n```\n\nNow, in JavaScript, I need to add an event listener to the search input that filters the displayed checkboxes based on the input value.\n\nJavaScript\n\n```\n\ndocument.getElementById('search-input').addEventListener('input', function() {\n\nconst filter = this.value.toLowerCase();\n\nconst coins = document.querySelectorAll('#coin-list input[type=checkbox], #coin-list label');\n\ncoins.forEach(coin => {\n\nconst text = coin.textContent || coin.value;\n\nif (text.toLowerCase().includes(filter)) {\n\ncoin.style.display = '';\n\n} else {\n\ncoin.style.display = 'none';\n\n}\n\n});\n\n});\n\n```\n\nThis will hide checkboxes and labels that don't match the search input.\n\nI need to make sure that the labels are associated correctly with their checkboxes so that hiding one hides the other.\n\nAlternatively, I can wrap each checkbox and its label in a span or div and hide the container.\n\nLet me adjust the code accordingly.\n\nHTML\n\n```\n\n<div id=\"selection\">\n\n<h2>Select Cryptocurrencies to Track:</h2>\n\n<input type=\"text\" id=\"search-input\" placeholder=\"Search for a cryptocurrency...\" />\n\n<div id=\"coin-list\"></div>\n\n</div>\n\n```\n\nJavaScript\n\n```\n\nasync function fetchCoins() {\n\nconst response = await fetch('https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&order=market_cap_desc&per_page=250&page=1&sparkline=false');\n\nconst coins = await response.json();\n\nconst coinList = document.getElementById('coin-list');\n\ncoins.forEach(coin => {\n\nconst container = document.createElement('div');\n\nconst checkbox = document.createElement('input');\n\ncheckbox.type = 'checkbox';\n\ncheckbox.id = coin.id;\n\ncheckbox.value = coin.id;\n\nconst label = document.createElement('label');\n\nlabel htmlFor = coin.id;\n\nlabel.textContent = `${coin.name} (${coin.symbol.toUpperCase()})`;\n\ncontainer.appendChild(checkbox);\n\ncontainer.appendChild(label);\n\ncoinList.appendChild(container);\n\n});\n\n}\n\n```\n\nNow, each checkbox and label are wrapped in a div, so I can hide the entire container based on the search input.\n\nAdjusting the search function:\n\nJavaScript\n\n```\n\ndocument.getElementById('search-input').addEventListener('input', function() {\n\nconst filter = this.value.toLowerCase();\n\nconst coinContainers = document.querySelectorAll('#coin-list div');\n\ncoinContainers.forEach(container => {\n\nconst text = container.textContent.toLowerCase();\n\nif (text.includes(filter)) {\n\ncontainer.style.display = '';\n\n} else {\n\ncontainer.style.display = 'none';\n\n}\n\n});\n\n});\n\n```\n\nThis should work better.\n\nI should also consider performance, as there might be up to 250 coins to display.\n\nBut for now, this should be acceptable.\n\nI need to test the search functionality to ensure it works correctly and that checking/unchecking boxes still updates the table as expected.\n\nAnother enhancement could be to persist the user's selections, maybe using local storage, so that when they reload the page, their selections are remembered.\n\nBut for the scope of this project, I'll leave that out.\n\nI should also make sure that the table headers are correctly sorting the data.\n\nI need to map the column indices to the corresponding properties in the data objects.\n\nIn the sortTable function, I have an array called columns that maps indices to properties.\n\nI need to ensure that the property names match exactly with those in the API response.\n\nLooking back at the API documentation, the properties are:\n\n- name\n\n- symbol\n\n- current_price\n\n- price_change_percentage_24h\n\n- market_cap\n\nSo, my columns array seems correct.\n\nI should also consider that some properties might be nested within other objects, but in this case, they are directly accessible.\n\nI need to test the sorting functionality by clicking on the table headers and verifying that the table updates accordingly.\n\nI should also make sure that clicking the same header again reverses the sort order.\n\nTo do that, I'll maintain the sortDirection variable and toggle it each time a header is clicked.\n\nI need to make sure that the sortDirection is correctly applied in the sort function.\n\nAnother thing to consider is that when the user selects different coins, the table should update accordingly, and the sort state should be maintained if possible.\n\nBut for simplicity, I'll reset the sort each time the table is updated based on new selections.\n\nI should also think about internationalization, but since the API provides data in US dollars by default, and considering time constraints, I'll keep it in USD.\n\nNow, to test the entire application:\n\n1. Open the HTML file in a browser.\n\n2. The list of cryptocurrencies should load from the API.\n\n3. The user can search for specific cryptocurrencies using the search input.\n\n4. The user can select up to 20 cryptocurrencies to track.\n\n5. The table should automatically update to display the selected cryptocurrencies' data.\n\n6. The user can click on the table headers to sort the data.\n\n7. The table should handle undefined or missing data gracefully.\n\nI should also consider adding a loading indicator while the data is being fetched to improve user experience.\n\nI can display a message like \"Loading data...\" while the API requests are being processed.\n\nTo do this, I can show a loading message in the table body while the data is being fetched and then replace it with the actual data once it's ready.\n\nJavaScript\n\n```\n\nfunction showLoading() {\n\nconst tableBody = document.getElementById('table-body');\n\ntableBody.innerHTML = '<tr><td colspan=\"5\">Loading data...</td></tr>';\n\n}\n\nasync function updateTable() {\n\nshowLoading();\n\nconst selectedCoins = Array.from(document.querySelectorAll('input[type=checkbox]:checked'))\n\n.map(checkbox => checkbox.value);\n\nif (selectedCoins.length === 0) {\n\ndocument.getElementById('table-body').innerHTML = '';\n\nreturn;\n\n}\n\nconst marketData = await fetchMarketData(selectedCoins);\n\npopulateTable(marketData);\n\n}\n\n```\n\nThis way, while the data is being fetched, a loading message is displayed in the table.\n\nOnce the data is ready, the table is populated with the actual data.\n\nI should also handle cases where the API request fails, perhaps by displaying an error message.\n\nJavaScript\n\n```\n\nasync function fetchMarketData(coins) {\n\ntry {\n\nconst ids = coins.join(',');\n\nconst response = await fetch(`https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&ids=${ids}&order=market_cap_desc&per_page=100&page=1&sparkline=false`);\n\nif (!response.ok) {\n\nthrow new Error('Network response was not ok');\n\n}\n\nconst data = await response.json();\n\nreturn data;\n\n} catch (error) {\n\nconsole.error('Error fetching market data:', error);\n\nalert('Failed to fetch data. Please try again later.');\n\nreturn [];\n\n}\n\n}\n\n```\n\nThis adds a try-catch block to handle network errors and displays an alert to the user.\n\nNow, I need to make sure that all these functions are correctly linked and that the application flows as expected.\n\nI should also consider code organization. Having all the JavaScript code in one file might become messy as the project grows, but for a small SPA like this, it should be manageable.\n\nI can group related functions together, like data fetching functions, UI updating functions, and event handlers.\n\nI should also make sure that variables are properly scoped and that there are no global variables unless necessary.\n\nLooking back at the code, I have variables like sortDirection and data that need to be accessible across different functions.\n\nI need to define them appropriately.\n\nActually, in the sortTable function, I'm using a variable data, which should be the current market data array.\n\nI need to make sure that it's accessible in that function.\n\nPerhaps I should store the current market data in a variable in the closure scope.\n\nLet me refactor that.\n\nJavaScript\n\n```\n\nlet marketData = [];\n\nlet sortDirection = 1;\n\nasync function updateTable() {\n\nshowLoading();\n\nconst selectedCoins = Array.from(document.querySelectorAll('input[type=checkbox]:checked'))\n\n.map(checkbox => checkbox.value);\n\nif (selectedCoins.length === 0) {\n\ndocument.getElementById('table-body').innerHTML = '';\n\nmarketData = [];\n\nreturn;\n\n}\n\nmarketData = await fetchMarketData(selectedCoins);\n\npopulateTable(marketData);\n\n}\n\nfunction sortTable(columnIndex) {\n\nif (!marketData || marketData.length === 0) return;\n\nconst column = columns[columnIndex];\n\nconst property = Object.keys(column)[0];\n\nmarketData.sort((a, b) => {\n\nconst valA = a[property];\n\nconst valB = b[property];\n\nif (typeof valA === 'number' && typeof valB === 'number') {\n\nreturn sortDirection * (valA - valB);\n\n} else {\n\nreturn sortDirection * String(valA).localeCompare(String(valB));\n\n}\n\n});\n\nsortDirection *= -1;\n\npopulateTable(marketData);\n\n}\n\n```\n\nHere, I'm storing the marketData in a variable that's accessible to both updateTable and sortTable functions.\n\nThis way, sortTable can access the current market data and sort it accordingly.\n\nI need to make sure that if the user selects different coins, the marketData is updated, and the sortDirection is reset if necessary.\n\nFor now, I'll leave it as is.\n\nI should also consider that the user might select the same set of coins again, and in that case, the table should still update with the latest data.\n\nTo achieve this, I can keep fetching the data whenever the selection changes, even if it's the same set of coins.\n\nSince the data changes over time, it's important to always get the latest data.\n\nI should also think about implementing some form of caching to avoid making too many API calls, but for this simple app, I'll skip that.\n\nAnother consideration is that the CoinGecko API might have rate limits. I need to check their documentation to see what the limits are and ensure that my application doesn't exceed them.\n\nAccording to the CoinGecko API documentation, their public endpoints have a rate limit of 50 requests per minute. Since my application might make requests whenever the user changes selections, I need to make sure that the requests are spaced out appropriately.\n\nTo handle this, I can implement a throttle function that limits the frequency of API calls.\n\nBut for now, with the 500ms delay before making the API call, it should be sufficient to stay within the rate limits.\n\nI should also add a note in the application informing users about any rate limits or potential delays in data refresh.\n\nNow, to test the application:\n\n1. Open the HTML file in a browser.\n\n2. The list of cryptocurrencies should load from the API.\n\n3. The user can search for specific cryptocurrencies using the search input.\n\n4. The user can select up to 20 cryptocurrencies to track.\n\n5. The table should automatically update to display the selected cryptocurrencies' data.\n\n6. The user can click on the table headers to sort the data.\n\n7. The table should handle undefined or missing data gracefully.\n\nI should test each of these steps to ensure that everything works as expected.\n\nI should also test edge cases, such as selecting no coins, selecting the maximum number of coins, searching for coins that don't exist, etc.\n\nAdditionally, I should check how the application behaves when the API is down or responds slowly.\n\nI've added error handling for failed API requests, but I should also consider adding timeouts for requests that take too long.\n\nIn fetch API, I can set a timeout using Promise.race.\n\nHere's how I can implement a timeout for the fetch request.\n\nJavaScript\n\n```\n\nfunction fetchWithTimeout(url, options = {}, timeout = 5000) {\n\nconst controller = new AbortController();\n\nconst timeoutId = setTimeout(() => {\n\ncontroller.abort();\n\n}, timeout);\n\nconst promise = fetch(url, { ...options, signal: controller.signal });\n\npromise.finally(() => {\n\nclearTimeout(timeoutId);\n\n});\n\nreturn promise;\n\n}\n\n```\n\nThen, in fetchMarketData, I can use this function.\n\nJavaScript\n\n```\n\nasync function fetchMarketData(coins) {\n\ntry {\n\nconst ids = coins.join(',');\n\nconst response = await fetchWithTimeout(`https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&ids=${ids}&order=market_cap_desc&per_page=100&page=1&sparkline=false`, { method: 'GET' }, 5000);\n\nif (!response.ok) {\n\nthrow new Error('Network response was not ok');\n\n}\n\nconst data = await response.json();\n\nreturn data;\n\n} catch (error) {\n\nconsole.error('Error fetching market data:', error);\n\nalert('Failed to fetch data. Please try again later.');\n\nreturn [];\n\n}\n\n}\n\n```\n\nThis adds a 5-second timeout to the fetch request, after which it aborts if no response is received.\n\nThis helps prevent the application from hanging if there are network issues.\n\nI should also consider adding pagination or infinite scrolling if the list of coins is too long, but for now, limiting it to 250 coins should be sufficient.\n\nI need to make sure that the application is accessible, meaning that users can navigate and interact with it using only the keyboard, if necessary.\n\nI should check that all interactive elements, like checkboxes and table headers, can be focused and activated using the keyboard.\n\nAdditionally, I should ensure that the application is usable for users with disabilities by following accessibility best practices, such as providing appropriate ARIA roles and labels.\n\nFor example, I can add ARIA labels to the table headers to indicate that they are sortable.\n\nHTML\n\n```\n\n<th aria-sort=\"none\" onclick=\"sortTable(0)\">Name</th>\n\n```\n\nAnd then update the aria-sort attribute based on the sort direction.\n\nJavaScript\n\n```\n\nfunction sortTable(columnIndex) {\n\nif (!marketData || marketData.length === 0) return;\n\nconst headers = document.querySelectorAll('th');\n\nheaders.forEach(header => header.setAttribute('aria-sort', 'none'));\n\nconst column = columns[columnIndex];\n\nconst property = Object.keys(column)[0];\n\nmarketData.sort((a, b) => {\n\nconst valA = a[property];\n\nconst valB = b[property];\n\nif (typeof valA === 'number' && typeof valB === 'number') {\n\nreturn sortDirection * (valA - valB);\n\n} else {\n\nreturn sortDirection * String(valA).localeCompare(String(valB));\n\n}\n\n});\n\nsortDirection *= -1;\n\npopulateTable(marketData);\n\nconst header = document.querySelectorAll('th')[columnIndex];\n\nheader.setAttribute('aria-sort', sortDirection === 1 ? 'ascending' : 'descending');\n\n}\n\n```\n\nThis sets the aria-sort attribute on the sorted header to indicate the current sort direction.\n\nI should also make sure that the table has a caption or a summary for better accessibility.\n\nHTML\n\n```\n\n<table id=\"crypto-table\" aria-labelledby=\"table-label\">\n\n<caption id=\"table-label\">Current Prices and Market Data for Selected Cryptocurrencies</caption>\n\n<thead>\n\n<tr>\n\n<th aria-sort=\"none\" onclick=\"sortTable(0)\">Name</th>\n\n<th aria-sort=\"none\" onclick=\"sortTable(1)\">Symbol</th>\n\n<th aria-sort=\"none\" onclick=\"sortTable(2)\">Price</th>\n\n<th aria-sort=\"none\" onclick=\"sortTable(3)\">24h Change</th>\n\n<th aria-sort=\"none\" onclick=\"sortTable(4)\">Market Cap</th>\n\n</tr>\n\n</thead>\n\n<tbody id=\"table-body\">\n\n</tbody>\n\n</table>\n\n```\n\nThis adds a caption to the table, which improves accessibility.\n\nI should also ensure that the color contrast is sufficient for all text elements, especially in the table.\n\nI can use accessibility tools in the browser's developer tools to check contrast ratios and other accessibility issues.\n\nAnother thing to consider is that some users might have JavaScript disabled, but since this is a JavaScript-heavy SPA, the application won't function without it. Therefore, I should include a message informing users that JavaScript is required to use this application.\n\nHTML\n\n```\n\n<noscript>\n\n<p>Sorry, but this application requires JavaScript to function properly.</p>\n\n</noscript>\n\n```\n\nThis will be displayed only if the user has JavaScript disabled.\n\nI should also make sure that all the resources, like the API endpoint URLs, are correct and that there are no typos in the code.\n\nIt's also a good practice to minify and validate the HTML, CSS, and JavaScript code to ensure there are no syntax errors or unnecessary bloat.\n\nI can use online tools or linters to check the code.\n\nFinally, I should test the application in multiple browsers to ensure cross-browser compatibility.\n\nCommon browsers to test include Chrome, Firefox, Safari, and Edge.\n\nI should also check how the application performs on mobile devices and ensure that the user interface is responsive and usable on smaller screens.\n\nI might need to adjust the table styling or consider using a responsive table plugin if the table becomes too cluttered on mobile.\n\nFor now, with the current styling, it should be manageable, but I might need to make further adjustments based on testing.\n\nI should also think about adding tooltips or hover effects to provide additional information, such as full names or additional metrics, but that might be beyond the scope of this project.\n\nIn summary, the steps to build this SPA are:\n\n1. Fetch a list of cryptocurrencies from the CoinGecko API and display them in a searchable list with checkboxes.\n\n2. Allow users to select up to 20 cryptocurrencies to track.\n\n3. Fetch the current market data for the selected cryptocurrencies and display it in a table.\n\n4. Implement sorting functionality for the table columns.\n\n5. Handle edge cases and errors gracefully, providing feedback to the user.\n\n6. Ensure the application is accessible and performs well across different devices and browsers.\n\nI need to test each component thoroughly and make sure that the user experience is smooth and intuitive.\n\nOnce I'm satisfied with the functionality and usability, I can consider deploying the application to a web server or a platform like GitHub Pages for others to use.\n\n## Final Solution\nTo create a single-page application (SPA) that displays real-time cryptocurrency prices using the CoinGecko API, follow the steps below. This solution involves HTML, CSS, and JavaScript to build an interactive and user-friendly interface.\n\n### Solution Code\n\n#### index.html\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Crypto Tracker</title>\n    <style>\n        body {\n            font-family: Arial, sans-serif;\n        }\n        #selection {\n            margin-bottom: 20px;\n        }\n        table {\n            width: 100%;\n            border-collapse: collapse;\n            max-height: 400px;\n            overflow-y: auto;\n        }\n        th, td {\n            padding: 8px;\n            text-align: left;\n            border-bottom: 1px solid #ddd;\n        }\n        th {\n            cursor: pointer;\n        }\n        input[type=checkbox] {\n            margin-right: 5px;\n        }\n        @media (max-width: 600px) {\n            table {\n                font-size: 14px;\n            }\n        }\n    </style>\n</head>\n<body>\n    <div id=\"selection\">\n        <h2>Select Cryptocurrencies to Track:</h2>\n        <input type=\"text\" id=\"search-input\" placeholder=\"Search for a cryptocurrency...\" />\n        <div id=\"coin-list\"></div>\n    </div>\n    <table id=\"crypto-table\" aria-labelledby=\"table-label\">\n        <caption id=\"table-label\">Current Prices and Market Data for Selected Cryptocurrencies</caption>\n        <thead>\n            <tr>\n                <th aria-sort=\"none\" onclick=\"sortTable(0)\">Name</th>\n                <th aria-sort=\"none\" onclick=\"sortTable(1)\">Symbol</th>\n                <th aria-sort=\"none\" onclick=\"sortTable(2)\">Price</th>\n                <th aria-sort=\"none\" onclick=\"sortTable(3)\">24h Change</th>\n                <th aria-sort=\"none\" onclick=\"sortTable(4)\">Market Cap</th>\n            </tr>\n        </thead>\n        <tbody id=\"table-body\">\n        </tbody>\n    </table>\n    <script src=\"app.js\"></script>\n</body>\n</html>\n```\n\n#### app.js\n```javascript\nlet marketData = [];\nlet sortDirection = 1;\nconst columns = [\n    { name: 'name' },\n    { symbol: 'symbol' },\n    { price: 'current_price' },\n    { change: 'price_change_percentage_24h' },\n    { marketCap: 'market_cap' }\n];\n\nasync function fetchCoins() {\n    const response = await fetch('https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&order=market_cap_desc&per_page=250&page=1&sparkline=false');\n    const coins = await response.json();\n    const coinList = document.getElementById('coin-list');\n    coins.forEach(coin => {\n        const container = document.createElement('div');\n        const checkbox = document.createElement('input');\n        checkbox.type = 'checkbox';\n        checkbox.id = coin.id;\n        checkbox.value = coin.id;\n        const label = document.createElement('label');\n        label.htmlFor = coin.id;\n        label.textContent = `${coin.name} (${coin.symbol.toUpperCase()})`;\n        container.appendChild(checkbox);\n        container.appendChild(label);\n        coinList.appendChild(container);\n    });\n}\n\ndocument.getElementById('search-input').addEventListener('input', function() {\n    const filter = this.value.toLowerCase();\n    const coinContainers = document.querySelectorAll('#coin-list div');\n    coinContainers.forEach(container => {\n        const text = container.textContent.toLowerCase();\n        if (text.includes(filter)) {\n            container.style.display = '';\n        } else {\n            container.style.display = 'none';\n        }\n    });\n});\n\nlet timeoutId;\nconst selectionInputs = document.querySelectorAll('input[type=checkbox]');\nconst maxSelections = 20;\n\nselectionInputs.forEach(input => {\n    input.addEventListener('change', () => {\n        if (Array.from(document.querySelectorAll('input[type=checkbox]:checked')).length > maxSelections) {\n            alert(`You can only select up to ${maxSelections} cryptocurrencies.`);\n            input.checked = false;\n        } else {\n            clearTimeout(timeoutId);\n            timeoutId = setTimeout(updateTable, 500);\n        }\n    });\n});\n\nasync function fetchMarketData(coins) {\n    try {\n        const ids = coins.join(',');\n        const response = await fetchWithTimeout(`https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&ids=${ids}&order=market_cap_desc&per_page=100&page=1&sparkline=false`, { method: 'GET' }, 5000);\n        if (!response.ok) {\n            throw new Error('Network response was not ok');\n        }\n        const data = await response.json();\n        return data;\n    } catch (error) {\n        console.error('Error fetching market data:', error);\n        alert('Failed to fetch data. Please try again later.');\n        return [];\n    }\n}\n\nfunction fetchWithTimeout(url, options = {}, timeout = 5000) {\n    const controller = new AbortController();\n    const timeoutId = setTimeout(() => {\n        controller.abort();\n    }, timeout);\n    const promise = fetch(url, { ...options, signal: controller.signal });\n    promise.finally(() => {\n        clearTimeout(timeoutId);\n    });\n    return promise;\n}\n\nfunction showLoading() {\n    const tableBody = document.getElementById('table-body');\n    tableBody.innerHTML = '<tr><td colspan=\"5\">Loading data...</td></tr>';\n}\n\nasync function updateTable() {\n    showLoading();\n    const selectedCoins = Array.from(document.querySelectorAll('input[type=checkbox]:checked'))\n        .map(checkbox => checkbox.value);\n    if (selectedCoins.length === 0) {\n        document.getElementById('table-body').innerHTML = '';\n        marketData = [];\n        return;\n    }\n    marketData = await fetchMarketData(selectedCoins);\n    populateTable(marketData);\n}\n\nfunction populateTable(data) {\n    const tableBody = document.getElementById('table-body');\n    tableBody.innerHTML = '';\n    data.forEach(coin => {\n        const row = document.createElement('tr');\n        row.innerHTML = `\n            <td>${coin.name || 'N/A'}</td>\n            <td>${coin.symbol ? coin.symbol.toUpperCase() : 'N/A'}</td>\n            <td>${coin.current_price !== undefined ? `$${coin.current_price.toFixed(2)}` : 'N/A'}</td>\n            <td>${coin.price_change_percentage_24h !== undefined ? `${coin.price_change_percentage_24h.toFixed(2)}%` : 'N/A'}</td>\n            <td>${coin.market_cap !== undefined ? `$${coin.market_cap.toLocaleString()}` : 'N/A'}</td>\n        `;\n        tableBody.appendChild(row);\n    });\n}\n\nfunction sortTable(columnIndex) {\n    if (!marketData || marketData.length === 0) return;\n    const headers = document.querySelectorAll('th');\n    headers.forEach(header => header.setAttribute('aria-sort', 'none'));\n    const column = columns[columnIndex];\n    const property = Object.keys(column)[0];\n    marketData.sort((a, b) => {\n        const valA = a[property];\n        const valB = b[property];\n        if (typeof valA === 'number' && typeof valB === 'number') {\n            return sortDirection * (valA - valB);\n        } else {\n            return sortDirection * String(valA).localeCompare(String(valB));\n        }\n    });\n    sortDirection *= -1;\n    populateTable(marketData);\n    const header = document.querySelectorAll('th')[columnIndex];\n    header.setAttribute('aria-sort', sortDirection === 1 ? 'ascending' : 'descending');\n}\n\nfetchCoins();\n```\n\n### Explanation\n\n1. **Fetching Coins**: The `fetchCoins` function retrieves a list of cryptocurrencies from the CoinGecko API and displays them with checkboxes for selection.\n\n2. **Search Functionality**: Users can search for specific cryptocurrencies using an input field, which filters the list dynamically.\n\n3. **Selection Handling**: Users can select up to 20 cryptocurrencies to track. JavaScript limits the selection and updates the table with a delayed API call to avoid excessive requests.\n\n4. **Fetching Market Data**: The `fetchMarketData` function fetches current market data for the selected cryptocurrencies and handles API errors gracefully.\n\n5. **Table Population and Sorting**: The table updates automatically based on user selections and allows sorting by column headers.\n\n6. **Accessibility and Performance**: The application includes ARIA roles for accessibility and basic performance optimizations like request timeouts.\n\nThis solution provides a robust foundation for a real-time cryptocurrency tracking application, ensuring both functionality and user experience are top-notch."
    }
]