[
    {
        "role": "user",
        "content": "Implement a binary search tree in JavaScript or TypeScript, with methods for insertion, deletion, and searching of nodes.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Alright, I'm going to help you implement a binary search tree (BST) in JavaScript. A BST is a data structure that allows for efficient insertion, deletion, and searching of nodes. Each node has at most two child nodes, arranged in a way that the value of the left child is less than the parent node, and the value of the right child is greater than the parent node.\n\nFirst, let's define the structure of a node in the BST. Each node will have a value and pointers to its left and right children.\n\n```javascript\nclass TreeNode {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n```\n\nNow, let's create the BST class that will manage these nodes.\n\n```javascript\nclass BinarySearchTree {\n  constructor() {\n    this.root = null;\n  }\n}\n```\n\n### Insertion\n\nTo insert a new value into the BST, we need to find the correct position for it based on its value. We start from the root and traverse the tree, moving left if the value is less than the current node, and right if it's greater. When we find a null position, we insert the new node there.\n\n```javascript\ninsert(value) {\n  const newNode = new TreeNode(value);\n  if (this.root === null) {\n    this.root = newNode;\n  } else {\n    this.insertNode(this.root, newNode);\n  }\n}\n\ninsertNode(node, newNode) {\n  if (newNode.value < node.value) {\n    if (node.left === null) {\n      node.left = newNode;\n    } else {\n      this.insertNode(node.left, newNode);\n    }\n  } else {\n    if (node.right === null) {\n      node.right = newNode;\n    } else {\n      this.insertNode(node.right, newNode);\n    }\n  }\n}\n```\n\n### Searching\n\nTo search for a value in the BST, we start from the root and compare the value with the current node. If the value matches, we return true. If the value is less, we move to the left child; if greater, we move to the right child. If we reach a null node, the value is not present.\n\n```javascript\nsearch(value) {\n  return this.searchNode(this.root, value);\n}\n\nsearchNode(node, value) {\n  if (node === null) {\n    return false;\n  }\n  if (value < node.value) {\n    return this.searchNode(node.left, value);\n  } else if (value > node.value) {\n    return this.searchNode(node.right, value);\n  } else {\n    return true;\n  }\n}\n```\n\n### Deletion\n\nDeletion is a bit more complex. We need to consider three cases:\n\n1. **Deleting a leaf node (no children):** Simply remove the node.\n2. **Deleting a node with one child:** Remove the node and replace it with its child.\n3. **Deleting a node with two children:** Find the in-order successor (the smallest value in the right subtree), replace the node's value with the successor's value, and then delete the successor node.\n\n```javascript\ndelete(value) {\n  this.root = this.deleteNode(this.root, value);\n}\n\ndeleteNode(node, value) {\n  if (node === null) {\n    return null;\n  }\n  if (value < node.value) {\n    node.left = this.deleteNode(node.left, value);\n    return node;\n  } else if (value > node.value) {\n    node.right = this.deleteNode(node.right, value);\n    return node;\n  } else {\n    // Node with one or no child\n    if (node.left === null) {\n      return node.right;\n    } else if (node.right === null) {\n      return node.left;\n    }\n    // Node with two children\n    // Find the in-order successor\n    let minNode = this.findMinNode(node.right);\n    node.value = minNode.value;\n    node.right = this.deleteNode(node.right, minNode.value);\n    return node;\n  }\n}\n\nfindMinNode(node) {\n  let current = node;\n  while (current.left !== null) {\n    current = current.left;\n  }\n  return current;\n}\n```\n\n### Example Usage\n\n```javascript\nconst bst = new BinarySearchTree();\nbst.insert(5);\nbst.insert(3);\nbst.insert(7);\nbst.insert(2);\nbst.insert(4);\nbst.insert(6);\nbst.insert(8);\n\nconsole.log(bst.search(5)); // true\nconsole.log(bst.search(10)); // false\n\nbst.delete(5);\nconsole.log(bst.search(5)); // false\n```\n\nThis implementation covers the basic operations of a binary search tree: insertion, searching, and deletion. You can expand upon this by adding more features like traversal methods (in-order, pre-order, post-order), finding the minimum and maximum values, etc.\n\n### Final Code\n\n```javascript\nclass TreeNode {\n  constructor(value) {\n    this.value = value;\n    this.left = null;\n    this.right = null;\n  }\n}\n\nclass BinarySearchTree {\n  constructor() {\n    this.root = null;\n  }\n\n  insert(value) {\n    const newNode = new TreeNode(value);\n    if (this.root === null) {\n      this.root = newNode;\n    } else {\n      this.insertNode(this.root, newNode);\n    }\n  }\n\n  insertNode(node, newNode) {\n    if (newNode.value < node.value) {\n      if (node.left === null) {\n        node.left = newNode;\n      } else {\n        this.insertNode(node.left, newNode);\n      }\n    } else {\n      if (node.right === null) {\n        node.right = newNode;\n      } else {\n        this.insertNode(node.right, newNode);\n      }\n    }\n  }\n\n  search(value) {\n    return this.searchNode(this.root, value);\n  }\n\n  searchNode(node, value) {\n    if (node === null) {\n      return false;\n    }\n    if (value < node.value) {\n      return this.searchNode(node.left, value);\n    } else if (value > node.value) {\n      return this.searchNode(node.right, value);\n    } else {\n      return true;\n    }\n  }\n\n  delete(value) {\n    this.root = this.deleteNode(this.root, value);\n  }\n\n  deleteNode(node, value) {\n    if (node === null) {\n      return null;\n    }\n    if (value < node.value) {\n      node.left = this.deleteNode(node.left, value);\n      return node;\n    } else if (value > node.value) {\n      node.right = this.deleteNode(node.right, value);\n      return node;\n    } else {\n      // Node with one or no child\n      if (node.left === null) {\n        return node.right;\n      } else if (node.right === null) {\n        return node.left;\n      }\n      // Node with two children\n      // Find the in-order successor\n      let minNode = this.findMinNode(node.right);\n      node.value = minNode.value;\n      node.right = this.deleteNode(node.right, minNode.value);\n      return node;\n    }\n  }\n\n  findMinNode(node) {\n    let current = node;\n    while (current.left !== null) {\n      current = current.left;\n    }\n    return current;\n  }\n}\n\n// Example usage\nconst bst = new BinarySearchTree();\nbst.insert(5);\nbst.insert(3);\nbst.insert(7);\nbst.insert(2);\nbst.insert(4);\nbst.insert(6);\nbst.insert(8);\n\nconsole.log(bst.search(5)); // true\nconsole.log(bst.search(10)); // false\n\nbst.delete(5);\nconsole.log(bst.search(5)); // false\n```\n\nThis code provides a solid foundation for working with binary search trees in JavaScript. You can further enhance it by adding more functionality as needed."
    }
]