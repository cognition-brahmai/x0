[
    {
        "role": "user",
        "content": "Implement a Java program that simulates a multi-threaded producer-consumer scenario. The producer should generate random numbers and add them to a shared buffer, while the consumer should read and process these numbers (e.g., calculate their square root). Use proper synchronization mechanisms to avoid race conditions and ensure correct operation.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Certainly! Below is a simple implementation of a multi-threaded producer-consumer scenario in Java. This program uses a shared buffer to exchange data between the producer and consumer threads. Synchronization is achieved using the `synchronized` keyword and the `wait()` and `notifyAll()` methods to manage access to the buffer.\n\n```java\nimport java.util.Random;\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\nclass SharedBuffer {\n    private final int capacity;\n    private int[] buffer;\n    private int count = 0;\n    private int produceIndex = 0;\n    private int consumeIndex = 0;\n\n    private final Lock lock = new ReentrantLock();\n    private final Condition notFull = lock.newCondition();\n    private final Condition notEmpty = lock.newCondition();\n\n    public SharedBuffer(int capacity) {\n        this.capacity = capacity;\n        this.buffer = new int[capacity];\n    }\n\n    public void produce(int value) throws InterruptedException {\n        lock.lock();\n        try {\n            while (count >= capacity) {\n                notFull.await();\n            }\n            buffer[produceIndex] = value;\n            produceIndex = (produceIndex + 1) % capacity;\n            count++;\n            notEmpty.signalAll();\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public int consume() throws InterruptedException {\n        lock.lock();\n        try {\n            while (count <= 0) {\n                notEmpty.await();\n            }\n            int value = buffer[consumeIndex];\n            consumeIndex = (consumeIndex + 1) % capacity;\n            count--;\n            notFull.signalAll();\n            return value;\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n\nclass Producer implements Runnable {\n    private final SharedBuffer buffer;\n    private final Random random;\n\n    public Producer(SharedBuffer buffer) {\n        this.buffer = buffer;\n        this.random = new Random();\n    }\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 10; i++) {\n            try {\n                int value = random.nextInt(100);\n                buffer.produce(value);\n                System.out.println(\"Produced: \" + value);\n                Thread.sleep(random.nextInt(500));\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n}\n\nclass Consumer implements Runnable {\n    private final SharedBuffer buffer;\n\n    public Consumer(SharedBuffer buffer) {\n        this.buffer = buffer;\n    }\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 10; i++) {\n            try {\n                int value = buffer.consume();\n                double sqrt = Math.sqrt(value);\n                System.out.println(\"Consumed: \" + value + \", sqrt: \" + sqrt);\n                Thread.sleep(100);\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n            }\n        }\n    }\n}\n\npublic class ProducerConsumer {\n    public static void main(String[] args) {\n        SharedBuffer buffer = new SharedBuffer(5);\n        Producer producer = new Producer(buffer);\n        Consumer consumer = new Consumer(buffer);\n\n        Thread producerThread = new Thread(producer);\n        Thread consumerThread = new Thread(consumer);\n\n        producerThread.start();\n        consumerThread.start();\n\n        try {\n            producerThread.join();\n            consumerThread.join();\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n        }\n    }\n}\n```\n\n### Explanation:\n\n1. **SharedBuffer Class**:\n   - Manages a fixed-size buffer for exchanging data between producer and consumer.\n   - Uses a `ReentrantLock` for synchronization and two `Condition` objects (`notFull` and `notEmpty`) to handle waiting and signaling.\n   - Methods `produce` and `consume` are synchronized to ensure exclusive access to the buffer.\n\n2. **Producer Class**:\n   - Generates random numbers and adds them to the buffer.\n   - Waits if the buffer is full.\n\n3. **Consumer Class**:\n   - Retrieves numbers from the buffer and calculates their square roots.\n   - Waits if the buffer is empty.\n\n4. **ProducerConsumer Class**:\n   - Sets up the buffer, producer, and consumer threads, and starts them.\n   - Waits for both threads to complete using `join`.\n\nThis setup ensures that the producer and consumer threads operate correctly without interfering with each other, maintaining the integrity of the shared buffer."
    }
]