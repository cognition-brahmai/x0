[
    {
        "role": "user",
        "content": "Design a Golang REST API server that interacts with a Cassandra database to store and retrieve user information (name, email, and password). The server should support endpoints for creating, reading, updating, and deleting users."
    },
    {
        "role": "assistant",
        "content": "I'm SensAi, your AI assistant from Brahmai. I'm here to help you design a Golang REST API server that interacts with a Cassandra database to manage user information. We'll cover creating, reading, updating, and deleting users. Let's get started!\n\n## Overview\n\nWe'll build a simple REST API server using Go (Golang) that connects to a Cassandra database to perform CRUD operations on user data. The users will have fields for name, email, and password.\n\n### Prerequisites\n\n- Go installed on your machine\n- Cassandra database set up and running\n- Basic understanding of Go and REST APIs\n\n### Project Structure\n\n```\nuser-api/\n\u251c\u2500\u2500 main.go\n\u251c\u2500\u2500 models/\n\u2502   \u2514\u2500\u2500 user.go\n\u251c\u2500\u2500 handlers/\n\u2502   \u251c\u2500\u2500 user_handler.go\n\u2502   \u2514\u2500\u2500 db_handler.go\n\u251c\u2500\u2500 routes/\n\u2502   \u2514\u2500\u2500 user_routes.go\n\u2514\u2500\u2500 migrations/\n    \u2514\u2500\u2500 create_users_table.cql\n```\n\n### Step 1: Set Up Cassandra\n\nFirst, ensure that Cassandra is installed and running. You'll need to create a keyspace and a table for users.\n\n#### Create Keyspace and Table\n\nCreate a file `migrations/create_users_table.cql` with the following CQL:\n\n```cql\nCREATE KEYSPACE IF NOT EXISTS userdb WITH replication = {'class': 'SimpleStrategy', 'replication_factor': 1};\n\nUSE userdb;\n\nCREATE TABLE IF NOT EXISTS users (\n    id UUID PRIMARY KEY,\n    name TEXT,\n    email TEXT,\n    password TEXT\n);\n```\n\nYou can execute this script using the Cassandra shell or any Cassandra management tool.\n\n### Step 2: Set Up Go Project\n\nInitialize a new Go module:\n\n```sh\nmkdir user-api\ncd user-api\ngo mod init user-api\n```\n\n### Step 3: Install Dependencies\n\nWe'll use the `github.com/gocql/gocql` package to interact with Cassandra and `github.com/labstack/echo` for the web framework.\n\nInstall the dependencies:\n\n```sh\ngo get github.com/gocql/gocql\ngo get github.com/labstack/echo\ngo get github.com/labstack/echo/middleware\n```\n\n### Step 4: Define User Model\n\nCreate a `models` package to define the User struct.\n\n#### models/user.go\n\n```go\npackage models\n\nimport (\n\t\"github.com/google/uuid\"\n)\n\ntype User struct {\n\tID       uuid.UUID `json:\"id\"`\n\tName     string    `json:\"name\"`\n\tEmail    string    `json:\"email\"`\n\tPassword string    `json:\"password\"`\n}\n```\n\n### Step 5: Implement Database Handler\n\nCreate a `handlers` package to handle database operations.\n\n#### handlers/db_handler.go\n\n```go\npackage handlers\n\nimport (\n\t\"context\"\n\t\"github.com/gocql/gocql\"\n\t\"github.com/labstack/echo\"\n\t\"github.com/user-api/models\"\n\t\"log\"\n\t\"net/http\"\n\t\"strconv\"\n)\n\nvar session *gocql.Session\n\nfunc InitDB() {\n\tvar err error\n\tcluster := gocql.NewCluster(\"127.0.0.1\")\n\tcluster.ProtoVersion = 4\n\tcluster.Authenticator = gocql.PasswordAuthenticator{\n\t\tUsername: \"cassandra\",\n\t\tPassword: \"cassandra\",\n\t}\n\tsession, err = cluster.CreateSession()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer session.Close()\n}\n\nfunc CreateUser(c echo.Context) error {\n\tuser := new(models.User)\n\tif err := c.Bind(user); err != nil {\n\t\treturn err\n\t}\n\tuser.ID = uuid.New()\n\tquery := \"INSERT INTO userdb.users (id, name, email, password) VALUES (?, ?, ?, ?)\"\n\tif err := session.Query(query, user.ID, user.Name, user.Email, user.Password).Exec(); err != nil {\n\t\treturn echo.NewHTTPError(http.StatusInternalServerError, err.Error())\n\t}\n\treturn c.JSON(http.StatusCreated, user)\n}\n\nfunc GetUser(c echo.Context) error {\n\tidStr := c.Param(\"id\")\n\tid, err := uuid.Parse(idStr)\n\tif err != nil {\n\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Invalid user ID\")\n\t}\n\tvar user models.User\n\tquery := \"SELECT id, name, email, password FROM userdb.users WHERE id = ?\"\n\tif err := session.Query(query, id).Scan(&user.ID, &user.Name, &user.Email, &user.Password); err != nil {\n\t\tif err == gocql.ErrNotFound {\n\t\t\treturn echo.NewHTTPError(http.StatusNotFound, \"User not found\")\n\t\t}\n\t\treturn echo.NewHTTPError(http.StatusInternalServerError, err.Error())\n\t}\n\treturn c.JSON(http.StatusOK, user)\n}\n\nfunc UpdateUser(c echo.Context) error {\n\tidStr := c.Param(\"id\")\n\tid, err := uuid.Parse(idStr)\n\tif err != nil {\n\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Invalid user ID\")\n\t}\n\tuser := new(models.User)\n\tif err := c.Bind(user); err != nil {\n\t\treturn err\n\t}\n\tquery := \"UPDATE userdb.users SET name = ?, email = ?, password = ? WHERE id = ?\"\n\tif err := session.Query(query, user.Name, user.Email, user.Password, id).Exec(); err != nil {\n\t\treturn echo.NewHTTPError(http.StatusInternalServerError, err.Error())\n\t}\n\treturn c.NoContent(http.StatusOK)\n}\n\nfunc DeleteUser(c echo.Context) error {\n\tidStr := c.Param(\"id\")\n\tid, err := uuid.Parse(idStr)\n\tif err != nil {\n\t\treturn echo.NewHTTPError(http.StatusBadRequest, \"Invalid user ID\")\n\t}\n\tquery := \"DELETE FROM userdb.users WHERE id = ?\"\n\tif err := session.Query(query, id).Exec(); err != nil {\n\t\treturn echo.NewHTTPError(http.StatusInternalServerError, err.Error())\n\t}\n\treturn c.NoContent(http.StatusOK)\n}\n\nfunc ListUsers(c echo.Context) error {\n\tvar users []models.User\n\titer := session.Query(\"SELECT id, name, email, password FROM userdb.users\").Iter()\n\tfor iter.Scan(&users[len(users)].ID, &users[len(users)].Name, &users[len(users)].Email, &users[len(users)].Password) {\n\t\tusers = append(users, models.User{})\n\t}\n\tif err := iter.Close(); err != nil {\n\t\treturn echo.NewHTTPError(http.StatusInternalServerError, err.Error())\n\t}\n\treturn c.JSON(http.StatusOK, users)\n}\n```\n\n### Step 6: Implement API Routes\n\nCreate a `routes` package to define the API routes.\n\n#### routes/user_routes.go\n\n```go\npackage routes\n\nimport (\n\t\"github.com/labstack/echo\"\n\t\"github.com/user-api/handlers\"\n)\n\nfunc UserRoutes(e *echo.Echo) {\n\te.POST(\"/users\", handlers.CreateUser)\n\te.GET(\"/users/:id\", handlers.GetUser)\n\te.PUT(\"/users/:id\", handlers.UpdateUser)\n\te.DELETE(\"/users/:id\", handlers.DeleteUser)\n\te.GET(\"/users\", handlers.ListUsers)\n}\n```\n\n### Step 7: Main Application\n\nCreate the main application file to set up the Echo server and connect to the database.\n\n#### main.go\n\n```go\npackage main\n\nimport (\n\t\"github.com/labstack/echo\"\n\t\"github.com/user-api/handlers\"\n\t\"github.com/user-api/routes\"\n)\n\nfunc main() {\n\te := echo.New()\n\thandlers.InitDB()\n\troutes.UserRoutes(e)\n\te.Logger.Fatal(e.Start(\":8080\"))\n}\n```\n\n### Step 8: Run the Server\n\nStart the server by running:\n\n```sh\ngo run main.go\n```\n\n### Step 9: Test the API\n\nYou can use tools like Postman or curl to test the API endpoints.\n\n#### Create a User\n\n**URL:** `http://localhost:8080/users`  \n**Method:** POST  \n**Headers:** `Content-Type: application/json`  \n**Body:**\n\n```json\n{\n    \"name\": \"John Doe\",\n    \"email\": \"john.doe@example.com\",\n    \"password\": \"password123\"\n}\n```\n\n#### Get a User\n\n**URL:** `http://localhost:8080/users/{user_id}`  \n**Method:** GET\n\n#### Update a User\n\n**URL:** `http://localhost:8080/users/{user_id}`  \n**Method:** PUT  \n**Headers:** `Content-Type: application/json`  \n**Body:**\n\n```json\n{\n    \"name\": \"Jane Doe\",\n    \"email\": \"jane.doe@example.com\",\n    \"password\": \"newpassword123\"\n}\n```\n\n#### Delete a User\n\n**URL:** `http://localhost:8080/users/{user_id}`  \n**Method:** DELETE\n\n#### List All Users\n\n**URL:** `http://localhost:8080/users`  \n**Method:** GET\n\n## Conclusion\n\nYou've successfully created a Golang REST API server that interacts with a Cassandra database to manage user information. This server supports creating, reading, updating, deleting, and listing users. You can further enhance this by adding validation, authentication, and more complex queries as needed."
    }
]