[
    {
        "role": "user",
        "content": "Implement a binary search tree in C++ with methods for insertion, deletion, and searching of elements. The tree should be self-balancing (e.g., AVL or Red-Black Tree).\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Implementing a self-balancing binary search tree like an AVL tree in C++ involves several steps. Below is an example implementation of an AVL tree that supports insertion, deletion, and searching operations.\n\n### AVL Tree Implementation in C++\n\n```cpp\n#include <iostream>\n\nclass Node {\npublic:\n    int key;\n    Node* left;\n    Node* right;\n    int height;\n\n    Node(int k) : key(k), left(nullptr), right(nullptr), height(1) {}\n};\n\nclass AVLTree {\npublic:\n    Node* root;\n\n    AVLTree() : root(nullptr) {}\n\n    // Utility functions\n    int height(Node* N) {\n        if (N == nullptr)\n            return 0;\n        return N->height;\n    }\n\n    int getBalance(Node* N) {\n        if (N == nullptr)\n            return 0;\n        return height(N->left) - height(N->right);\n    }\n\n    Node* rotateLeft(Node* z) {\n        Node* y = z->right;\n        Node* T2 = y->left;\n\n        y->left = z;\n        z->right = T2;\n\n        z->height = std::max(height(z->left), height(z->right)) + 1;\n        y->height = std::max(height(y->left), height(y->right)) + 1;\n\n        return y;\n    }\n\n    Node* rotateRight(Node* y) {\n        Node* x = y->left;\n        Node* T2 = x->right;\n\n        x->right = y;\n        y->left = T2;\n\n        y->height = std::max(height(y->left), height(y->right)) + 1;\n        x->height = std::max(height(x->left), height(x->right)) + 1;\n\n        return x;\n    }\n\n    // Recursive function to insert a key in the subtree rooted with node and returns the new root of the subtree.\n    Node* insert(Node* node, int key) {\n        if (node == nullptr)\n            return new Node(key);\n\n        if (key < node->key)\n            node->left = insert(node->left, key);\n        else if (key > node->key)\n            node->right = insert(node->right, key);\n        else\n            return node; // Duplicate keys not allowed\n\n        node->height = 1 + std::max(height(node->left), height(node->right));\n\n        int balance = getBalance(node);\n\n        // Left Left Case\n        if (balance > 1 && key < node->left->key)\n            return rotateRight(node);\n\n        // Right Right Case\n        if (balance < -1 && key > node->right->key)\n            return rotateLeft(node);\n\n        // Left Right Case\n        if (balance > 1 && key > node->left->key) {\n            node->left = rotateLeft(node->left);\n            return rotateRight(node);\n        }\n\n        // Right Left Case\n        if (balance < -1 && key < node->right->key) {\n            node->right = rotateRight(node->right);\n            return rotateLeft(node);\n        }\n\n        return node;\n    }\n\n    // Wrapper function for insertion\n    void insert(int key) {\n        root = insert(root, key);\n    }\n\n    // Recursive function to delete a key in the subtree rooted with node and returns the new root of the subtree.\n    Node* minValueNode(Node* node) {\n        Node* current = node;\n        while (current->left != nullptr)\n            current = current->left;\n        return current;\n    }\n\n    Node* deleteNode(Node* root, int key) {\n        if (root == nullptr)\n            return root;\n\n        if (key < root->key)\n            root->left = deleteNode(root->left, key);\n        else if (key > root->key)\n            root->right = deleteNode(root->right, key);\n        else {\n            if ((root->left == nullptr) || (root->right == nullptr)) {\n                Node* temp = root->left ? root->left : root->right;\n\n                if (temp == nullptr) {\n                    temp = root;\n                    root = nullptr;\n                } else\n                    *root = *temp; // Copy the contents of the non-null child\n\n                delete temp;\n            } else {\n                Node* temp = minValueNode(root->right);\n                root->key = temp->key;\n                root->right = deleteNode(root->right, temp->key);\n            }\n        }\n\n        if (root == nullptr)\n            return root;\n\n        root->height = 1 + std::max(height(root->left), height(root->right));\n\n        int balance = getBalance(root);\n\n        // Left Left Case\n        if (balance > 1 && getBalance(root->left) >= 0)\n            return rotateRight(root);\n\n        // Left Right Case\n        if (balance > 1 && getBalance(root->left) < 0) {\n            root->left = rotateLeft(root->left);\n            return rotateRight(root);\n        }\n\n        // Right Right Case\n        if (balance < -1 && getBalance(root->right) <= 0)\n            return rotateLeft(root);\n\n        // Right Left Case\n        if (balance < -1 && getBalance(root->right) > 0) {\n            root->right = rotateRight(root->right);\n            return rotateLeft(root);\n        }\n\n        return root;\n    }\n\n    // Wrapper function for deletion\n    void deleteNode(int key) {\n        root = deleteNode(root, key);\n    }\n\n    // Function to search for a key in the tree\n    bool search(Node* node, int key) {\n        if (node == nullptr)\n            return false;\n        if (key == node->key)\n            return true;\n        else if (key < node->key)\n            return search(node->left, key);\n        else\n            return search(node->right, key);\n    }\n\n    // Wrapper function for search\n    bool search(int key) {\n        return search(root, key);\n    }\n\n    // Function to print the tree in inorder traversal\n    void inorder(Node* node) {\n        if (node != nullptr) {\n            inorder(node->left);\n            std::cout << node->key << \" \";\n            inorder(node->right);\n        }\n    }\n\n    // Wrapper function for inorder traversal\n    void inorder() {\n        inorder(root);\n        std::cout << std::endl;\n    }\n};\n\nint main() {\n    AVLTree tree;\n\n    tree.insert(9);\n    tree.insert(5);\n    tree.insert(10);\n    tree.insert(0);\n    tree.insert(6);\n    tree.insert(11);\n    tree.insert(-1);\n    tree.insert(1);\n    tree.insert(2);\n\n    std::cout << \"Inorder traversal of the constructed tree: \";\n    tree.inorder();\n\n    std::cout << \"Search for 5: \" << (tree.search(5) ? \"Found\" : \"Not Found\") << std::endl;\n    std::cout << \"Search for 3: \" << (tree.search(3) ? \"Found\" : \"Not Found\") << std::endl;\n\n    tree.deleteNode(10);\n    std::cout << \"After deleting 10, inorder traversal: \";\n    tree.inorder();\n\n    return 0;\n}\n```\n\n### Explanation\n\n1. **Node Class**: Represents a node in the AVL tree with attributes for the key, left and right children, and height.\n2. **AVLTree Class**: Manages the AVL tree operations.\n   - **Insertion**: Inserts a new key while maintaining the AVL tree properties by performing rotations if necessary.\n   - **Deletion**: Deletes a key while maintaining the AVL tree properties by performing rotations if necessary.\n   - **Searching**: Searches for a key in the tree.\n   - **Utility Functions**: Helper functions for getting the height, balance factor, and performing rotations.\n3. **Main Function**: Demonstrates the insertion, searching, and deletion operations with sample data.\n\nThis implementation ensures that the tree remains balanced after each insertion or deletion, maintaining logarithmic time complexity for these operations."
    }
]