[
    {
        "role": "user",
        "content": "Implement a C++ class for a basic stack data structure with push, pop, and top operations.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Sure! Implementing a stack in C++ is a fundamental exercise that helps understand the basics of data structures and object-oriented programming. A stack is a Last In First Out (LIFO) data structure, meaning the last element added is the first one to be removed.\n\nTo create a stack class in C++, we need to define the class with methods for pushing elements onto the stack, popping elements off the stack, and peeking at the top element without removing it. Additionally, it's useful to have methods to check if the stack is empty and to get the size of the stack.\n\nWe'll use an array to store the elements of the stack for efficiency, but we need to handle the case when the stack grows beyond its initial capacity. To handle this, we'll double the capacity of the array whenever it fills up.\n\nHere's a step-by-step plan:\n\n1. Define the class with private members for the array, the current size, and the capacity.\n2. Implement a constructor to initialize the stack.\n3. Implement a destructor to free the allocated memory.\n4. Implement the push method to add elements to the stack.\n5. Implement the pop method to remove elements from the stack.\n6. Implement the top method to access the top element without removing it.\n7. Implement methods to check if the stack is empty and to get the size of the stack.\n\nLet's proceed to write the code accordingly.\n\n## Final Solution\nTo implement a basic stack data structure in C++, we can create a class that uses an array to store the elements. The class will provide methods to push elements onto the stack, pop elements off the stack, and check the top element of the stack. Additionally, we'll include methods to check if the stack is empty and to get the size of the stack.\n\n### Approach\n1. **Array-Based Implementation**: We use an array to store the stack elements for efficient access and manipulation.\n2. **Dynamic Resizing**: The array doubles in size whenever it fills up to handle an increasing number of elements efficiently.\n3. **Top Tracker**: A variable tracks the current top of the stack to manage push and pop operations efficiently.\n\n### Solution Code\n\n```cpp\n#include <iostream>\n\nclass Stack {\nprivate:\n    int* arr;\n    int top;\n    int capacity;\n\npublic:\n    // Constructor to initialize the stack\n    Stack(int size = 1) {\n        arr = new int[size];\n        capacity = size;\n        top = -1;\n    }\n\n    // Destructor to free allocated memory\n    ~Stack() {\n        delete[] arr;\n    }\n\n    // Method to add an element to the stack\n    void push(int value) {\n        if (top == capacity - 1) {\n            resize(2 * capacity);\n        }\n        arr[++top] = value;\n    }\n\n    // Method to remove the top element from the stack\n    int pop() {\n        if (top == -1) {\n            std::cout << \"Stack is empty. Cannot pop.\" << std::endl;\n            return -1;\n        }\n        return arr[top--];\n    }\n\n    // Method to get the top element of the stack without removing it\n    int getTop() {\n        if (top == -1) {\n            std::cout << \"Stack is empty.\" << std::endl;\n            return -1;\n        }\n        return arr[top];\n    }\n\n    // Method to check if the stack is empty\n    bool isEmpty() {\n        return top == -1;\n    }\n\n    // Method to get the current size of the stack\n    int size() {\n        return top + 1;\n    }\n\nprivate:\n    // Helper method to resize the array\n    void resize(int newCapacity) {\n        int* temp = new int[newCapacity];\n        for (int i = 0; i <= top; i++) {\n            temp[i] = arr[i];\n        }\n        capacity = newCapacity;\n        delete[] arr;\n        arr = temp;\n    }\n};\n\nint main() {\n    Stack s(1); // Initialize stack with initial capacity of 1\n\n    s.push(10);\n    s.push(20);\n    s.push(30);\n\n    std::cout << \"Top element is: \" << s.getTop() << std::endl; // Output: 30\n\n    s.pop();\n\n    std::cout << \"After popping, top element is: \" << s.getTop() << std::endl; // Output: 20\n\n    std::cout << \"Is stack empty? \" << (s.isEmpty() ? \"Yes\" : \"No\") << std::endl; // Output: No\n\n    std::cout << \"Stack size: \" << s.size() << std::endl; // Output: 2\n\n    return 0;\n}\n```\n\n### Explanation\n- **Constructor**: Initializes the stack with a given capacity (default is 1).\n- **Destructor**: Frees the dynamically allocated array memory.\n- **push(int value)**: Adds an element to the top of the stack. If the stack is full, the array is resized to double its current capacity.\n- **pop()**: Removes the top element from the stack and returns it. If the stack is empty, it prints an error message and returns -1.\n- **getTop()**: Returns the top element of the stack without removing it. If the stack is empty, it prints an error message and returns -1.\n- **isEmpty()**: Returns true if the stack is empty, otherwise false.\n- **size()**: Returns the current number of elements in the stack.\n- **resize(int newCapacity)**: A helper method to resize the array to the new capacity.\n\nThis implementation ensures that the stack operations are efficient, and the dynamic resizing handles stacks of varying sizes effectively."
    }
]