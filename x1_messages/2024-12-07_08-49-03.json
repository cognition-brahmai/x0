[
    {
        "role": "user",
        "content": "Create a Golang program that implements a simple REST API for managing a list of tasks. The API should support the following operations: create, read, update, and delete tasks. Include the following requirements:\n    - Use an in-memory data structure to store tasks.\n    - Implement proper error handling and status codes.\n    - Allow filtering tasks by status (completed or pending)."
    },
    {
        "role": "assistant",
        "content": "Sure, I'd be happy to help you with that! Let's break down the requirements and plan out how to implement this simple REST API for managing tasks in Golang.\n\n## Requirements\n\n1. **In-memory data structure to store tasks**: We'll use a slice of structs to store task data in memory.\n2. **Implement proper error handling and status codes**: We'll ensure that our API responses include appropriate HTTP status codes and error messages when needed.\n3. **Allow filtering tasks by status (completed or pending)**: We'll provide an endpoint that allows filtering tasks based on their completion status.\n\n## Plan\n\n1. **Define the Task struct**: This will represent the task data.\n2. **Set up the in-memory store**: Use a slice to store tasks.\n3. **Implement CRUD operations**:\n   - **Create**: POST /tasks\n   - **Read**: GET /tasks (with optional status query parameter)\n   - **Update**: PUT /tasks/{id}\n   - **Delete**: DELETE /tasks/{id}\n4. **Error handling**: Ensure proper error responses with appropriate HTTP status codes.\n5. **Testing**: Write tests to verify each endpoint.\n\n## Implementation\n\n### 1. Define the Task struct\n\n```go\ntype Task struct {\n    ID        string  `json:\"id\"`\n    Title     string  `json:\"title\"`\n    Status    string  `json:\"status\"`\n}\n```\n\n### 2. Set up the in-memory store\n\n```go\nvar tasks []Task\nvar idCounter int\n```\n\n### 3. Implement CRUD operations\n\n#### Create Task (POST /tasks)\n\n- **Request Body**: Task details (title and status)\n- **Response**: Created task with assigned ID\n\n```go\nfunc createTask(w http.ResponseWriter, r *http.Request) {\n    var newTask Task\n    if err := json.NewDecoder(r.Body).Decode(&newTask); err != nil {\n        http.Error(w, \"Bad request\", http.StatusBadRequest)\n        return\n    }\n    idCounter++\n    newTask.ID = strconv.Itoa(idCounter)\n    tasks = append(tasks, newTask)\n    w.Header().Set(\"Content-Type\", \"application/json\")\n    w.WriteHeader(http.StatusCreated)\n    json.NewEncoder(w).Encode(newTask)\n}\n```\n\n#### Read Tasks (GET /tasks)\n\n- **Query Parameter**: status (optional)\n- **Response**: List of tasks filtered by status if provided\n\n```go\nfunc readTasks(w http.ResponseWriter, r *http.Request) {\n    status := r.URL.Query().Get(\"status\")\n    var filteredTasks []Task\n    for _, task := range tasks {\n        if status == \"\" || task.Status == status {\n            filteredTasks = append(filteredTasks, task)\n        }\n    }\n    w.Header().Set(\"Content-Type\", \"application/json\")\n    json.NewEncoder(w).Encode(filteredTasks)\n}\n```\n\n#### Update Task (PUT /tasks/{id})\n\n- **Path Parameter**: id\n- **Request Body**: Updated task details\n- **Response**: Updated task or error if not found\n\n```go\nfunc updateTask(w http.ResponseWriter, r *http.Request) {\n    id := chi.URLParam(r, \"id\")\n    var updatedTask Task\n    if err := json.NewDecoder(r.Body).Decode(&updatedTask); err != nil {\n        http.Error(w, \"Bad request\", http.StatusBadRequest)\n        return\n    }\n    for i, task := range tasks {\n        if task.ID == id {\n            tasks[i].Title = updatedTask.Title\n            tasks[i].Status = updatedTask.Status\n            w.Header().Set(\"Content-Type\", \"application/json\")\n            json.NewEncoder(w).Encode(tasks[i])\n            return\n        }\n    }\n    http.Error(w, \"Task not found\", http.StatusNotFound)\n}\n```\n\n#### Delete Task (DELETE /tasks/{id})\n\n- **Path Parameter**: id\n- **Response**: Success message or error if not found\n\n```go\nfunc deleteTask(w http.ResponseWriter, r *http.Request) {\n    id := chi.URLParam(r, \"id\")\n    for i, task := range tasks {\n        if task.ID == id {\n            tasks = append(tasks[:i], tasks[i+1:]...)\n            w.WriteHeader(http.StatusNoContent)\n            return\n        }\n    }\n    http.Error(w, \"Task not found\", http.StatusNotFound)\n}\n```\n\n### 4. Error Handling\n\n- Use `http.Error` to send error responses with appropriate status codes.\n- Ensure that all possible error scenarios are handled, such as missing request bodies, invalid IDs, etc.\n\n### 5. Testing\n\n- Write tests for each endpoint to verify functionality.\n- Use tools like `curl` or Postman to manually test the API.\n\n## Example Usage\n\n### Create a Task\n\n**Request**:\n\n```http\nPOST /tasks HTTP/1.1\nContent-Type: application/json\n\n{\n    \"title\": \"Buy groceries\",\n    \"status\": \"pending\"\n}\n```\n\n**Response**:\n\n```http\nHTTP/1.1 201 Created\nContent-Type: application/json\n\n{\n    \"id\": \"1\",\n    \"title\": \"Buy groceries\",\n    \"status\": \"pending\"\n}\n```\n\n### Read Tasks\n\n**Request**:\n\n```http\nGET /tasks?status=pending HTTP/1.1\n```\n\n**Response**:\n\n```http\nHTTP/1.1 200 OK\nContent-Type: application/json\n\n[\n    {\n        \"id\": \"1\",\n        \"title\": \"Buy groceries\",\n        \"status\": \"pending\"\n    }\n]\n```\n\n### Update Task\n\n**Request**:\n\n```http\nPUT /tasks/1 HTTP/1.1\nContent-Type: application/json\n\n{\n    \"title\": \"Buy groceries\",\n    \"status\": \"completed\"\n}\n```\n\n**Response**:\n\n```http\nHTTP/1.1 200 OK\nContent-Type: application/json\n\n{\n    \"id\": \"1\",\n    \"title\": \"Buy groceries\",\n    \"status\": \"completed\"\n}\n```\n\n### Delete Task\n\n**Request**:\n\n```http\nDELETE /tasks/1 HTTP/1.1\n```\n\n**Response**:\n\n```http\nHTTP/1.1 204 No Content\n```\n\n## Conclusion\n\nThis simple REST API in Golang allows you to manage tasks with basic CRUD operations and filtering by status. It uses an in-memory slice to store tasks, which is suitable for demonstration purposes. For production use, consider persisting data to a database."
    }
]