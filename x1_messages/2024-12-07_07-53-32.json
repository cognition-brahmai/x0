[
    {
        "role": "user",
        "content": "Write a Node.js script that listens for incoming HTTP requests on a specified port and responds with the current date and time in JSON format."
    },
    {
        "role": "assistant",
        "content": "Okay, I need to write a Node.js script that listens for HTTP requests on a specific port and sends back the current date and time in JSON format. Sounds straightforward. I've worked with Node.js before, so I should be fine.\n\nFirst, I need to set up a basic HTTP server in Node.js. I know that the built-in `http` module can handle this. So, I'll start by requiring the `http` module.\n\n```javascript\nconst http = require('http');\n```\n\nNext, I need to create a server that listens on a specified port. Let's say port 3000 for now, but I should make it configurable. Maybe I can take the port number as a command-line argument or use an environment variable. That way, it's easier to change if needed.\n\nLet me think about how to do that. I can use the `process.argv` object to get command-line arguments or `process.env` to access environment variables.\n\nMaybe I'll use an environment variable for the port. That seems more flexible. So, I'll assume there's an environment variable named `PORT` that holds the port number.\n\n```javascript\nconst port = process.env.PORT || 3000;\n```\n\nThis way, if `PORT` is set in the environment, it will use that; otherwise, it defaults to 3000.\n\nNow, I need to create the server. Using the `http.createServer()` method, I can pass a callback function that handles incoming requests.\n\nInside this callback, I need to send a JSON response containing the current date and time.\n\nSo, something like:\n\n```javascript\nconst server = http.createServer((req, res) => {\n  const currentDate = new Date();\n  const responseObject = {\n    date: currentDate.toISOString()\n  };\n  res.setHeader('Content-Type', 'application/json');\n  res.end(JSON.stringify(responseObject));\n});\n```\n\nHere, I'm creating a new `Date` object to get the current date and time, converting it to an ISO string, and then sending it in a JSON object.\n\nDon't forget to make the server listen on the specified port:\n\n```javascript\nserver.listen(port, () => {\n  console.log(`Server is running on port ${port}`);\n});\n```\n\nThis will print a message to the console once the server starts listening.\n\nLet me put it all together:\n\n```javascript\nconst http = require('http');\n\nconst port = process.env.PORT || 3000;\n\nconst server = http.createServer((req, res) => {\n  const currentDate = new Date();\n  const responseObject = {\n    date: currentDate.toISOString()\n  };\n  res.setHeader('Content-Type', 'application/json');\n  res.end(JSON.stringify(responseObject));\n});\n\nserver.listen(port, () => {\n  console.log(`Server is running on port ${port}`);\n});\n```\n\nI think this should work. Let me test it.\n\nI'll save this script as `server.js` and run it using Node.js.\n\nFirst, I'll set the `PORT` environment variable to 3000.\n\nIn the terminal:\n\n```\nexport PORT=3000\nnode server.js\n```\n\nIt should start the server on port 3000.\n\nNow, if I open a web browser and go to `http://localhost:3000`, I should see a JSON response with the current date and time.\n\nAlternatively, I can use `curl` to test it:\n\n```\ncurl http://localhost:3000\n```\n\nThis should return something like:\n\n```\n{\"date\":\"2023-04-01T12:34:56.789Z\"}\n```\n\nLooks good.\n\nMaybe I should also handle different HTTP methods. For now, the server responds to any request with the date and time. But typically, we might want to handle only GET requests and perhaps return different responses for other methods like POST, PUT, etc.\n\nBut since the task is to respond with the current date and time in JSON format, this seems sufficient.\n\nWait a minute, maybe I should only respond to GET requests and send an appropriate response for other methods.\n\nFor example, if someone makes a POST request, I could send a 405 Method Not Allowed response.\n\nLet me adjust the code to handle that.\n\nInside the request callback:\n\n```javascript\nif (req.method === 'GET') {\n  const currentDate = new Date();\n  const responseObject = {\n    date: currentDate.toISOString()\n  };\n  res.setHeader('Content-Type', 'application/json');\n  res.end(JSON.stringify(responseObject));\n} else {\n  res.writeHead(405, { 'Content-Type': 'application/json' });\n  const errorResponse = {\n    error: 'Method Not Allowed'\n  };\n  res.end(JSON.stringify(errorResponse));\n}\n```\n\nThis way, only GET requests will get the date and time, and other methods will get a 405 response.\n\nLet me test this again.\n\nStart the server:\n\n```\nnode server.js\n```\n\nMake a GET request:\n\n```\ncurl http://localhost:3000\n```\n\nShould return the date and time in JSON.\n\nMake a POST request:\n\n```\ncurl -X POST http://localhost:3000\n```\n\nShould return a 405 response with an error message in JSON.\n\nPerfect.\n\nMaybe I should also add some error handling, like if there's an issue with creating the server or listening on the port.\n\nI can add a `listen` event listener and an `error` event listener.\n\nHere's how:\n\n```javascript\nserver.on('listening', () => {\n  console.log(`Server is running on port ${port}`);\n});\n\nserver.on('error', (err) => {\n  console.error(`Server error: ${err.message}`);\n});\n```\n\nThis will log a message when the server starts successfully and log any errors that occur.\n\nLet me update the code:\n\n```javascript\nconst http = require('http');\n\nconst port = process.env.PORT || 3000;\n\nconst server = http.createServer((req, res) => {\n  if (req.method === 'GET') {\n    const currentDate = new Date();\n    const responseObject = {\n      date: currentDate.toISOString()\n    };\n    res.setHeader('Content-Type', 'application/json');\n    res.end(JSON.stringify(responseObject));\n  } else {\n    res.writeHead(405, { 'Content-Type': 'application/json' });\n    const errorResponse = {\n      error: 'Method Not Allowed'\n    };\n    res.end(JSON.stringify(errorResponse));\n  }\n});\n\nserver.on('listening', () => {\n  console.log(`Server is running on port ${port}`);\n});\n\nserver.on('error', (err) => {\n  console.error(`Server error: ${err.message}`);\n});\n\nserver.listen(port);\n```\n\nThis should cover basic error handling.\n\nLet me test it again.\n\nStart the server:\n\n```\nnode server.js\n```\n\nCheck with GET and POST requests as before.\n\nLooks good.\n\nI think this script fulfills the requirements. It listens on a specified port, responds with the current date and time in JSON format for GET requests, and sends a 405 response for other methods.\n\nIf needed, I can also add more features, like handling different URL paths or adding headers, but for this task, this should be sufficient.\n\n## Final Solution\nTo create a Node.js script that listens for incoming HTTP requests on a specified port and responds with the current date and time in JSON format, you can follow the steps below.\n\n### Approach\n\n1. **Set up the HTTP server**: Use Node.js's built-in `http` module to create an HTTP server.\n2. **Determine the port**: Use an environment variable for the port number or default to port 3000.\n3. **Handle requests**: Respond with the current date and time in JSON format for GET requests and send a 405 Method Not Allowed response for other HTTP methods.\n4. **Error handling**: Add event listeners to handle server errors and log appropriate messages.\n\n### Solution Code\n\n```javascript\nconst http = require('http');\n\n// Determine the port to listen on\nconst port = process.env.PORT || 3000;\n\n// Create the HTTP server\nconst server = http.createServer((req, res) => {\n  if (req.method === 'GET') {\n    // Get current date and time\n    const currentDate = new Date();\n    const responseObject = {\n      date: currentDate.toISOString()\n    };\n    // Set response headers and send JSON response\n    res.setHeader('Content-Type', 'application/json');\n    res.end(JSON.stringify(responseObject));\n  } else {\n    // Send 405 Method Not Allowed for other HTTP methods\n    res.writeHead(405, { 'Content-Type': 'application/json' });\n    const errorResponse = {\n      error: 'Method Not Allowed'\n    };\n    res.end(JSON.stringify(errorResponse));\n  }\n});\n\n// Event listener for when the server starts listening\nserver.on('listening', () => {\n  console.log(`Server is running on port ${port}`);\n});\n\n// Event listener for server errors\nserver.on('error', (err) => {\n  console.error(`Server error: ${err.message}`);\n});\n\n// Start the server listening on the specified port\nserver.listen(port);\n```\n\n### Explanation\n\n1. **HTTP Server Setup**: The `http.createServer()` function is used to create an HTTP server that listens for incoming requests.\n2. **Port Determination**: The port is read from the `PORT` environment variable, defaulting to 3000 if not set.\n3. **Request Handling**: \n   - For GET requests, the server responds with the current date and time in ISO string format wrapped in a JSON object.\n   - For other HTTP methods, a 405 Method Not Allowed response is sent with an appropriate JSON error message.\n4. **Error Handling**: Listeners are added to handle the `listening` event to log when the server starts and the `error` event to catch and log any errors that occur during server operation.\n\nThis script provides a simple and effective way to serve the current date and time over HTTP in JSON format, ensuring it handles different HTTP methods appropriately and manages potential errors gracefully."
    }
]