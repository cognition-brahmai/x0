[
    {
        "role": "user",
        "content": "Write a Java program that implements a Binary Search Tree data structure, with methods for inserting, searching, and deleting nodes. The program should demonstrate these operations using sample data."
    },
    {
        "role": "assistant",
        "content": "Alright, I'm going to write a Java program that implements a Binary Search Tree (BST). A BST is a tree data structure where each node has at most two children, referred to as the left child and the right child. For each node, all elements in the left subtree are less than the node, and all elements in the right subtree are greater than the node.\n\nFirst, I need to define the structure of a node in the BST. Each node will hold an integer value, a reference to the left child, and a reference to the right child.\n\nNext, I'll create a BST class that will have methods to insert a new node, search for a node with a given value, and delete a node with a given value.\n\nI should also think about how to handle the deletion operation, as it can be a bit tricky in a BST. There are three cases to consider when deleting a node:\n\n1. The node to be deleted is a leaf node (no children).\n\n2. The node to be deleted has one child.\n\n3. The node to be deleted has two children.\n\nFor the third case, I need to find the in-order successor (the smallest node in the right subtree) or the in-order predecessor (the largest node in the left subtree) and replace the node's value with the successor's value, then delete the successor node.\n\nI should also consider that duplicate values need to be handled appropriately. For simplicity, I'll assume that duplicates are not allowed in the tree.\n\nLet me start by defining the Node class.\n\n## Final Solution\nTo implement a Binary Search Tree (BST) in Java, we need to create a tree where each node has a value and references to left and right children. The left child must have a value less than its parent, and the right child must have a value greater than its parent. This structure allows for efficient searching, insertion, and deletion operations.\n\n### Approach\n\n1. **Node Class**: Represents each node in the BST with an integer value, and references to left and right children.\n2. **BST Class**: Manages the tree operations:\n   - **Insertion**: Adds a new node while maintaining the BST properties.\n   - **Search**: Finds a node with a specific value.\n   - **Deletion**: Removes a node with a specific value, handling different cases based on the number of children the node has.\n\n### Solution Code\n\n```java\nclass Node {\n    int value;\n    Node left, right;\n\n    Node(int item) {\n        value = item;\n        left = right = null;\n    }\n}\n\npublic class BST {\n    Node root;\n\n    BST() {\n        root = null;\n    }\n\n    void insert(int value) {\n        root = insertRec(root, value);\n    }\n\n    Node insertRec(Node root, int value) {\n        if (root == null) {\n            root = new Node(value);\n            return root;\n        }\n\n        if (value < root.value)\n            root.left = insertRec(root.left, value);\n        else if (value > root.value)\n            root.right = insertRec(root.right, value);\n\n        return root;\n    }\n\n    void delete(int value) {\n        root = deleteRec(root, value);\n    }\n\n    Node deleteRec(Node root, int value) {\n        if (root == null) return root;\n\n        if (value < root.value)\n            root.left = deleteRec(root.left, value);\n        else if (value > root.value)\n            root.right = deleteRec(root.right, value);\n        else {\n            if (root.left == null)\n                return root.right;\n            else if (root.right == null)\n                return root.left;\n\n            root.value = minValue(root.right);\n            root.right = deleteRec(root.right, root.value);\n        }\n\n        return root;\n    }\n\n    int minValue(Node root) {\n        int minValue = root.value;\n        while (root.left != null) {\n            minValue = root.left.value;\n            root = root.left;\n        }\n        return minValue;\n    }\n\n    Node search(int value) {\n        return searchRec(root, value);\n    }\n\n    Node searchRec(Node root, int value) {\n        if (root == null || root.value == value)\n            return root;\n\n        if (value < root.value)\n            return searchRec(root.left, value);\n        return searchRec(root.right, value);\n    }\n\n    public static void main(String[] args) {\n        BST tree = new BST();\n\n        // Inserting nodes\n        tree.insert(50);\n        tree.insert(30);\n        tree.insert(20);\n        tree.insert(40);\n        tree.insert(70);\n        tree.insert(60);\n        tree.insert(80);\n\n        // Searching for nodes\n        if (tree.search(20) != null)\n            System.out.println(\"20 is found\");\n        else\n            System.out.println(\"20 not found\");\n\n        if (tree.search(90) != null)\n            System.out.println(\"90 is found\");\n        else\n            System.out.println(\"90 not found\");\n\n        // Deleting nodes\n        tree.delete(20);\n        if (tree.search(20) != null)\n            System.out.println(\"20 is found\");\n        else\n            System.out.println(\"20 not found\");\n\n        tree.delete(30);\n        if (tree.search(30) != null)\n            System.out.println(\"30 is found\");\n        else\n            System.out.println(\"30 not found\");\n\n        tree.delete(50);\n        if (tree.search(50) != null)\n            System.out.println(\"50 is found\");\n        else\n            System.out.println(\"50 not found\");\n    }\n}\n```\n\n### Explanation\n\n1. **Node Class**: Represents each node in the BST with an integer value and left and right child pointers.\n2. **BST Class**:\n   - **Insertion**: Recursively finds the correct position for a new value and inserts a new node.\n   - **Search**: Recursively searches for a node with a specified value.\n   - **Deletion**: Handles three cases:\n     - Deleting a leaf node.\n     - Deleting a node with one child.\n     - Deleting a node with two children by finding the in-order successor and replacing the node's value.\n3. **Main Method**: Demonstrates insertion, searching, and deletion operations with sample data.\n\nThis implementation ensures that the BST properties are maintained throughout all operations."
    }
]