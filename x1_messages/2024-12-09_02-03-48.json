[
    {
        "role": "user",
        "content": "Implement a Binary Search Tree (BST) in C++ with the following functionalities: insertion, deletion, search, and traversal (in-order, pre-order, post-order).\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Implementing a Binary Search Tree (BST) in C++ involves creating a data structure that allows for efficient insertion, deletion, searching, and traversal operations. Below is a step-by-step implementation of a BST with these functionalities.\n\n### Step 1: Define the Node Structure\n\nFirst, we need to define the structure of a node in the BST. Each node will contain an integer value, and pointers to its left and right children.\n\n```cpp\nstruct Node {\n    int data;\n    Node* left;\n    Node* right;\n    Node(int val) : data(val), left(nullptr), right(nullptr) {}\n};\n```\n\n### Step 2: Implement the BST Class\n\nNext, we create a class for the BST that will contain methods for insertion, deletion, search, and traversals.\n\n```cpp\nclass BST {\nprivate:\n    Node* root;\n\n    // Helper functions\n    Node* insert(Node* node, int val);\n    Node* minValueNode(Node* node);\n    Node* deleteNode(Node* node, int val);\n    void inOrder(Node* node);\n    void preOrder(Node* node);\n    void postOrder(Node* node);\n\npublic:\n    BST() : root(nullptr) {}\n    ~BST();\n    void insert(int val);\n    void deleteNode(int val);\n    bool search(int val);\n    void inOrder();\n    void preOrder();\n    void postOrder();\n};\n```\n\n### Step 3: Implement Insertion\n\nInsertion in a BST involves finding the correct position for the new value based on the BST properties (left child < parent < right child).\n\n```cpp\nNode* BST::insert(Node* node, int val) {\n    if (node == nullptr) {\n        return new Node(val);\n    }\n    if (val < node->data) {\n        node->left = insert(node->left, val);\n    } else if (val > node->data) {\n        node->right = insert(node->right, val);\n    }\n    return node;\n}\n\nvoid BST::insert(int val) {\n    root = insert(root, val);\n}\n```\n\n### Step 4: Implement Deletion\n\nDeletion in a BST is more complex and involves three cases:\n1. Deleting a node with no children.\n2. Deleting a node with one child.\n3. Deleting a node with two children.\n\n```cpp\nNode* BST::minValueNode(Node* node) {\n    Node* current = node;\n    while (current && current->left != nullptr)\n        current = current->left;\n    return current;\n}\n\nNode* BST::deleteNode(Node* root, int val) {\n    if (root == nullptr)\n        return root;\n    if (val < root->data)\n        root->left = deleteNode(root->left, val);\n    else if (val > root->data)\n        root->right = deleteNode(root->right, val);\n    else {\n        if (root->left == nullptr) {\n            Node* temp = root->right;\n            delete root;\n            return temp;\n        } else if (root->right == nullptr) {\n            Node* temp = root->left;\n            delete root;\n            return temp;\n        }\n        Node* temp = minValueNode(root->right);\n        root->data = temp->data;\n        root->right = deleteNode(root->right, temp->data);\n    }\n    return root;\n}\n\nvoid BST::deleteNode(int val) {\n    root = deleteNode(root, val);\n}\n```\n\n### Step 5: Implement Search\n\nSearching in a BST involves comparing the search value with the node's value and deciding to go left or right accordingly.\n\n```cpp\nbool BST::search(int val) {\n    Node* current = root;\n    while (current != nullptr) {\n        if (val < current->data)\n            current = current->left;\n        else if (val > current->data)\n            current = current->right;\n        else\n            return true;\n    }\n    return false;\n}\n```\n\n### Step 6: Implement Traversals\n\nTraversal methods include in-order, pre-order, and post-order traversals.\n\n```cpp\nvoid BST::inOrder(Node* node) {\n    if (node != nullptr) {\n        inOrder(node->left);\n        std::cout << node->data << \" \";\n        inOrder(node->right);\n    }\n}\n\nvoid BST::preOrder(Node* node) {\n    if (node != nullptr) {\n        std::cout << node->data << \" \";\n        preOrder(node->left);\n        preOrder(node->right);\n    }\n}\n\nvoid BST::postOrder(Node* node) {\n    if (node != nullptr) {\n        postOrder(node->left);\n        postOrder(node->right);\n        std::cout << node->data << \" \";\n    }\n}\n\nvoid BST::inOrder() {\n    inOrder(root);\n    std::cout << std::endl;\n}\n\nvoid BST::preOrder() {\n    preOrder(root);\n    std::cout << std::endl;\n}\n\nvoid BST::postOrder() {\n    postOrder(root);\n    std::cout << std::endl;\n}\n```\n\n### Step 7: Implement Destructor\n\nThe destructor is used to deallocate the memory used by the tree nodes.\n\n```cpp\nBST::~BST() {\n    // Implement tree deletion if needed\n}\n```\n\n### Step 8: Usage Example\n\nHere's how you can use the BST class:\n\n```cpp\nint main() {\n    BST tree;\n    tree.insert(50);\n    tree.insert(30);\n    tree.insert(20);\n    tree.insert(40);\n    tree.insert(70);\n    tree.insert(60);\n    tree.insert(80);\n\n    std::cout << \"In-order traversal: \";\n    tree.inOrder();\n\n    std::cout << \"Pre-order traversal: \";\n    tree.preOrder();\n\n    std::cout << \"Post-order traversal: \";\n    tree.postOrder();\n\n    std::cout << \"Search 40: \" << (tree.search(40) ? \"Found\" : \"Not Found\") << std::endl;\n    std::cout << \"Search 90: \" << (tree.search(90) ? \"Found\" : \"Not Found\") << std::endl;\n\n    tree.deleteNode(20);\n    std::cout << \"After deleting 20:\" << std::endl;\n    tree.inOrder();\n\n    tree.deleteNode(30);\n    std::cout << \"After deleting 30:\" << std::endl;\n    tree.inOrder();\n\n    tree.deleteNode(50);\n    std::cout << \"After deleting 50:\" << std::endl;\n    tree.inOrder();\n\n    return 0;\n}\n```\n\nThis implementation provides a basic Binary Search Tree with insertion, deletion, search, and traversal operations. You can expand upon this by adding more features such as balancing the tree for better performance or implementing additional operations like finding the height of the tree."
    }
]