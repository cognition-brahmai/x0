[
    {
        "role": "user",
        "content": "Implement Dijkstra's shortest path algorithm in Python. Given a weighted graph represented as an adjacency matrix, find the shortest path between two nodes and return the path and its total weight. PLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Certainly! Dijkstra's algorithm is a popular method for finding the shortest path between two nodes in a graph with non-negative edge weights. Below is a Python implementation of Dijkstra's algorithm that takes a weighted graph represented as an adjacency matrix and returns the shortest path between two specified nodes along with its total weight.\n\n```python\nimport sys\nimport heapq\n\ndef dijkstra(adj_matrix, start, end):\n    n = len(adj_matrix)\n    visited = [False] * n\n    distances = [sys.maxsize] * n\n    distances[start] = 0\n    path = [-1] * n  # To reconstruct the path\n    \n    # Min-heap to always extract the node with the smallest distance\n    min_heap = []\n    heapq.heappush(min_heap, (0, start))\n    \n    while min_heap:\n        current_distance, current_node = heapq.heappop(min_heap)\n        \n        # Skip if this node has already been visited\n        if visited[current_node]:\n            continue\n        visited[current_node] = True\n        \n        # Explore neighbors\n        for neighbor in range(n):\n            weight = adj_matrix[current_node][neighbor]\n            if weight > 0 and not visited[neighbor]:\n                new_distance = distances[current_node] + weight\n                if new_distance < distances[neighbor]:\n                    distances[neighbor] = new_distance\n                    path[neighbor] = current_node\n                    heapq.heappush(min_heap, (new_distance, neighbor))\n    \n    # Reconstruct the path\n    shortest_path = []\n    node = end\n    while node != -1:\n        shortest_path.insert(0, node)\n        node = path[node]\n    \n    return shortest_path, distances[end]\n\n# Example usage:\nadj_matrix = [\n    [0, 10, 20, 0, 0],\n    [10, 0, 5, 16, 1],\n    [20, 5, 0, 20, 2],\n    [0, 16, 20, 0, 5],\n    [0, 1, 2, 5, 0]\n]\n\nstart_node = 0\nend_node = 3\npath, total_weight = dijkstra(adj_matrix, start_node, end_node)\nprint(\"Shortest path:\", path)\nprint(\"Total weight:\", total_weight)\n```\n\n### Explanation:\n1. **Initialization**:\n   - `visited`: Tracks visited nodes to avoid processing them multiple times.\n   - `distances`: Keeps track of the shortest distance from the start node to each node. Initialize with a large value except for the start node, which is 0.\n   - `path`: Used to reconstruct the path once the algorithm completes.\n\n2. **Min-Heap**:\n   - A min-heap is used to efficiently get the node with the smallest distance.\n   - Start by pushing the start node with distance 0 into the heap.\n\n3. **Processing**:\n   - While the heap is not empty, pop the node with the smallest distance.\n   - If the node has already been visited, skip it.\n   - For each neighbor of the current node, calculate the new distance through the current node.\n   - If this new distance is smaller than the previously known distance, update the distance and the path, and push the neighbor into the heap with the new distance.\n\n4. **Path Reconstruction**:\n   - Once the algorithm completes, reconstruct the path from the end node to the start node using the `path` array.\n   - Return the shortest path and its total weight.\n\nThis implementation ensures that you get the shortest path and its total weight efficiently, even in a graph with many nodes and edges."
    }
]