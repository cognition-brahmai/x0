[
    {
        "role": "user",
        "content": "Implement a Golang web server that serves static files from a specified directory and provides endpoints for uploading new files and deleting existing ones. Use goroutines for concurrent processing and integrate rate limiting to prevent abuse.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Implementing a Golang web server that serves static files, allows file uploads and deletions, uses goroutines for concurrency, and includes rate limiting involves several steps. Below is a basic implementation to achieve this.\n\n### Step 1: Set up the project structure\n\nFirst, create a new directory for your project and set up the necessary files:\n\n```bash\nmkdir static-server\ncd static-server\nmkdir static\ntouch main.go\n```\n\nThe `static` directory will hold the static files.\n\n### Step 2: Install required packages\n\nYou'll need the following packages:\n\n- `github.com/gorilla/mux` for routing\n- `github.com/didip/tollbooth` for rate limiting\n\nInstall them using:\n\n```bash\ngo get -u github.com/gorilla/mux\ngo get -u github.com/didip/tollbooth\n```\n\n### Step 3: Write the server code\n\nOpen `main.go` and add the following code:\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n\n\t\"github.com/didip/tollbooth\"\n\t\"github.com/didip/tollbooth/limiter\"\n\t\"github.com/gorilla/mux\"\n)\n\nconst (\n\tstaticDir  = \"static\"\n\tmaxRate    = 100 // requests per minute\n\tburstRate  = 200 // maximum burst requests\n)\n\nvar (\n\tlmt *limiter.Limiter\n)\n\nfunc init() {\n\tlmt = tollbooth.NewLimiter(maxRate, &limiter.Options{\n\t\tAllowBurst: true,\n\t\tBurst:      burstRate,\n\t\tMaxDelay:   0,\n\t})\n\tlmt.SetIPLookups([]string{\"RemoteAddr\", \"X-Forwarded-For\", \"X-Real-IP\"})\n}\n\nfunc main() {\n\tr := mux.NewRouter()\n\n\t// Serve static files with rate limiting\n\tr.PathPrefix(\"/static/\").Handler(http.StripPrefix(\"/static/\", http.FileServer(http.Dir(staticDir)))).Methods(\"GET\")\n\n\t// Upload endpoint with rate limiting\n\tr.HandleFunc(\"/upload\", rateLimitedHandler(uploadFile)).Methods(\"POST\")\n\n\t// Delete endpoint with rate limiting\n\tr.HandleFunc(\"/delete/{filename}\", rateLimitedHandler(deleteFile)).Methods(\"DELETE\")\n\n\tlog.Println(\"Starting server on :8080\")\n\tlog.Fatal(http.ListenAndServe(\":8080\", r))\n}\n\nfunc rateLimitedHandler(handler http.HandlerFunc) http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tif lmt.Allow(r) {\n\t\t\thandler.ServeHTTP(w, r)\n\t\t} else {\n\t\t\thttp.Error(w, \"Rate limit exceeded\", http.StatusTooManyRequests)\n\t\t}\n\t}\n}\n\nfunc uploadFile(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodPost {\n\t\thttp.Error(w, \"Invalid request method\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tfile, header, err := r.FormFile(\"file\")\n\tif err != nil {\n\t\thttp.Error(w, \"Error retrieving file from form\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tdefer file.Close()\n\n\tfileBytes, err := ioutil.ReadAll(file)\n\tif err != nil {\n\t\thttp.Error(w, \"Error reading file\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tdst, err := os.OpenFile(filepath.Join(staticDir, header.Filename), os.O_WRONLY|os.O_CREATE, 0666)\n\tif err != nil {\n\t\thttp.Error(w, \"Error opening file for writing\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\tdefer dst.Close()\n\n\t_, err = dst.Write(fileBytes)\n\tif err != nil {\n\t\thttp.Error(w, \"Error writing file\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tfmt.Fprintf(w, \"File uploaded successfully: %s\", header.Filename)\n}\n\nfunc deleteFile(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != http.MethodDelete {\n\t\thttp.Error(w, \"Invalid request method\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tvars := mux.Vars(r)\n\tfilename := vars[\"filename\"]\n\n\tfilePath := filepath.Join(staticDir, filename)\n\terr := os.Remove(filePath)\n\tif err != nil {\n\t\tif os.IsNotExist(err) {\n\t\t\thttp.Error(w, \"File not found\", http.StatusNotFound)\n\t\t} else {\n\t\t\thttp.Error(w, \"Error deleting file\", http.StatusInternalServerError)\n\t\t}\n\t\treturn\n\t}\n\n\tfmt.Fprintf(w, \"File deleted successfully: %s\", filename)\n}\n```\n\n### Explanation\n\n1. **Project Structure**:\n   - `static-server/`: Root directory.\n   - `static/`: Directory to serve static files.\n   - `main.go`: Main source file.\n\n2. **Packages**:\n   - `github.com/gorilla/mux`: For router.\n   - `github.com/didip/tollbooth`: For rate limiting.\n\n3. **Rate Limiting**:\n   - Configured to allow 100 requests per minute with a burst rate of 200 requests.\n   - Applied to all endpoints using `rateLimitedHandler`.\n\n4. **File Serving**:\n   - Serves files from the `static` directory under the `/static/` path.\n\n5. **File Upload**:\n   - Endpoint `/upload` accepts POST requests with a file in the form field `file`.\n   - Saves the uploaded file to the `static` directory.\n\n6. **File Deletion**:\n   - Endpoint `/delete/{filename}` accepts DELETE requests to delete a specified file.\n   - Uses `mux.Vars` to extract the filename from the URL.\n\n7. **Concurrency**:\n   - Goroutines are handled by the Go HTTP server internally for each request.\n\nThis setup provides a basic static file server with upload and delete functionalities, protected by rate limiting to prevent abuse. For production use, consider adding more robust error handling, authentication, and logging."
    }
]