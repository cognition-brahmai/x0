[
    {
        "role": "user",
        "content": "Implement a binary search tree in C++ with the following operations: insert, delete, search, and find the minimum and maximum elements."
    },
    {
        "role": "assistant",
        "content": "Sure! Implementing a binary search tree (BST) in C++ involves creating a structure for the nodes and defining functions for insertion, deletion, search, and finding the minimum and maximum elements. Below is a step-by-step guide to achieve this.\n\n### Step 1: Define the Node Structure\n\nFirst, we need to define a structure for the nodes of the BST. Each node will contain an integer key and pointers to its left and right children.\n\n```cpp\nstruct Node {\n    int key;\n    Node* left;\n    Node* right;\n    Node(int k) : key(k), left(nullptr), right(nullptr) {}\n};\n```\n\n### Step 2: Implement the Insert Function\n\nThe insert function will add a new node with the given key into the BST.\n\n```cpp\nNode* insert(Node* root, int key) {\n    if (root == nullptr) {\n        return new Node(key);\n    }\n    if (key < root->key) {\n        root->left = insert(root->left, key);\n    } else if (key > root->key) {\n        root->right = insert(root->right, key);\n    }\n    return root;\n}\n```\n\n### Step 3: Implement the Search Function\n\nThe search function will check if a node with the given key exists in the BST.\n\n```cpp\nbool search(Node* root, int key) {\n    if (root == nullptr) {\n        return false;\n    }\n    if (root->key == key) {\n        return true;\n    } else if (key < root->key) {\n        return search(root->left, key);\n    } else {\n        return search(root->right, key);\n    }\n}\n```\n\n### Step 4: Implement the Find Minimum Function\n\nThe find minimum function will return the node with the smallest key in the BST.\n\n```cpp\nNode* findMin(Node* root) {\n    if (root == nullptr) {\n        return nullptr;\n    }\n    if (root->left == nullptr) {\n        return root;\n    }\n    return findMin(root->left);\n}\n```\n\n### Step 5: Implement the Find Maximum Function\n\nThe find maximum function will return the node with the largest key in the BST.\n\n```cpp\nNode* findMax(Node* root) {\n    if (root == nullptr) {\n        return nullptr;\n    }\n    if (root->right == nullptr) {\n        return root;\n    }\n    return findMax(root->right);\n}\n```\n\n### Step 6: Implement the Delete Function\n\nThe delete function will remove a node with the given key from the BST.\n\n```cpp\nNode* deleteNode(Node* root, int key) {\n    if (root == nullptr) {\n        return root;\n    }\n    if (key < root->key) {\n        root->left = deleteNode(root->left, key);\n    } else if (key > root->key) {\n        root->right = deleteNode(root->right, key);\n    } else {\n        if (root->left == nullptr) {\n            Node* temp = root->right;\n            delete root;\n            return temp;\n        } else if (root->right == nullptr) {\n            Node* temp = root->left;\n            delete root;\n            return temp;\n        }\n        Node* temp = findMin(root->right);\n        root->key = temp->key;\n        root->right = deleteNode(root->right, temp->key);\n    }\n    return root;\n}\n```\n\n### Step 7: Implement a Function to Print the BST (Inorder Traversal)\n\nThis function will help verify the structure of the BST.\n\n```cpp\nvoid inorder(Node* root) {\n    if (root != nullptr) {\n        inorder(root->left);\n        std::cout << root->key << \" \";\n        inorder(root->right);\n    }\n}\n```\n\n### Step 8: Main Function\n\nFinally, the main function to test the BST operations.\n\n```cpp\n#include <iostream>\nusing namespace std;\n\nint main() {\n    Node* root = nullptr;\n    root = insert(root, 50);\n    insert(root, 30);\n    insert(root, 20);\n    insert(root, 40);\n    insert(root, 70);\n    insert(root, 60);\n    insert(root, 80);\n\n    cout << \"Inorder traversal of the given tree \\n\";\n    inorder(root);\n\n    cout << \"\\nDelete 20\\n\";\n    root = deleteNode(root, 20);\n    inorder(root);\n\n    cout << \"\\nDelete 30\\n\";\n    root = deleteNode(root, 30);\n    inorder(root);\n\n    cout << \"\\nDelete 50\\n\";\n    root = deleteNode(root, 50);\n    inorder(root);\n\n    cout << \"\\nMin element is \" << (findMin(root))->key << endl;\n    cout << \"Max element is \" << (findMax(root))->key << endl;\n\n    cout << \"Search 40: \" << search(root, 40) << endl;\n    cout << \"Search 100: \" << search(root, 100) << endl;\n\n    return 0;\n}\n```\n\nThis code covers all the required operations for a binary search tree in C++. You can compile and run this code to see the BST in action."
    }
]