[
    {
        "role": "user",
        "content": "Write a Golang program that serves a simple RESTful API with endpoints for creating, reading, updating, and deleting records in a SQLite database.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Alright, I'll help you write a simple RESTful API in Golang that interacts with a SQLite database. We'll create endpoints for CRUD operations: Create, Read, Update, and Delete.\n\nFirst, make sure you have Go installed on your machine. You can download it from https://golang.org/dl/.\n\nWe'll also need the following packages:\n\n- `gorilla/mux` for routing\n\n- `database/sql` for database operations\n\n- `github.com/mattn/go-sqlite3` as the SQLite driver\n\nYou can install these using `go get`:\n\n```sh\ngo get -u github.com/gorilla/mux\n\ngo get -u github.com/mattn/go-sqlite3\n```\n\nLet's start by setting up the basic structure of our project.\n\n## Project Structure\n\n```\n/restful-api/\n\nmain.go\n\nmodel/\n\ndb.go\n\nrecord.go\n\nhandler/\n\nrecord_handler.go\n\nrouter/\n\nrouter.go\n```\n\n## Step 1: Define the Model\n\nFirst, we need to define what a record is. For simplicity, let's assume a record has an ID and a name.\n\n### model/record.go\n\n```go\n\npackage model\n\ntype Record struct {\n\nID int `json:\"id\"`\n\nName string `json:\"name\"`\n\n}\n```\n\n## Step 2: Set Up the Database\n\nWe need to create a SQLite database and a table to store our records.\n\n### model/db.go\n\n```go\n\npackage model\n\nimport (\n\n\"database/sql\"\n\n\"fmt\"\n\n\"log\"\n\n\"github.com/mattn/go-sqlite3\"\n\n)\n\nvar db *sql.DB\n\nfunc InitDB() {\n\nvar err error\n\ndb, err = sql.Open(\"sqlite3\", \"./records.db\")\n\nif err != nil {\n\nlog.Fatal(err)\n\n}\n\nerr = db.Ping()\n\nif err != nil {\n\nlog.Fatal(err)\n\n}\n\nfmt.Println(\"Connected to SQLite\")\n\ncreateTable()\n\n}\n\nfunc createTable() {\n\nsqlStatement := `CREATE TABLE IF NOT EXISTS records (\n\nid INTEGER PRIMARY KEY AUTOINCREMENT,\n\nname TEXT NOT NULL\n\n);`\n\n_, err := db.Exec(sqlStatement)\n\nif err != nil {\n\nlog.Fatalf(\"Failed to create table: %s\", err)\n\n}\n\nfmt.Println(\"records table created.\")\n\n}\n```\n\nIn this file, we initialize the database connection and create a table named `records` if it doesn't exist.\n\n## Step 3: Create Handlers for CRUD Operations\n\nNow, we'll create handlers for each CRUD operation.\n\n### handler/record_handler.go\n\n```go\n\npackage handler\n\nimport (\n\n\"net/http\"\n\n\"strconv\"\n\n\"github.com/gorilla/mux\"\n\n\"github.com/yourusername/restful-api/model\"\n\n)\n\n// Create a new record\n\nfunc CreateRecord(w http.ResponseWriter, r *http.Request) {\n\nvar record model.Record\n\n// Read the JSON body into the record struct\n\nerr := json.NewDecoder(r.Body).Decode(&record)\n\nif err != nil {\n\nhttp.Error(w, err.Error(), http.StatusBadRequest)\n\nreturn\n\n}\n\nstmt, err := model.DB.Prepare(\"INSERT INTO records(name) VALUES(?)\")\n\nif err != nil {\n\nlog.Println(err)\n\nhttp.Error(w, \"Internal server error\", http.StatusInternalServerError)\n\nreturn\n\n}\n\nres, err := stmt.Exec(record.Name)\n\nif err != nil {\n\nlog.Println(err)\n\nhttp.Error(w, \"Internal server error\", http.StatusInternalServerError)\n\nreturn\n\n}\n\nlastID, err := res.LastInsertId()\n\nif err != nil {\n\nlog.Println(err)\n\nhttp.Error(w, \"Internal server error\", http.StatusInternalServerError)\n\nreturn\n\n}\n\nrecord.ID = int(lastID)\n\nw.Header().Set(\"Content-Type\", \"application/json\")\n\njson.NewEncoder(w).Encode(record)\n\n}\n\n// Get all records\n\nfunc GetRecords(w http.ResponseWriter, r *http.Request) {\n\nrows, err := model.DB.Query(\"SELECT id, name FROM records\")\n\nif err != nil {\n\nlog.Println(err)\n\nhttp.Error(w, \"Internal server error\", http.StatusInternalServerError)\n\nreturn\n\n}\n\ndefer rows.Close()\n\nvar records []model.Record\n\nfor rows.Next() {\n\nvar record model.Record\n\nerr := rows.Scan(&record.ID, &record.Name)\n\nif err != nil {\n\nlog.Println(err)\n\nhttp.Error(w, \"Internal server error\", http.StatusInternalServerError)\n\nreturn\n\n}\n\nrecords = append(records, record)\n\n}\n\nw.Header().Set(\"Content-Type\", \"application/json\")\n\njson.NewEncoder(w).Encode(records)\n\n}\n\n// Get a single record by ID\n\nfunc GetRecord(w http.ResponseWriter, r *http.Request) {\n\nparams := mux.Vars(r)\n\n\tidStr := params[\"id\"]\n\n\tid, err := strconv.Atoi(idStr)\n\n\tif err != nil {\n\n\thttp.Error(w, \"Invalid ID\", http.StatusBadRequest)\n\n\treturn\n\n\t}\n\n\trow := model.DB.QueryRow(\"SELECT id, name FROM records WHERE id=?\", id)\n\n\tvar record model.Record\n\n\terr = row.Scan(&record.ID, &record.Name)\n\n\tif err == sql.ErrNoRows {\n\n\thttp.Error(w, \"Record not found\", http.StatusNotFound)\n\n\treturn\n\n\t} else if err != nil {\n\n\tlog.Println(err)\n\n\thttp.Error(w, \"Internal server error\", http.StatusInternalServerError)\n\n\treturn\n\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\n\tjson.NewEncoder(w).Encode(record)\n\n}\n\n// Update a record\n\nfunc UpdateRecord(w http.ResponseWriter, r *http.Request) {\n\n\tparams := mux.Vars(r)\n\n\tidStr := params[\"id\"]\n\n\tid, err := strconv.Atoi(idStr)\n\n\tif err != nil {\n\n\thttp.Error(w, \"Invalid ID\", http.StatusBadRequest)\n\n\treturn\n\n\t}\n\n\tvar record model.Record\n\n\terr = json.NewDecoder(r.Body).Decode(&record)\n\n\tif err != nil {\n\n\thttp.Error(w, err.Error(), http.StatusBadRequest)\n\n\treturn\n\n\t}\n\n\tstmt, err := model.DB.Prepare(\"UPDATE records SET name=? WHERE id=?\")\n\n\tif err != nil {\n\n\tlog.Println(err)\n\n\thttp.Error(w, \"Internal server error\", http.StatusInternalServerError)\n\n\treturn\n\n\t}\n\n\tres, err := stmt.Exec(record.Name, id)\n\n\tif err != nil {\n\n\tlog.Println(err)\n\n\thttp.Error(w, \"Internal server error\", http.StatusInternalServerError)\n\n\treturn\n\n\t}\n\n\trowsAffected, err := res.RowsAffected()\n\n\tif err != nil {\n\n\tlog.Println(err)\n\n\thttp.Error(w, \"Internal server error\", http.StatusInternalServerError)\n\n\treturn\n\n\t}\n\n\tif rowsAffected == 0 {\n\n\thttp.Error(w, \"Record not found\", http.StatusNotFound)\n\n\treturn\n\n\t}\n\n\trecord.ID = id\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\n\tjson.NewEncoder(w).Encode(record)\n\n}\n\n// Delete a record\n\nfunc DeleteRecord(w http.ResponseWriter, r *http.Request) {\n\n\tparams := mux.Vars(r)\n\n\tidStr := params[\"id\"]\n\n\tid, err := strconv.Atoi(idStr)\n\n\tif err != nil {\n\n\thttp.Error(w, \"Invalid ID\", http.StatusBadRequest)\n\n\treturn\n\n\t}\n\n\tres, err := model.DB.Exec(\"DELETE FROM records WHERE id=?\", id)\n\n\tif err != nil {\n\n\tlog.Println(err)\n\n\thttp.Error(w, \"Internal server error\", http.StatusInternalServerError)\n\n\treturn\n\n\t}\n\n\trowsAffected, err := res.RowsAffected()\n\n\tif err != nil {\n\n\tlog.Println(err)\n\n\thttp.Error(w, \"Internal server error\", http.StatusInternalServerError)\n\n\treturn\n\n\t}\n\n\tif rowsAffected == 0 {\n\n\thttp.Error(w, \"Record not found\", http.StatusNotFound)\n\n\treturn\n\n\t}\n\n\tw.WriteHeader(http.StatusNoContent)\n\n}\n```\n\n## Step 4: Set Up Routing\n\nWe'll use the `gorilla/mux` router to handle different endpoints.\n\n### router/router.go\n\n```go\n\npackage router\n\nimport (\n\n\"github.com/gorilla/mux\"\n\n\"github.com/yourusername/restful-api/handler\"\n\n)\n\nfunc NewRouter() *mux.Router {\n\n\tr := mux.NewRouter()\n\n\tr.HandleFunc(\"/records\", handler.CreateRecord).Methods(\"POST\")\n\n\tr.HandleFunc(\"/records\", handler.GetRecords).Methods(\"GET\")\n\n\tr.HandleFunc(\"/records/{id}\", handler.GetRecord).Methods(\"GET\")\n\n\tr.HandleFunc(\"/records/{id}\", handler.UpdateRecord).Methods(\"PUT\")\n\n\tr.HandleFunc(\"/records/{id}\", handler.DeleteRecord).Methods(\"DELETE\")\n\n\treturn r\n\n}\n```\n\n## Step 5: Main Function\n\nFinally, in our `main.go`, we'll initialize the database and start the server.\n\n### main.go\n\n```go\n\npackage main\n\nimport (\n\n\"log\"\n\n\"net/http\"\n\n\"github.com/yourusername/restful-api/model\"\n\n\"github.com/yourusername/restful-api/router\"\n\n)\n\nfunc main() {\n\nmodel.InitDB()\n\n\tdefer model.DB.Close()\n\n\tr := router.NewRouter()\n\n\tlog.Fatal(http.ListenAndServe(\":8000\", r))\n\n}\n```\n\n## Running the Application\n\nTo run the application, navigate to the project directory and execute:\n\n```sh\n\ngo run main.go\n\n```\n\nYour API should now be running on http://localhost:8000.\n\n## Testing the API\n\nYou can use tools like Postman or curl to test the API endpoints.\n\n- **Create a record:** POST to `http://localhost:8000/records` with JSON body `{ \"name\": \"Sample Record\" }`\n\n- **Get all records:** GET `http://localhost:8000/records`\n\n- **Get a single record:** GET `http://localhost:8000/records/1`\n\n- **Update a record:** PUT to `http://localhost:8000/records/1` with JSON body `{ \"name\": \"Updated Record\" }`\n\n- **Delete a record:** DELETE `http://localhost:8000/records/1`\n\nThat's it! You've created a simple RESTful API in Golang that interacts with a SQLite database."
    }
]