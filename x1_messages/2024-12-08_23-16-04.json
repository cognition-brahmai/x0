[
    {
        "role": "user",
        "content": "Implement a Java program that uses the Dijkstra's algorithm to find the shortest path between two nodes in a weighted graph. The input should be given as an adjacency matrix, and the output should display the shortest path and its total weight.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Alright, I've got this task to implement Dijkstra's algorithm in Java to find the shortest path between two nodes in a weighted graph. The graph is represented by an adjacency matrix, and I need to output the shortest path along with its total weight. Let's break this down step by step.\n\nFirst, I need to understand what Dijkstra's algorithm is and how it works. Dijkstra's algorithm is a popular method for finding the shortest paths between nodes in a graph, which may represent, for example, road networks. It was conceived by computer scientist Edsger W. Dijkstra in 1956 and published three years later.\n\nThe algorithm starts at a given node (the source node) and iteratively explores the graph outward, always choosing the next node to be the one closest to the source that hasn't been finalized yet. It keeps track of the current shortest distance from the source to each node and updates these distances as it discovers shorter paths.\n\nNow, since the graph is given as an adjacency matrix, I need to remember that an adjacency matrix is a square matrix used to represent a finite graph. The elements of the matrix indicate whether pairs of vertices are adjacent or not in the graph. In the case of a weighted graph, the matrix elements represent the weights of the edges between the vertices.\n\nIn Java, I can represent the adjacency matrix as a 2D array. For example, if the graph has n nodes, the adjacency matrix will be an n x n array. If there is an edge from node i to node j with weight w, then matrix[i][j] = w. If there is no edge, matrix[i][j] can be set to infinity or a special value like -1 or 0, depending on the implementation.\n\nI need to decide how to handle the absence of edges. Since it's a weighted graph, I'll assume that if matrix[i][j] is 0, there is no edge between i and j. But in Dijkstra's algorithm, it's common to use infinity for no edges, so I might need to adjust that in the code.\n\nNext, I need to think about how to implement the algorithm. The standard steps are:\n\n1. Create a set of unvisited nodes.\n\n2. Assign a tentative distance value to every node: set it to zero for the initial node and infinity for all other nodes.\n\n3. Set the initial node as the current node.\n\n4. For the current node, consider all its unvisited neighbors and calculate their tentative distances through the current node.\n\n5. If a new calculated tentative distance to a neighbor is less than the previously recorded tentative distance, update it.\n\n6. When all neighbors of the current node have been considered, mark the current node as visited.\n\n7. Select the unvisited node with the smallest tentative distance, set it as the new current node, and repeat the process.\n\n8. Stop when the destination node is marked visited or when the smallest tentative distance among the unvisited nodes is infinity (which means there's no connection to the destination).\n\nI need to choose the right data structures to implement this efficiently. Since we're dealing with an adjacency matrix, which is dense, and for Dijkstra's algorithm, a priority queue is often used to efficiently select the node with the smallest tentative distance.\n\nIn Java, I can use the PriorityQueue class for this purpose. I'll need to define a custom class to represent nodes, which will include the node index and its tentative distance from the source. This class should implement the Comparable interface so that the priority queue can order them correctly.\n\nAlso, I need to keep track of which nodes have been visited to avoid processing them multiple times. For that, I can use a boolean array.\n\nLet's outline the steps in code terms:\n\n- Define a class, say, Node, with index and distance, implementing Comparable based on distance.\n\n- Initialize distances array with infinity for all nodes except the source, which is 0.\n\n- Initialize a priority queue and add the source node with distance 0.\n\n- While the priority queue is not empty:\n\n- Extract the node with the smallest distance (poll from the queue).\n\n- If this node is the destination, reconstruct and return the path.\n\n- Mark this node as visited.\n\n- For each neighbor of the current node:\n\n- If the neighbor has not been visited:\n\n- Calculate the new distance through the current node.\n\n- If this new distance is less than the current known distance:\n\n- Update the distance.\n\n- Add the neighbor to the priority queue with the updated distance.\n\n- If the destination is not reached by the time the queue is empty, there is no path.\n\nWait, actually, in Dijkstra's algorithm, we don't necessarily need to keep track of visited nodes in the same way as in some other graph algorithms. In the standard implementation, once a node is dequeued from the priority queue, its shortest distance is finalized, and we don't need to consider it again. So, perhaps it's better to avoid a separate visited array and rely on the priority queue to manage which nodes are processed.\n\nLet me correct that:\n\n- Initialize distances array with infinity for all nodes except the source, which is 0.\n\n- Initialize a priority queue to hold nodes based on their tentative distances.\n\n- Add all nodes to the priority queue.\n\n- While the priority queue is not empty:\n\n- Remove the node with the smallest distance (poll).\n\n- For each neighbor of the current node still in the queue:\n\n- Calculate the tentative distance through the current node.\n\n- If this distance is less than the neighbor's current distance:\n\n- Update the neighbor's distance.\n\n- Update the neighbor's priority in the queue.\n\nThis approach avoids a separate visited array because once a node is polled from the queue, its distance is finalized, and we don't consider it again.\n\nHowever, implementing a binary heap-based priority queue in Java's PriorityQueue doesn't support decreasing priorities directly, which could be inefficient. To handle this, we can allow multiple entries for the same node in the queue, each with different distances, but ensure that when we process a node, it's with the smallest distance.\n\nBut this can lead to increased time complexity because we might have multiple entries for the same node in the queue. To optimize, we can use a data structure that allows decreasing priorities, but in standard Java, PriorityQueue doesn't support that directly.\n\nAlternatively, since the graph is represented by an adjacency matrix, which implies a dense graph, and with n nodes, the time complexity might not be a big issue for small n.\n\nFor now, I'll proceed with using PriorityQueue and allowing multiple entries for the same node, but I'll keep track of the finalized nodes in a set to skip processing if their distance has been finalized.\n\nSo, here's a refined plan:\n\n- Initialize distances array with infinity for all nodes except the source, which is 0.\n\n- Initialize a priority queue to hold nodes based on their tentative distances.\n\n- Add the source node to the queue with distance 0.\n\n- Initialize a set to keep track of nodes whose shortest distance has been finalized.\n\n- While the priority queue is not empty:\n\n- Remove the node with the smallest distance (poll).\n\n- If this node is already in the finalized set, skip it.\n\n- Add it to the finalized set.\n\n- If this node is the destination, stop and reconstruct the path.\n\n- For each neighbor of the current node:\n\n- If the neighbor is not in the finalized set:\n\n- Calculate the tentative distance through the current node.\n\n- If this distance is less than the neighbor's current known distance:\n\n- Update the neighbor's distance.\n\n- Add the neighbor to the priority queue with the updated distance.\n\nThis way, we ensure that each node's shortest distance is finalized only once, and we don't process it again.\n\nNow, I need to think about how to reconstruct the path once the destination is reached. To do this, I need to keep track of the previous node for each node as we update their distances. This way, once the destination is reached, I can trace back from the destination to the source using the previous nodes.\n\nSo, I'll need a previous array that keeps track of the parent node for each node in the shortest path tree.\n\nLet's outline that:\n\n- Define an array previous of size n, initialized to -1 (indicating no parent).\n\n- When updating a neighbor's distance, set previous[neighbor] = current node.\n\n- Once the destination is reached, reconstruct the path by starting from the destination and following the previous nodes until reaching the source.\n\n- Collect the path in a list and reverse it to get the path from source to destination.\n\nNow, considering the input is an adjacency matrix, I need to handle the matrix properly. Since it's a 2D array, I'll assume it's passed to the method as int[][] matrix.\n\nI need to handle cases where there is no path between the source and destination. In such cases, I should output an appropriate message.\n\nAlso, I need to ensure that the graph has at least two nodes, as we need to find a path between two nodes.\n\nLet me think about the method signature. It should accept the adjacency matrix, the source node, and the destination node. It should print the shortest path and its total weight.\n\nAssuming nodes are numbered from 0 to n-1, where n is the number of nodes.\n\nI should also validate the input to ensure that the source and destination are within the valid range.\n\nEdge cases to consider:\n\n- Source and destination are the same node.\n\n- There is no path between the source and destination.\n\n- Negative weights (Dijkstra's algorithm doesn't handle negative weights, so I'll assume all weights are non-negative).\n\n- Diagonal elements of the adjacency matrix should be 0, as there is no self-loop.\n\nWait, in an adjacency matrix, diagonal elements are usually 0 because there's no edge from a node to itself. But in some representations, they might be infinite or another value. I need to ensure that diagonal elements are handled correctly.\n\nSince Dijkstra's algorithm doesn't handle negative weights, I should document that the graph must have non-negative weights.\n\nAlso, I need to decide how to represent infinity in the distances array. In Java, I can use Integer.MAX_VALUE to represent infinity.\n\nNow, let's think about the implementation in code.\n\nFirst, define the Node class:\n\nclass Node implements Comparable<Node> {\n\nint index;\n\nint distance;\n\npublic Node(int index, int distance) {\n\nthis.index = index;\n\nthis.distance = distance;\n\n}\n\n@Override\n\npublic int compareTo(Node other) {\n\nreturn Integer.compare(this.distance, other.distance);\n\n}\n\n}\n\nThen, in the main method or in a dedicated method, implement Dijkstra's algorithm as per the steps outlined earlier.\n\nHere's a rough sketch:\n\npublic static void dijkstra(int[][] matrix, int source, int destination) {\n\nint n = matrix.length;\n\nint[] distances = new int[n];\n\nint[] previous = new int[n];\n\nArrays.fill(distances, Integer.MAX_VALUE);\n\nArrays.fill(previous, -1);\n\ndistances[source] = 0;\n\nPriorityQueue<Node> queue = new PriorityQueue<>();\n\nqueue.add(new Node(source, 0));\n\nSet<Integer> finalized = new HashSet<>();\n\nwhile (!queue.isEmpty()) {\n\nNode current = queue.poll();\n\nint currentIndex = current.index;\n\nif (finalized.contains(currentIndex)) {\n\ncontinue;\n\n}\n\nfinalized.add(currentIndex);\n\nif (currentIndex == destination) {\n\n// Reconstruct path\n\nList<Integer> path = new ArrayList<>();\n\nint temp = destination;\n\nwhile (temp != -1) {\n\npath.add(temp);\n\ntemp = previous[temp];\n\n}\n\nCollections.reverse(path);\n\nSystem.out.println(\"Shortest path: \" + path);\n\nSystem.out.println(\"Total weight: \" + distances[destination]);\n\nreturn;\n\n}\n\nfor (int neighbor = 0; neighbor < n; neighbor++) {\n\nif (matrix[currentIndex][neighbor] != 0 && !finalized.contains(neighbor)) {\n\nint newDistance = distances[currentIndex] + matrix[currentIndex][neighbor];\n\nif (newDistance < distances[neighbor]) {\n\ndistances[neighbor] = newDistance;\n\nprevious[neighbor] = currentIndex;\n\nqueue.add(new Node(neighbor, newDistance));\n\n}\n\n}\n\n}\n\n}\n\n// If we reach here, there is no path to the destination\n\nSystem.out.println(\"No path found.\");\n\n}\n\nI need to test this method with a sample adjacency matrix.\n\nFor example:\n\nint[][] matrix = {\n\n{0, 10, 0, 0},\n\n{0, 0, 1, 0},\n\n{0, 0, 0, 10},\n\n{0, 0, 0, 0}\n\n};\n\nSource: 0, Destination: 3\n\nThis represents a graph with 4 nodes, where:\n\n- 0 -> 1 with weight 10\n\n- 1 -> 2 with weight 1\n\n- 2 -> 3 with weight 10\n\nSo the shortest path from 0 to 3 is 0 -> 1 -> 2 -> 3 with total weight 21.\n\nLet me run this through the algorithm:\n\n1. Initialize distances: [0, inf, inf, inf]\n\n2. Queue: [0:0]\n\n3. Dequeue 0, mark as finalized.\n\n4. Update neighbors of 0: only 1 with distance 10.\n\n5. Queue: [1:10]\n\n6. Dequeue 1, mark as finalized.\n\n7. Update neighbors of 1: only 2 with distance 11 (10 + 1).\n\n8. Queue: [2:11]\n\n9. Dequeue 2, mark as finalized.\n\n10. Update neighbors of 2: only 3 with distance 21 (11 + 10).\n\n11. Queue: [3:21]\n\n12. Dequeue 3, mark as finalized.\n\n13. Since 3 is the destination, reconstruct path: 3 -> 2 -> 1 -> 0, which is [0,1,2,3] with total weight 21.\n\nLooks correct.\n\nAnother test case: No path from source to destination.\n\nint[][] matrix = {\n\n{0, 1, 0},\n\n{1, 0, 0},\n\n{0, 0, 0}\n\n};\n\nSource: 0, Destination: 2\n\nHere, 0 -> 1 and 1 -> 0, but no path to 2.\n\nThe algorithm should detect that there's no path.\n\nLet me think about the time complexity. Since we're using a priority queue, and in each iteration, we process each node once and look at all its neighbors, the time complexity is O(n^2 log n) for an adjacency matrix representation, where n is the number of nodes.\n\nSpace complexity is O(n) for the distances, previous, and the priority queue.\n\nI need to ensure that the program handles large matrices efficiently, but since adjacency matrices can be memory-intensive for large graphs, there might be limitations.\n\nHowever, for the purpose of this task, I'll assume that the graph is small enough to fit into memory.\n\nI should also consider that the matrix is symmetric if the graph is undirected, but since it's a weighted graph, it might be directed. I need to assume that it's directed unless specified otherwise.\n\nWait, in the adjacency matrix, matrix[i][j] represents the weight from i to j, and matrix[j][i] represents the weight from j to i. If the graph is undirected, matrix[i][j] should equal matrix[j][i], but in a directed graph, they can be different.\n\nI need to make sure that the implementation works for directed graphs, as Dijkstra's algorithm can handle both directed and undirected graphs, given that all weights are non-negative.\n\nI should also consider that if matrix[i][j] is 0, it means there is no edge from i to j. So, in the code, I need to check if matrix[currentIndex][neighbor] != 0 to consider it as an edge.\n\nBut wait, in some representations, 0 might be used as the weight for an edge with no cost, so I need to clarify that in this implementation, 0 means no edge.\n\nAlternatively, I can allow custom representation, but to keep it simple, I'll assume that 0 means no edge, and positive integers represent edge weights.\n\nI should also handle cases where the source or destination is out of bounds, or if the graph is empty (n=0), but that's unlikely.\n\nLet me think about the main method to test this implementation.\n\npublic static void main(String[] args) {\n\nint[][] matrix = {\n\n{0, 10, 0, 0},\n\n{0, 0, 1, 0},\n\n{0, 0, 0, 10},\n\n{0, 0, 0, 0}\n\n};\n\nint source = 0;\n\nint destination = 3;\n\ndijkstra(matrix, source, destination);\n\n}\n\nThis should output:\n\nShortest path: [0, 1, 2, 3]\n\nTotal weight: 21\n\nAnother test case:\n\nint[][] matrix = {\n\n{0, 1, 0},\n\n{1, 0, 0},\n\n{0, 0, 0}\n\n};\n\nint source = 0;\n\nint destination = 2;\n\nOutput:\n\nNo path found.\n\nLooks good.\n\nI need to make sure that the program doesn't go into an infinite loop or handle any unexpected inputs gracefully.\n\nAlso, I should ensure that the priority queue doesn't contain duplicate nodes with different distances, but in this implementation, since we're adding new nodes with updated distances, and we have a finalized set, it should be handled correctly.\n\nOne thing to consider is that if the graph has multiple edges to the same node with different weights, but in an adjacency matrix, each pair (i,j) has only one weight.\n\nI think that's covered.\n\nLet me think about the code structure.\n\nI can encapsulate the Dijkstra's method in a class, say, ShortestPathFinder, and have the main method to test it.\n\nAlso, I can add some input validation, like checking if the matrix is square, and if the source and destination are within bounds.\n\nFor example:\n\nif (matrix == null || matrix.length == 0 || source < 0 || source >= matrix.length || destination < 0 || destination >= matrix.length) {\n\nthrow new IllegalArgumentException(\"Invalid input.\");\n\n}\n\nAlso, ensure that the matrix is square:\n\nfor (int[] row : matrix) {\n\nif (row.length != matrix.length) {\n\nthrow new IllegalArgumentException(\"Matrix must be square.\");\n\n}\n\n}\n\nBut for simplicity, I'll assume that the input matrix is square and valid.\n\nNow, let's think about how to represent the path. In the earlier sketch, I used a list of integers representing node indices. That's fine, but I can also convert them to a string for display.\n\nAlso, I need to handle the case where source and destination are the same. In that case, the path is just the source node, and the total weight is 0.\n\nLet me adjust the algorithm to handle that.\n\nIf source == destination, immediately return the path [source] and weight 0.\n\nOtherwise, proceed with the algorithm.\n\nThis optimization avoids unnecessary computation.\n\nLet me update the method accordingly.\n\nAlso, I need to ensure that the previous array is correctly updated only when the distance is improved.\n\nI should also consider that if the destination is not reachable, the previous array might not be fully populated.\n\nBut since I'm stopping once the destination is reached, I don't need to worry about that.\n\nWait, in the stopping condition, I have:\n\nif (currentIndex == destination) {\n\n// Reconstruct path\n\n...\n\nreturn;\n\n}\n\nThis ensures that once the destination is dequeued, we reconstruct the path and exit.\n\nIf the destination is not reached by the time the queue is empty, then there is no path.\n\nThat should cover all cases.\n\nLet me think about another test case.\n\nint[][] matrix = {\n\n{0, 2, 0, 0},\n\n{2, 0, 3, 0},\n\n{0, 3, 0, 1},\n\n{0, 0, 1, 0}\n\n};\n\nSource: 0, Destination: 3\n\nPaths:\n\n0 -> 1 -> 2 -> 3: 2 + 3 + 1 = 6\n\nNo other paths.\n\nSo, shortest path is [0,1,2,3] with weight 6.\n\nAnother test case with negative weights:\n\nint[][] matrix = {\n\n{0, -1, 0},\n\n{0, 0, 1},\n\n{0, 0, 0}\n\n};\n\nSource: 0, Destination: 2\n\nDijkstra's algorithm doesn't handle negative weights, so it might give incorrect results.\n\nBut as per the assumption, all weights are non-negative, so I'll document that.\n\nNow, let's think about implementing the path reconstruction.\n\nIn the earlier sketch, I used a list to build the path by tracing back from the destination using the previous array, then reversed it.\n\nThat should work.\n\nI need to ensure that if the source is the destination, the path is just [source], otherwise build the path as described.\n\nLet me write a helper method to build the path for clarity.\n\nprivate static List<Integer> buildPath(int[] previous, int source, int destination) {\n\nList<Integer> path = new ArrayList<>();\n\nint current = destination;\n\nwhile (current != source && current != -1) {\n\npath.add(current);\n\ncurrent = previous[current];\n\n}\n\nif (current == -1) {\n\nreturn new ArrayList<>(); // No path\n\n} else {\n\npath.add(source);\n\nCollections.reverse(path);\n\nreturn path;\n\n}\n\n}\n\nThen, in the dijkstra method:\n\nList<Integer> path = buildPath(previous, source, destination);\n\nif (path.isEmpty()) {\n\nSystem.out.println(\"No path found.\");\n\n} else {\n\nSystem.out.println(\"Shortest path: \" + path);\n\nSystem.out.println(\"Total weight: \" + distances[destination]);\n\n}\n\nThis way, it's cleaner.\n\nAlso, I can return the path and weight from the dijkstra method instead of printing them, and let the main method handle the output.\n\nThis makes the method more reusable.\n\nSo, perhaps define a class to hold the path and weight:\n\nclass ShortestPathResult {\n\nList<Integer> path;\n\nint weight;\n\npublic ShortestPathResult(List<Integer> path, int weight) {\n\nthis.path = path;\n\nthis.weight = weight;\n\n}\n\n}\n\nThen, dijkstra method can return ShortestPathResult, and in the main method, check if the path is empty and print accordingly.\n\nThis is a better design.\n\nLet me adjust the plan:\n\n- Define ShortestPathResult class.\n\n- Modify dijkstra method to return ShortestPathResult.\n\n- In main method, call dijkstra and handle the output.\n\nThis way, the dijkstra method is decoupled from the output mechanism.\n\nNow, considering that, I need to ensure that the path list is correctly built, including handling the case where source == destination.\n\nLet me think about that.\n\nIf source == destination:\n\n- path = [source]\n\n- weight = 0\n\nOtherwise, build the path as before.\n\nI need to adjust the buildPath method to handle this.\n\nLet me update the buildPath method:\n\nprivate static List<Integer> buildPath(int[] previous, int source, int destination) {\n\nList<Integer> path = new ArrayList<>();\n\nif (destination == source) {\n\npath.add(source);\n\nreturn path;\n\n}\n\nint current = destination;\n\nwhile (current != source && current != -1) {\n\npath.add(current);\n\ncurrent = previous[current];\n\n}\n\nif (current == -1) {\n\nreturn new ArrayList<>(); // No path\n\n} else {\n\npath.add(source);\n\nCollections.reverse(path);\n\nreturn path;\n\n}\n\n}\n\nThis should cover all cases.\n\nNow, let's think about the time and space complexity.\n\nTime complexity:\n\n- O(n^2 log n), where n is the number of nodes, because each node is processed once, and each edge is relaxed once, with log n time for priority queue operations.\n\nSpace complexity:\n\n- O(n) for distances, previous, and the priority queue.\n\nGiven that, for small to medium-sized graphs, this should be efficient enough.\n\nHowever, for very large graphs, a more efficient implementation might be needed, such as using a Fibonacci heap for the priority queue, but in Java, we can stick with PriorityQueue for simplicity.\n\nNow, let's consider how to represent the graph.\n\nSince it's an adjacency matrix, and weights are positive integers, I'll assume that matrix[i][j] == 0 means no edge from i to j.\n\nBut in some representations, matrix[i][j] could be Integer.MAX_VALUE or another value to represent no edge.\n\nTo make it more flexible, I can allow the user to specify what value represents no edge.\n\nBut for simplicity, I'll assume 0 means no edge.\n\nNow, I need to think about how to take input from the user.\n\nIn the main method, I can ask the user to input the number of nodes, the adjacency matrix, the source node, and the destination node.\n\nBut for simplicity, I'll hardcode the adjacency matrix and parameters in the main method for demonstration.\n\nIn a real-world scenario, I might read from files or user input.\n\nAssuming n is small, say up to 100 nodes, it should be fine.\n\nNow, let's consider writing the code.\n\nFirst, define the Node class:\n\nclass Node implements Comparable<Node> {\n\nint index;\n\nint distance;\n\npublic Node(int index, int distance) {\n\nthis.index = index;\n\nthis.distance = distance;\n\n}\n\n@Override\n\npublic int compareTo(Node other) {\n\nreturn Integer.compare(this.distance, other.distance);\n\n}\n\n}\n\nThen, define the ShortestPathResult class:\n\nclass ShortestPathResult {\n\nList<Integer> path;\n\nint weight;\n\npublic ShortestPathResult(List<Integer> path, int weight) {\n\nthis.path = path;\n\nthis.weight = weight;\n\n}\n\n}\n\nThen, implement the dijkstra method:\n\npublic static ShortestPathResult dijkstra(int[][] matrix, int source, int destination) {\n\nint n = matrix.length;\n\nint[] distances = new int[n];\n\nint[] previous = new int[n];\n\nArrays.fill(distances, Integer.MAX_VALUE);\n\nArrays.fill(previous, -1);\n\ndistances[source] = 0;\n\nPriorityQueue<Node> queue = new PriorityQueue<>();\n\nqueue.add(new Node(source, 0));\n\nSet<Integer> finalized = new HashSet<>();\n\nwhile (!queue.isEmpty()) {\n\nNode current = queue.poll();\n\nint currentIndex = current.index;\n\nif (finalized.contains(currentIndex)) {\n\ncontinue;\n\n}\n\nfinalized.add(currentIndex);\n\nif (currentIndex == destination) {\n\nList<Integer> path = buildPath(previous, source, destination);\n\nreturn new ShortestPathResult(path, distances[destination]);\n\n}\n\nfor (int neighbor = 0; neighbor < n; neighbor++) {\n\nif (matrix[currentIndex][neighbor] != 0 && !finalized.contains(neighbor)) {\n\nint newDistance = distances[currentIndex] + matrix[currentIndex][neighbor];\n\nif (newDistance < distances[neighbor]) {\n\ndistances[neighbor] = newDistance;\n\nprevious[neighbor] = currentIndex;\n\nqueue.add(new Node(neighbor, newDistance));\n\n}\n\n}\n\n}\n\n}\n\nList<Integer> path = buildPath(previous, source, destination);\n\nreturn new ShortestPathResult(path, Integer.MAX_VALUE);\n\n}\n\nAnd the buildPath method:\n\nprivate static List<Integer> buildPath(int[] previous, int source, int destination) {\n\nList<Integer> path = new ArrayList<>();\n\nif (destination == source) {\n\npath.add(source);\n\nreturn path;\n\n}\n\nint current = destination;\n\nwhile (current != source && current != -1) {\n\npath.add(current);\n\ncurrent = previous[current];\n\n}\n\nif (current == -1) {\n\nreturn new ArrayList<>(); // No path\n\n} else {\n\npath.add(source);\n\nCollections.reverse(path);\n\nreturn path;\n\n}\n\n}\n\nFinally, in the main method:\n\npublic static void main(String[] args) {\n\nint[][] matrix = {\n\n{0, 10, 0, 0},\n\n{0, 0, 1, 0},\n\n{0, 0, 0, 10},\n\n{0, 0, 0, 0}\n\n};\n\nint source = 0;\n\nint destination = 3;\n\nShortestPathResult result = dijkstra(matrix, source, destination);\n\nif (result.path.isEmpty()) {\n\nSystem.out.println(\"No path found.\");\n\n} else {\n\nSystem.out.println(\"Shortest path: \" + result.path);\n\nSystem.out.println(\"Total weight: \" + result.weight);\n\n}\n\n}\n\nThis should work as expected.\n\nLet me think about potential improvements or optimizations.\n\nOne optimization is to use a boolean array instead of a set for finalized nodes, as array access is faster.\n\nSo, instead of:\n\nSet<Integer> finalized = new HashSet<>();\n\nUse:\n\nboolean[] finalized = new boolean[n];\n\nAnd in the loop:\n\nif (finalized[currentIndex]) {\n\ncontinue;\n\n}\n\nfinalized[currentIndex] = true;\n\nSimilarly, check if using a boolean array speeds up the neighbor checks.\n\nAnother optimization is to avoid adding duplicate nodes to the priority queue. However, since PriorityQueue in Java doesn't support removing arbitrary elements, allowing duplicates is simpler.\n\nBut to optimize, I can keep a set of nodes in the queue and remove duplicates, but it complicates the implementation.\n\nGiven that, and considering the time constraints, I'll stick with the current implementation.\n\nI can also add some documentation and comments in the code for clarity.\n\nFinally, I should test the program with various test cases to ensure its correctness.\n\nSome test cases to consider:\n\n1. Simple graph with direct path.\n\n2. Graph with multiple paths, choosing the shortest.\n\n3. Graph with no path between source and destination.\n\n4. Graph with negative weights (though Dijkstra's shouldn't be used, but to see if it handles correctly).\n\n5. Graph with all nodes disconnected.\n\n6. Graph with one node (source and destination are the same).\n\n7. Graph with cycles.\n\nBy testing these cases, I can ensure that the implementation is robust.\n\nIn summary, implementing Dijkstra's algorithm in Java involves carefully managing distances, previous nodes, and a priority queue to efficiently find the shortest path in a weighted graph represented by an adjacency matrix.\u0448\u0438\u0431\u043a\u0430\n\n"
    }
]