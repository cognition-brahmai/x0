[
    {
        "role": "user",
        "content": "Develop a Golang program that interacts with the Twitter API to fetch and display tweets containing specific keywords. The program should accept command line arguments for the keywords, number of tweets to fetch, and an optional output file name to save the fetched tweets.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Alright, I've got this task to create a Golang program that interacts with the Twitter API to fetch and display tweets based on specific keywords. I need to make sure that the program accepts command-line arguments for the keywords, the number of tweets to fetch, and optionally, an output file name to save those tweets. Since I'm new to working with APIs in Go, I'll need to do a bit of research and follow some steps to get this done.\n\nFirst things first, I need to set up a development environment for Go. I already have Go installed on my machine, but I should double-check the version to ensure compatibility with the libraries I'll be using. I can do this by running `go version` in my terminal.\n\nNext, I need to sign up for a Twitter Developer account and create an app to get the API keys and access tokens required to interact with the Twitter API. I've heard that Twitter has rate limits and usage policies, so I should familiarize myself with those to avoid any issues.\n\nOnce I have the API credentials, I need to choose a Go library that makes it easy to work with the Twitter API. A quick search reveals that \"github.com/dghubble/go-twitter\" is a popular choice. I should read through its documentation to understand how to set it up and use it in my program.\n\nNow, let's think about the program's structure. It should accept command-line arguments for keywords, the number of tweets to fetch, and an optional output file. In Go, I can use the \"flag\" package to handle command-line flags easily. I'll need to define flags for the keywords, number of tweets, and output file.\n\nFor fetching tweets, I need to use the Twitter API's search functionality. The go-twitter library probably has a method for searching tweets based on a query. I'll need to construct a query from the provided keywords and specify the number of tweets to retrieve.\n\nOnce I have the tweets, I need to display them. Probably, printing the tweet text and maybe some metadata like the username and timestamp would be useful. If an output file is specified, I should write the tweets to that file instead of printing them to the console.\n\nError handling is crucial. I need to handle cases where the API request fails, such as due to invalid credentials or exceeding rate limits. I should also validate the command-line arguments to ensure that necessary parameters are provided and that the number of tweets is a positive integer.\n\nLet me outline the steps I need to follow:\n\n1. Set up the Go environment and verify the Go version.\n\n2. Sign up for Twitter Developer account and create an app to get API keys and access tokens.\n\n3. Choose and set up a Go library for interacting with the Twitter API (e.g., go-twitter).\n\n4. Define command-line flags for keywords, number of tweets, and optional output file.\n\n5. Construct a search query from the keywords.\n\n6. Use the Twitter API client to fetch the specified number of tweets.\n\n7. Display the tweets on the console or save them to a file based on user input.\n\n8. Implement error handling for API requests and command-line arguments.\n\nI should also consider writing some test cases or at least test the program with different sets of keywords and output options to ensure it works as expected.\n\nLet me start by setting up the Go environment and verifying the Go version.\n\n**Step 1: Verify Go version**\n\nI'll open my terminal and run:\n\n```\n\ngo version\n\n```\n\nThis should display the installed Go version. I need at least Go 1.17 or later, as earlier versions might not support some features I plan to use.\n\n**Step 2: Sign up for Twitter Developer account and create an app**\n\nI need to go to the Twitter Developer portal and apply for a developer account if I don't have one already. Once approved, I can create a new app to obtain the API keys and access tokens.\n\nI should note down the following credentials:\n\n- Consumer API key\n\n- Consumer API secret key\n\n- Access token\n\n- Access token secret\n\nThese will be needed to authenticate with the Twitter API.\n\n**Step 3: Choose and set up a Go library for Twitter API**\n\nI'll use the go-twitter library. To install it, I can run:\n\n```\n\ngo get github.com/dghubble/go-twitter/twitter\n\ngo get github.com/dghubble/oauth1\n\n```\n\nI need to import these packages in my Go code.\n\nNow, I need to set up the Twitter client using my API credentials. The go-twitter documentation should have examples on how to do this.\n\n**Step 4: Define command-line flags**\n\nIn Go, the \"flag\" package allows me to define and parse command-line flags easily. I'll need to define the following flags:\n\n- Keywords: a string that represents the search query.\n\n- Count: an integer specifying the number of tweets to fetch.\n\n- Output file: a string for the optional output file name.\n\nI should also set default values and handle cases where required flags are missing.\n\n**Step 5: Construct a search query**\n\nBased on the provided keywords, I need to construct a query string that the Twitter API can understand. I might need to URL-encode the keywords to handle any special characters.\n\n**Step 6: Fetch tweets using the Twitter API client**\n\nUsing the go-twitter client, I can make a search/tweets request with the constructed query and specify the number of tweets to retrieve.\n\nI need to handle pagination if the number of requested tweets exceeds the API's per-request limit.\n\n**Step 7: Display or save the tweets**\n\nIf an output file is specified, I should write the tweets to that file. Otherwise, I'll print them to the console.\n\nI need to decide on the format for displaying or saving the tweets. Perhaps include the tweet ID, creation date, user handle, and the text.\n\n**Step 8: Implement error handling**\n\nI need to handle various error scenarios, such as:\n\n- Failed API authentication due to invalid credentials.\n\n- Rate limits exceeded.\n\n- Invalid command-line arguments.\n\n- Failed file operations if saving to a file.\n\nI should provide meaningful error messages to help the user understand and resolve the issues.\n\nAlright, that's a good plan. Let me start implementing this step by step.\n\nFirst, I'll set up a new Go file, say, `main.go`.\n\nThen, I'll import the necessary packages:\n\n```go\n\nimport (\n\n \"flag\"\n\n \"fmt\"\n\n \"log\"\n\n \"os\"\n\n \"github.com/dghubble/go-twitter/twitter\"\n\n \"github.com/dghubble/oauth1\"\n\n)\n\n```\n\nNext, I'll define the command-line flags:\n\n```go\n\nvar (\n\n keywords = flag.String(\"keywords\", \"\", \"Keywords to search for\")\n\n count = flag.Int(\"count\", 10, \"Number of tweets to fetch\")\n\n outfile = flag.String(\"output\", \"\", \"Optional output file name\")\n\n)\n\n```\n\nI'll need to parse the flags after defining them:\n\n```go\n\nflag.Parse()\n\n```\n\nNow, I need to set up the Twitter client using my API credentials. For now, I'll hardcode them, but in a production scenario, it's better to use environment variables or a configuration file.\n\n```go\n\nconsumerKey := \"YOUR_CONSUMER_KEY\"\n\nconsumerSecret := \"YOUR_CONSUMER_SECRET\"\n\naccessToken := \"YOUR_ACCESS_TOKEN\"\n\naccessSecret := \"YOUR_ACCESS_SECRET\"\n\n```\n\nI'll create an OAuth client:\n\n```go\n\nconfig := oauth1.NewConfig(consumerKey, consumerSecret)\n\ntoken := oauth1.NewToken(accessToken, accessSecret)\n\nhttpClient := config.Client(oauth1.NoContext, token)\n\n// Twitter client\n\nclient := twitter.NewClient(httpClient)\n\n```\n\nNow, I need to construct the search query. I'll assume that the keywords are space-separated and need to be URL-encoded.\n\nI can use the `url.Query()` function to encode the keywords.\n\nWait, but in go-twitter, the search service might handle the query string properly, so I might not need to manually encode it.\n\nLet me check the go-twitter documentation for the Search Tweets method.\n\nLooking at the documentation, it seems I can create a search service and make a request with parameters.\n\nI need to import the \"context\" package as well.\n\n```go\n\nctx := context.Background()\n\n```\n\nThen, create a search service:\n\n```go\n\ntwitterService := client.Search\n\n```\n\nNow, make a tweet search request:\n\n```go\n\nparams := &twitter.SearchTweetParams{\n\n Q: *keywords,\n\n Count: fmt.Sprintf(\"%d\", *count),\n\n}\n\ntweets, resp, err := twitterService.Tweets(ctx, params)\n\nif err != nil {\n\n log.Fatalf(\"Error fetching tweets: %+v\", err)\n\n}\n\ndefer resp.Body.Close()\n\n```\n\nThis should fetch the tweets based on the keywords and the specified count.\n\nNow, I need to handle the tweets. If an output file is specified, write them to the file; otherwise, print them to the console.\n\nFirst, check if outfile is provided:\n\n```go\n\nif *outfile != \"\" {\n\n file, err := os.Create(*outfile)\n\n if err != nil {\n\n log.Fatalf(\"Error creating output file: %+v\", err)\n\n }\n\n defer file.Close()\n\n // Write tweets to file\n\n for _, tweet := range tweets.Statuses {\n\n _, err := file.WriteString(fmt.Sprintf(\"%s\\n\", tweet.Text))\n\n if err != nil {\n\n log.Printf(\"Error writing to file: %+v\", err)\n\n }\n\n }\n\n log.Printf(\"Fetched %d tweets and saved to %s\", len(tweets.Statuses), *outfile)\n\n} else {\n\n // Print tweets to console\n\n for _, tweet := range tweets.Statuses {\n\n fmt.Printf(\"%s\\n\", tweet.Text)\n\n }\n\n log.Printf(\"Fetched %d tweets\", len(tweets.Statuses))\n\n}\n\n```\n\nThis seems straightforward. However, I should consider adding more information to the output, like the tweet ID, user handle, and creation date.\n\nLet me modify the output to include more details.\n\nDefine a format string for each tweet:\n\n```go\n\ntweetFormat := \"%s (%s) - %s\\n\"\n\n```\n\nThen, when writing to the file or printing to the console, use this format:\n\n```go\n\nfor _, tweet := range tweets.Statuses {\n\n line := fmt.Sprintf(tweetFormat, tweet.User.ScreenName, tweet.CreatedAt, tweet.Text)\n\n if *outfile != \"\" {\n\n _, err := file.WriteString(line)\n\n if err != nil {\n\n log.Printf(\"Error writing to file: %+v\", err)\n\n }\n\n } else {\n\n fmt.Print(line)\n\n }\n\n}\n\n```\n\nThis way, each tweet will display the user's screen name, creation date, and text.\n\nNow, I need to add error handling for various scenarios.\n\nFirst, check if keywords are provided:\n\n```go\n\nif *keywords == \"\" {\n\n log.Fatal(\"Keywords must be provided\")\n\n}\n\n```\n\nEnsure that the count is a positive integer:\n\n```go\n\nif *count <= 0 {\n\n log.Fatal(\"Count must be a positive integer\")\n\n}\n\n```\n\nAlso, handle cases where the API request fails due to authentication issues or rate limits.\n\nIn the current implementation, errors are logged fatal, which is okay for a simple program, but I might want to provide more specific error messages.\n\nAdditionally, I should handle file operations carefully to avoid data loss or corrupt files.\n\nI should also consider rate limits imposed by the Twitter API and inform the user if they've exceeded the limit.\n\nLooking at the Twitter API documentation, the search/tweets endpoint has certain rate limits, and the go-twitter library might provide response headers that include rate limit information.\n\nI can log the rate limit status if available.\n\nMoreover, I need to ensure that the program doesn't fetch more tweets than allowed per request. Twitter API might have a maximum count per request, and for higher counts, I need to handle pagination.\n\nIn go-twitter, the Search.Tweets method might handle pagination internally, but I need to check the documentation.\n\nFor simplicity, I'll assume that the API returns up to a certain number of tweets per request and handle pagination if necessary.\n\nWait, actually, the Twitter API's search/tweets endpoint returns a maximum of 100 tweets per request, and to fetch more, I need to handle pagination using the max_id parameter.\n\nIn my implementation, if the user specifies a count greater than 100, I need to make multiple requests with the appropriate max_id parameter to fetch up to the specified number of tweets.\n\nThis adds complexity, but it's necessary to fetch more than 100 tweets.\n\nI need to manage the pagination tokens and ensure that I don't fetch duplicate tweets.\n\nAlternatively, I can limit the program to fetch a maximum of 100 tweets per request and inform the user if they request more than that.\n\nFor now, I'll assume that the API returns up to 100 tweets per request, and if the user requests more, I'll fetch multiple pages accordingly.\n\nI need to modify the tweet fetching logic to handle pagination.\n\nHere's an approach:\n\n- Initialize an empty slice to store all tweets.\n\n- Make requests in batches of 100 until the desired count is reached or no more tweets are available.\n\n- In each request, set the max_id parameter to fetch the next page of tweets.\n\n- Avoid duplicates by keeping track of the tweet IDs.\n\nThis sounds manageable, but I need to implement it carefully to avoid infinite loops or missing tweets.\n\nLet me sketch some pseudocode for this:\n\n```go\n\nvar allTweets []*twitter.Tweet\n\nfor len(allTweets) < *count {\n\n params := &twitter.SearchTweetParams{\n\n Q: *keywords,\n\n Count: \"100\", // Maximum per request\n\n MaxID: OptionalMaxID, // Set appropriately for pagination\n\n }\n\n tweets, resp, err := twitterService.Tweets(ctx, params)\n\n if err != nil {\n\n log.Fatalf(\"Error fetching tweets: %+v\", err)\n\n }\n\n allTweets = append(allTweets, tweets.Statuses...)\n\n if len(tweets.Statuses) < 100 {\n\n // No more tweets available\n\n break\n\n }\n\n // Set MaxID for the next request\n\n OptionalMaxID = strval(tweets.Statuses[len(tweets.Statuses)-1].ID - 1)\n\n}\n\n// Select the required number of tweets\n\ntweetsToProcess := allTweets[:min(*count, len(allTweets))]\n\n```\n\nI need to define OptionalMaxID as an optional parameter and manage its value accordingly.\n\nIn go-twitter, the SearchTweetParams has an MaxID field of type twitter.ID, which is a int64.\n\nSo, I need to handle the MaxID as an int64 and set it appropriately.\n\nAlso, I need to import \"strconv\" to convert the MaxID to a string if needed.\n\nWait, in the SearchTweetParams, MaxID is of type twitter.ID, which is int64, so I can set it directly.\n\nLet me adjust the pseudocode accordingly.\n\nDefine a variable to track the next MaxID:\n\n```go\n\nvar maxID *int64\n\n```\n\nThen, in the loop:\n\n```go\n\nfor len(allTweets) < *count {\n\n params := &twitter.SearchTweetParams{\n\n Q: *keywords,\n\n Count: \"100\", // Maximum per request\n\n MaxID: maxID,\n\n }\n\n tweets, resp, err := twitterService.Tweets(ctx, params)\n\n if err != nil {\n\n log.Fatalf(\"Error fetching tweets: %+v\", err)\n\n }\n\n allTweets = append(allTweets, tweets.Statuses...)\n\n if len(tweets.Statuses) == 0 {\n\n // No more tweets available\n\n break\n\n }\n\n // Set MaxID for the next request\n\n lastID := tweets.Statuses[len(tweets.Statuses)-1].ID - 1\n\n maxID = &lastID\n\n}\n\n// Select the required number of tweets\n\nnumToProcess := min(*count, len(allTweets))\n\ntweetsToProcess := allTweets[:numToProcess]\n\n```\n\nI need to define a min function since Go doesn't have a built-in one.\n\n```go\n\nfunc min(a, b int) int {\n\n if a < b {\n\n return a\n\n }\n\n return b\n\n}\n\n```\n\nThis should work. Now, I need to implement this in the code.\n\nAlso, I should consider the rate limits. The Twitter API has rate limits for search/tweets, and if I exceed them, the API will return an error.\n\nI need to handle such errors gracefully and inform the user about rate limits.\n\nLooking at the go-twitter library, the response object might contain rate limit headers, which I can log if needed.\n\nI can check the resp.Header and log relevant information.\n\nFor example:\n\n```go\n\nremaining := resp.Header.Get(\"X-Rate-Limit-Remaining\")\n\nreset := resp.Header.Get(\"X-Rate-Limit-Reset\")\n\nlog.Printf(\"Rate limit remaining: %s, Reset: %s\", remaining, reset)\n\n```\n\nThis way, the user can be aware of their remaining quota and when it resets.\n\nNow, I need to put all these pieces together in the main function.\n\nBut before that, I should think about organizing the code properly. For a simple program, having everything in main.go is acceptable, but for better readability and maintainability, I can consider splitting the code into multiple functions.\n\nFor example:\n\n- A function to set up the Twitter client.\n\n- A function to fetch tweets with pagination.\n\n- A function to save tweets to a file or print them.\n\nThis will make the code cleaner and easier to test.\n\nLet me define these functions.\n\nFirst, a function to create the Twitter client:\n\n```go\n\nfunc newTwitterClient(consumerKey, consumerSecret, accessToken, accessSecret string) (*twitter.Client, error) {\n\n config := oauth1.NewConfig(consumerKey, consumerSecret)\n\n token := oauth1.NewToken(accessToken, accessSecret)\n\n httpClient := config.Client(oauth1.NoContext, token)\n\n return twitter.NewClient(httpClient), nil\n\n}\n\n```\n\nNext, a function to fetch tweets with pagination:\n\n```go\n\nfunc fetchTweets(client *twitter.Client, keywords string, count int) ([]*twitter.Tweet, error) {\n\n ctx := context.Background()\n\n twitterService := client.Search\n\n var allTweets []*twitter.Tweet\n\n var maxID *int64\n\n for len(allTweets) < count {\n\n params := &twitter.SearchTweetParams{\n\n Q: keywords,\n\n Count: \"100\", // Maximum per request\n\n MaxID: maxID,\n\n }\n\n tweets, resp, err := twitterService.Tweets(ctx, params)\n\n if err != nil {\n\n return nil, err\n\n }\n\n allTweets = append(allTweets, tweets.Statuses...)\n\n if len(tweets.Statuses) == 0 {\n\n break\n\n }\n\n // Set MaxID for the next request\n\n lastID := tweets.Statuses[len(tweets.Statuses)-1].ID - 1\n\n maxID = &lastID\n\n}\n\n numToProcess := min(count, len(allTweets))\n\n return allTweets[:numToProcess], nil\n\n}\n\n```\n\nThen, a function to save or print tweets:\n\n```go\n\nfunc processTweets(tweets []*twitter.Tweet, outfile string) error {\n\n tweetFormat := \"%s (%s) - %s\\n\"\n\n if outfile != \"\" {\n\n file, err := os.Create(outfile)\n\n if err != nil {\n\n return err\n\n }\n\n defer file.Close()\n\n for _, tweet := range tweets {\n\n line := fmt.Sprintf(tweetFormat, tweet.User.ScreenName, tweet.CreatedAt, tweet.Text)\n\n _, err := file.WriteString(line)\n\n if err != nil {\n\n return err\n\n }\n\n }\n\n log.Printf(\"Fetched %d tweets and saved to %s\", len(tweets), outfile)\n\n} else {\n\n for _, tweet := range tweets {\n\n line := fmt.Sprintf(tweetFormat, tweet.User.ScreenName, tweet.CreatedAt, tweet.Text)\n\n fmt.Print(line)\n\n }\n\n log.Printf(\"Fetched %d tweets\", len(tweets))\n\n}\n\nreturn nil\n\n}\n\n```\n\nNow, in the main function, I can call these functions in sequence.\n\nFirst, parse flags and validate arguments.\n\nThen, create the Twitter client.\n\nFetch the tweets.\n\nProcess the tweets by saving or printing them.\n\nHere's how the main function might look:\n\n```go\n\nfunc main() {\n\n flag.Parse()\n\n if *keywords == \"\" {\n\n log.Fatal(\"Keywords must be provided\")\n\n }\n\n if *count <= 0 {\n\n log.Fatal(\"Count must be a positive integer\")\n\n }\n\n // Set up Twitter client\n\n consumerKey := \"YOUR_CONSUMER_KEY\"\n\n consumerSecret := \"YOUR_CONSUMER_SECRET\"\n\n accessToken := \"YOUR_ACCESS_TOKEN\"\n\n accessSecret := \"YOUR_ACCESS_SECRET\"\n\n client, err := newTwitterClient(consumerKey, consumerSecret, accessToken, accessSecret)\n\n if err != nil {\n\n log.Fatalf(\"Error creating Twitter client: %+v\", err)\n\n }\n\n // Fetch tweets\n\n tweets, err := fetchTweets(client, *keywords, *count)\n\n if err != nil {\n\n log.Fatalf(\"Error fetching tweets: %+v\", err)\n\n }\n\n // Process tweets\n\n err = processTweets(tweets, *outfile)\n\n if err != nil {\n\n log.Fatalf(\"Error processing tweets: %+v\", err)\n\n }\n\n}\n\n```\n\nThis structure makes the code organized and easier to follow.\n\nI should also add comments to the code to explain each section, especially for someone who might be reading it for the first time.\n\nAdditionally, I can add a usage message to remind users how to use the program.\n\nI can do this by printing the usage when the program is run without the required flags.\n\nFor example, in the main function, after parsing flags:\n\n```go\n\nif *keywords == \"\" {\n\n log.Fatal(\"Keywords must be provided. Usage: go run main.go -keywords='your keywords' -count=10 -output=optional_file.txt\")\n\n}\n\n```\n\nThis will guide the user on how to provide the necessary parameters.\n\nI should also consider adding a version flag or a help flag to provide more information about the program's usage.\n\nFor now, keeping it simple with the required checks should suffice.\n\nI need to remember to replace the placeholder API keys with my actual Twitter API credentials.\n\nAlternatively, I can read these credentials from environment variables to keep them separate from the code.\n\nIn Go, I can use the \"os\" package to read environment variables.\n\nFor example:\n\n```go\n\nconsumerKey := os.Getenv(\"TWITTER_CONSUMER_KEY\")\n\nconsumerSecret := os.Getenv(\"TWITTER_CONSUMER_SECRET\")\n\naccessToken := os.Getenv(\"TWITTER_ACCESS_TOKEN\")\n\naccessSecret := os.Getenv(\"TWITTER_ACCESS_SECRET\")\n\n```\n\nThis is a better practice as it avoids hardcoding sensitive information in the source code.\n\nI should also ensure that these environment variables are set before running the program.\n\nI can add a check to verify that all required environment variables are present.\n\n```go\n\nif consumerKey == \"\" || consumerSecret == \"\" || accessToken == \"\" || accessSecret == \"\" {\n\n log.Fatal(\"Missing Twitter API credentials. Please set TWITTER_CONSUMER_KEY, TWITTER_CONSUMER_SECRET, TWITTER_ACCESS_TOKEN, and TWITTER_ACCESS_SECRET environment variables.\")\n\n}\n\n```\n\nThis way, the program will only run if all required credentials are provided via environment variables.\n\nNow, let's think about testing the program.\n\nI should test the program with different sets of keywords, various counts, and both console output and file output.\n\nI need to ensure that the program handles cases where the output file already exists and decide whether to overwrite it or append to it.\n\nFor simplicity, I'll have the program overwrite the file if it already exists.\n\nI should also test the error handling, such as providing invalid keywords, negative counts, and missing credentials.\n\nAdditionally, I need to check how the program behaves when the Twitter API returns no results for certain keywords or when rate limits are exceeded.\n\nI should make sure that the program doesn't crash in these scenarios but instead provides informative error messages.\n\nLastly, I need to consider the performance implications, especially if the user requests a large number of tweets, as multiple API requests may be necessary.\n\nI should inform the user that there might be delays due to API rate limits.\n\nOverall, this seems like a solid plan. I'll proceed to implement the code based on this structure and test it thoroughly.\n\n**Final Solution**\n\nTo create a Golang program that interacts with the Twitter API to fetch and display tweets containing specific keywords, follow these steps:\n\n### Prerequisites\n\n1. **Golang Installation**: Ensure Go is installed on your machine. Verify the installation using:\n   ```sh\n   go version\n   ```\n\n2. **Twitter Developer Account**: Sign up for a Twitter Developer account and create an app to obtain API keys and access tokens.\n\n3. **Environment Variables**: Set the following environment variables with your Twitter API credentials:\n   ```sh\n   export TWITTER_CONSUMER_KEY='your_consumer_key'\n   export TWITTER_CONSUMER_SECRET='your_consumer_secret'\n   export TWITTER_ACCESS_TOKEN='your_access_token'\n   export TWITTER_ACCESS_SECRET='your_access_secret'\n   ```\n\n### Solution Code\n\nCreate a file named `main.go` and add the following code:\n\n```go\npackage main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"strconv\"\n\t\"context\"\n\n\t\"github.com/dghubble/go-twitter/twitter\"\n\t\"github.com/dghubble/oauth1\"\n)\n\nvar (\n\tkeywords = flag.String(\"keywords\", \"\", \"Keywords to search for\")\n\tcount    = flag.Int(\"count\", 10, \"Number of tweets to fetch\")\n\toutfile  = flag.String(\"output\", \"\", \"Optional output file name\")\n)\n\nfunc main() {\n\tflag.Parse()\n\n\tif *keywords == \"\" {\n\t\tlog.Fatal(\"Keywords must be provided. Usage: go run main.go -keywords='your keywords' -count=10 -output=optional_file.txt\")\n\t}\n\n\tif *count <= 0 {\n\t\tlog.Fatal(\"Count must be a positive integer\")\n\t}\n\n\tconsumerKey := os.Getenv(\"TWITTER_CONSUMER_KEY\")\n\tconsumerSecret := os.Getenv(\"TWITTER_CONSUMER_SECRET\")\n\taccessToken := os.Getenv(\"TWITTER_ACCESS_TOKEN\")\n\taccessSecret := os.Getenv(\"TWITTER_ACCESS_SECRET\")\n\n\tif consumerKey == \"\" || consumerSecret == \"\" || accessToken == \"\" || accessSecret == \"\" {\n\t\tlog.Fatal(\"Missing Twitter API credentials. Please set TWITTER_CONSUMER_KEY, TWITTER_CONSUMER_SECRET, TWITTER_ACCESS_TOKEN, and TWITTER_ACCESS_SECRET environment variables.\")\n\t}\n\n\tclient, err := newTwitterClient(consumerKey, consumerSecret, accessToken, accessSecret)\n\tif err != nil {\n\t\tlog.Fatalf(\"Error creating Twitter client: %+v\", err)\n\t}\n\n\ttweets, err := fetchTweets(client, *keywords, *count)\n\tif err != nil {\n\t\tlog.Fatalf(\"Error fetching tweets: %+v\", err)\n\t}\n\n\terr = processTweets(tweets, *outfile)\n\tif err != nil {\n\t\tlog.Fatalf(\"Error processing tweets: %+v\", err)\n\t}\n}\n\nfunc newTwitterClient(consumerKey, consumerSecret, accessToken, accessSecret string) (*twitter.Client, error) {\n\tconfig := oauth1.NewConfig(consumerKey, consumerSecret)\n\ttoken := oauth1.NewToken(accessToken, accessSecret)\n\thttpClient := config.Client(oauth1.NoContext, token)\n\treturn twitter.NewClient(httpClient), nil\n}\n\nfunc fetchTweets(client *twitter.Client, keywords string, count int) ([]*twitter.Tweet, error) {\n\tctx := context.Background()\n\ttwitterService := client.Search\n\tvar allTweets []*twitter.Tweet\n\tvar maxID *int64\n\n\tfor len(allTweets) < count {\n\t\tparams := &twitter.SearchTweetParams{\n\t\t\tQ:      keywords,\n\t\t\tCount:  \"100\", // Maximum per request\n\t\t\tMaxID:  maxID,\n\t\t}\n\t\ttweets, resp, err := twitterService.Tweets(ctx, params)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tallTweets = append(allTweets, tweets.Statuses...)\n\t\tif len(tweets.Statuses) == 0 {\n\t\t\tbreak\n\t\t}\n\t\t// Set MaxID for the next request\n\t\tlastID := tweets.Statuses[len(tweets.Statuses)-1].ID - 1\n\t\tmaxID = &lastID\n\t}\n\tnumToProcess := min(count, len(allTweets))\n\treturn allTweets[:numToProcess], nil\n}\n\nfunc processTweets(tweets []*twitter.Tweet, outfile string) error {\n\ttweetFormat := \"%s (%s) - %s\\n\"\n\tif outfile != \"\" {\n\t\tfile, err := os.Create(outfile)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer file.Close()\n\t\tfor _, tweet := range tweets {\n\t\t\tline := fmt.Sprintf(tweetFormat, tweet.User.ScreenName, tweet.CreatedAt, tweet.Text)\n\t\t\t_, err := file.WriteString(line)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t\tlog.Printf(\"Fetched %d tweets and saved to %s\", len(tweets), outfile)\n\t} else {\n\t\tfor _, tweet := range tweets {\n\t\t\tline := fmt.Sprintf(tweetFormat, tweet.User.ScreenName, tweet.CreatedAt, tweet.Text)\n\t\t\tfmt.Print(line)\n\t\t}\n\t\tlog.Printf(\"Fetched %d tweets\", len(tweets))\n\t}\n\treturn nil\n}\n\nfunc min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n```\n\n### How to Run\n\n1. **Install Dependencies**:\n   ```sh\n   go get github.com/dghubble/go-twitter/twitter\n   go get github.com/dghubble/oauth1\n   ```\n\n2. **Set Environment Variables**:\n   Ensure you have set the Twitter API credentials as environment variables.\n\n3. **Run the Program**:\n   Use the following command to fetch and display tweets:\n   ```sh\n   go run main.go -keywords='golang twitter' -count=20 -output=tweets.txt\n   ```\n\nThis command fetches 20 tweets containing the keywords 'golang' and 'twitter' and saves them to `tweets.txt`. Adjust the keywords and count as needed."
    }
]