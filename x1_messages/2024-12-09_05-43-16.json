[
    {
        "role": "user",
        "content": "Develop a Golang server that serves static HTML files and also exposes a WebSocket endpoint. When clients connect to the WebSocket, broadcast messages received from one client to all other connected clients."
    },
    {
        "role": "assistant",
        "content": "I have a task to develop a Golang server that serves static HTML files and also has a WebSocket endpoint. The WebSocket should broadcast messages from one client to all other connected clients. I'm not entirely sure how to approach this, but I'll try to break it down into smaller steps.\n\nFirst, I need to set up a basic Golang server that can serve static HTML files. I know that Go has a built-in package for http services, so I'll probably use the \"net/http\" package for that. I can create a file server that serves files from a specific directory.\n\nSecond, I need to implement a WebSocket endpoint. Go has a package called \"gorilla/websocket\" which is widely used for handling WebSockets. I might need to install that package if it's not already available.\n\nThird, I need to handle multiple client connections and broadcast messages from one client to all others. This sounds like I'll need to maintain a list of connected clients and, whenever a message is received from one client, send that message to all other clients.\n\nLet me start by setting up the basic HTTP server to serve static files.\n\n## Final Solution\nTo create a Golang server that serves static HTML files and exposes a WebSocket endpoint for broadcasting messages among connected clients, follow these steps:\n\n### Solution Code\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\nvar clients = make(map[*websocket.Conn]bool) // Connected clients\nvar broadcast = make(chan Message)           // Broadcast channel for messages\n\n// Message struct to hold message data\ntype Message struct {\n\tUsername string `json:\"username\"`\n\tMessage  string `json:\"message\"`\n}\n\nvar upgrader = websocket.Upgrader{\n\tCheckOrigin: func(r *http.Request) bool {\n\t\treturn true\n\t},\n}\n\nfunc main() {\n\tfs := http.FileServer(http.Dir(\"static\"))\n\thttp.Handle(\"/\", fs)\n\thttp.HandleFunc(\"/ws\", handleWebSocket)\n\n\tgo broadcastMessages()\n\n\tfmt.Println(\"Starting server on :8080\")\n\tif err := http.ListenAndServe(\":8080\", nil); err != nil {\n\t\tlog.Fatal(\"ListenAndServe: \", err)\n\t}\n}\n\nfunc handleWebSocket(w http.ResponseWriter, r *http.Request) {\n\tconn, err := upgrader.Upgrade(w, r, nil)\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn\n\t}\n\tdefer conn.Close()\n\n\tclients[conn] = true\n\n\tfor {\n\t\tvar msg Message\n\t\terr := conn.ReadJSON(&msg)\n\t\tif err != nil {\n\t\t\tdelete(clients, conn)\n\t\t\tbreak\n\t\t}\n\t\tbroadcast <- msg\n\t}\n}\n\nfunc broadcastMessages() {\n\tfor {\n\t\tmsg := <-broadcast\n\t\tfor client := range clients {\n\t\t\terr := client.WriteJSON(msg)\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"Error broadcasting message: %v\", err)\n\t\t\t\tclient.Close()\n\t\t\t\tdelete(clients, client)\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n### Explanation\n\n1. **Static File Server**:\n   - Use `http.FileServer` to serve static files from the \"static\" directory.\n   - Map the file server to the root URL `/`.\n\n2. **WebSocket Handling**:\n   - Use the `gorilla/websocket` package to handle WebSocket upgrades.\n   - Maintain a map of connected clients (`clients`).\n   - Use a channel (`broadcast`) to handle message broadcasting.\n\n3. **Message Structure**:\n   - Define a `Message` struct to hold username and message data.\n\n4. **Upgrader**:\n   - Configure `websocket.Upgrader` to handle WebSocket handshake.\n\n5. **Main Function**:\n   - Set up HTTP file server and WebSocket handler.\n   - Start a goroutine to handle broadcasting.\n   - Start the HTTP server on port 8080.\n\n6. **WebSocket Handler**:\n   - Upgrade the HTTP connection to a WebSocket connection.\n   - Add the new connection to the `clients` map.\n   - Read messages from the client and send them to the broadcast channel.\n   - Remove the client from the map upon disconnection.\n\n7. **Broadcast Handler**:\n   - Listen for messages on the broadcast channel.\n   - Send each message to all connected clients.\n   - Remove any clients that cause write errors.\n\nThis setup ensures that any message received from a client via WebSocket is broadcast to all other connected clients, while also serving static HTML files."
    }
]