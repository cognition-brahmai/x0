[
    {
        "role": "user",
        "content": "Create a Python program that implements a Trie data structure for efficient storage and retrieval of words in a dictionary."
    },
    {
        "role": "assistant",
        "content": "Certainly! I'd be happy to help you with that. A Trie, also known as a prefix tree, is a tree data structure used to store a dynamic set of strings, usually for retrieval purposes. It's particularly efficient for tasks like auto-completion, spell checking, and other operations where you need to handle a large set of strings.\n\nImplementing a Trie in Python involves creating nodes that represent each character in the strings. Each node can have children nodes corresponding to the next characters in the strings. Additionally, each node should indicate whether it marks the end of a word.\n\nHere's a basic implementation of a Trie in Python:\n\n```python\nclass TrieNode:\n    def __init__(self):\n        # Initialize a trie node with a dictionary to store children nodes\n        self.children = {}\n        # Flag to denote the end of a word\n        self.is_end_of_word = False\n\nclass Trie:\n    def __init__(self):\n        # Initialize the trie with a root node\n        self.root = TrieNode()\n\n    def insert(self, word):\n        # Insert a word into the trie\n        current = self.root\n        for char in word:\n            if char not in current.children:\n                current.children[char] = TrieNode()\n            current = current.children[char]\n        current.is_end_of_word = True\n\n    def search(self, word):\n        # Search for a word in the trie\n        current = self.root\n        for char in word:\n            if char not in current.children:\n                return False\n            current = current.children[char]\n        return current.is_end_of_word\n\n    def starts_with(self, prefix):\n        # Check if there is any word in the trie that starts with the given prefix\n        current = self.root\n        for char in prefix:\n            if char not in current.children:\n                return False\n            current = current.children[char]\n        return True\n\n# Example usage:\ntrie = Trie()\nwords = [\"hello\", \"world\", \"trie\", \"tri\"]\nfor word in words:\n    trie.insert(word)\n\nprint(trie.search(\"hello\"))  # Output: True\nprint(trie.search(\"hell\"))   # Output: False\nprint(trie.starts_with(\"hel\"))  # Output: True\nprint(trie.starts_with(\"tri\"))  # Output: True\nprint(trie.starts_with(\"xyz\"))  # Output: False\n```\n\n### Explanation:\n\n1. **TrieNode Class**:\n   - Each node contains a dictionary (`children`) to hold its child nodes.\n   - A boolean flag (`is_end_of_word`) to mark the end of a word.\n\n2. **Trie Class**:\n   - **insert(word)**: Inserts a word into the trie. It iterates through each character in the word, creating new nodes if necessary, and marks the end of the word.\n   - **search(word)**: Searches for a word in the trie. It traverses the trie based on the characters in the word and checks if the last character marks the end of a word.\n   - **starts_with(prefix)**: Checks if there is any word in the trie that starts with the given prefix. It traverses the trie based on the characters in the prefix and returns True if all characters are found, regardless of whether it's the end of a word.\n\nThis implementation provides a solid foundation for working with strings efficiently using a Trie data structure. If you have any specific requirements or need further enhancements, feel free to ask!"
    }
]