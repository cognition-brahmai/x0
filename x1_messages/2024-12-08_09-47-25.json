[
    {
        "role": "user",
        "content": "Create a Python script that implements a linked list data structure with methods for adding elements at the beginning, end, and specific index positions, deleting elements by value or index, and searching for an element in the list. PLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Alright, I've got this task to create a Python script that implements a linked list with various operations like adding elements at different positions, deleting elements, and searching for elements. I need to make sure that the script is complete and handles all possible scenarios.\n\nFirst, I need to understand what a linked list is. A linked list is a linear data structure where each element is a separate object called a node, and each node contains data and a reference (or link) to the next node in the sequence. The main advantage of a linked list over a Python list is that inserting and deleting elements are more efficient, especially when dealing with large datasets, because they don't require shifting elements like in a list.\n\nSo, I need to create a class for the nodes and another class for the linked list itself. Each node will have at least two attributes: data and next_node. The linked list class will have methods to add elements at the beginning, end, and specific indices, delete elements by value or index, and search for an element.\n\nLet me start by defining the Node class.\n\n```python\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next_node = None\n```\n\nThis seems straightforward. Now, I need to create the LinkedList class.\n\n```python\nclass LinkedList:\n    def __init__(self):\n        self.head = None\n```\n\nThe head will point to the first node in the list. If the list is empty, head will be None.\n\nFirst, I need to implement a method to add a element at the beginning of the list. This should be straightforward. I need to create a new node with the given data and set its next_node to the current head, then update the head to point to this new node.\n\n```python\n    def add_beginning(self, data):\n        new_node = Node(data)\n        new_node.next_node = self.head\n        self.head = new_node\n```\n\nNext, adding at the end. For this, I need to traverse the list to the last node and set its next_node to the new node.\n\n```python\n    def add_end(self, data):\n        new_node = Node(data)\n        if self.head is None:\n            self.head = new_node\n            return\n        current = self.head\n        while current.next_node:\n            current = current.next_node\n        current.next_node = new_node\n```\n\nNow, adding at a specific index. I need to consider that indices start at 0. So, if the index is 0, it's the same as adding at the beginning. If the index is equal to the length of the list, it's the same as adding at the end. I need to handle cases where the index is out of bounds.\n\nFirst, I need a method to get the length of the list.\n\n```python\n    def __len__(self):\n        count = 0\n        current = self.head\n        while current:\n            count += 1\n            current = current.next_node\n        return count\n```\n\nNow, the add_at_index method.\n\n```python\n    def add_at_index(self, index, data):\n        if index < 0:\n            raise IndexError(\"Index cannot be negative\")\n        if index == 0:\n            self.add_beginning(data)\n            return\n        current = self.head\n        prev = None\n        position = 0\n        while current and position < index:\n            prev = current\n            current = current.next_node\n            position += 1\n        if position == index:\n            new_node = Node(data)\n            prev.next_node = new_node\n            new_node.next_node = current\n        else:\n            raise IndexError(\"Index out of range\")\n```\n\nNext, deleting an element by value. I need to traverse the list, keep track of the previous node, and if the current node's data matches the value, set the previous node's next_node to the current node's next_node.\n\nAlso, handle the case where the head node is to be deleted.\n\n```python\n    def delete_by_value(self, value):\n        current = self.head\n        prev = None\n        while current and current.data != value:\n            prev = current\n            current = current.next_node\n        if current is None:\n            raise ValueError(\"Value not found in the list\")\n        if prev is None:\n            self.head = current.next_node\n        else:\n            prev.next_node = current.next_node\n```\n\nDeleting by index is similar. I need to traverse to the index, keep track of the previous node, and adjust the links accordingly.\n\n```python\n    def delete_by_index(self, index):\n        if index < 0:\n            raise IndexError(\"Index cannot be negative\")\n        if index >= len(self):\n            raise IndexError(\"Index out of range\")\n        current = self.head\n        prev = None\n        position = 0\n        while position < index:\n            prev = current\n            current = current.next_node\n            position += 1\n        if prev is None:\n            self.head = current.next_node\n        else:\n            prev.next_node = current.next_node\n```\n\nNow, searching for an element. I need to traverse the list and check if any node's data matches the given value.\n\n```python\n    def search(self, value):\n        current = self.head\n        index = 0\n        while current:\n            if current.data == value:\n                return index\n            current = current.next_node\n            index += 1\n        raise ValueError(\"Value not found in the list\")\n```\n\nI should also implement a method to display the list for easy visualization.\n\n```python\n    def display(self):\n        elements = []\n        current = self.head\n        while current:\n            elements.append(str(current.data))\n            current = current.next_node\n        print(\" -> \".join(elements))\n```\n\nLet me test these methods with some examples.\n\nFirst, create a linked list and add elements.\n\n```python\nll = LinkedList()\nll.add_end(1)\nll.add_end(2)\nll.add_end(3)\nll.display()  # Should print: 1 -> 2 -> 3\n```\n\nAdd at the beginning.\n\n```python\nll.add_beginning(0)\nll.display()  # Should print: 0 -> 1 -> 2 -> 3\n```\n\nAdd at a specific index.\n\n```python\nll.add_at_index(2, \"a\")\nll.display()  # Should print: 0 -> 1 -> a -> 2 -> 3\n```\n\nDelete by value.\n\n```python\nll.delete_by_value(\"a\")\nll.display()  # Should print: 0 -> 1 -> 2 -> 3\n```\n\nDelete by index.\n\n```python\nll.delete_by_index(1)\nll.display()  # Should print: 0 -> 2 -> 3\n```\n\nSearch for an element.\n\n```python\nprint(ll.search(2))  # Should print: 1\nprint(ll.search(3))  # Should print: 2\n```\n\nHandle edge cases, like adding at index 0 or equal to the list length.\n\n```python\nll.add_at_index(0, -1)\nll.display()  # Should print: -1 -> 0 -> 2 -> 3\nll.add_at_index(4, 4)\nll.display()  # Should print: -1 -> 0 -> 2 -> 3 -> 4\n```\n\nAnd trying to delete from an empty list or invalid index.\n\n```python\nempty_ll = LinkedList()\n# empty_ll.delete_by_index(0)  # Should raise IndexError\n# empty_ll.delete_by_value(1)  # Should raise ValueError\n```\n\nAlso, searching for a value not in the list.\n\n```python\n# ll.search(5)  # Should raise ValueError\n```\n\nI think this covers the basic functionality of a linked list with the required operations. I need to make sure that all methods handle edge cases properly, such as empty lists, negative indices, and indices out of range.\n\nI should also consider implementing a method to get the element at a specific index for testing purposes.\n\n```python\n    def get_at_index(self, index):\n        if index < 0:\n            raise IndexError(\"Index cannot be negative\")\n        current = self.head\n        position = 0\n        while current:\n            if position == index:\n                return current.data\n            current = current.next_node\n            position += 1\n        raise IndexError(\"Index out of range\")\n```\n\nThis method can be useful for verifying the correctness of other operations.\n\nLet me test getting elements by index.\n\n```python\nprint(ll.get_at_index(0))  # Should print: -1\nprint(ll.get_at_index(1))  # Should print: 0\nprint(ll.get_at_index(2))  # Should print: 2\nprint(ll.get_at_index(3))  # Should print: 3\nprint(ll.get_at_index(4))  # Should print: 4\n```\n\nAnd testing negative indices and out-of-range indices.\n\n```python\n# ll.get_at_index(-1)  # Should raise IndexError\n# ll.get_at_index(5)   # Should raise IndexError\n```\n\nEverything seems to be working as expected. I need to make sure that the code is clean, well-documented, and follows Python best practices.\n\nI should also consider adding exception handling for cases where the list is empty or indices are out of range, which I've partially done.\n\nFinally, I can write a main function to demonstrate the usage of this linked list.\n\n```python\ndef main():\n    ll = LinkedList()\n    ll.add_end(1)\n    ll.add_end(2)\n    ll.add_end(3)\n    ll.display()  # 1 -> 2 -> 3\n    ll.add_beginning(0)\n    ll.display()  # 0 -> 1 -> 2 -> 3\n    ll.add_at_index(2, \"a\")\n    ll.display()  # 0 -> 1 -> a -> 2 -> 3\n    ll.delete_by_value(\"a\")\n    ll.display()  # 0 -> 1 -> 2 -> 3\n    ll.delete_by_index(1)\n    ll.display()  # 0 -> 2 -> 3\n    print(ll.search(2))  # 1\n    print(ll.search(3))  # 2\n    ll.add_at_index(0, -1)\n    ll.display()  # -1 -> 0 -> 2 -> 3\n    ll.add_at_index(4, 4)\n    ll.display()  # -1 -> 0 -> 2 -> 3 -> 4\n    print(ll.get_at_index(2))  # 2\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis should cover all the requirements. I need to make sure that the code is self-contained and clear.\n\n## Final Solution\nTo create a linked list data structure in Python with methods for adding elements at the beginning, end, and specific indices, deleting elements by value or index, and searching for an element in the list, you can use the following code:\n\n```python\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next_node = None\n\nclass LinkedList:\n    def __init__(self):\n        self.head = None\n\n    def add_beginning(self, data):\n        new_node = Node(data)\n        new_node.next_node = self.head\n        self.head = new_node\n\n    def add_end(self, data):\n        new_node = Node(data)\n        if self.head is None:\n            self.head = new_node\n            return\n        current = self.head\n        while current.next_node:\n            current = current.next_node\n        current.next_node = new_node\n\n    def add_at_index(self, index, data):\n        if index < 0:\n            raise IndexError(\"Index cannot be negative\")\n        if index == 0:\n            self.add_beginning(data)\n            return\n        current = self.head\n        prev = None\n        position = 0\n        while current and position < index:\n            prev = current\n            current = current.next_node\n            position += 1\n        if position == index:\n            new_node = Node(data)\n            prev.next_node = new_node\n            new_node.next_node = current\n        else:\n            raise IndexError(\"Index out of range\")\n\n    def delete_by_value(self, value):\n        current = self.head\n        prev = None\n        while current and current.data != value:\n            prev = current\n            current = current.next_node\n        if current is None:\n            raise ValueError(\"Value not found in the list\")\n        if prev is None:\n            self.head = current.next_node\n        else:\n            prev.next_node = current.next_node\n\n    def delete_by_index(self, index):\n        if index < 0:\n            raise IndexError(\"Index cannot be negative\")\n        if index >= len(self):\n            raise IndexError(\"Index out of range\")\n        current = self.head\n        prev = None\n        position = 0\n        while position < index:\n            prev = current\n            current = current.next_node\n            position += 1\n        if prev is None:\n            self.head = current.next_node\n        else:\n            prev.next_node = current.next_node\n\n    def search(self, value):\n        current = self.head\n        index = 0\n        while current:\n            if current.data == value:\n                return index\n            current = current.next_node\n            index += 1\n        raise ValueError(\"Value not found in the list\")\n\n    def display(self):\n        elements = []\n        current = self.head\n        while current:\n            elements.append(str(current.data))\n            current = current.next_node\n        print(\" -> \".join(elements))\n\n    def __len__(self):\n        count = 0\n        current = self.head\n        while current:\n            count += 1\n            current = current.next_node\n        return count\n\n    def get_at_index(self, index):\n        if index < 0:\n            raise IndexError(\"Index cannot be negative\")\n        current = self.head\n        position = 0\n        while current:\n            if position == index:\n                return current.data\n            current = current.next_node\n            position += 1\n        raise IndexError(\"Index out of range\")\n\ndef main():\n    ll = LinkedList()\n    ll.add_end(1)\n    ll.add_end(2)\n    ll.add_end(3)\n    ll.display()  # 1 -> 2 -> 3\n    ll.add_beginning(0)\n    ll.display()  # 0 -> 1 -> 2 -> 3\n    ll.add_at_index(2, \"a\")\n    ll.display()  # 0 -> 1 -> a -> 2 -> 3\n    ll.delete_by_value(\"a\")\n    ll.display()  # 0 -> 1 -> 2 -> 3\n    ll.delete_by_index(1)\n    ll.display()  # 0 -> 2 -> 3\n    print(ll.search(2))  # 1\n    print(ll.search(3))  # 2\n    ll.add_at_index(0, -1)\n    ll.display()  # -1 -> 0 -> 2 -> 3\n    ll.add_at_index(4, 4)\n    ll.display()  # -1 -> 0 -> 2 -> 3 -> 4\n    print(ll.get_at_index(2))  # 2\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n\n1. **Node Class**: Represents a single node in the linked list, containing data and a reference to the next node.\n2. **LinkedList Class**: Manages the nodes and provides methods to manipulate the list.\n   - `add_beginning(data)`: Adds a new node with the given data at the start of the list.\n   - `add_end(data)`: Adds a new node with the given data at the end of the list.\n   - `add_at_index(index, data)`: Inserts a new node with the given data at the specified index.\n   - `delete_by_value(value)`: Removes the first node containing the given value.\n   - `delete_by_index(index)`: Removes the node at the specified index.\n   - `search(value)`: Returns the index of the first occurrence of the given value.\n   - `display()`: Prints the list in a readable format.\n   - `__len__()`: Returns the number of nodes in the list.\n   - `get_at_index(index)`: Returns the data of the node at the specified index.\n3. **Main Function**: Demonstrates the usage of the LinkedList class with various operations."
    }
]