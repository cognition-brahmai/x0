[
    {
        "role": "user",
        "content": "Write a Java program to implement the Dijkstra's shortest path algorithm on a weighted graph represented as an adjacency matrix.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Certainly! Below is a Java program that implements Dijkstra's shortest path algorithm on a weighted graph represented as an adjacency matrix. This program finds the shortest path from a given source vertex to all other vertices in the graph.\n\n```java\nimport java.util.*;\n\nclass DijkstraShortestPath {\n    private static final int NO_PARENT = -1;\n\n    // Method to find the vertex with the minimum distance value, from the set of vertices not yet included in shortest path tree\n    private static int minDistance(int[] dist, boolean[] visited, int V) {\n        int min = Integer.MAX_VALUE;\n        int minIndex = -1;\n\n        for (int v = 0; v < V; v++) {\n            if (!visited[v] && dist[v] <= min) {\n                min = dist[v];\n                minIndex = v;\n            }\n        }\n        return minIndex;\n    }\n\n    // Function to print the constructed distance array\n    private static void printSolution(int[] dist, int[] parent, int V) {\n        System.out.println(\"Vertex\\t Distance from Source\\t Path\");\n        for (int i = 0; i < V; i++) {\n            List<Integer> path = new ArrayList<>();\n            int j = i;\n            while (j != NO_PARENT) {\n                path.add(j);\n                j = parent[j];\n            }\n            Collections.reverse(path);\n            System.out.print(\" \" + i + \"\\t\\t \" + dist[i] + \"\\t\\t\\t\");\n            for (int vertex : path) {\n                System.out.print(vertex + \" \");\n            }\n            System.out.println();\n        }\n    }\n\n    // Function that implements Dijkstra's single source shortest path algorithm for a graph represented using adjacency matrix representation\n    public static void dijkstra(int[][] graph, int src, int V) {\n        int[] dist = new int[V]; // The output array. dist[i] will hold the shortest distance from src to i\n        boolean[] visited = new boolean[V]; // sptSet[i] will be true if vertex i is included in shortest path tree or shortest distance from src to i is finalized\n        int[] parent = new int[V]; // Array to store the shortest path tree\n\n        // Initialize all distances as INFINITE and stpSet[] as false\n        for (int i = 0; i < V; i++) {\n            dist[i] = Integer.MAX_VALUE;\n            visited[i] = false;\n            parent[i] = NO_PARENT;\n        }\n\n        // Distance of source vertex from itself is always 0\n        dist[src] = 0;\n\n        // Find shortest path for all vertices\n        for (int count = 0; count < V - 1; count++) {\n            // Pick the minimum distance vertex from the set of vertices not yet processed\n            int u = minDistance(dist, visited, V);\n\n            // Mark the picked vertex as processed\n            visited[u] = true;\n\n            // Update dist value of the adjacent vertices of the picked vertex\n            for (int v = 0; v < V; v++) {\n                // Update dist[v] only if is not in sptSet, there is an edge from u to v, and the total weight of path from src to v through u is smaller than current value of dist[v]\n                if (!visited[v] && graph[u][v] != 0 && dist[u] != Integer.MAX_VALUE && dist[u] + graph[u][v] < dist[v]) {\n                    dist[v] = dist[u] + graph[u][v];\n                    parent[v] = u;\n                }\n            }\n        }\n\n        // Print the constructed distance array\n        printSolution(dist, parent, V);\n    }\n\n    public static void main(String[] args) {\n        /* Let us create the example graph discussed above */\n        int V = 9;\n        int[][] graph = new int[][]{\n                {0, 4, 0, 0, 0, 0, 0, 8, 0},\n                {4, 0, 8, 0, 0, 0, 0, 11, 0},\n                {0, 8, 0, 7, 0, 4, 0, 0, 2},\n                {0, 0, 7, 0, 9, 14, 0, 0, 0},\n                {0, 0, 0, 9, 0, 10, 0, 0, 0},\n                {0, 0, 4, 14, 10, 0, 2, 0, 0},\n                {0, 0, 0, 0, 0, 2, 0, 1, 6},\n                {8, 11, 0, 0, 0, 0, 1, 0, 7},\n                {0, 0, 2, 0, 0, 0, 6, 7, 0}\n        };\n\n        dijkstra(graph, 0, V);\n    }\n}\n```\n\n### Explanation:\n\n1. **minDistance Method**: This method selects the vertex with the minimum distance value from the set of vertices not yet included in the shortest path tree.\n\n2. **printSolution Method**: This method prints the shortest distance from the source to each vertex and the path taken.\n\n3. **dijkstra Method**: This is the main method implementing Dijkstra's algorithm. It initializes distances to all vertices as infinite except the source vertex, which is set to 0. It then iteratively selects the unvisited vertex with the smallest distance, marks it as visited, and updates the distances of its adjacent vertices.\n\n4. **main Method**: This sets up the graph as an adjacency matrix and calls the dijkstra method with the source vertex as 0.\n\nThis program will output the shortest distances from the source vertex to all other vertices along with the path taken to reach each vertex."
    }
]