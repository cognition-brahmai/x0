[
    {
        "role": "user",
        "content": "Develop a Java program that simulates a simple chat server using sockets. The server should allow multiple clients to connect, send messages, and broadcast messages to all connected clients. Handle disconnections gracefully and ensure proper cleanup of resources.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Alright, I'm going to try to create a simple chat server in Java using sockets. The goal is to allow multiple clients to connect, send messages, and have those messages broadcasted to all connected clients. I also need to handle disconnections properly and make sure that resources are cleaned up to avoid leaks.\n\nFirst, I need to understand the basics of socket programming in Java. Sockets allow for communication between two devices over a network. In this case, I'll be using server sockets to accept incoming connections from clients.\n\nI should start by creating a ServerSocket that listens on a specific port for incoming connections. Once a client connects, I'll accept the connection and create a new Socket object for that client. To handle multiple clients, I'll need to manage each client connection in a separate thread.\n\nEach client thread will be responsible for reading messages from its associated client and broadcasting those messages to all other connected clients. Additionally, I need to handle cases where clients disconnect unexpectedly and remove them from the list of connected clients.\n\nLet me outline the steps I need to take:\n\n1. Set up a ServerSocket to listen for incoming client connections.\n\n2. When a client connects, accept the connection and create a new thread to handle that client.\n\n3. In the client handler thread:\n\na. Read messages from the client.\n\nb. Broadcast the received message to all other connected clients.\n\nc. Handle disconnections gracefully by removing the client from the list of connected clients and closing resources.\n\n4. Ensure that the server can handle multiple clients simultaneously.\n\n5. Implement a way to stop the server gracefully, closing all connections and freeing up resources.\n\nI need to think about how to manage the list of connected clients. Probably, I'll use a collection like a CopyOnWriteArrayList because it's thread-safe and suitable for concurrent modifications.\n\nAlso, I should consider defining a protocol for the messages. For example, messages could be plain text, and I'll use newline characters to delimit them. I need to make sure that the reading and writing of messages are handled correctly to avoid blocking issues.\n\nError handling is crucial. I need to catch exceptions that may occur during socket operations, such as IOExceptions, and handle them appropriately without crashing the server.\n\nLet me sketch a basic structure of the server class:\n\n- A class, say ChatServer, which has a ServerSocket and a list of connected ClientHandler threads.\n\n- The ChatServer has a method to start listening for connections.\n\n- The ClientHandler class is a Runnable that handles communication with a single client.\n\n- The ClientHandler reads messages from its client and broadcasts them to all other clients.\n\n- When a client disconnects, its ClientHandler removes itself from the list of connected clients.\n\nI should also think about how to broadcast messages. One approach is for the ChatServer to maintain a list of all connected ClientHandler instances and provide a method to broadcast a message to all of them.\n\nWait, but to avoid synchronization issues, it might be better for each ClientHandler to have a reference to the list of connected clients and broadcast from there. However, using a thread-safe collection like CopyOnWriteArrayList should mitigate concurrency issues.\n\nLet me consider using a ExecutorService to manage the client handler threads, which could help in controlling the number of active threads and handling thread lifecycle more efficiently.\n\nAlso, I need to decide how to read messages from the client. Using BufferedReader to read lines from the input stream seems straightforward. Similarly, using PrintWriter for writing messages to the client.\n\nI should also think about how to close resources properly when a client disconnects or when the server shuts down. I need to make sure that sockets are closed and threads are terminated to prevent resource leaks.\n\nAnother consideration is how to handle the server's main thread. I need to keep the server running indefinitely, perhaps with a way to shut it down gracefully, like catching a KeyboardInterrupt or providing a shutdown command.\n\nLet me try to write some pseudocode to outline the structure:\n\nclass ChatServer {\n\nprivate ServerSocket serverSocket;\n\nprivate List<ClientHandler> clients;\n\npublic ChatServer(int port) {\n\ntry {\n\nserverSocket = new ServerSocket(port);\n\nclients = new CopyOnWriteArrayList<>();\n\nSystem.out.println(\"Server started on port \" + port);\n\n} catch (IOException e) {\n\ne.printStackTrace();\n\n}\n\n}\n\npublic void start() {\n\nwhile (true) {\n\ntry {\n\nSocket clientSocket = serverSocket.accept();\n\nClientHandler clientHandler = new ClientHandler(clientSocket, this);\n\nclients.add(clientHandler);\n\nnew Thread(clientHandler).start();\n\n} catch (IOException e) {\n\ne.printStackTrace();\n\n}\n\n}\n\n}\n\npublic void broadcast(String message, ClientHandler sender) {\n\nfor (ClientHandler client : clients) {\n\nif (client != sender) {\n\nclient.sendMessage(message);\n\n}\n\n}\n\n}\n\npublic void removeClient(ClientHandler client) {\n\nclients.remove(client);\n\n}\n\n}\n\nclass ClientHandler implements Runnable {\n\nprivate Socket socket;\n\nprivate ChatServer server;\n\nprivate PrintWriter out;\n\nprivate String username;\n\npublic ClientHandler(Socket socket, ChatServer server) {\n\nthis.socket = socket;\n\nthis.server = server;\n\ntry {\n\nout = new PrintWriter(socket.getOutputStream(), true);\n\n} catch (IOException e) {\n\ne.printStackTrace();\n\n}\n\n}\n\n@Override\n\npublic void run() {\n\ntry (\n\nBufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\n) {\n\nString inputLine;\n\nwhile ((inputLine = in.readLine()) != null) {\n\nserver.broadcast(inputLine, this);\n\n}\n\n} catch (IOException e) {\n\ne.printStackTrace();\n\n} finally {\n\nserver.removeClient(this);\n\ntry {\n\nsocket.close();\n\n} catch (IOException e) {\n\ne.printStackTrace();\n\n}\n\n}\n\n}\n\npublic void sendMessage(String message) {\n\nout.println(message);\n\n}\n\n}\n\nIn this pseudocode, the ChatServer class manages the server socket and the list of connected clients. Each client is handled by a ClientHandler thread, which reads messages from the client and broadcasts them to other clients.\n\nI need to handle usernames or some form of client identification, but for simplicity, I'll assume that messages are sent anonymously or that the username is included in the message.\n\nI should also think about how to handle large numbers of clients. With many clients connected, there could be performance issues. Using non-blocking I/O or NIO could be a better approach for handling a large number of connections, but for a simple chat server, standard blocking I/O should suffice.\n\nError handling is essential. I need to make sure that exceptions are caught and handled properly, and that resources are always closed, even if an error occurs.\n\nLet me consider adding a way for clients to register their usernames when they connect. This would require modifying the protocol to include a initial message for username registration.\n\nFor example, when a client connects, the server expects the first message to be the username. Once the username is received and validated, the client can start sending messages.\n\nThis would require modifying the ClientHandler to read the first message as the username and then proceed to read regular messages.\n\nI need to ensure that usernames are unique. So, when a new client tries to register a username, I need to check if it's already in use and handle duplicates appropriately.\n\nLet me adjust the pseudocode to include username registration:\n\nclass ChatServer {\n\nprivate ServerSocket serverSocket;\n\nprivate CopyOnWriteArrayList<ClientHandler> clients;\n\nprivate Set<String> usernames;\n\npublic ChatServer(int port) {\n\ntry {\n\nserverSocket = new ServerSocket(port);\n\nclients = new CopyOnWriteArrayList<>();\n\nusernames = new ConcurrentSkipListSet<>();\n\nSystem.out.println(\"Server started on port \" + port);\n\n} catch (IOException e) {\n\ne.printStackTrace();\n\n}\n\n}\n\npublic void start() {\n\nwhile (true) {\n\ntry {\n\nSocket clientSocket = serverSocket.accept();\n\nClientHandler clientHandler = new ClientHandler(clientSocket, this);\n\nnew Thread(clientHandler).start();\n\n} catch (IOException e) {\n\ne.printStackTrace();\n\n}\n\n}\n\n}\n\npublic void broadcast(String message, ClientHandler sender) {\n\nfor (ClientHandler client : clients) {\n\nif (client != sender) {\n\nclient.sendMessage(message);\n\n}\n\n}\n\n}\n\npublic void addClient(ClientHandler client) {\n\nclients.add(client);\n\n}\n\npublic void removeClient(ClientHandler client) {\n\nclients.remove(client);\n\nusernames.remove(client.getUsername());\n\n}\n\npublic boolean isUsernameAvailable(String username) {\n\nreturn !usernames.contains(username);\n\n}\n\npublic void addUsername(String username) {\n\nusernames.add(username);\n\n}\n\n}\n\nclass ClientHandler implements Runnable {\n\nprivate Socket socket;\n\nprivate ChatServer server;\n\nprivate PrintWriter out;\n\nprivate String username;\n\npublic ClientHandler(Socket socket, ChatServer server) {\n\nthis.socket = socket;\n\nthis.server = server;\n\ntry {\n\nout = new PrintWriter(socket.getOutputStream(), true);\n\n} catch (IOException e) {\n\ne.printStackTrace();\n\n}\n\n}\n\n@Override\n\npublic void run() {\n\ntry (\n\nBufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\n) {\n\nout.println(\"ENTER_USERNAME\");\n\nString username = in.readLine();\n\nif (server.isUsernameAvailable(username)) {\n\nthis.username = username;\n\nserver.addUsername(username);\n\nserver.addClient(this);\n\nout.println(\"WELCOME \" + username);\n\nbroadcast(\"USER_JOINED \" + username);\n\n} else {\n\nout.println(\"USERNAME_TAKEN\");\n\nsocket.close();\n\nreturn;\n\n}\n\nString inputLine;\n\nwhile ((inputLine = in.readLine()) != null) {\n\nbroadcast(\"MESSAGE \" + username + \": \" + inputLine);\n\n}\n\n} catch (IOException e) {\n\ne.printStackTrace();\n\n} finally {\n\nserver.removeClient(this);\n\ntry {\n\nsocket.close();\n\n} catch (IOException e) {\n\ne.printStackTrace();\n\n}\n\n}\n\n}\n\npublic void sendMessage(String message) {\n\nout.println(message);\n\n}\n\npublic String getUsername() {\n\nreturn username;\n\n}\n\npublic void broadcast(String message) {\n\nserver.broadcast(message, this);\n\n}\n\n}\n\nIn this updated pseudocode, when a client connects, the server sends an \"ENTER_USERNAME\" message. The client should respond with its chosen username. The server checks if the username is available and either accepts it or rejects it with a \"USERNAME_TAKEN\" message.\n\nOnce a username is accepted, the server adds the client to the list of connected clients and broadcasts a \"USER_JOINED\" message to all other clients.\n\nMessages sent by clients are prefixed with \"MESSAGE \" followed by the username and the actual message content.\n\nThis simple protocol allows the server and clients to communicate about usernames and messages.\n\nI need to implement the client side as well to test this server. The client should connect to the server, receive the \"ENTER_USERNAME\" prompt, send the username, and then proceed to send and receive messages.\n\nI should also think about how to handle multiple messages from clients concurrently. Since each client has its own thread, reading and writing should be handled independently for each client.\n\nHowever, I need to ensure that the broadcast method is threadsafe. Using a CopyOnWriteArrayList for the list of clients should handle concurrent modifications without issues.\n\nI should also consider limiting the number of connections to prevent the server from being overwhelmed. I can set a maximum number of allowed connections and reject additional connections when that limit is reached.\n\nAdditionally, I might want to implement a heartbeat mechanism to detect disconnected clients, but for simplicity, relying on the socket's built-in disconnection detection should suffice.\n\nLet me think about how to implement the client side now.\n\nThe client needs to:\n\n1. Connect to the server's IP address and port.\n\n2. Receive the \"ENTER_USERNAME\" prompt and send the chosen username.\n\n3. If the username is accepted, proceed to send and receive messages.\n\n4. Handle incoming messages from the server and display them to the user.\n\n5. Allow the user to type messages and send them to the server.\n\n6. Handle disconnections gracefully.\n\nI need to create a Java class for the client that establishes a socket connection to the server, reads prompts and messages from the server, and sends user input back to the server.\n\nI should use separate threads for reading from the server and reading from the user's input to allow concurrent processing.\n\nLet me sketch a basic structure for the client:\n\nclass ChatClient {\n\nprivate Socket socket;\n\nprivate BufferedReader in;\n\nprivate PrintWriter out;\n\npublic ChatClient(String hostname, int port) {\n\ntry {\n\nsocket = new Socket(hostname, port);\n\nin = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\nout = new PrintWriter(socket.getOutputStream(), true);\n\n} catch (IOException e) {\n\ne.printStackTrace();\n\nSystem.exit(1);\n\n}\n\n}\n\npublic void start() {\n\ntry {\n\n// Read username prompt and send username\n\nout.println(getUsername());\n\nString response = in.readLine();\n\nif (\"USERNAME_TAKEN\".equals(response)) {\n\nSystem.out.println(\"Username is already taken. Please try again.\");\n\nsocket.close();\n\nreturn;\n\n} else if (\"WELCOME\".equals(response)) {\n\nSystem.out.println(\"Welcome to the chat server!\");\n\n} else {\n\nSystem.out.println(\"Unexpected response from server.\");\n\nsocket.close();\n\nreturn;\n\n}\n\n// Start reader thread to read messages from server\n\nThread readerThread = new Thread(() -> {\n\ntry {\n\nString message;\n\nwhile ((message = in.readLine()) != null) {\n\nSystem.out.println(message);\n\n}\n\n} catch (IOException e) {\n\ne.printStackTrace();\n\n} finally {\n\nsocket.close();\n\n}\n\n});\n\nreaderThread.start();\n\n// Start writer thread to send user input to server\n\nThread writerThread = new Thread(() -> {\n\nBufferedReader userInput = new BufferedReader(new InputStreamReader(System.in));\n\nString input;\n\ntry {\n\nwhile ((input = userInput.readLine()) != null) {\n\nout.println(input);\n\n}\n\n} catch (IOException e) {\n\ne.printStackTrace();\n\n} finally {\n\nsocket.close();\n\n}\n\n});\n\nwriterThread.start();\n\n} catch (Exception e) {\n\ne.printStackTrace();\n\n} finally {\n\ntry {\n\nsocket.close();\n\n} catch (IOException e) {\n\ne.printStackTrace();\n\n}\n\n}\n\n}\n\nprivate String getUsername() {\n\n// For simplicity, hardcode a username here or prompt the user\n\nreturn \"Alice\";\n\n}\n\npublic static void main(String[] args) {\n\nif (args.length != 2) {\n\nSystem.out.println(\"Usage: java ChatClient <hostname> <port>\");\n\nSystem.exit(1);\n\n}\n\nString hostname = args[0];\n\nint port = Integer.parseInt(args[1]);\n\nChatClient client = new ChatClient(hostname, port);\n\nclient.start();\n\n}\n\n}\n\nIn this pseudocode, the ChatClient connects to the specified hostname and port, reads the \"ENTER_USERNAME\" prompt, sends the username, and then starts two threads: one for reading messages from the server and another for reading user input and sending it to the server.\n\nI need to handle the case where the username is already taken and disconnect the client in that scenario.\n\nAlso, I should think about how to handle the client's disconnection. Perhaps by closing the socket when the user wants to exit the chat.\n\nFor now, I'll assume that the user can type messages and they are sent directly to the server, which broadcasts them to other clients.\n\nI should also consider adding some kind of command for users to exit the chat, like typing \"/quit\" or something similar.\n\nLet me adjust the client code to include a quit command:\n\nclass ChatClient {\n\nprivate Socket socket;\n\nprivate BufferedReader in;\n\nprivate PrintWriter out;\n\npublic ChatClient(String hostname, int port) {\n\ntry {\n\nsocket = new Socket(hostname, port);\n\nin = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\nout = new PrintWriter(socket.getOutputStream(), true);\n\n} catch (IOException e) {\n\ne.printStackTrace();\n\nSystem.exit(1);\n\n}\n\n}\n\npublic void start() {\n\ntry {\n\n// Read username prompt and send username\n\nout.println(getUsername());\n\nString response = in.readLine();\n\nif (\"USERNAME_TAKEN\".equals(response)) {\n\nSystem.out.println(\"Username is already taken. Please try again.\");\n\nsocket.close();\n\nreturn;\n\n} else if (\"WELCOME\".equals(response)) {\n\nSystem.out.println(\"Welcome to the chat server!\");\n\n} else {\n\nSystem.out.println(\"Unexpected response from server.\");\n\nsocket.close();\n\nreturn;\n\n}\n\n// Start reader thread to read messages from server\n\nThread readerThread = new Thread(() -> {\n\ntry {\n\nString message;\n\nwhile ((message = in.readLine()) != null) {\n\nSystem.out.println(message);\n\n}\n\n} catch (IOException e) {\n\ne.printStackTrace();\n\n} finally {\n\nsocket.close();\n\n}\n\n});\n\nreaderThread.start();\n\n// Start writer thread to send user input to server\n\nThread writerThread = new Thread(() -> {\n\nBufferedReader userInput = new BufferedReader(new InputStreamReader(System.in));\n\nString input;\n\ntry {\n\nwhile ((input = userInput.readLine()) != null) {\n\nif (\"/quit\".equalsIgnoreCase(input)) {\n\nout.println(\"QUIT\");\n\nbreak;\n\n} else {\n\nout.println(input);\n\n}\n\n}\n\n} catch (IOException e) {\n\ne.printStackTrace();\n\n} finally {\n\ntry {\n\nsocket.close();\n\n} catch (IOException e) {\n\ne.printStackTrace();\n\n}\n\n}\n\n});\n\nwriterThread.start();\n\n} catch (Exception e) {\n\ne.printStackTrace();\n\n} finally {\n\ntry {\n\nsocket.close();\n\n} catch (IOException e) {\n\ne.printStackTrace();\n\n}\n\n}\n\n}\n\nprivate String getUsername() {\n\n// For simplicity, hardcode a username here or prompt the user\n\nreturn \"Alice\";\n\n}\n\npublic static void main(String[] args) {\n\nif (args.length != 2) {\n\nSystem.out.println(\"Usage: java ChatClient <hostname> <port>\");\n\nSystem.exit(1);\n\n}\n\nString hostname = args[0];\n\nint port = Integer.parseInt(args[1]);\n\nChatClient client = new ChatClient(hostname, port);\n\nclient.start();\n\n}\n\n}\n\nIn this version, if the user types \"/quit\", the client sends a \"QUIT\" message to the server and breaks out of the input loop, leading to the socket being closed.\n\nOn the server side, I need to handle the \"QUIT\" message by removing the client from the list of connected clients and broadcasting a \"USER_LEFT\" message to other clients.\n\nI should also handle the case where a client disconnects unexpectedly, perhaps by catching exceptions in the client handler thread and removing the client accordingly.\n\nLet me update the server code to handle \"QUIT\" messages:\n\nclass ChatServer {\n\n// ... (previous code)\n\npublic void broadcast(String message, ClientHandler sender) {\n\nfor (ClientHandler client : clients) {\n\nif (client != sender) {\n\nclient.sendMessage(message);\n\n}\n\n}\n\n}\n\npublic void removeClient(ClientHandler client) {\n\nclients.remove(client);\n\nif (client.getUsername() != null) {\n\nusernames.remove(client.getUsername());\n\nbroadcast(\"USER_LEFT \" + client.getUsername(), null);\n\n}\n\n}\n\n}\n\nclass ClientHandler implements Runnable {\n\n// ... (previous code)\n\n@Override\n\npublic void run() {\n\ntry (\n\nBufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\n) {\n\nout.println(\"ENTER_USERNAME\");\n\nString username = in.readLine();\n\nif (server.isUsernameAvailable(username)) {\n\nthis.username = username;\n\nserver.addUsername(username);\n\nserver.addClient(this);\n\nout.println(\"WELCOME\");\n\nbroadcast(\"USER_JOINED \" + username);\n\n} else {\n\nout.println(\"USERNAME_TAKEN\");\n\nsocket.close();\n\nreturn;\n\n}\n\nString inputLine;\n\nwhile ((inputLine = in.readLine()) != null) {\n\nif (\"QUIT\".equals(inputLine)) {\n\nbreak;\n\n}\n\nbroadcast(\"MESSAGE \" + username + \": \" + inputLine);\n\n}\n\n} catch (IOException e) {\n\ne.printStackTrace();\n\n} finally {\n\nserver.removeClient(this);\n\ntry {\n\nsocket.close();\n\n} catch (IOException e) {\n\ne.printStackTrace();\n\n}\n\n}\n\n}\n\n// ... (previous code)\n\n}\n\nIn this updated code, when the client sends \"QUIT\", the loop breaks, and the client is removed from the server's list of connected clients, and a \"USER_LEFT\" message is broadcasted to other clients.\n\nI need to make sure that the client closes its socket properly when quitting.\n\nAdditionally, I should handle cases where clients disconnect without sending a \"QUIT\" message, perhaps due to network issues or closing the program abruptly. In such cases, the server should still remove the client and broadcast a \"USER_LEFT\" message.\n\nTo handle unexpected disconnections, I can catch IOExceptions in the client handler's read loop and remove the client accordingly.\n\nLet me adjust the client handler's run method to handle exceptions:\n\n@Override\n\npublic void run() {\n\ntry (\n\nBufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\n) {\n\nout.println(\"ENTER_USERNAME\");\n\nString username = in.readLine();\n\nif (server.isUsernameAvailable(username)) {\n\nthis.username = username;\n\nserver.addUsername(username);\n\nserver.addClient(this);\n\nout.println(\"WELCOME\");\n\nbroadcast(\"USER_JOINED \" + username);\n\n} else {\n\nout.println(\"USERNAME_TAKEN\");\n\nsocket.close();\n\nreturn;\n\n}\n\nString inputLine;\n\nwhile ((inputLine = in.readLine()) != null) {\n\nif (\"QUIT\".equals(inputLine)) {\n\nbreak;\n\n}\n\nbroadcast(\"MESSAGE \" + username + \": \" + inputLine);\n\n}\n\n} catch (IOException e) {\n\ne.printStackTrace();\n\n} finally {\n\nserver.removeClient(this);\n\ntry {\n\nsocket.close();\n\n} catch (IOException e) {\n\ne.printStackTrace();\n\n}\n\n}\n\n}\n\nThis should cover both expected and unexpected disconnections.\n\nNow, I need to implement the actual Java classes based on this design.\n\nI should also think about how to test the server and client. I can run the server on my local machine and connect multiple client instances to it to simulate multiple users chatting.\n\nI might also want to add some error checking and better handling of edge cases, such as empty messages, very long messages, or special characters in messages.\n\nAdditionally, for a more robust solution, I could implement message formatting, private messaging, user lists, and other features, but for a simple chat server, the current functionality should suffice.\n\nI should also consider securing the communications, perhaps by using SSL/TLS for the sockets, but that would complicate the implementation significantly.\n\nFor now, I'll focus on getting the basic functionality working correctly.\n\nLet me proceed to write the actual Java code for the server and client based on the pseudocode I've developed.\n\n## Final Solution\nTo create a simple chat server in Java using sockets that allows multiple clients to connect, send messages, and broadcast messages to all connected clients, follow these steps:\n\n### Chat Server\n\n1. **Create a `ChatServer` class** that sets up a `ServerSocket` to listen for incoming client connections and manages multiple client threads.\n\n```java\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\n\nclass ChatServer {\n    private ServerSocket serverSocket;\n    private CopyOnWriteArrayList<ClientHandler> clients;\n    private Set<String> usernames;\n\n    public ChatServer(int port) {\n        try {\n            serverSocket = new ServerSocket(port);\n            clients = new CopyOnWriteArrayList<>();\n            usernames = new ConcurrentSkipListSet<>();\n            System.out.println(\"Server started on port \" + port);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void start() {\n        while (true) {\n            try {\n                Socket clientSocket = serverSocket.accept();\n                ClientHandler clientHandler = new ClientHandler(clientSocket, this);\n                new Thread(clientHandler).start();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public void broadcast(String message, ClientHandler sender) {\n        for (ClientHandler client : clients) {\n            if (client != sender) {\n                client.sendMessage(message);\n            }\n        }\n    }\n\n    public void addClient(ClientHandler client) {\n        clients.add(client);\n    }\n\n    public void removeClient(ClientHandler client) {\n        clients.remove(client);\n        if (client.getUsername() != null) {\n            usernames.remove(client.getUsername());\n            broadcast(\"USER_LEFT \" + client.getUsername(), null);\n        }\n    }\n\n    public boolean isUsernameAvailable(String username) {\n        return !usernames.contains(username);\n    }\n\n    public void addUsername(String username) {\n        usernames.add(username);\n    }\n\n    public static void main(String[] args) {\n        int port = 1234; // Choose your port\n        ChatServer server = new ChatServer(port);\n        server.start();\n    }\n}\n```\n\n2. **Create a `ClientHandler` class** that handles communication with each connected client.\n\n```java\nimport java.io.*;\nimport java.net.*;\n\nclass ClientHandler implements Runnable {\n    private Socket socket;\n    private ChatServer server;\n    private PrintWriter out;\n    private String username;\n\n    public ClientHandler(Socket socket, ChatServer server) {\n        this.socket = socket;\n        this.server = server;\n        try {\n            out = new PrintWriter(socket.getOutputStream(), true);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    @Override\n    public void run() {\n        try (\n                BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()))\n        ) {\n            out.println(\"ENTER_USERNAME\");\n            String username = in.readLine();\n            if (server.isUsernameAvailable(username)) {\n                this.username = username;\n                server.addUsername(username);\n                server.addClient(this);\n                out.println(\"WELCOME\");\n                broadcast(\"USER_JOINED \" + username);\n            } else {\n                out.println(\"USERNAME_TAKEN\");\n                socket.close();\n                return;\n            }\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                if (\"QUIT\".equals(inputLine)) {\n                    break;\n                }\n                broadcast(\"MESSAGE \" + username + \": \" + inputLine);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            server.removeClient(this);\n            try {\n                socket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public void sendMessage(String message) {\n        out.println(message);\n    }\n\n    public String getUsername() {\n        return username;\n    }\n\n    public void broadcast(String message) {\n        server.broadcast(message, this);\n    }\n}\n```\n\n### Chat Client\n\n1. **Create a `ChatClient` class** that connects to the server, handles sending and receiving messages.\n\n```java\nimport java.io.*;\nimport java.net.*;\n\nclass ChatClient {\n    private Socket socket;\n    private BufferedReader in;\n    private PrintWriter out;\n\n    public ChatClient(String hostname, int port) {\n        try {\n            socket = new Socket(hostname, port);\n            in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n            out = new PrintWriter(socket.getOutputStream(), true);\n        } catch (IOException e) {\n            e.printStackTrace();\n            System.exit(1);\n        }\n    }\n\n    public void start() {\n        try {\n            out.println(getUsername());\n            String response = in.readLine();\n            if (\"USERNAME_TAKEN\".equals(response)) {\n                System.out.println(\"Username is already taken. Please try again.\");\n                socket.close();\n                return;\n            } else if (\"WELCOME\".equals(response)) {\n                System.out.println(\"Welcome to the chat server!\");\n            } else {\n                System.out.println(\"Unexpected response from server.\");\n                socket.close();\n                return;\n            }\n            Thread readerThread = new Thread(() -> {\n                try {\n                    String message;\n                    while ((message = in.readLine()) != null) {\n                        System.out.println(message);\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                } finally {\n                    socket.close();\n                }\n            });\n            readerThread.start();\n            Thread writerThread = new Thread(() -> {\n                BufferedReader userInput = new BufferedReader(new InputStreamReader(System.in));\n                String input;\n                try {\n                    while ((input = userInput.readLine()) != null) {\n                        if (\"/quit\".equalsIgnoreCase(input)) {\n                            out.println(\"QUIT\");\n                            break;\n                        } else {\n                            out.println(input);\n                        }\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                } finally {\n                    try {\n                        socket.close();\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n            });\n            writerThread.start();\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                socket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    private String getUsername() {\n        return \"Alice\"; // For simplicity, hardcode or prompt user\n    }\n\n    public static void main(String[] args) {\n        if (args.length != 2) {\n            System.out.println(\"Usage: java ChatClient <hostname> <port>\");\n            System.exit(1);\n        }\n        String hostname = args[0];\n        int port = Integer.parseInt(args[1]);\n        ChatClient client = new ChatClient(hostname, port);\n        client.start();\n    }\n}\n```\n\n### Explanation\n\n- **Server Setup**: The `ChatServer` class sets up a `ServerSocket` to listen for incoming connections. For each connection, it creates a new `ClientHandler` thread.\n- **Client Handling**: Each `ClientHandler` manages a single client, handling username registration, message broadcasting, and cleanup on disconnection.\n- **Client Operations**: The `ChatClient` connects to the server, sends the username, and starts threads for reading messages from the server and sending user input to the server.\n- **Communication Protocol**: Simple text-based protocol where the server expects \"ENTER_USERNAME\", and clients respond with their chosen username. Messages are prefixed with \"MESSAGE \", \"USER_JOINED\", or \"USER_LEFT\" for broadcasting.\n\nThis setup ensures that multiple clients can connect, send messages, and receive broadcasts from the server efficiently."
    }
]