[
    {
        "role": "user",
        "content": "Develop a Python script that generates random mazes using Prim's algorithm and visualizes them using the Matplotlib library. Allow the user to specify the dimensions of the maze and the starting point.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "I've developed a Python script that generates random mazes using Prim's algorithm and visualizes them using the Matplotlib library. The script allows users to specify the dimensions of the maze and the starting point.\n\n## Final Solution\nTo create a random maze generator using Prim's algorithm and visualize it using Matplotlib, follow these steps:\n\n### Approach\n\n1. **Maze Generation using Prim's Algorithm**:\n   - Prim's algorithm is typically used for generating minimum spanning trees, but it can also be adapted to generate mazes.\n   - We treat each cell in the grid as a node and the walls between them as edges.\n   - Start from an initial cell and add neighboring walls to a list.\n   - Randomly select a wall from the list, and if the adjacent cell is not visited, remove the wall and mark the cell as visited.\n   - Repeat until all cells are visited.\n\n2. **Visualization using Matplotlib**:\n   - Use Matplotlib to draw the maze by plotting the grid and the walls.\n\n### Solution Code\n\n```python\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport random\n\ndef create_maze(width, height, start):\n    maze = np.full((height, width), 1)\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    opposite = {(-1, 0): (1, 0), (1, 0): (-1, 0), (0, -1): (0, 1), (0, 1): (0, -1)}\n    \n    stack = []\n    maze[start] = 0\n    x, y = start\n    stack.append((x, y))\n    \n    while stack:\n        x, y = stack[-1]\n        neighbors = []\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < height and 0 <= ny < width and maze[nx, ny] == 1:\n                walls = [(x, y, dx, dy)]\n                if dx == -1:\n                    walls.append((x - 1, y, 1, 0))\n                elif dx == 1:\n                    walls.append((x, y, -1, 0))\n                elif dy == -1:\n                    walls.append((x, y, 0, 1))\n                elif dy == 1:\n                    walls.append((x, y, 0, -1))\n                neighbors.append((nx, ny, walls))\n        if neighbors:\n            nx, ny, walls = random.choice(neighbors)\n            for wall in walls:\n                maze[wall[0], wall[1]] = 0\n            maze[nx, ny] = 0\n            stack.append((nx, ny))\n        else:\n            stack.pop()\n    return maze\n\ndef visualize_maze(maze):\n    fig, ax = plt.subplots()\n    ax.imshow(maze, cmap='binary')\n    ax.axis('off')\n    plt.show()\n\nif __name__ == \"__main__\":\n    width = int(input(\"Enter maze width: \"))\n    height = int(input(\"Enter maze height: \"))\n    start_x = int(input(\"Enter starting x-coordinate: \"))\n    start_y = int(input(\"Enter starting y-coordinate: \"))\n    start = (start_x, start_y)\n    \n    maze = create_maze(width, height, start)\n    visualize_maze(maze)\n```\n\n### Explanation\n\n1. **Maze Generation**:\n   - Initialize a grid of size `height` x `width` with all cells marked as walls (1).\n   - Start from the given starting point and mark it as a path (0).\n   - Use a stack to keep track of the current path.\n   - Randomly select a neighboring cell that has not been visited, remove the wall between them, and add the new cell to the stack.\n   - If there are no unvisited neighbors, backtrack by popping the current cell from the stack.\n\n2. **Visualization**:\n   - Use Matplotlib to display the maze grid, where 1 represents walls and 0 represents paths.\n   - Turn off the axis for a cleaner view.\n\nThis script provides an interactive way to generate and visualize mazes with customizable dimensions and starting points."
    }
]