[
    {
        "role": "user",
        "content": "Write a C++ program that implements a basic command-line calculator supporting addition, subtraction, multiplication, and division operations. The program should use a stack-based approach to evaluate expressions.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Alright, I've got this task to create a simple command-line calculator in C++ that can handle addition, subtraction, multiplication, and division using a stack-based approach. I need to make sure it can evaluate expressions correctly.\n\nFirst, I need to understand what a stack-based approach means for evaluating expressions. I think it has something to do with Reverse Polish Notation (RPN), where operators follow their operands, making it easier to evaluate expressions without worrying about precedence. But I'm not entirely sure if that's the only way to use stacks for this purpose.\n\nLet me recall how stacks work. A stack is a Last In, First Out (LIFO) data structure, meaning the last element added is the first one to be removed. It's like a stack of plates; you can only take the top one off.\n\nFor evaluating expressions, especially in infix notation (where operators are between operands, like 2 + 3), it's a bit more complicated because of operator precedence and associativity. But if I use postfix notation (RPN), it simplifies things significantly.\n\nSo, perhaps the calculator should accept postfix expressions. But that might not be user-friendly, as people are more accustomed to infix notation. Maybe I should consider both options, but to keep it simple, starting with postfix might be better.\n\nLet me outline the steps for evaluating a postfix expression using a stack:\n\n1. Read the expression from left to right.\n\n2. If the token is a number, push it onto the stack.\n\n3. If the token is an operator, pop the top two numbers from the stack, apply the operator, and push the result back onto the stack.\n\n4. When the expression is fully read, the result should be on the top of the stack.\n\nI need to handle basic operators: addition (+), subtraction (-), multiplication (*), and division (/). I also need to consider error handling, like division by zero.\n\nLet me think about how to implement this in C++. I'll need a stack data structure. C++'s standard library has a stack container in the <stack> header, which I can use.\n\nI'll need to read input from the command line. Maybe accept a single string input representing the postfix expression, with spaces separating the tokens.\n\nFor example, the infix expression \"2 + 3 * 4\" would be \"2 3 4 * +\" in postfix.\n\nWait, but to make it more user-friendly, maybe I should convert infix to postfix inside the program. That way, users can input expressions as they normally would.\n\nConverting infix to postfix involves using the Shunting Yard algorithm, which I think is a bit more complex. Since the task is to implement a basic calculator using a stack-based approach, maybe sticking with postfix for now is simpler.\n\nBut to make it more useful and similar to what users expect, I'll try to implement infix to postfix conversion as well.\n\nLet me first recall the Shunting Yard algorithm for converting infix to postfix:\n\n1. Read the infix expression from left to right.\n\n2. Initialize an empty stack for operators and an empty list for output (postfix expression).\n\n3. For each token in the expression:\n\na. If it's a number, add it to the output list.\n\nb. If it's an operator, pop operators from the stack to the output list until the stack is empty or the top operator has lower precedence. Then push the current operator onto the stack.\n\nc. If it's an opening parenthesis, push it onto the stack.\n\nd. If it's a closing parenthesis, pop operators from the stack to the output list until an opening parenthesis is encountered. Pop the opening parenthesis but don't add it to the output.\n\n4. After reading all tokens, pop any remaining operators from the stack to the output list.\n\nThis seems manageable. I need to define operator precedence. For example, multiplication and division have higher precedence than addition and subtraction.\n\nI should also consider handling negative numbers and multiple-digit numbers.\n\nAlright, let's sketch out the structure of the program:\n\n- Main function:\n\n- Prompt user for infix expression.\n\n- Convert infix to postfix.\n\n- Evaluate the postfix expression using a stack.\n\n- Display the result.\n\n- Function to check if a character is an operator.\n\n- Function to determine the precedence of operators.\n\n- Function to convert infix to postfix.\n\n- Function to evaluate postfix expression.\n\nI need to handle potential errors, such as division by zero, invalid tokens, unmatched parentheses, etc.\n\nLet me think about how to represent numbers. For simplicity, I'll assume integers for now, but later I can extend it to floating-point numbers.\n\nI should also consider whitespace in the input expression. I need to ignore spaces while parsing.\n\nLet me consider an example:\n\nInfix: 2 + 3 * 4\n\nPostfix: 2 3 4 * +\n\nEvaluation:\n\n- Push 2 onto stack.\n\n- Push 3 onto stack.\n\n- Push 4 onto stack.\n\n- Encounter '*': pop 4 and 3, multiply to get 12, push 12 onto stack.\n\n- Encounter '+': pop 12 and 2, add to get 14, push 14 onto stack.\n\n- Result: 14\n\nAnother example:\n\nInfix: (2 + 3) * 4\n\nPostfix: 2 3 + 4 *\n\nEvaluation:\n\n- Push 2 onto stack.\n\n- Push 3 onto stack.\n\n- Encounter '+': pop 3 and 2, add to get 5, push 5 onto stack.\n\n- Push 4 onto stack.\n\n- Encounter '*': pop 4 and 5, multiply to get 20, push 20 onto stack.\n\n- Result: 20\n\nSeems correct.\n\nNow, for the infix to postfix conversion:\n\nTake the infix expression \"2 + 3 * 4\"\n\n- Read '2': number, add to output.\n\n- Read '+': operator, push to stack.\n\n- Read '3': number, add to output.\n\n- Read '*': operator with higher precedence than '+', push to stack.\n\n- Read '4': number, add to output.\n\n- End of expression: pop '*' from stack to output, then pop '+' from stack to output.\n\n- Postfix: 2 3 4 * +\n\nAnother example: \"(2 + 3) * 4\"\n\n- Read '(': push to stack.\n\n- Read '2': number, add to output.\n\n- Read '+': operator, push to stack.\n\n- Read '3': number, add to output.\n\n- Read ')': pop '+' from stack to output, pop '(' from stack.\n\n- Read '*': operator, push to stack.\n\n- Read '4': number, add to output.\n\n- End of expression: pop '*' from stack to output.\n\n- Postfix: 2 3 + 4 *\n\nLooks good.\n\nNow, to implement this in C++, I need to split the infix expression into tokens. I can do this by iterating through the string and separating numbers and operators, ignoring spaces.\n\nI need to handle numbers that have multiple digits, so I need to keep reading characters until I reach a non-digit character.\n\nAlso, need to handle negative numbers. For example, \"-2 + 3\". So, if a '-' sign is preceded by an operator or the start of the expression, it might be a negative sign.\n\nThis adds a bit more complexity.\n\nMaybe I can assume that all negative numbers are enclosed in parentheses for now, to simplify things. So, \"-2\" would be \"(0 - 2)\" or something similar.\n\nBut that seems hacky. Better to handle negative numbers properly.\n\nLet me think about how to handle negative numbers in the infix to postfix conversion.\n\nOne approach is to treat a negative sign as a unary operator that negates the following number.\n\nSo, in the Shunting Yard algorithm, I can treat '-' as a unary operator with high precedence.\n\nBut I need to distinguish between unary and binary minus operators.\n\nFor example, in \"2 - 3\", '-' is a binary operator between 2 and 3.\n\nIn \"-2 + 3\", '-' is a unary operator applied to 2.\n\nTo handle this, I can look at the context in which the '-' appears.\n\n- If it appears at the beginning of the expression, it's unary.\n\n- If it follows another operator or an opening parenthesis, it's unary.\n\n- Otherwise, it's binary.\n\nSo, in the tokenization step, I need to identify whether each '-' is unary or binary.\n\nSimilarly, I need to handle multiple operators in a row, like \"2 + -3\".\n\nThis requires careful tokenization and classification of operators.\n\nMaybe I should define a function that, given the current token and the previous token, determines whether the current '-' is unary or binary.\n\nThis is getting a bit complicated for a basic calculator, but I'll try to keep it simple.\n\nAlternatively, I can require that the user inputs expressions with spaces separating all tokens, including parentheses and operators. This might make tokenization easier.\n\nFor example, instead of \"2+3*4\", the user inputs \"2 + 3 * 4\".\n\nThis way, I can split the input string by spaces and process each token individually.\n\nBut even then, I need to handle negative numbers properly.\n\nPerhaps I can treat a '-' followed by a number as a single token representing a negative number.\n\nSo, in \"2 -3\", the tokens are \"2\", \"-\", \"3\".\n\nBut in \"2 - 3\", the tokens are \"2\", \"-\", \"3\".\n\nIn \"2 + -3\", the tokens are \"2\", \"+\", \"-\", \"3\".\n\nThen, in the infix to postfix conversion, I need to handle the \"-\" as a unary operator when it's not following a number or a closing parenthesis.\n\nThis seems manageable.\n\nLet me outline the token types:\n\n- Numbers: integers or floats.\n\n- Operators: +, -, *, /\n\n- Parentheses: (, )\n\nI need to categorize each token accordingly.\n\nNow, for the stack in the infix to postfix conversion, I need to store operators and parentheses.\n\nI can use a stack of strings, where each element is an operator or a parenthesis.\n\nFor the evaluation stage, I'll need a stack for numbers.\n\nI can use a stack of integers or floats, depending on whether I'm handling integers or floating-point numbers.\n\nFor simplicity, I'll start with integers.\n\nLet me sketch a rough code structure:\n\n#include <iostream>\n\n#include <stack>\n\n#include <vector>\n\n#include <cctype>\n\nusing namespace std;\n\nvector<string> infixToPostfix(vector<string> infix);\n\nint evaluatePostfix(vector<string> postfix);\n\nint main() {\n\nstring expression;\n\ncout << \"Enter an infix expression: \";\n\ngetline(cin, expression);\n\n// Tokenize the expression\n\nvector<string> tokens;\n\nstring token;\n\nfor (char ch : expression) {\n\nif (isspace(ch)) {\n\nif (!token.empty()) {\n\ntokens.push_back(token);\n\ntoken.clear();\n\n}\n\ncontinue;\n\n}\n\nif (isalnum(ch)) {\n\ntoken += ch;\n\n} else {\n\nif (!token.empty()) {\n\ntokens.push_back(token);\n\ntoken.clear();\n\n}\n\ntoken += ch;\n\ntokens.push_back(token);\n\ntoken.clear();\n\n}\n\n}\n\nif (!token.empty()) {\n\ntokens.push_back(token);\n\n}\n\n// Convert infix to postfix\n\nvector<string> postfix = infixToPostfix(tokens);\n\n// Evaluate postfix\n\nint result = evaluatePostfix(postfix);\n\ncout << \"Result: \" << result << endl;\n\nreturn 0;\n\n}\n\nvector<string> infixToPostfix(vector<string> infix) {\n\nstack<string> opStack;\n\nvector<string> postfix;\n\nfor (string token : infix) {\n\nif (isdigit(token[0])) {\n\n// Number\n\npostfix.push_back(token);\n\n} else if (token == \"+\" || token == \"-\" || token == \"*\" || token == \"/\") {\n\n// Operator\n\nwhile (!opStack.empty() && opStack.top() != \"(\" && getPrecedence(token) <= getPrecedence(opStack.top())) {\n\npostfix.push_back(opStack.top());\n\nopStack.pop();\n\n}\n\nopStack.push(token);\n\n} else if (token == \"(\") {\n\nopStack.push(token);\n\n} else if (token == \")\") {\n\nwhile (!opStack.empty() && opStack.top() != \"(\") {\n\npostfix.push_back(opStack.top());\n\nopStack.pop();\n\n}\n\nif (!opStack.empty() && opStack.top() == \"(\") {\n\nopStack.pop();\n\n} else {\n\n// Error: unmatched parentheses\n\ncerr << \"Error: unmatched parentheses\" << endl;\n\nexit(1);\n\n}\n\n} else {\n\n// Invalid token\n\ncerr << \"Error: invalid token \" << token << endl;\n\nexit(1);\n\n}\n\n}\n\nwhile (!opStack.empty()) {\n\nif (opStack.top() == \"(\") {\n\ncerr << \"Error: unmatched parentheses\" << endl;\n\nexit(1);\n\n}\n\npostfix.push_back(opStack.top());\n\nopStack.pop();\n\n}\n\nreturn postfix;\n\n}\n\nint getPrecedence(string op) {\n\nif (op == \"+\" || op == \"-\") {\n\nreturn 1;\n\n} else if (op == \"*\" || op == \"/\") {\n\nreturn 2;\n\n}\n\nreturn 0;\n\n}\n\nint evaluatePostfix(vector<string> postfix) {\n\nstack<int> numStack;\n\nfor (string token : postfix) {\n\nif (isdigit(token[0])) {\n\nnumStack.push(stoi(token));\n\n} else {\n\nint b = numStack.top();\n\nnumStack.pop();\n\nint a = numStack.top();\n\nnumStack.pop();\n\nint result;\n\nif (token == \"+\") {\n\nresult = a + b;\n\n} else if (token == \"-\") {\n\nresult = a - b;\n\n} else if (token == \"*\") {\n\nresult = a * b;\n\n} else if (token == \"/\") {\n\nif (b == 0) {\n\ncerr << \"Error: division by zero\" << endl;\n\nexit(1);\n\n}\n\nresult = a / b;\n\n} else {\n\ncerr << \"Error: invalid operator \" << token << endl;\n\nexit(1);\n\n}\n\nnumStack.push(result);\n\n}\n\n}\n\nif (numStack.size() == 1) {\n\nreturn numStack.top();\n\n} else {\n\ncerr << \"Error: invalid expression\" << endl;\n\nexit(1);\n\n}\n\n}\n\nThis is a rough draft. I need to handle negative numbers properly.\n\nCurrently, if the user inputs \"-3 + 2\", the tokens would be [\"-\", \"3\", \"+\", \"2\"]. The \"-\" is treated as an operator, but in this case, it's a unary operator.\n\nI need to modify the tokenization or the infix to postfix conversion to handle unary operators.\n\nOne way is to detect when a \"-\" token is a unary operator and convert it to a special token, say \"u-\", to distinguish it from the binary minus operator.\n\nThen, in the infix to postfix conversion, treat \"u-\" as having higher precedence and apply it accordingly.\n\nAlternatively, I can insert a \"0+\" before the expression if it starts with a \"-\", to make it \"0+ -3 + 2\", which would be easier to handle.\n\nBut that might not cover all cases.\n\nAnother approach is to modify the tokenization step to recognize negative numbers as single tokens.\n\nFor example, treat \"-3\" as a single number token with value -3.\n\nThis would simplify the infix to postfix conversion.\n\nTo do this, in the tokenization loop, when I encounter a \"-\", I look ahead to see if the next token is a number. If it is, I combine them into a single negative number token.\n\nThis sounds promising.\n\nLet me adjust the tokenization code accordingly.\n\nI'll need to look ahead after encountering a \"-\", to see if the next token is a number. If it is, I combine them into one token, e.g., \"-3\".\n\nAlso, I need to handle cases like \"2 +-3\", which should be treated as \"2 + (-3)\".\n\nThis requires looking at the context in which the \"-\" appears.\n\nTo keep it simple, I'll assume that the user inputs expressions with spaces separating all tokens, including operators and parentheses.\n\nThen, in the tokenization step, I can read tokens separated by spaces, and if a \"-\" is preceded by an operator or an opening parenthesis, or it's at the beginning of the expression, it's a unary operator, and I'll treat the next number as negative.\n\nWait, actually, in the tokenization step, I can check if the \"-\" is followed by a number, and if so, combine them into a single negative number token.\n\nFor example:\n\n- \"2 -3\" -> [\"2\", \"-3\"]\n\n- \"2 + -3\" -> [\"2\", \"+\", \"-3\"]\n\n- \"-2 + 3\" -> [\"-2\", \"+\", \"3\"]\n\nThis way, negative numbers are treated as single tokens.\n\nIn the infix to postfix conversion, I can treat negative numbers just like positive numbers.\n\nThis seems straightforward.\n\nLet me adjust the tokenization code to handle negative numbers.\n\nI'll modify the loop to check if a token is \"-\" and the next token is a number. If so, combine them into one token with a negative sign.\n\nHere's how I can do it:\n\nvector<string> tokens;\n\nstring token;\n\nfor (size_t i = 0; i < expression.length(); ) {\n\nchar ch = expression[i];\n\nif (isspace(ch)) {\n\nif (!token.empty()) {\n\ntokens.push_back(token);\n\ntoken.clear();\n\n}\n\ni++;\n\ncontinue;\n\n}\n\nif (isdigit(ch)) {\n\nwhile (i < expression.length() && isdigit(expression[i])) {\n\ntoken += expression[i];\n\ni++;\n\n}\n\ntokens.push_back(token);\n\ntoken.clear();\n\n} else if (ch == '-') {\n\n// Check if it's a negative number\n\nif (i + 1 < expression.length() && isdigit(expression[i + 1])) {\n\ntoken += ch;\n\ni++;\n\nwhile (i < expression.length() && isdigit(expression[i])) {\n\ntoken += expression[i];\n\ni++;\n\n}\n\ntokens.push_back(token);\n\ntoken.clear();\n\n} else {\n\ntoken += ch;\n\ntokens.push_back(token);\n\ntoken.clear();\n\ni++;\n\n}\n\n} else {\n\ntoken += ch;\n\ntokens.push_back(token);\n\ntoken.clear();\n\ni++;\n\n}\n\n}\n\nif (!token.empty()) {\n\ntokens.push_back(token);\n\n}\n\nThis way, negative numbers are handled as single tokens.\n\nNow, in the infix to postfix conversion, I can treat negative numbers just like positive numbers.\n\nLet me test this with an example:\n\nInfix: \"-2 + 3\"\n\nTokens: [\"-2\", \"+\", \"3\"]\n\nPostfix: \"-2 3 +\"\n\nEvaluation:\n\n- Push -2 onto stack.\n\n- Push 3 onto stack.\n\n- Encounter '+': pop 3 and -2, add to get 1, push 1 onto stack.\n\n- Result: 1\n\nLooks correct.\n\nAnother example:\n\nInfix: \"2 + -3 * 4\"\n\nTokens: [\"2\", \"+\", \"-3\", \"*\", \"4\"]\n\nPostfix: \"2 -3 4 * +\"\n\nEvaluation:\n\n- Push 2 onto stack.\n\n- Push -3 onto stack.\n\n- Push 4 onto stack.\n\n- Encounter '*': pop 4 and -3, multiply to get -12, push -12 onto stack.\n\n- Encounter '+': pop -12 and 2, add to get -10, push -10 onto stack.\n\n- Result: -10\n\nCorrect.\n\nSeems like this approach works for negative numbers.\n\nNow, I need to make sure that the program handles all possible edge cases, such as:\n\n- Multiple negative numbers in a row: \"2 + -3 - -4\"\n\n- Nested parentheses with negative numbers: \"(2 + -3) * (4 - -5)\"\n\n- Expressions starting with a negative number: \"-2 + 3\"\n\n- Expressions with leading or trailing spaces\n\n- Expressions with multiple spaces between tokens\n\n- Division by zero\n\n- Invalid tokens\n\n- Unmatched parentheses\n\nI should add error handling for these cases.\n\nAlso, I need to decide how to handle floating-point numbers. For now, I'll stick with integers to keep it simple, but later I can extend it to handle floats by checking for decimal points.\n\nLet me consider the expression \"2 + 3 * (4 - 5)\".\n\nInfix: \"2 + 3 * (4 - 5)\"\n\nTokens: [\"2\", \"+\", \"3\", \"*\", \"(\", \"4\", \"-\", \"5\", \")\"]\n\nPostfix: \"2 3 4 5 - * +\"\n\nEvaluation:\n\n- Push 2 onto stack.\n\n- Push 3 onto stack.\n\n- Push 4 onto stack.\n\n- Push 5 onto stack.\n\n- Encounter '-': pop 5 and 4, subtract to get -1, push -1 onto stack.\n\n- Encounter '*': pop -1 and 3, multiply to get -3, push -3 onto stack.\n\n- Encounter '+': pop -3 and 2, add to get -1, push -1 onto stack.\n\n- Result: -1\n\nCorrect.\n\nAnother test case: \"10 / (2 + 3)\"\n\nInfix: \"10 / (2 + 3)\"\n\nTokens: [\"10\", \"/\", \"(\", \"2\", \"+\", \"3\", \")\"]\n\nPostfix: \"10 2 3 + /\"\n\nEvaluation:\n\n- Push 10 onto stack.\n\n- Push 2 onto stack.\n\n- Push 3 onto stack.\n\n- Encounter '+': pop 3 and 2, add to get 5, push 5 onto stack.\n\n- Encounter '/': pop 5 and 10, divide to get 2, push 2 onto stack.\n\n- Result: 2\n\nCorrect.\n\nNow, let's consider an expression with negative numbers: \"-10 + 2 * (3 - 5)\"\n\nInfix: \"-10 + 2 * (3 - 5)\"\n\nTokens: [\"-10\", \"+\", \"2\", \"*\", \"(\", \"3\", \"-\", \"5\", \")\"]\n\nPostfix: \"-10 2 3 5 - * +\"\n\nEvaluation:\n\n- Push -10 onto stack.\n\n- Push 2 onto stack.\n\n- Push 3 onto stack.\n\n- Push 5 onto stack.\n\n- Encounter '-': pop 5 and 3, subtract to get -2, push -2 onto stack.\n\n- Encounter '*': pop -2 and 2, multiply to get -4, push -4 onto stack.\n\n- Encounter '+': pop -4 and -10, add to get -14, push -14 onto stack.\n\n- Result: -14\n\nCorrect.\n\nSeems like the program is working as expected.\n\nNow, I need to think about how to handle division by zero.\n\nIn the evaluatePostfix function, when encountering a division operator, I need to check if the divisor is zero before performing the division.\n\nIf it is zero, I should print an error message and exit the program.\n\nSimilarly, if there are any invalid tokens or unmatched parentheses, I should handle those errors gracefully.\n\nAlso, I need to make sure that the stack doesn't have extra elements at the end of the evaluation.\n\nFor example, in the expression \"2 + 3 * 4\", the postfix is \"2 3 4 * +\", which should leave only one element on the stack at the end.\n\nIf there are more or less elements, it's an error.\n\nI should add checks for these conditions.\n\nAdditionally, I can consider adding support for more operators or functions in the future, but for now, keeping it simple with the basic arithmetic operations is sufficient.\n\nI should also think about the user interface. Maybe allow the user to perform multiple calculations without restarting the program.\n\nFor now, I'll keep it simple and just handle one expression per run.\n\nIn summary, here's the plan for the program:\n\n1. Read the infix expression from the user.\n\n2. Tokenize the expression, handling negative numbers as single tokens.\n\n3. Convert the infix expression to postfix using the Shunting Yard algorithm.\n\n4. Evaluate the postfix expression using a stack.\n\n5. Display the result.\n\n6. Handle errors such as division by zero, invalid tokens, and unmatched parentheses.\n\nI need to implement and test each part carefully to ensure correctness.\n\nI think this should cover the requirements for a basic command-line calculator using a stack-based approach.\n\n## Final Solution\nTo create a basic command-line calculator in C++ that supports addition, subtraction, multiplication, and division using a stack-based approach, follow the steps below.\n\n### Approach\n\n1. **Read the Expression:** \n   - Read the infix expression from the user.\n   \n2. **Tokenize the Expression:**\n   - Split the expression into tokens (numbers and operators) while handling negative numbers as single tokens.\n\n3. **Convert Infix to Postfix:**\n   - Use the Shunting Yard algorithm to convert the infix expression to postfix notation.\n\n4. **Evaluate the Postfix Expression:**\n   - Use a stack to evaluate the postfix expression.\n\n5. **Handle Errors:**\n   - Manage potential errors such as division by zero, invalid tokens, and unmatched parentheses.\n\n### Solution Code\n\n```cpp\n#include <iostream>\n#include <stack>\n#include <vector>\n#include <cctype>\n#include <cstdlib>\n\nusing namespace std;\n\nvector<string> infixToPostfix(vector<string> infix);\nint evaluatePostfix(vector<string> postfix);\nint getPrecedence(string op);\n\nint main() {\n    string expression;\n    cout << \"Enter an infix expression: \";\n    getline(cin, expression);\n\n    // Tokenize the expression\n    vector<string> tokens;\n    string token;\n    for (size_t i = 0; i < expression.length(); ) {\n        char ch = expression[i];\n        if (isspace(ch)) {\n            if (!token.empty()) {\n                tokens.push_back(token);\n                token.clear();\n            }\n            i++;\n            continue;\n        }\n        if (isdigit(ch)) {\n            while (i < expression.length() && isdigit(expression[i])) {\n                token += expression[i];\n                i++;\n            }\n            tokens.push_back(token);\n            token.clear();\n        } else if (ch == '-') {\n            // Check if it's a negative number\n            if (i + 1 < expression.length() && isdigit(expression[i + 1])) {\n                token += ch;\n                i++;\n                while (i < expression.length() && isdigit(expression[i])) {\n                    token += expression[i];\n                    i++;\n                }\n                tokens.push_back(token);\n                token.clear();\n            } else {\n                token += ch;\n                tokens.push_back(token);\n                token.clear();\n                i++;\n            }\n        } else {\n            token += ch;\n            tokens.push_back(token);\n            token.clear();\n            i++;\n        }\n    }\n    if (!token.empty()) {\n        tokens.push_back(token);\n    }\n\n    // Convert infix to postfix\n    vector<string> postfix = infixToPostfix(tokens);\n\n    // Evaluate postfix\n    int result = evaluatePostfix(postfix);\n    cout << \"Result: \" << result << endl;\n\n    return 0;\n}\n\nvector<string> infixToPostfix(vector<string> infix) {\n    stack<string> opStack;\n    vector<string> postfix;\n    for (string token : infix) {\n        if (isdigit(token[0])) {\n            // Number\n            postfix.push_back(token);\n        } else if (token == \"+\" || token == \"-\" || token == \"*\" || token == \"/\") {\n            // Operator\n            while (!opStack.empty() && opStack.top() != \"(\" && getPrecedence(token) <= getPrecedence(opStack.top())) {\n                postfix.push_back(opStack.top());\n                opStack.pop();\n            }\n            opStack.push(token);\n        } else if (token == \"(\") {\n            opStack.push(token);\n        } else if (token == \")\") {\n            while (!opStack.empty() && opStack.top() != \"(\") {\n                postfix.push_back(opStack.top());\n                opStack.pop();\n            }\n            if (!opStack.empty() && opStack.top() == \"(\") {\n                opStack.pop();\n            } else {\n                // Error: unmatched parentheses\n                cerr << \"Error: unmatched parentheses\" << endl;\n                exit(1);\n            }\n        } else {\n            // Invalid token\n            cerr << \"Error: invalid token \" << token << endl;\n            exit(1);\n        }\n    }\n    while (!opStack.empty()) {\n        if (opStack.top() == \"(\") {\n            cerr << \"Error: unmatched parentheses\" << endl;\n            exit(1);\n        }\n        postfix.push_back(opStack.top());\n        opStack.pop();\n    }\n    return postfix;\n}\n\nint getPrecedence(string op) {\n    if (op == \"+\" || op == \"-\") {\n        return 1;\n    } else if (op == \"*\" || op == \"/\") {\n        return 2;\n    }\n    return 0;\n}\n\nint evaluatePostfix(vector<string> postfix) {\n    stack<int> numStack;\n    for (string token : postfix) {\n        if (isdigit(token[0])) {\n            numStack.push(stoi(token));\n        } else {\n            int b = numStack.top();\n            numStack.pop();\n            int a = numStack.top();\n            numStack.pop();\n            int result;\n            if (token == \"+\") {\n                result = a + b;\n            } else if (token == \"-\") {\n                result = a - b;\n            } else if (token == \"*\") {\n                result = a * b;\n            } else if (token == \"/\") {\n                if (b == 0) {\n                    cerr << \"Error: division by zero\" << endl;\n                    exit(1);\n                }\n                result = a / b;\n            } else {\n                cerr << \"Error: invalid operator \" << token << endl;\n                exit(1);\n            }\n            numStack.push(result);\n        }\n    }\n    if (numStack.size() == 1) {\n        return numStack.top();\n    } else {\n        cerr << \"Error: invalid expression\" << endl;\n        exit(1);\n    }\n}\n```\n\n### Explanation\n\n1. **Tokenization:**\n   - The expression is read and split into tokens, with negative numbers treated as single tokens.\n\n2. **Infix to Postfix Conversion:**\n   - Uses the Shunting Yard algorithm to convert the infix expression to postfix notation, handling operator precedence and parentheses.\n\n3. **Postfix Evaluation:**\n   - Evaluates the postfix expression using a stack, performing operations based on operators and operands.\n\n4. **Error Handling:**\n   - Checks for division by zero, invalid tokens, and unmatched parentheses, providing appropriate error messages.\n\nThis approach ensures that the calculator handles basic arithmetic operations correctly and efficiently using stack-based methods.\n"
    }
]