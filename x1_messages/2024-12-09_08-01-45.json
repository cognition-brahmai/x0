[
    {
        "role": "user",
        "content": "Write a C++ program that implements a Least Recently Used (LRU) cache using a doubly-linked list and a hash map. The cache should support get(key), put(key, value), and delete(key) operations with O(1) time complexity. Additionally, it should have a configurable maximum size, and when the cache is full, the least recently used item should be evicted.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Sure, I can help you with that! Implementing an LRU cache in C++ using a doubly-linked list and a hash map is a great way to achieve O(1) time complexity for get, put, and delete operations. The doubly-linked list helps in maintaining the order of usage, and the hash map provides quick access to the nodes.\n\nFirst, let's understand the components we need:\n\n1. **Doubly-Linked List**: Each node in the list will hold a key-value pair. The list will maintain the order of usage, with the most recently used item at the front and the least recently used at the end.\n\n2. **Hash Map**: This will map keys to the corresponding nodes in the doubly-linked list, allowing us to access any item in O(1) time.\n\n3. **Cache Class**: This will manage the hash map and the linked list, and provide the get, put, and delete operations.\n\n### Step-by-Step Implementation\n\n#### 1. Define the Node Structure\n\nWe'll create a structure for the nodes of the doubly-linked list.\n\n```cpp\nstruct Node {\n    int key;\n    int value;\n    Node* prev;\n    Node* next;\n    Node(int k, int v) : key(k), value(v), prev(nullptr), next(nullptr) {}\n};\n```\n\n#### 2. Implement the Doubly-Linked List Operations\n\nWe need functions to add a node to the front, remove a node, and remove the least recently used node (the one at the end).\n\n#### 3. Create the LRU Cache Class\n\nThis class will contain the hash map and the doubly-linked list, and implement the get, put, and delete operations.\n\n### Full Code\n\n```cpp\n#include <unordered_map>\n\nclass LRUCache {\nprivate:\n    std::unordered_map<int, Node*> cache;\n    Node* head;\n    Node* tail;\n    int capacity;\n    int currentSize;\n\n    // Helper function to add a node to the front of the list\n    void addToFront(Node* node) {\n        node->next = head;\n        node->prev = nullptr;\n        if (head != nullptr) {\n            head->prev = node;\n        }\n        head = node;\n        if (tail == nullptr) {\n            tail = head;\n        }\n    }\n\n    // Helper function to remove a node from the list\n    void removeNode(Node* node) {\n        if (node->prev != nullptr) {\n            node->prev->next = node->next;\n        } else {\n            head = node->next;\n        }\n        if (node->next != nullptr) {\n            node->next->prev = node->prev;\n        } else {\n            tail = node->prev;\n        }\n    }\n\n    // Helper function to evict the least recently used item\n    void evictLeastRecent() {\n        if (tail != nullptr) {\n            cache.erase(tail->key);\n            removeNode(tail);\n            delete tail;\n            currentSize--;\n        }\n    }\n\npublic:\n    LRUCache(int cap) : capacity(cap), currentSize(0) {\n        head = nullptr;\n        tail = nullptr;\n    }\n\n    // Get the value of the key if exists, otherwise return -1.\n    int get(int key) {\n        auto it = cache.find(key);\n        if (it == cache.end()) {\n            return -1;\n        }\n        Node* node = it->second;\n        // Move the accessed node to the front\n        removeNode(node);\n        addToFront(node);\n        return node->value;\n    }\n\n    // Set or insert the value if the key is not already present.\n    // If the cache reached its capacity, evict the least recently used item before inserting.\n    void put(int key, int value) {\n        auto it = cache.find(key);\n        if (it != cache.end()) {\n            // Key exists, update the value and move to front\n            Node* node = it->second;\n            node->value = value;\n            removeNode(node);\n            addToFront(node);\n        } else {\n            // New key, check capacity\n            if (currentSize >= capacity) {\n                evictLeastRecent();\n            }\n            // Add new node to front\n            Node* newNode = new Node(key, value);\n            cache[key] = newNode;\n            addToFront(newNode);\n            currentSize++;\n        }\n    }\n\n    // Delete the key from the cache if it exists\n    void del(int key) {\n        auto it = cache.find(key);\n        if (it != cache.end()) {\n            Node* node = it->second;\n            removeNode(node);\n            cache.erase(key);\n            delete node;\n            currentSize--;\n        }\n    }\n};\n```\n\n### Explanation\n\n1. **Node Structure**: Each node holds a key-value pair and pointers to the previous and next nodes.\n2. **addToFront Function**: Adds a node to the front of the list, making it the most recently used.\n3. **removeNode Function**: Removes a node from the list.\n4. **evictLeastRecent Function**: Removes the least recently used item from the cache.\n5. **LRUCache Constructor**: Initializes the cache with a given capacity.\n6. **get Function**: Retrieves a value by key and moves the accessed node to the front.\n7. **put Function**: Inserts or updates a key-value pair, evicting the least recently used item if necessary.\n8. **del Function**: Deletes a key from the cache if it exists.\n\nThis implementation ensures that all operations are performed in O(1) time complexity, leveraging the efficient operations of the hash map and the doubly-linked list."
    }
]