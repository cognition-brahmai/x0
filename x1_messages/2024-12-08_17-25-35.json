[
    {
        "role": "user",
        "content": "Develop a Golang web application that interacts with OpenSearch to perform full-text searches on a collection of documents. The application should provide endpoints for indexing new documents and searching existing ones.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Alright, I'm going to try to develop this Golang web application that interacts with OpenSearch for full-text search. I'm not entirely sure about all the details, but I'll do my best to figure it out step by step.\n\nFirst, I need to understand what OpenSearch is. From what I've gathered, OpenSearch is an open-source search engine that is compatible with Elasticsearch. It's part of the Amazon suite of services, but it's also available as an open-source project. So, for this project, I'll assume we're using the open-source version.\n\nMy goal is to create a web application in Golang that can index documents and perform searches on those documents using OpenSearch. So, I need to have endpoints for indexing new documents and searching existing ones.\n\nLet me start by setting up a basic Golang web server. I'm familiar with the net/http package, so I'll use that to create the server. I'll need to define routes for indexing and searching.\n\nFor indexing, I'll probably have a POST endpoint where I can send JSON data representing the document to be indexed. For searching, I'll have a GET endpoint where I can specify the search query.\n\nBut before I dive into coding, I need to set up OpenSearch. I'll need to install it locally for development purposes. I can download it from the official OpenSearch website and follow the installation instructions.\n\nOnce OpenSearch is set up, I need to connect to it from my Golang application. I think there's an official OpenSearch client for Golang, so I'll look into that. If not, maybe there's an Elasticsearch client that can be used since OpenSearch is compatible with Elasticsearch.\n\nLet me search for \"OpenSearch Golang client.\" Hmm, it seems like there isn't an official Golang client yet. Maybe I can use the Elasticsearch Golang client since OpenSearch is compatible. I'll try that.\n\nSo, I'll add the Elasticsearch Golang client as a dependency in my project. I can use Go modules for that.\n\nNext, I need to configure the client to connect to my local OpenSearch instance. I'll need to specify the URL and possibly some credentials if I set up security.\n\nAssuming OpenSearch is running locally on the default port, the URL would be \"http://localhost:9200\". I'll need to make sure that OpenSearch is accessible at that address.\n\nNow, for indexing documents, I need to define the structure of the documents. Let's assume for now that documents are simple JSON objects with a \"title\" and \"content\" field. So, each document has a title and some content text.\n\nWhen indexing a new document, I'll need to send a POST request to the OpenSearch index with the document data.\n\nIn my Golang web server, I'll create a handler for the indexing endpoint that accepts POST requests, reads the JSON data from the request body, and uses the OpenSearch client to index the document.\n\nSimilarly, for the search endpoint, I'll have a GET endpoint where I can specify a query parameter, say \"q\", which contains the search query.\n\nThe handler for the search endpoint will read the \"q\" parameter, use the OpenSearch client to perform a full-text search on the index using that query, and return the search results as JSON.\n\nI need to make sure to handle errors properly, such as connection errors to OpenSearch or invalid JSON data in the indexing endpoint.\n\nAlso, for the search functionality, I should consider implementing pagination, so that only a certain number of results are returned per request, and the user can specify the page they want.\n\nAdditionally, it might be useful to have an endpoint to delete documents or update existing ones, but for now, I'll focus on indexing and searching.\n\nLet me sketch out the basic structure of the application.\n\nFirst, the main function will set up the web server and define the routes.\n\nI'll have a router that handles different endpoints:\n\n- POST /index: for indexing new documents\n\n- GET /search: for searching documents\n\nI'll need to initialize the OpenSearch client with the appropriate configuration.\n\nIn the indexing handler, I'll read the request body, unmarshal the JSON into a struct, and use the OpenSearch client to index the document.\n\nIn the search handler, I'll read the \"q\" parameter, construct a search query using the OpenSearch client, execute the search, and marshal the results into JSON to be sent back in the response.\n\nI should also consider content types, making sure that the indexing endpoint expects JSON and that the search endpoint returns JSON.\n\nLet me think about the data structures.\n\nFor the document, as I said, it has a title and content.\n\nI can define a struct like this:\n\ntype Document struct {\n\nTitle string `json:\"title\"`\n\nContent string `json:\"content\"`\n\n}\n\nThen, in the indexing handler, I'll read the request body and unmarshal it into this struct.\n\nFor the search results, I'll need to see what the OpenSearch client returns and marshal that into JSON.\n\nNow, let's think about error handling.\n\nIf there's an error connecting to OpenSearch, I should return a 500 Internal Server Error with an appropriate error message.\n\nIf the indexing request has invalid JSON, I should return a 400 Bad Request error.\n\nSimilarly, for the search endpoint, if the \"q\" parameter is missing or invalid, I should return a 400 Bad Request.\n\nI should also consider rate limiting or other safeguards to prevent abuse, but that might be overkill for now.\n\nLet me outline the steps for the indexing endpoint:\n\n1. Receive a POST request to /index\n\n2. Read the request body\n\n3. Unmarshal the JSON body into a Document struct\n\n4. Use the OpenSearch client to index the document\n\n5. If successful, return a 201 Created response with a JSON message indicating success\n\n6. If there's an error, return a 500 Internal Server Error with an error message\n\nFor the search endpoint:\n\n1. Receive a GET request to /search with a \"q\" parameter\n\n2. Read the \"q\" parameter\n\n3. Use the OpenSearch client to perform a full-text search on the index using the \"q\" parameter\n\n4. Retrieve the search results\n\n5. Marshal the results into JSON and return them in the response\n\n6. If there's an error, return a 500 Internal Server Error with an error message\n\nI should also think about the OpenSearch index name. For simplicity, I'll assume there's one default index, say \"documents\".\n\nI need to make sure that the index exists before trying to index or search on it. Maybe I can create the index programmatically if it doesn't exist.\n\nWait, but in OpenSearch, indices are created automatically when you index a document, so maybe I don't need to worry about that.\n\nLet me verify that. From my experience with Elasticsearch, indices are created automatically when you index a document if they don't exist, provided that the mapping allows it.\n\nAssuming OpenSearch behaves similarly, I can proceed without explicitly creating the index.\n\nNow, let's think about dependencies.\n\nI need the net/http package for the web server.\n\nI need the Elasticsearch Golang client to interact with OpenSearch.\n\nI need to import \"github.com/olivere/elastic/v7\" or whichever client library is recommended.\n\nWait, actually, I should check if there's an official OpenSearch Golang client. Let me look that up.\n\nAfter a quick search, it seems that there isn't an official OpenSearch Golang client yet, so using the Elasticsearch client should be fine.\n\nI'll proceed with \"github.com/olivere/elastic/v7\".\n\nIn my go.mod file, I'll require that package.\n\nNow, let's think about the code structure.\n\nI'll have a main.go file where I set up the router and define the handlers.\n\nI'll have a client.go file where I initialize the OpenSearch client.\n\nI'll have an index.go file where I define the indexing handler.\n\nAnd a search.go file where I define the search handler.\n\nThis way, the code is organized and manageable.\n\nLet me start by setting up the main function in main.go.\n\nI'll initialize the router, set up the routes, and start the server on a specific port, say :8080.\n\nFor the router, I can use the net/http package's native router or a third-party router like Gorilla Mux.\n\nI think Gorilla Mux is more flexible, so I'll use that.\n\nI'll need to add \"github.com/gorilla/mux\" as a dependency.\n\nIn main.go:\n\npackage main\n\nimport (\n\n\"log\"\n\n\"net/http\"\n\n\"github.com/gorilla/mux\"\n\n\"github.com/olivere/elastic/v7\"\n\n)\n\nfunc main() {\n\n// Initialize OpenSearch client\n\nclient, err := elastic.NewClient(elastic.SetURL(\"http://localhost:9200\"))\n\nif err != nil {\n\nlog.Fatalf(\"Error creating OpenSearch client: %v\", err)\n\n}\n\n// Create router\n\nr := mux.NewRouter()\n\n// Define routes\n\nr.HandleFunc(\"/index\", indexHandler(client)).Methods(\"POST\")\n\nr.HandleFunc(\"/search\", searchHandler(client)).Methods(\"GET\")\n\n// Start server\n\nlog.Println(\"Starting server on :8080\")\n\nlog.Fatal(http.ListenAndServe(\":8080\", r))\n\n}\n\nHere, I'm initializing the OpenSearch client and passing it to the handlers.\n\nWait, but in Go, it's better to use a context for dependencies. Maybe I should consider a context or a struct to hold the client.\n\nActually, since the client is stateless, it's fine to pass it directly to the handlers.\n\nBut to keep things clean, maybe I should define a handler function that takes the client as a parameter and returns http.HandlerFunc.\n\nLet me adjust that.\n\nIn main.go:\n\npackage main\n\nimport (\n\n\"log\"\n\n\"net/http\"\n\n\"github.com/gorilla/mux\"\n\n\"github.com/olivere/elastic/v7\"\n\n)\n\nfunc main() {\n\n// Initialize OpenSearch client\n\nclient, err := elastic.NewClient(elastic.SetURL(\"http://localhost:9200\"))\n\nif err != nil {\n\nlog.Fatalf(\"Error creating OpenSearch client: %v\", err)\n\n}\n\n// Create router\n\nr := mux.NewRouter()\n\n// Define routes\n\nr.HandleFunc(\"/index\", indexHandler(client)).Methods(\"POST\")\n\nr.HandleFunc(\"/search\", searchHandler(client)).Methods(\"GET\")\n\n// Start server\n\nlog.Println(\"Starting server on :8080\")\n\nlog.Fatal(http.ListenAndServe(\":8080\", r))\n\n}\n\nfunc indexHandler(client *elastic.Client) http.HandlerFunc {\n\nreturn func(w http.ResponseWriter, r *http.Request) {\n\n// Indexing logic here\n\n}\n\n}\n\nfunc searchHandler(client *elastic.Client) http.HandlerFunc {\n\nreturn func(w http.ResponseWriter, r *http.Request) {\n\n// Search logic here\n\n}\n\n}\n\nThis way, the client is injected into the handlers.\n\nNow, I need to implement the indexHandler.\n\nIn indexHandler, I need to:\n\n1. Read the request body\n\n2. Unmarshal JSON into a Document struct\n\n3. Use the client to index the document\n\n4. Return a 201 Created response with a success message\n\n5. Handle errors appropriately\n\nLet me define the Document struct.\n\ntype Document struct {\n\nTitle string `json:\"title\"`\n\nContent string `json:\"content\"`\n\n}\n\nI'll put this in a separate file, maybe model.go.\n\nmodel.go:\n\npackage main\n\ntype Document struct {\n\nTitle string `json:\"title\"`\n\nContent string `json:\"content\"`\n\n}\n\nNow, in indexHandler:\n\nfunc indexHandler(client *elastic.Client) http.HandlerFunc {\n\nreturn func(w http.ResponseWriter, r *http.Request) {\n\nvar doc Document\n\nerr := json.NewDecoder(r.Body).Decode(&doc)\n\nif err != nil {\n\nhttp.Error(w, \"Bad Request: Invalid JSON\", http.StatusBadRequest)\n\nreturn\n\n}\n\n// Index the document\n\nindex := \"documents\"\n\nresp, err := client.Index().\n\nIndex(index).\n\nBodyJson(doc).\n\nDo(context.Background())\n\nif err != nil {\n\nhttp.Error(w, \"Internal Server Error: \"+err.Error(), http.StatusInternalServerError)\n\nreturn\n\n}\n\nw.WriteHeader(http.StatusCreated)\n\njson.NewEncoder(w).Encode(map[string]string{\"message\": \"Document indexed successfully\", \"id\": resp.Id})\n\n}\n\n}\n\nHere, I'm decoding the request body into a Document struct, then using the client to index it in the \"documents\" index.\n\nI'm returning a 201 Created response with a JSON object containing a success message and the document ID returned by OpenSearch.\n\nI'm also handling errors by returning appropriate HTTP error responses.\n\nNow, for the searchHandler.\n\nIn searchHandler, I need to:\n\n1. Read the \"q\" query parameter\n\n2. Use the client to perform a full-text search on the \"documents\" index using the query\n\n3. Retrieve the search results\n\n4. Marshal the results into JSON and return them in the response\n\n5. Handle errors appropriately\n\nLet me think about the search query.\n\nIn OpenSearch, full-text search can be performed using the query_string query or the match query.\n\nI think for simplicity, I'll use the query_string query, as it allows for more flexibility in the search query.\n\nSo, in the handler, I'll get the \"q\" parameter, construct a query_string query with that value, and execute the search.\n\nHere's a rough idea:\n\nfunc searchHandler(client *elastic.Client) http.HandlerFunc {\n\nreturn func(w http.ResponseWriter, r *http.Request) {\n\nq := r.URL.Query().Get(\"q\")\n\nif q == \"\" {\n\nhttp.Error(w, \"Bad Request: Missing 'q' parameter\", http.StatusBadRequest)\n\nreturn\n\n}\n\n// Perform search\n\nindex := \"documents\"\n\nquery := elastic.NewQueryStringQuery(q)\n\nsearchResult, err := client.Search().\n\nIndex(index).\n\nQuery(query).\n\nDo(context.Background())\n\nif err != nil {\n\nhttp.Error(w, \"Internal Server Error: \"+err.Error(), http.StatusInternalServerError)\n\nreturn\n\n}\n\n// Marshal results to JSON and write to response\n\njson.NewEncoder(w).Encode(searchResult.Hits.Hits)\n\n}\n\n}\n\nThis will return the search hits as JSON.\n\nHowever, the search results from OpenSearch include metadata like _index, _type, _id, _score, etc., along with the _source which contains the actual document data.\n\nMaybe I should extract only the relevant fields to return to the user, like title and content.\n\nAlternatively, I can return the entire _source.\n\nFor now, I'll return the _source in the search results.\n\nBut perhaps it's better to define a struct to map the search results.\n\nWait, actually, since the search results are already JSON, I can directly marshal them.\n\nBut I should make sure to only include the necessary fields.\n\nAlternatively, I can iterate through the search hits, extract the _source, and collect them into a slice to be marshaled.\n\nLet me adjust the searchHandler accordingly.\n\nfunc searchHandler(client *elastic.Client) http.HandlerFunc {\n\nreturn func(w http.ResponseWriter, r *http.Request) {\n\nq := r.URL.Query().Get(\"q\")\n\nif q == \"\" {\n\nhttp.Error(w, \"Bad Request: Missing 'q' parameter\", http.StatusBadRequest)\n\nreturn\n\n}\n\n// Perform search\n\nindex := \"documents\"\n\nquery := elastic.NewQueryStringQuery(q)\n\nsearchResult, err := client.Search().\n\nIndex(index).\n\nQuery(query).\n\nDo(context.Background())\n\nif err != nil {\n\nhttp.Error(w, \"Internal Server Error: \"+err.Error(), http.StatusInternalServerError)\n\nreturn\n\n}\n\n// Collect search hits\n\nvar docs []Document\n\nfor _, hit := range searchResult.Hits.Hits {\n\nvar doc Document\n\nerr := json.Unmarshal(hit.Source, &doc)\n\nif err != nil {\n\nhttp.Error(w, \"Internal Server Error: \"+err.Error(), http.StatusInternalServerError)\n\nreturn\n\n}\n\ndocs = append(docs, doc)\n\n}\n\n// Return the documents as JSON\n\njson.NewEncoder(w).Encode(docs)\n\n}\n\n}\n\nHere, I'm iterating through the search hits, unmarshaling the _source into Document structs, and collecting them into a slice, which is then marshaled into JSON and returned.\n\nThis way, the response only includes the document data without metadata.\n\nThis seems cleaner.\n\nNow, I need to make sure to handle cases where there are no results or errors during unmarshaling.\n\nI've already added error handling for unmarshaling.\n\nNext, I should consider adding pagination to the search results.\n\nFor example, allowing the user to specify the page number and the number of results per page.\n\nI can add query parameters for \"page\" and \"size\".\n\nDefault values can be set, say page=1 and size=10.\n\nThen, in the search query, I can set the from and size parameters accordingly.\n\nFrom = (page - 1) * size\n\nSize = size\n\nLet me adjust the searchHandler to include pagination.\n\nFirst, I'll read the \"page\" and \"size\" query parameters, with defaults.\n\nThen, calculate the from value and set it in the search request.\n\nfunc searchHandler(client *elastic.Client) http.HandlerFunc {\n\nreturn func(w http.ResponseWriter, r *http.Request) {\n\nq := r.URL.Query().Get(\"q\")\n\nif q == \"\" {\n\nhttp.Error(w, \"Bad Request: Missing 'q' parameter\", http.StatusBadRequest)\n\nreturn\n\n}\n\npageStr := r.URL.Query().Get(\"page\")\n\nsizeStr := r.URL.Query().Get(\"size\")\n\npage, err := strconv.Atoi(pageStr)\n\nif err != nil || page < 1 {\n\npage = 1\n\n}\n\nsize, err := strconv.Atoi(sizeStr)\n\nif err != nil || size < 1 {\n\nsize = 10\n\n}\n\nfrom := (page - 1) * size\n\n// Perform search\n\nindex := \"documents\"\n\nquery := elastic.NewQueryStringQuery(q)\n\nsearchResult, err := client.Search()..\n\nIndex(index).\n\nQuery(query).\n\nFrom(from).\n\nSize(size).\n\nDo(context.Background())\n\nif err != nil {\n\nhttp.Error(w, \"Internal Server Error: \"+err.Error(), http.StatusInternalServerError)\n\nreturn\n\n}\n\n// Collect search hits\n\nvar docs []Document\n\nfor _, hit := range searchResult.Hits.Hits {\n\nvar doc Document\n\nerr := json.Unmarshal(hit.Source, &doc)\n\nif err != nil {\n\nhttp.Error(w, \"Internal Server Error: \"+err.Error(), http.StatusInternalServerError)\n\nreturn\n\n}\n\ndocs = append(docs, doc)\n\n}\n\n// Return the documents as JSON\n\njson.NewEncoder(w).Encode(docs)\n\n}\n\n}\n\nThis way, the user can specify the page and size parameters to paginate through the search results.\n\nFor example, /search?q=example&page=2&size=10 would return the second page with 10 results per page.\n\nI should also consider adding headers or additional information in the response to indicate the total number of hits, current page, and total pages.\n\nThis can be useful for the client to display pagination controls.\n\nI can include this information in the JSON response.\n\nLet me adjust the searchHandler to include pagination metadata.\n\nFirst, I need to get the total number of hits from the search result.\n\nThen, calculate the total pages based on the size.\n\nFinally, include this metadata in the response.\n\nHere's an updated version:\n\ntype SearchResponse struct {\n\nMeta struct {\n\nTotal int `json:\"total\"`\n\nPages int `json:\"pages\"`\n\nCurrentPage int `json:\"current_page\"`\n\nPageSize int `json:\"page_size\"`\n\n} `json:\"meta\"`\n\nDocuments []Document `json:\"documents\"`\n\n}\n\nfunc searchHandler(client *elastic.Client) http.HandlerFunc {\n\nreturn func(w http.ResponseWriter, r *http.Request) {\n\nq := r.URL.Query().Get(\"q\")\n\nif q == \"\" {\n\nhttp.Error(w, \"Bad Request: Missing 'q' parameter\", http.StatusBadRequest)\n\nreturn\n\n}\n\npageStr := r.URL.Query().Get(\"page\")\n\nsizeStr := r.URL.Query().Get(\"size\")\n\npage, err := strconv.Atoi(pageStr)\n\nif err != nil || page < 1 {\n\npage = 1\n\n}\n\nsize, err := strconv.Atoi(sizeStr)\n\nif err != nil || size < 1 {\n\nsize = 10\n\n}\n\nfrom := (page - 1) * size\n\n// Perform search\n\nindex := \"documents\"\n\nquery := elastic.NewQueryStringQuery(q)\n\nsearchResult, err := client.Search()..\n\nIndex(index).\n\nQuery(query).\n\nFrom(from).\n\nSize(size).\n\nDo(context.Background())\n\nif err != nil {\n\nhttp.Error(w, \"Internal Server Error: \"+err.Error(), http.StatusInternalServerError)\n\nreturn\n\n}\n\ntotal := searchResult.Hits.Total.Value\n\npages := int(math.Ceil(float64(total) / float64(size)))\n\nif pages < 1 {\n\npages = 1\n\n}\n\n// Collect search hits\n\nvar docs []Document\n\nfor _, hit := range searchResult.Hits.Hits {\n\nvar doc Document\n\nerr := json.Unmarshal(hit.Source, &doc)\n\nif err != nil {\n\nhttp.Error(w, \"Internal Server Error: \"+err.Error(), http.StatusInternalServerError)\n\nreturn\n\n}\n\ndocs = append(docs, doc)\n\n}\n\n// Prepare response\n\nresp := SearchResponse{\n\nMeta: struct {\n\nTotal int\n\nPages int\n\nCurrentPage int\n\nPageSize int\n\n}{\n\nTotal: total,\n\nPages: pages,\n\nCurrentPage: page,\n\nPageSize: size,\n\n},\n\nDocuments: docs,\n\n}\n\n// Return the response as JSON\n\njson.NewEncoder(w).Encode(resp)\n\n}\n\n}\n\nNow, the search response includes metadata about the total number of hits, total pages, current page, and page size, along with the list of documents.\n\nThis should help the client handle pagination effectively.\n\nI think this covers the basic requirements for the application.\n\nLet me summarize:\n\n- Set up a Golang web server using Gorilla Mux\n\n- Defined two endpoints:\n\n- POST /index: for indexing new documents\n\n- GET /search: for searching documents\n\n- Used the Elasticsearch Golang client to interact with OpenSearch\n\n- Handled JSON serialization and deserialization for documents\n\n- Implemented pagination for search results\n\nNext steps would be to test the application thoroughly, ensure that it connects to OpenSearch correctly, and handle any edge cases or errors that may arise.\n\nI should also consider adding more features, such as deleting or updating documents, improving error messages, and possibly adding authentication or authorization if needed.\n\nBut for now, this should serve as a basic implementation of the required functionality.\n\n**Final Solution**\n\nTo create a Golang web application that interacts with OpenSearch for full-text search, follow these steps:\n\n### Prerequisites\n\n1. **Install OpenSearch**: Ensure OpenSearch is installed and running locally on `http://localhost:9200`.\n\n2. **Set Up Go Project**:\n   - Initialize a new Go module:\n     ```sh\n     go mod init your-module-name\n     ```\n   - Install dependencies:\n     ```sh\n     go get github.com/gorilla/mux\n     go get github.com/olivere/elastic/v7\n     go get github.com/google/uuid\n     ```\n\n### Solution Code\n\n#### main.go\n\n```go\npackage main\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"log\"\n\t\"net/http\"\n\t\"strconv\"\n\n\t\"github.com/gorilla/mux\"\n\t\"github.com/olivere/elastic/v7\"\n)\n\ntype Document struct {\n\tTitle   string `json:\"title\"`\n\tContent string `json:\"content\"`\n}\n\ntype SearchResponse struct {\n\tMeta struct {\n\t\tTotal      int `json:\"total\"`\n\t\tPages      int `json:\"pages\"`\n\t\tCurrentPage int `json:\"current_page\"`\n\t\tPageSize   int `json:\"page_size\"`\n\t} `json:\"meta\"`\n\tDocuments []Document `json:\"documents\"`\n}\n\nfunc main() {\n\t// Initialize OpenSearch client\n\tclient, err := elastic.NewClient(elastic.SetURL(\"http://localhost:9200\"))\n\tif err != nil {\n\t\tlog.Fatalf(\"Error creating OpenSearch client: %v\", err)\n\t}\n\n\t// Create router\n\tr := mux.NewRouter()\n\n\t// Define routes\n\tr.HandleFunc(\"/index\", indexHandler(client)).Methods(\"POST\")\n\tr.HandleFunc(\"/search\", searchHandler(client)).Methods(\"GET\")\n\n\t// Start server\n\tlog.Println(\"Starting server on :8080\")\n\tlog.Fatal(http.ListenAndServe(\":8080\", r))\n}\n\nfunc indexHandler(client *elastic.Client) http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tvar doc Document\n\t\terr := json.NewDecoder(r.Body).Decode(&doc)\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Bad Request: Invalid JSON\", http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\n\t\tindex := \"documents\"\n\t\tresp, err := client.Index().\n\t\t\tIndex(index).\n\t\t\tBodyJson(doc).\n\t\t\tDo(context.Background())\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Internal Server Error: \"+err.Error(), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\tw.WriteHeader(http.StatusCreated)\n\t\tjson.NewEncoder(w).Encode(map[string]string{\"message\": \"Document indexed successfully\", \"id\": resp.Id})\n\t}\n}\n\nfunc searchHandler(client *elastic.Client) http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tq := r.URL.Query().Get(\"q\")\n\t\tif q == \"\" {\n\t\t\thttp.Error(w, \"Bad Request: Missing 'q' parameter\", http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\n\t\tpageStr := r.URL.Query().Get(\"page\")\n\t\tsizeStr := r.URL.Query().Get(\"size\")\n\n\t\tpage, err := strconv.Atoi(pageStr)\n\t\tif err != nil || page < 1 {\n\t\t\tpage = 1\n\t\t}\n\n\t\tsize, err := strconv.Atoi(sizeStr)\n\t\tif err != nil || size < 1 {\n\t\t\tsize = 10\n\t\t}\n\n\t\tfrom := (page - 1) * size\n\n\t\tindex := \"documents\"\n\t\tquery := elastic.NewQueryStringQuery(q)\n\t\tsearchResult, err := client.Search().\n\t\t\tIndex(index).\n\t\t\tQuery(query).\n\t\t\tFrom(from).\n\t\t\tSize(size).\n\t\t\tDo(context.Background())\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Internal Server Error: \"+err.Error(), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\ttotal := searchResult.Hits.Total.Value\n\t\tpages := int(float64(total)/float64(size)) + 1\n\t\tif pages < 1 {\n\t\t\tpages = 1\n\t\t}\n\n\t\tvar docs []Document\n\t\tfor _, hit := range searchResult.Hits.Hits {\n\t\t\tvar doc Document\n\t\t\terr := json.Unmarshal(hit.Source, &doc)\n\t\t\tif err != nil {\n\t\t\t\thttp.Error(w, \"Internal Server Error: \"+err.Error(), http.StatusInternalServerError)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tdocs = append(docs, doc)\n\t\t}\n\n\t\tresp := SearchResponse{\n\t\t\tMeta: struct {\n\t\t\t\tTotal      int\n\t\t\t\tPages      int\n\t\t\t\tCurrentPage int\n\t\t\t\tPageSize   int\n\t\t\t}{\n\t\t\t\tTotal:      total,\n\t\t\t\tPages:      pages,\n\t\t\t\tCurrentPage: page,\n\t\t\t\tPageSize:   size,\n\t\t\t},\n\t\t\tDocuments: docs,\n\t\t}\n\n\t\tjson.NewEncoder(w).Encode(resp)\n\t}\n}\n```\n\n### Explanation\n\n1. **Initialization**:\n   - Set up an OpenSearch client pointing to `http://localhost:9200`.\n   - Use `gorilla/mux` for routing.\n\n2. **Indexing Documents**:\n   - **Endpoint**: `POST /index`\n   - Accepts a JSON document with `title` and `content`, indexes it in the `documents` index.\n\n3. **Searching Documents**:\n   - **Endpoint**: `GET /search`\n   - Accepts a query parameter `q` for the search query.\n   - Optional parameters `page` and `size` for pagination.\n   - Returns search results with pagination metadata.\n\nThis setup provides a basic full-text search application using Golang and OpenSearch, with capabilities to index and search documents efficiently."
    }
]