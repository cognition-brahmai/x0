[
    {
        "role": "user",
        "content": "Implement a binary search tree in C++ with the following operations: insert, delete, search, and find the minimum and maximum elements.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Certainly! Below is an implementation of a binary search tree (BST) in C++ that includes the operations you've requested: insert, delete, search, and finding the minimum and maximum elements.\n\n```cpp\n#include <iostream>\n\nclass Node {\npublic:\n    int data;\n    Node* left;\n    Node* right;\n    Node(int data) : data(data), left(nullptr), right(nullptr) {}\n};\n\nclass BinarySearchTree {\npublic:\n    Node* root;\n\n    BinarySearchTree() : root(nullptr) {}\n\n    // Insert a new node with the given data\n    void insert(int data) {\n        root = insert(root, data);\n    }\n\n    // Delete a node with the given data\n    void remove(int data) {\n        root = remove(root, data);\n    }\n\n    // Search for a node with the given data\n    bool search(int data) const {\n        return search(root, data);\n    }\n\n    // Find the minimum value in the tree\n    int findMin() const {\n        if (root == nullptr) {\n            throw std::runtime_error(\"Tree is empty\");\n        }\n        Node* current = root;\n        while (current->left != nullptr) {\n            current = current->left;\n        }\n        return current->data;\n    }\n\n    // Find the maximum value in the tree\n    int findMax() const {\n        if (root == nullptr) {\n            throw std::runtime_error(\"Tree is empty\");\n        }\n        Node* current = root;\n        while (current->right != nullptr) {\n            current = current->right;\n        }\n        return current->data;\n    }\n\nprivate:\n    // Helper function for insertion\n    Node* insert(Node* node, int data) {\n        if (node == nullptr) {\n            return new Node(data);\n        }\n        if (data < node->data) {\n            node->left = insert(node->left, data);\n        } else if (data > node->data) {\n            node->right = insert(node->right, data);\n        }\n        return node;\n    }\n\n    // Helper function for deletion\n    Node* remove(Node* node, int data) {\n        if (node == nullptr) {\n            return node;\n        }\n        if (data < node->data) {\n            node->left = remove(node->left, data);\n        } else if (data > node->data) {\n            node->right = remove(node->right, data);\n        } else {\n            // Node with only one child or no child\n            if (node->left == nullptr) {\n                Node* temp = node->right;\n                delete node;\n                return temp;\n            } else if (node->right == nullptr) {\n                Node* temp = node->left;\n                delete node;\n                return temp;\n            }\n            // Node with two children: get the inorder successor (smallest in the right subtree)\n            Node* temp = minValueNode(node->right);\n            // Copy the inorder successor's content to this node\n            node->data = temp->data;\n            // Delete the inorder successor\n            node->right = remove(node->right, temp->data);\n        }\n        return node;\n    }\n\n    // Helper function to find the minimum node\n    Node* minValueNode(Node* node) {\n        Node* current = node;\n        while (current->left != nullptr) {\n            current = current->left;\n        }\n        return current;\n    }\n\n    // Helper function for search\n    bool search(Node* node, int data) const {\n        if (node == nullptr) {\n            return false;\n        }\n        if (data == node->data) {\n            return true;\n        } else if (data < node->data) {\n            return search(node->left, data);\n        } else {\n            return search(node->right, data);\n        }\n    }\n};\n\nint main() {\n    BinarySearchTree bst;\n\n    bst.insert(50);\n    bst.insert(30);\n    bst.insert(20);\n    bst.insert(40);\n    bst.insert(70);\n    bst.insert(60);\n    bst.insert(80);\n\n    std::cout << \"Minimum element: \" << bst.findMin() << std::endl;\n    std::cout << \"Maximum element: \" << bst.findMax() << std::endl;\n\n    std::cout << \"Search for 20: \" << (bst.search(20) ? \"Found\" : \"Not Found\") << std::endl;\n    std::cout << \"Search for 100: \" << (bst.search(100) ? \"Found\" : \"Not Found\") << std::endl;\n\n    bst.remove(20);\n    std::cout << \"After deleting 20, search for 20: \" << (bst.search(20) ? \"Found\" : \"Not Found\") << std::endl;\n\n    bst.remove(30);\n    std::cout << \"After deleting 30, search for 30: \" << (bst.search(30) ? \"Found\" : \"Not Found\") << std::endl;\n\n    bst.remove(50);\n    std::cout << \"After deleting 50, search for 50: \" << (bst.search(50) ? \"Found\" : \"Not Found\") << std::endl;\n\n    return 0;\n}\n```\n\n### Explanation\n\n1. **Node Class**: Represents each node in the BST, containing data and pointers to left and right children.\n2. **BinarySearchTree Class**: Manages the BST operations.\n   - **Insertion**: Recursively finds the correct position for the new node based on its value.\n   - **Deletion**: Handles three cases:\n     - Node to be deleted is a leaf.\n     - Node to be deleted has one child.\n     - Node to be deleted has two children (replaces with the inorder successor).\n   - **Search**: Recursively searches for a node with the given value.\n   - **Find Minimum and Maximum**: Traverse to the leftmost and rightmost nodes, respectively.\n3. **Main Function**: Demonstrates insertion, finding min and max, searching, and deletion operations.\n\nThis implementation ensures that the BST properties are maintained after each operation."
    }
]