[
    {
        "role": "user",
        "content": "Write a Java program that interacts with AWS Lambda to create, update, and delete Lambda functions. The program should use the AWS SDK for Java and support command-line arguments for specifying the required actions and parameters.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Alright, I've got this task to create a Java program that interacts with AWS Lambda using the AWS SDK for Java. The program needs to be able to create, update, and delete Lambda functions, and it should accept command-line arguments to specify these actions along with the necessary parameters.\n\nFirst things first, I need to set up my development environment. Since I'm using Java, I'll need to have JDK installed, and I'll probably use an IDE like IntelliJ IDEA or Eclipse to write the code. Also, I need to make sure that the AWS SDK for Java is included in my project dependencies.\n\nI'm familiar with Maven, so I'll use that to manage my dependencies. I need to add the AWS SDK for Lambda to my pom.xml file. The dependency should look something like this:\n\n```xml\n<dependency>\n    <groupId>com.amazonaws</groupId>\n    <artifactId>aws-java-sdk-lambda</artifactId>\n    <version>1.12.107</version>\n</dependency>\n```\n\nI should check for the latest version on the AWS SDK for Java documentation page.\n\nNext, I need to think about how the program will accept command-line arguments. Probably, the first argument will be the action to perform, like \"create\", \"update\", or \"delete\", and then subsequent arguments will be the parameters required for that action.\n\nFor example:\n\n- To create a Lambda function: `java LambdaManager create function_name runtime handler_path`\n\n- To update a Lambda function: `java LambdaManager update function_name new_code_path`\n\n- To delete a Lambda function: `java LambdaManager delete function_name`\n\nI need to parse these arguments in my Java program. I can use the `args` array that's passed to the `main` method. I'll need to check the first argument to determine the action and then validate and extract the necessary parameters based on the action.\n\nLet me sketch out the basic structure of the program:\n\n1. Parse command-line arguments to determine the action and parameters.\n\n2. Set up the AWS Lambda client using the AWS SDK.\n\n3. Perform the specified action using the client.\n\n4. Handle any exceptions and provide appropriate feedback to the user.\n\nI need to handle different actions separately. Maybe I can use a switch statement based on the action argument.\n\nFirst, I need to handle the \"create\" action. To create a Lambda function, I need to provide the function name, runtime, handler information, and the code.\n\nIn the AWS SDK, this would involve using the `AWSLambda` client and calling the `createFunction` method, passing a `CreateFunctionRequest` object with all the required parameters.\n\nSimilarly, for \"update\", I might use the `updateFunctionCode` or `updateFunctionConfiguration` methods, depending on what needs to be updated.\n\nFor \"delete\", I can use the `deleteFunction` method.\n\nI should also consider error handling. If the function doesn't exist when trying to update or delete, I need to handle that gracefully.\n\nAnother important aspect is handling the code for the Lambda function. The code is usually zipped, so I might need to zip the files specified by the user before uploading them to Lambda.\n\nWait, actually, the AWS SDK can handle zipping the files if I use the appropriate methods. I need to check the documentation for that.\n\nAlso, I need to make sure that the user has the necessary permissions to perform these actions on AWS Lambda.\n\nLet me start by setting up a new Maven project and adding the AWS SDK dependency.\n\nFirst, create a new Maven project:\n\n```\nmvn archetype:generate -DgroupId=com.example -DartifactId=lambda-manager -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=false\n```\n\nThen, open the `pom.xml` file and add the AWS SDK dependency:\n\n```xml\n<dependencies>\n    <dependency>\n        <groupId>junit</groupId>\n        <artifactId>junit</artifactId>\n        <version>4.11</version>\n        <scope>test</scope>\n    </dependency>\n    <dependency>\n        <groupId>com.amazonaws</groupId>\n        <artifactId>aws-java-sdk-lambda</artifactId>\n        <version>1.12.107</version>\n    </dependency>\n</dependencies>\n```\n\nNow, open the `App.java` file in the `src/main/java/com/example` directory.\n\nLet me start by writing the basic structure of the program.\n\n```java\npackage com.example;\n\nimport com.amazonaws.services.lambda.AWSLambda;\nimport com.amazonaws.services.lambda.AWSLambdaClientBuilder;\nimport com.amazonaws.services.lambda.model.CreateFunctionRequest;\nimport com.amazonaws.services.lambda.model.CreateFunctionResult;\nimport com.amazonaws.services.lambda.model.DeleteFunctionRequest;\nimport com.amazonaws.services.lambda.model.DeleteFunctionResult;\nimport com.amazonaws.services.lambda.model.UpdateFunctionCodeRequest;\nimport com.amazonaws.services.lambda.model.UpdateFunctionCodeResult;\nimport com.amazonaws.services.lambda.model.UpdateFunctionConfigurationRequest;\nimport com.amazonaws.services.lambda.model.UpdateFunctionConfigurationResult;\n\npublic class LambdaManager {\n\n    public static void main(String[] args) {\n        if (args.length < 1) {\n            System.out.println(\"Usage: java LambdaManager <action> [parameters...]\");\n            System.exit(1);\n        }\n\n        String action = args[0].toLowerCase();\n\n        switch (action) {\n            case \"create\":\n                if (args.length != 4) {\n                    System.out.println(\"Usage: java LambdaManager create <function_name> <runtime> <handler_path>\");\n                    System.exit(1);\n                }\n                createFunction(args[1], args[2], args[3]);\n                break;\n            case \"update\":\n                if (args.length != 3) {\n                    System.out.println(\"Usage: java LambdaManager update <function_name> <new_code_path>\");\n                    System.exit(1);\n                }\n                updateFunction(args[1], args[2]);\n                break;\n            case \"delete\":\n                if (args.length != 2) {\n                    System.out.println(\"Usage: java LambdaManager delete <function_name>\");\n                    System.exit(1);\n                }\n                deleteFunction(args[1]);\n                break;\n            default:\n                System.out.println(\"Invalid action. Supported actions: create, update, delete\");\n                System.exit(1);\n        }\n    }\n\n    private static void createFunction(String functionName, String runtime, String handlerPath) {\n        AWSLambda client = AWSLambdaClientBuilder.defaultClient();\n\n        // Need to build CreateFunctionRequest here\n        // This includes setting the function name, runtime, handler, role, and code\n        // For code, it could be from a .zip file or S3 bucket\n        // Need to handle uploading the code\n\n        // Placeholder for actual implementation\n        System.out.println(\"Creating function: \" + functionName);\n    }\n\n    private static void updateFunction(String functionName, String codePath) {\n        AWSLambda client = AWSLambdaClientBuilder.defaultClient();\n\n        // Need to build UpdateFunctionCodeRequest here\n        // This includes setting the function name and the new code\n\n        // Placeholder for actual implementation\n        System.out.println(\"Updating function: \" + functionName);\n    }\n\n    private static void deleteFunction(String functionName) {\n        AWSLambda client = AWSLambdaClientBuilder.defaultClient();\n\n        DeleteFunctionRequest request = new DeleteFunctionRequest().withFunctionName(functionName);\n        DeleteFunctionResult result = client.deleteFunction(request);\n        System.out.println(\"Deleted function: \" + functionName);\n    }\n}\n```\n\nThis is a basic skeleton. Now, I need to fill in the actual implementations for `createFunction` and `updateFunction`.\n\nStarting with `createFunction`, I need to build a `CreateFunctionRequest` object. According to the AWS SDK documentation, this requires several parameters:\n\n- FunctionName\n\n- Runtime\n\n- Role (the ARN of the IAM role that Lambda assumes when it executes your function)\n\n- Handler\n\n- Code (which can be provided as a .zip file or a reference to an S3 object)\n\n- Description (optional)\n\n- Timeout (optional)\n\n- MemorySize (optional)\n\n- Publish (optional)\n\nI need to consider how to handle the role ARN. Maybe I can have it hardcoded in the program or have it passed as an additional parameter.\n\nAlso, for the code, I need to zip the files specified by the user. The AWS SDK provides a way to upload a .zip file directly.\n\nSo, in the `createFunction` method, I need to:\n\n1. Zip the files from the handler path provided by the user.\n\n2. Build a `CreateFunctionRequest` with the function name, runtime, role, handler, and the zipped code.\n\n3. Call the `createFunction` method on the `AWSLambda` client with this request.\n\nI need to handle any exceptions that might occur, such as the role not existing or the function name already being in use.\n\nSimilarly, for `updateFunction`, I need to:\n\n1. Zip the new code files from the path provided by the user.\n\n2. Build an `UpdateFunctionCodeRequest` with the function name and the new zipped code.\n\n3. Call the `updateFunctionCode` method on the `AWSLambda` client with this request.\n\nI should also consider whether to publish a new version of the function after updating the code.\n\nI need to look into how to zip the files using Java. I can use the `java.util.zip` package for this.\n\nLet me write a helper method to zip a directory.\n\n```java\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipOutputStream;\n\npublic class ZipUtils {\n\n    public static void zipDirectory(String dirPath, String zipFilePath) throws IOException {\n        FileOutputStream fos = new FileOutputStream(zipFilePath);\n        ZipOutputStream zos = new ZipOutputStream(fos);\n        File dir = new File(dirPath);\n        zipFile(dir, dir.getName(), zos);\n        zos.close();\n        fos.close();\n    }\n\n    private static void zipFile(File fileToZip, String fileName, ZipOutputStream zipOutputStream) throws IOException {\n        if (fileToZip.isDirectory()) {\n            File[] children = fileToZip.listFiles();\n            for (File childFile : children) {\n                zipFile(childFile, fileName + \"/\" + childFile.getName(), zipOutputStream);\n            }\n            return;\n        }\n        FileInputStream fis = new FileInputStream(fileToZip);\n        ZipEntry zipEntry = new ZipEntry(fileName);\n        zipOutputStream.putNextEntry(zipEntry);\n        byte[] bytes = new byte[1024];\n        int length;\n        while ((length = fis.read(bytes)) >= 0) {\n            zipOutputStream.write(bytes, 0, length);\n        }\n        fis.close();\n    }\n}\n```\n\nNow, in the `createFunction` and `updateFunction` methods, I can use this `zipDirectory` method to zip the handler code before uploading it to Lambda.\n\nBut wait, the handler path might be a single file or a directory. I need to handle both cases.\n\nMaybe I should check if the handler path is a file or a directory and zip accordingly.\n\nAlso, for Lambda, the handler should be in the format `filename.handler_method`, so I need to make sure that the user provides this correctly.\n\nI need to validate the handler format.\n\nMoreover, for the role, I need to have an IAM role that Lambda can assume to execute the function. I need to make sure that this role exists and has the necessary permissions.\n\nPerhaps I can have the role ARN passed as an additional parameter when creating the function.\n\nLet me adjust the create command to include the role ARN.\n\nFor example:\n\n`java LambdaManager create function_name runtime role_arn handler_path`\n\nI need to update the usage message and the argument checks accordingly.\n\nSimilarly, for updating, I might need to include other parameters if needed.\n\nLet me update the `main` method accordingly.\n\n```java\npublic static void main(String[] args) {\n    if (args.length < 1) {\n        System.out.println(\"Usage: java LambdaManager <action> [parameters...]\");\n        System.exit(1);\n    }\n\n    String action = args[0].toLowerCase();\n\n    switch (action) {\n        case \"create\":\n            if (args.length != 5) {\n                System.out.println(\"Usage: java LambdaManager create <function_name> <runtime> <role_arn> <handler_path>\");\n                System.exit(1);\n            }\n            createFunction(args[1], args[2], args[3], args[4]);\n            break;\n        case \"update\":\n            if (args.length != 3) {\n                System.out.println(\"Usage: java LambdaManager update <function_name> <new_code_path>\");\n                System.exit(1);\n            }\n            updateFunction(args[1], args[2]);\n            break;\n        case \"delete\":\n            if (args.length != 2) {\n                System.out.println(\"Usage: java LambdaManager delete <function_name>\");\n                System.exit(1);\n            }\n            deleteFunction(args[1]);\n            break;\n        default:\n            System.out.println(\"Invalid action. Supported actions: create, update, delete\");\n            System.exit(1);\n    }\n}\n```\n\nNow, update the `createFunction` method to accept the role ARN.\n\n```java\nprivate static void createFunction(String functionName, String runtime, String roleArn, String handlerPath) {\n    AWSLambda client = AWSLambdaClientBuilder.defaultClient();\n\n    // Zip the handler code\n    String zipFilePath = \"function_code.zip\";\n    try {\n        ZipUtils.zipDirectory(handlerPath, zipFilePath);\n    } catch (IOException e) {\n        System.err.println(\"Error zipping handler code: \" + e.getMessage());\n        System.exit(1);\n    }\n\n    // Read the zipped code into a byte array\n    byte[] codeZip = null;\n    try {\n        codeZip = java.nio.file.Files.readAllBytes(java.nio.file.Paths.get(zipFilePath));\n    } catch (IOException e) {\n        System.err.println(\"Error reading zipped code: \" + e.getMessage());\n        System.exit(1);\n    }\n\n    // Build the CreateFunctionRequest\n    CreateFunctionRequest request = new CreateFunctionRequest()\n            .withFunctionName(functionName)\n            .withRuntime(runtime)\n            .withRole(roleArn)\n            .withHandler(handlerPath)\n            .withCode(new com.amazonaws.services.lambda.model.FunctionCode().withZipFile(codeZip));\n\n    // Create the function\n    try {\n        CreateFunctionResult result = client.createFunction(request);\n        System.out.println(\"Function created: \" + result.getFunctionArn());\n    } catch (Exception e) {\n        System.err.println(\"Error creating function: \" + e.getMessage());\n        System.exit(1);\n    }\n}\n```\n\nSimilarly, update the `updateFunction` method.\n\n```java\nprivate static void updateFunction(String functionName, String codePath) {\n    AWSLambda client = AWSLambdaClientBuilder.defaultClient();\n\n    // Zip the new code\n    String zipFilePath = \"new_code.zip\";\n    try {\n        ZipUtils.zipDirectory(codePath, zipFilePath);\n    } catch (IOException e) {\n        System.err.println(\"Error zipping new code: \" + e.getMessage());\n        System.exit(1);\n    }\n\n    // Read the zipped code into a byte array\n    byte[] codeZip = null;\n    try {\n        codeZip = java.nio.file.Files.readAllBytes(java.nio.file.Paths.get(zipFilePath));\n    } catch (IOException e) {\n        System.err.println(\"Error reading zipped code: \" + e.getMessage());\n        System.exit(1);\n    }\n\n    // Build the UpdateFunctionCodeRequest\n    UpdateFunctionCodeRequest request = new UpdateFunctionCodeRequest()\n            .withFunctionName(functionName)\n            .withZipFile(codeZip)\n            .withPublish(true);\n\n    // Update the function code\n    try {\n        UpdateFunctionCodeResult result = client.updateFunctionCode(request);\n        System.out.println(\"Function updated: \" + result.getFunctionArn());\n    } catch (Exception e) {\n        System.err.println(\"Error updating function: \" + e.getMessage());\n        System.exit(1);\n    }\n}\n```\n\nI should also consider cleaning up the temporary zip files after they're uploaded, to avoid cluttering the file system.\n\nI can add code to delete the zip files after they're uploaded.\n\nLet me add that.\n\nIn `createFunction` and `updateFunction`, after uploading the code, I can delete the zip file.\n\n```java\n// In createFunction\njava.nio.file.Files.deleteIfExists(java.nio.file.Paths.get(zipFilePath));\n\n// In updateFunction\njava.nio.file.Files.deleteIfExists(java.nio.file.Paths.get(zipFilePath));\n```\n\nAlso, I need to make sure that the handler path is correctly formatted. According to AWS Lambda, the handler should be in the format `file_name.method_name`, without the .zip extension.\n\nI should validate that the handler path provided by the user follows this format.\n\nSimilarly, I need to validate that the runtime is one of the supported runtimes by AWS Lambda.\n\nI can hardcode a list of supported runtimes in the program or retrieve them dynamically from AWS.\n\nFor simplicity, I'll hardcode a list of supported runtimes.\n\nLet me add validation for the runtime and handler format.\n\nFirst, define a list of supported runtimes.\n\n```java\nprivate static final List<String> SUPPORTED_RUNTIMES = Arrays.asList(\n        \"nodejs\", \"nodejs4.3\", \"nodejs6.10\", \"nodejs8.10\", \"nodejs10.x\", \"nodejs12.x\", \"nodejs14.x\",\n        \"java8\", \"java11\", \"python2.7\", \"python3.6\", \"python3.7\", \"python3.8\", \"python3.9\",\n        \"dotnetcore1.0\", \"dotnetcore2.0\", \"dotnetcore2.1\", \"dotnetcore3.1\",\n        \"nodejs4.3-edge\", \"go1.x\", \"ruby2.5\", \"ruby2.7\", \"provided\"\n);\n```\n\nThen, in `createFunction`, check if the provided runtime is in the supported list.\n\n```java\nif (!SUPPORTED_RUNTIMES.contains(runtime)) {\n    System.err.println(\"Unsupported runtime: \" + runtime);\n    System.err.println(\"Supported runtimes: \" + String.join(\", \", SUPPORTED_RUNTIMES));\n    System.exit(1);\n}\n```\n\nSimilarly, validate the handler format. It should contain at least one dot, separating the file name and the method name.\n\n```java\nif (!handlerPath.contains(\".\")) {\n    System.err.println(\"Invalid handler format. It should be in the format 'file_name.method_name'\");\n    System.exit(1);\n}\n```\n\nI should add these validations before proceeding with zipping and uploading the code.\n\nAlso, I need to handle cases where the function already exists when trying to create it. AWS Lambda will throw an exception if a function with the same name already exists.\n\nI should catch that exception and provide a meaningful error message.\n\nSimilarly, when deleting a function that doesn't exist, AWS Lambda will throw an exception, which I should handle gracefully.\n\nLet me update the `createFunction` and `deleteFunction` methods to handle these cases.\n\nIn `createFunction`:\n\n```java\ntry {\n    CreateFunctionResult result = client.createFunction(request);\n    System.out.println(\"Function created: \" + result.getFunctionArn());\n} catch (com.amazonaws.services.lambda.model.AlreadyExistsException e) {\n    System.err.println(\"Function already exists: \" + functionName);\n    System.exit(1);\n} catch (Exception e) {\n    System.err.println(\"Error creating function: \" + e.getMessage());\n    System.exit(1);\n}\n```\n\nIn `deleteFunction`:\n\n```java\ntry {\n    DeleteFunctionResult result = client.deleteFunction(request);\n    System.out.println(\"Deleted function: \" + functionName);\n} catch (com.amazonaws.services.lambda.model.ResourceNotFoundException e) {\n    System.err.println(\"Function not found: \" + functionName);\n    System.exit(1);\n} catch (Exception e) {\n    System.err.println(\"Error deleting function: \" + e.getMessage());\n    System.exit(1);\n}\n```\n\nThis way, I'm providing more specific error messages based on the type of exception thrown by the AWS SDK.\n\nNow, I need to think about how to package and run this program.\n\nSince it's a command-line tool, I can compile it using Maven and create a JAR file.\n\nI can add a Maven shade plugin to create an executable JAR with all dependencies included.\n\nLet me add the shade plugin to the `pom.xml`.\n\n```xml\n<build>\n    <plugins>\n        <plugin>\n            <groupId>org.apache.maven.plugins</groupId>\n            <artifactId>maven-shade-plugin</artifactId>\n            <version>3.2.4</version>\n            <executions>\n                <execution>\n                    <phase>package</phase>\n                    <goals>\n                        <goal>shade</goal>\n                    </goals>\n                    <configuration>\n                        <transformers>\n                            <transformer implementation=\"org.apache.maven.plugins.shade.resource.ManifestResourceTransformer\">\n                                <mainClass>com.example.LambdaManager</mainClass>\n                            </transformer>\n                        </transformers>\n                    </configuration>\n                </execution>\n            </executions>\n        </plugin>\n    </plugins>\n</build>\n```\n\nNow, I can build the project using `mvn clean package`, and it will create a fat JAR file in the `target` directory.\n\nUsers can then run the program using `java -jar lambda-manager.jar <action> [parameters]`.\n\nI should also consider adding some logging instead of just printing to stdout and stderr. Maybe use a logging framework like Log4j.\n\nBut for simplicity, I'll stick with `System.out` and `System.err` for now.\n\nAnother consideration is handling AWS credentials. The AWS SDK for Java supports various ways of providing credentials, such as through environment variables, AWS config files, or IAM roles if running on an EC2 instance.\n\nI need to make sure that the program can access valid AWS credentials to perform the Lambda operations.\n\nI should document this requirement for users of the program.\n\nAlso, I need to make sure that the region is set correctly. By default, the SDK will use the region specified in the AWS config files or environment variables.\n\nIf needed, I can allow the user to specify the region as an additional command-line argument.\n\nFor now, I'll assume that the default region is set correctly.\n\nLet me think about how to test this program.\n\nI can set up an AWS account and create an IAM user with permissions to create, update, and delete Lambda functions.\n\nThen, I can configure the AWS credentials for that IAM user on my machine.\n\nAfter that, I can run the program with different actions and parameters to see if it works as expected.\n\nFor example:\n\n- Create a new Lambda function with a simple \"hello world\" handler.\n\n- Update the function code with a new version of the handler.\n\n- Delete the function.\n\nI need to make sure that the function is created successfully, that the updates are applied correctly, and that the function is deleted without issues.\n\nI should also test error scenarios, such as trying to create a function that already exists, updating a function that doesn't exist, etc., to verify that the error handling works correctly.\n\nAdditionally, I need to ensure that the zipping of files works correctly for both single files and directories.\n\nI should test both cases.\n\nWait, actually, AWS Lambda requires the handler code to be zipped into a .zip file, with the handler file at the root of the zip.\n\nSo, if the user provides a directory, I need to zip that directory correctly.\n\nIf the user provides a single file, I need to zip that file with the correct name inside the zip.\n\nThis might require some adjustments in the `zipDirectory` method.\n\nLet me consider an example.\n\nSuppose the user provides a directory structure like this:\n\n- myfunction/\n\n- handler.js\n\nThen, the zip should contain:\n\n- handler.js\n\nNot:\n\n- myfunction/\n\n- handler.js\n\nSo, I need to zip the contents of the directory, not the directory itself.\n\nSimilarly, if the user provides a single file, say `handler.js`, the zip should contain `handler.js` at the root.\n\nI need to adjust the `zipDirectory` method to handle this correctly.\n\nLet me update the `zipDirectory` method to exclude the directory name from the zip entries.\n\n```java\npublic class ZipUtils {\n\n    public static void zipDirectory(String dirPath, String zipFilePath) throws IOException {\n        FileOutputStream fos = new FileOutputStream(zipFilePath);\n        ZipOutputStream zos = new ZipOutputStream(fos);\n        File dir = new File(dirPath);\n        zipFile(dir, \"\", zos);\n        zos.close();\n        fos.close();\n    }\n\n    private static void zipFile(File fileToZip, String base, ZipOutputStream zipOutputStream) throws IOException {\n        if (fileToZip.isDirectory()) {\n            File[] children = fileToZip.listFiles();\n            for (File childFile : children) {\n                zipFile(childFile, base + fileToZip.getName() + \"/\", zipOutputStream);\n            }\n            return;\n        }\n        FileInputStream fis = new FileInputStream(fileToZip);\n        ZipEntry zipEntry = new ZipEntry(base + fileToZip.getName());\n        zipOutputStream.putNextEntry(zipEntry);\n        byte[] bytes = new byte[1024];\n        int length;\n        while ((length = fis.read(bytes)) >= 0) {\n            zipOutputStream.write(bytes, 0, length);\n        }\n        fis.close();\n    }\n}\n```\n\nIn this updated version, when zipping a directory, I pass an empty string as the base, and then prepend the directory name followed by \"/\" to the base for each subdirectory.\n\nWait, no. I need to exclude the top-level directory name from the zip entries.\n\nLet me think differently.\n\nI can calculate the parent directory path and then subtract that from the entry path.\n\nHere's an improved version:\n\n```java\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipOutputStream;\n\npublic class ZipUtils {\n\n    public static void zipDirectory(String dirPath, String zipFilePath) throws IOException {\n        FileOutputStream fos = new FileOutputStream(zipFilePath);\n        ZipOutputStream zos = new ZipOutputStream(fos);\n        File dir = new File(dirPath);\n        String parentDir = dir.getCanonicalPath();\n        zipFiles(dir, parentDir, zos);\n        zos.close();\n        fos.close();\n    }\n\n    private static void zipFiles(File fileToZip, String parentDir, ZipOutputStream zos) throws IOException {\n        if (fileToZip.isDirectory()) {\n            File[] children = fileToZip.listFiles();\n            for (File childFile : children) {\n                zipFiles(childFile, parentDir, zos);\n            }\n            return;\n        }\n        String filePath = fileToZip.getCanonicalPath();\n        String relativePath = filePath.substring(parentDir.length() + 1);\n        ZipEntry zipEntry = new ZipEntry(relativePath);\n        zos.putNextEntry(zipEntry);\n        FileInputStream fis = new FileInputStream(fileToZip);\n        byte[] bytes = new byte[1024];\n        int length;\n        while ((length = fis.read(bytes)) >= 0) {\n            zos.write(bytes, 0, length);\n        }\n        fis.close();\n        zos.closeEntry();\n    }\n}\n```\n\nIn this version, I calculate the canonical path of the directory to zip and use it as the parent directory. Then, for each file, I calculate the relative path by subtracting the parent directory path and use that as the entry name in the zip file.\n\nThis should ensure that the zip file contains the files and directories relative to the provided directory path, excluding the top-level directory name.\n\nI should test this method with both single files and directories to ensure it works as expected.\n\nAlso, I need to handle cases where the handler path is a single file.\n\nIn that case, I can zip the single file directly.\n\nI need to modify the `zipDirectory` method to handle both files and directories.\n\nLet me adjust it to check if the path is a file or a directory and handle accordingly.\n\nHere's an updated version:\n\n```java\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipOutputStream;\n\npublic class ZipUtils {\n\n    public static void zipFiles(String path, String zipFilePath) throws IOException {\n        FileOutputStream fos = new FileOutputStream(zipFilePath);\n        ZipOutputStream zos = new ZipOutputStream(fos);\n        File file = new File(path);\n        if (file.isDirectory()) {\n            zipDirectory(file, file.getCanonicalPath(), zos);\n        } else {\n            zipFile(file, zos);\n        }\n        zos.close();\n        fos.close();\n    }\n\n    private static void zipDirectory(File dir, String parentDir, ZipOutputStream zos) throws IOException {\n        File[] files = dir.listFiles();\n        for (File file : files) {\n            if (file.isDirectory()) {\n                zipDirectory(file, parentDir, zos);\n            } else {\n                String filePath = file.getCanonicalPath();\n                String relativePath = filePath.substring(parentDir.length() + 1);\n                ZipEntry zipEntry = new ZipEntry(relativePath);\n                zos.putNextEntry(zipEntry);\n                FileInputStream fis = new FileInputStream(file);\n                byte[] bytes = new byte[1024];\n                int length;\n                while ((length = fis.read(bytes)) >= 0) {\n                    zos.write(bytes, 0, length);\n                }\n                fis.close();\n                zos.closeEntry();\n            }\n        }\n    }\n\n    private static void zipFile(File file, ZipOutputStream zos) throws IOException {\n        ZipEntry zipEntry = new ZipEntry(file.getName());\n        zos.putNextEntry(zipEntry);\n        FileInputStream fis = new FileInputStream(file);\n        byte[] bytes = new byte[1024];\n        int length;\n        while ((length = fis.read(bytes)) >= 0) {\n            zos.write(bytes, 0, length);\n        }\n        fis.close();\n        zos.closeEntry();\n    }\n}\n```\n\nNow, in the `createFunction` and `updateFunction` methods, I can call `ZipUtils.zipFiles(handlerPath, zipFilePath);` regardless of whether `handlerPath` is a file or a directory.\n\nI need to update the `createFunction` and `updateFunction` methods to use this new `zipFiles` method.\n\nAlso, I should consider handling exceptions more gracefully when zipping files, such as handling cases where the file or directory doesn't exist.\n\nI can add checks to ensure that the handler path exists before attempting to zip it.\n\nLet me add these checks.\n\nIn `createFunction`:\n\n```java\nFile handlerFile = new File(handlerPath);\nif (!handlerFile.exists()) {\n    System.err.println(\"Handler path does not exist: \" + handlerPath);\n    System.exit(1);\n}\n```\n\nSimilarly, in `updateFunction`:\n\n```java\nFile codeFile = new File(codePath);\nif (!codeFile.exists()) {\n    System.err.println(\"Code path does not exist: \" + codePath);\n    System.exit(1);\n}\n```\n\nThis should prevent attempts to zip non-existent paths.\n\nNow, I need to make sure that the zip file is created correctly and that the code is uploaded properly to Lambda.\n\nI can add some debug statements or logging to verify the contents of the zip file before uploading it.\n\nBut for now, I'll assume that the zipping works correctly.\n\nAnother thing to consider is the size of the zip file. AWS Lambda has limits on the deployment package size, currently up to 50 MB unziped and 250 MB zipped.\n\nI need to ensure that the zip file doesn't exceed these limits.\n\nI can add checks to verify the size of the zip file before uploading it.\n\nLet me add a check in `createFunction` and `updateFunction` to verify the zip file size.\n\nDefine a constant for the maximum allowed zip file size:\n\n```java\nprivate static final long MAX_ZIP_FILE_SIZE = 250 * 1024 * 1024; // 250 MB\n```\n\nThen, in `createFunction` and `updateFunction`, after zipping the files, check the size of the zip file:\n\n```java\nFile zipFile = new File(zipFilePath);\nif (zipFile.length() > MAX_ZIP_FILE_SIZE) {\n    System.err.println(\"Zip file size exceeds the maximum allowed size of 250 MB.\");\n    System.exit(1);\n}\n```\n\nThis will prevent uploading oversized zip files.\n\nAlso, I need to make sure that the function's code meets Lambda's requirements, such as the handler being correctly named and implemented.\n\nBut enforcing that is beyond the scope of this program, as it depends on the specific runtime and code implementation.\n\nNow, I need to think about how to handle the IAM role ARN.\n\nI can assume that the user provides a valid role ARN, but I should validate that it's in the correct format.\n\nAWS IAM role ARNs typically follow the pattern `arn:aws:iam::account-id:role/role-name`.\n\nI can use a regular expression to validate the role ARN format.\n\nHere's an example regex for validating an IAM role ARN:\n\n```java\nprivate static final Pattern ROLE_ARN_PATTERN = Pattern.compile(\"^arn:aws:iam::\\\\d{12}:role/[a-zA-Z_0-9+=,.@-]+$\");\n```\n\nThen, in `createFunction`, I can validate the role ARN:\n\n```java\nif (!ROLE_ARN_PATTERN.matcher(roleArn).matches()) {\n    System.err.println(\"Invalid role ARN format: \" + roleArn);\n    System.exit(1);\n}\n```\n\nThis adds an extra layer of validation to ensure that the role ARN is correctly formatted before proceeding.\n\nI should also consider handling regions explicitly.\n\nMaybe allow the user to specify the AWS region as an additional parameter.\n\nThis can be useful if the default region is not set or if the user wants to operate in a different region.\n\nI can add a `--region` option or similar.\n\nBut to keep it simple, I'll assume that the default region is set correctly.\n\nIf needed, I can extend the program later to support specifying the region.\n\nAnother consideration is handling timeouts and memory configurations for the Lambda function.\n\nAWS Lambda allows setting the timeout and memory size for a function.\n\nI can extend the `createFunction` method to accept additional parameters for timeout and memory size.\n\nFor now, I'll use the default values.\n\nSimilarly, for updating the function configuration, I can add options to update timeout, memory size, etc.\n\nBut to keep it simple, I'll focus on creating, updating, and deleting the function code for now.\n\nI should also think about how to handle environment variables for the Lambda function.\n\nAWS Lambda allows setting environment variables for a function.\n\nI can extend the `createFunction` method to accept a path to a JSON file containing environment variables.\n\nBut for this initial version, I'll skip that feature.\n\nNow, I need to ensure that the program handles all possible exceptions and edge cases.\n\nI can create a list of test cases:\n\n1. Create a new Lambda function with valid parameters.\n\n2. Try to create a Lambda function with an already existing name.\n\n3. Update the code of an existing Lambda function.\n\n4. Try to update the code of a non-existing Lambda function.\n\n5. Delete an existing Lambda function.\n\n6. Try to delete a non-existing Lambda function.\n\n7. Provide invalid runtime values.\n\n8. Provide incorrectly formatted handler paths.\n\n9. Provide non-existent handler paths.\n\n10. Provide role ARNs with incorrect formats.\n\nI need to write test cases for each of these scenarios to ensure that the program behaves correctly and provides meaningful error messages.\n\nI can write separate test methods for each case, but since this is a command-line program, it's easier to test manually for now.\n\nOnce I'm confident that the program works correctly, I can package it into a JAR file and distribute it.\n\nI should also write a README file explaining how to use the program, including how to set up AWS credentials and the required permissions.\n\nAdditionally, I can consider adding more features in the future, such as listing functions, invoking functions, or managing function aliases and versions.\n\nBut for this initial version, focusing on create, update, and delete operations should suffice.\n\nI think I've covered the main requirements for this task.\n\n## Final Solution\nTo create a Java program that interacts with AWS Lambda to manage Lambda functions, follow the steps below. This program uses the AWS SDK for Java and supports command-line arguments for specifying actions and parameters.\n\n### Prerequisites\n1. **AWS Account and IAM User**: Ensure you have an AWS account and an IAM user with appropriate permissions to manage Lambda functions.\n2. **AWS SDK for Java**: Add the AWS SDK dependency to your project.\n3. **Java Development Kit (JDK)**: Ensure JDK is installed on your machine.\n\n### Solution Code\n\n```java\npackage com.example;\n\nimport com.amazonaws.services.lambda.AWSLambda;\nimport com.amazonaws.services.lambda.AWSLambdaClientBuilder;\nimport com.amazonaws.services.lambda.model.CreateFunctionRequest;\nimport com.amazonaws.services.lambda.model.CreateFunctionResult;\nimport com.amazonaws.services.lambda.model.DeleteFunctionRequest;\nimport com.amazonaws.services.lambda.model.DeleteFunctionResult;\nimport com.amazonaws.services.lambda.model.UpdateFunctionCodeRequest;\nimport com.amazonaws.services.lambda.model.UpdateFunctionCodeResult;\nimport com.amazonaws.services.lambda.model.AlreadyExistsException;\nimport com.amazonaws.services.lambda.model.ResourceNotFoundException;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.regex.Pattern;\n\npublic class LambdaManager {\n\n    private static final List<String> SUPPORTED_RUNTIMES = Arrays.asList(\n            \"nodejs\", \"nodejs4.3\", \"nodejs6.10\", \"nodejs8.10\", \"nodejs10.x\", \"nodejs12.x\", \"nodejs14.x\",\n            \"java8\", \"java11\", \"python2.7\", \"python3.6\", \"python3.7\", \"python3.8\", \"python3.9\",\n            \"dotnetcore1.0\", \"dotnetcore2.0\", \"dotnetcore2.1\", \"dotnetcore3.1\",\n            \"nodejs4.3-edge\", \"go1.x\", \"ruby2.5\", \"ruby2.7\", \"provided\"\n    );\n\n    private static final Pattern ROLE_ARN_PATTERN = Pattern.compile(\"^arn:aws:iam::\\\\d{12}:role/[a-zA-Z_0-9+=,.@-]+$\");\n    private static final long MAX_ZIP_FILE_SIZE = 250 * 1024 * 1024; // 250 MB\n    private static final String ZIP_FILE_PATH = \"function_code.zip\";\n\n    public static void main(String[] args) {\n        if (args.length < 1) {\n            System.out.println(\"Usage: java LambdaManager <action> [parameters...]\");\n            System.exit(1);\n        }\n\n        String action = args[0].toLowerCase();\n\n        switch (action) {\n            case \"create\":\n                if (args.length != 5) {\n                    System.out.println(\"Usage: java LambdaManager create <function_name> <runtime> <role_arn> <handler_path>\");\n                    System.exit(1);\n                }\n                createFunction(args[1], args[2], args[3], args[4]);\n                break;\n            case \"update\":\n                if (args.length != 3) {\n                    System.out.println(\"Usage: java LambdaManager update <function_name> <new_code_path>\");\n                    System.exit(1);\n                }\n                updateFunction(args[1], args[2]);\n                break;\n            case \"delete\":\n                if (args.length != 2) {\n                    System.out.println(\"Usage: java LambdaManager delete <function_name>\");\n                    System.exit(1);\n                }\n                deleteFunction(args[1]);\n                break;\n            default:\n                System.out.println(\"Invalid action. Supported actions: create, update, delete\");\n                System.exit(1);\n        }\n    }\n\n    private static void createFunction(String functionName, String runtime, String roleArn, String handlerPath) {\n        validateRuntime(runtime);\n        validateRoleArn(roleArn);\n        validateHandlerPath(handlerPath);\n\n        File handlerFile = new File(handlerPath);\n        if (!handlerFile.exists()) {\n            System.err.println(\"Handler path does not exist: \" + handlerPath);\n            System.exit(1);\n        }\n\n        AWSLambda client = AWSLambdaClientBuilder.defaultClient();\n\n        try {\n            ZipUtils.zipFiles(handlerPath, ZIP_FILE_PATH);\n            byte[] codeZip = Files.readAllBytes(Paths.get(ZIP_FILE_PATH));\n\n            CreateFunctionRequest request = new CreateFunctionRequest()\n                    .withFunctionName(functionName)\n                    .withRuntime(runtime)\n                    .withRole(roleArn)\n                    .withHandler(handlerPath)\n                    .withCode(new com.amazonaws.services.lambda.model.FunctionCode().withZipFile(codeZip));\n\n            CreateFunctionResult result = client.createFunction(request);\n            System.out.println(\"Function created: \" + result.getFunctionArn());\n        } catch (AlreadyExistsException e) {\n            System.err.println(\"Function already exists: \" + functionName);\n            System.exit(1);\n        } catch (IOException e) {\n            System.err.println(\"Error zipping or uploading code: \" + e.getMessage());\n            System.exit(1);\n        } catch (Exception e) {\n            System.err.println(\"Error creating function: \" + e.getMessage());\n            System.exit(1);\n        } finally {\n            deleteZipFile(ZIP_FILE_PATH);\n        }\n    }\n\n    private static void updateFunction(String functionName, String codePath) {\n        File codeFile = new File(codePath);\n        if (!codeFile.exists()) {\n            System.err.println(\"Code path does not exist: \" + codePath);\n            System.exit(1);\n        }\n\n        AWSLambda client = AWSLambdaClientBuilder.defaultClient();\n\n        try {\n            ZipUtils.zipFiles(codePath, ZIP_FILE_PATH);\n            byte[] codeZip = Files.readAllBytes(Paths.get(ZIP_FILE_PATH));\n\n            UpdateFunctionCodeRequest request = new UpdateFunctionCodeRequest()\n                    .withFunctionName(functionName)\n                    .withZipFile(codeZip)\n                    .withPublish(true);\n\n            UpdateFunctionCodeResult result = client.updateFunctionCode(request);\n            System.out.println(\"Function updated: \" + result.getFunctionArn());\n        } catch (ResourceNotFoundException e) {\n            System.err.println(\"Function not found: \" + functionName);\n            System.exit(1);\n        } catch (IOException e) {\n            System.err.println(\"Error zipping or uploading code: \" + e.getMessage());\n            System.exit(1);\n        } catch (Exception e) {\n            System.err.println(\"Error updating function: \" + e.getMessage());\n            System.exit(1);\n        } finally {\n            deleteZipFile(ZIP_FILE_PATH);\n        }\n    }\n\n    private static void deleteFunction(String functionName) {\n        AWSLambda client = AWSLambdaClientBuilder.defaultClient();\n\n        DeleteFunctionRequest request = new DeleteFunctionRequest().withFunctionName(functionName);\n        try {\n            DeleteFunctionResult result = client.deleteFunction(request);\n            System.out.println(\"Deleted function: \" + functionName);\n        } catch (ResourceNotFoundException e) {\n            System.err.println(\"Function not found: \" + functionName);\n            System.exit(1);\n        } catch (Exception e) {\n            System.err.println(\"Error deleting function: \" + e.getMessage());\n            System.exit(1);\n        }\n    }\n\n    private static void validateRuntime(String runtime) {\n        if (!SUPPORTED_RUNTIMES.contains(runtime)) {\n            System.err.println(\"Unsupported runtime: \" + runtime);\n            System.err.println(\"Supported runtimes: \" + String.join(\", \", SUPPORTED_RUNTIMES));\n            System.exit(1);\n        }\n    }\n\n    private static void validateRoleArn(String roleArn) {\n        if (!ROLE_ARN_PATTERN.matcher(roleArn).matches()) {\n            System.err.println(\"Invalid role ARN format: \" + roleArn);\n            System.exit(1);\n        }\n    }\n\n    private static void validateHandlerPath(String handlerPath) {\n        if (!handlerPath.contains(\".\")) {\n            System.err.println(\"Invalid handler format. It should be in the format 'file_name.method_name'\");\n            System.exit(1);\n        }\n    }\n\n    private static void deleteZipFile(String zipFilePath) {\n        try {\n            Files.deleteIfExists(Paths.get(zipFilePath));\n        } catch (IOException e) {\n            System.err.println(\"Error deleting zip file: \" + e.getMessage());\n        }\n    }\n}\n\nclass ZipUtils {\n    public static void zipFiles(String path, String zipFilePath) throws IOException {\n        try (FileOutputStream fos = new FileOutputStream(zipFilePath);\n             ZipOutputStream zos = new ZipOutputStream(fos)) {\n            File file = new File(path);\n            if (file.isDirectory()) {\n                zipDirectory(file, file.getCanonicalPath(), zos);\n            } else {\n                zipFile(file, zos);\n            }\n        }\n    }\n\n    private static void zipDirectory(File dir, String parentDir, ZipOutputStream zos) throws IOException {\n        File[] files = dir.listFiles();\n        for (File file : files) {\n            if (file.isDirectory()) {\n                zipDirectory(file, parentDir, zos);\n            } else {\n                String filePath = file.getCanonicalPath();\n                String relativePath = filePath.substring(parentDir.length() + 1);\n                ZipEntry zipEntry = new ZipEntry(relativePath);\n                zos.putNextEntry(zipEntry);\n                try (FileInputStream fis = new FileInputStream(file)) {\n                    byte[] bytes = new byte[1024];\n                    int length;\n                    while ((length = fis.read(bytes)) >= 0) {\n                        zos.write(bytes, 0, length);\n                    }\n                }\n                zos.closeEntry();\n            }\n        }\n    }\n\n    private static void zipFile(File file, ZipOutputStream zos) throws IOException {\n        ZipEntry zipEntry = new ZipEntry(file.getName());\n        zos.putNextEntry(zipEntry);\n        try (FileInputStream fis = new FileInputStream(file)) {\n            byte[] bytes = new byte[1024];\n            int length;\n            while ((length = fis.read(bytes)) >= 0) {\n                zos.write(bytes, 0, length);\n            }\n        }\n        zos.closeEntry();\n    }\n}\n```\n\n### Usage\n\n1. **Create a Lambda Function**:\n   ```sh\n   java LambdaManager create <function_name> <runtime> <role_arn> <handler_path>\n   ```\n\n2. **Update a Lambda Function**:\n   ```sh\n   java LambdaManager update <function_name> <new_code_path>\n   ```\n\n3. **Delete a Lambda Function**:\n   ```sh\n   java LambdaManager delete <function_name>\n   ```\n\n### Explanation\n\n- **Dependencies**: The AWS SDK for Java is used to interact with AWS Lambda.\n- **Command-Line Arguments**: The program accepts actions like `create`, `update`, and `delete` with necessary parameters.\n- **Zip Utility**: A utility class `ZipUtils` handles zipping of files or directories.\n- **Validation**: Input validations are performed for runtime, role ARN, and handler path formats.\n- **Error Handling**: The program handles exceptions and provides meaningful error messages for invalid inputs or AWS operation failures.\n\n### Note\n\n- Ensure AWS credentials are configured properly on your machine.\n- Adjust the supported runtimes list as needed based on AWS updates.\n- This is a basic implementation and can be extended with more features like handling environment variables, memory settings, etc."
    }
]