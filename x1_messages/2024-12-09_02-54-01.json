[
    {
        "role": "user",
        "content": "Create a weather forecast CLI tool in Node.js that fetches data from a public weather API. The tool should accept a city name or coordinates as input and display the current weather conditions and a 5-day forecast. Cache the fetched data in a Redis datastore to reduce the number of API calls.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Alright, I've got this task to create a weather forecast CLI tool using Node.js that fetches data from a public weather API. The tool needs to accept either a city name or coordinates and then display the current weather conditions along with a 5-day forecast. Additionally, I need to cache the fetched data in a Redis datastore to minimize the number of API calls. Sounds like a fun project!\n\nFirst things first, I need to choose a public weather API. There are several options out there, but one of the most popular ones is OpenWeatherMap. It offers a free tier that should suffice for this project. So, I'll sign up for an API key from OpenWeatherMap.\n\nOnce I have the API key, I need to figure out how to structure my CLI tool. Since it's a command-line tool, I'll probably use a package like Commander.js to handle the command-line arguments and options in a nice way.\n\nLet me think about the inputs the user can provide. The tool should accept either a city name or coordinates (latitude and longitude). So, I need to handle both cases. Maybe I'll have options like --city for specifying a city name and --coords for specifying coordinates.\n\nNext, I need to fetch the weather data from the OpenWeatherMap API. For current weather conditions, I can use their current weather data API, and for the 5-day forecast, I can use their forecast API.\n\nBut before making API calls, I should check if the data is already cached in Redis. If it is, and it's not too old, I can just retrieve it from there instead of hitting the API again. This will help reduce the load on the API and improve the response time for the user.\n\nSo, I need to set up a Redis datastore. I can either run a local Redis server or use a cloud-based Redis service like Redis Labs or Amazon ElastiCache. For simplicity, I'll probably go with a local Redis server for now.\n\nI need to install the necessary Node.js packages. Besides Commander.js for the CLI, I'll need a package to interact with Redis, like redis, and probably axios or fetch to make HTTP requests to the weather API.\n\nLet me list out the steps I need to follow:\n\n1. Set up a new Node.js project and install the required packages: commander, redis, axios.\n\n2. Set up Redis connection in Node.js.\n\n3. Create functions to fetch current weather and 5-day forecast from OpenWeatherMap API.\n\n4. Create functions to check and retrieve data from Redis cache before making an API call.\n\n5. Implement caching of API responses in Redis with an appropriate expiration time.\n\n6. Design the CLI tool using Commander.js to accept city name or coordinates.\n\n7. Display the fetched weather data in a user-friendly format.\n\n8. Handle possible errors, such as invalid input, API request failures, or cache misses.\n\nLet me start by setting up a new Node.js project. I'll create a new directory for my project and initialize it with npm.\n\n```\n\nmkdir weather-cli\n\ncd weather-cli\n\nnpm init -y\n\n```\n\nNow, I'll install the required packages.\n\n```\n\nnpm install commander redis axios\n\n```\n\nNext, I need to set up Redis. I'll assume that Redis is installed locally and running on the default port. If not, I'll need to install it or configure the connection settings accordingly.\n\nIn Node.js, I can create a Redis client using the redis package.\n\n```\n\nconst redis = require('redis');\n\nconst client = redis.createClient();\n\nclient.on('error', (err) => console.log('Redis Client Error', err));\n\n```\n\nI should also set up the OpenWeatherMap API configuration. I'll need to store the API key securely. For now, I can keep it in an environment variable.\n\n```\n\nrequire('dotenv').config();\n\nconst API_KEY = process.env.OPENWEATHERMAP_API_KEY;\n\nconst API_BASE_URL = 'https://api.openweathermap.org/data/2.5';\n\n```\n\nI need to create functions to fetch the current weather and the forecast.\n\nFor the current weather, I can use the `/weather` endpoint. The API accepts parameters like city name or coordinates.\n\nSimilarly, for the forecast, I can use the `/forecast` endpoint.\n\nI need to decide on the cache expiration time. Let's say 1 hour for the current weather and 6 hours for the forecast to balance between freshness and reducing API calls.\n\nNow, I need to think about how to structure the caching. I'll use the city name or coordinates as the cache key. For example, if the user provides a city name like \"London\", I'll use \"london\" as the key. If they provide coordinates, maybe something like \"coords:51.5074,-0.1278\".\n\nBut I should probably normalize the keys to make them case-insensitive and free of extra spaces.\n\nAlso, since the API responses are in JSON, I'll need to serialize them to strings when storing in Redis and deserialize them when retrieving.\n\nI should also handle situations where the cache is empty or the data has expired.\n\nLet me sketch out some pseudocode for the fetch functions.\n\n```\n\nfunction fetchCurrentWeather(cityOrCoords) {\n\n  const cacheKey = generateCacheKey(cityOrCoords);\n\n  const cachedData = redis.get(cacheKey);\n\n  if (cachedData) {\n\n    return JSON.parse(cachedData);\n\n  } else {\n\n    const apiResponse = axios.get(`${API_BASE_URL}/weather`, { params: { q: cityOrCoords,appid: API_KEY } });\n\n    redis.set(cacheKey, JSON.stringify(apiResponse.data), 'EX', 3600); // 1 hour expiration\n\n    return apiResponse.data;\n\n  }\n\n}\n\n```\n\nSimilarly for the forecast.\n\nNow, I need to handle the CLI options using Commander.js.\n\nI'll create a CLI command called \"weather\" with options for city and coordinates.\n\nSomething like:\n\n```\n\nweather --city London\n\nor\n\nweather --coords 51.5074,-0.1278\n\n```\n\nI need to make sure that the user provides either a city or coordinates, but not both.\n\nIn Commander.js, I can define options and require one of them.\n\nThen, based on the provided option, I'll call the appropriate fetch functions and display the data.\n\nI should also think about how to format the output. For the current weather, I can display temperature, description, humidity, etc. For the forecast, I can show the date and the corresponding weather conditions for each day.\n\nI need to handle possible errors, such as:\n\n- Invalid city name or coordinates.\n\n- API request failures (e.g., network issues, rate limiting).\n\n- Cache misses.\n\n- Invalid responses from the API.\n\nI should provide meaningful error messages to the user in such cases.\n\nAlso, I need to make sure that the tool is usable from the command line, so I'll need to write a bin script in package.json.\n\nLet me outline the steps in code structure:\n\n- Create an index.js file for the main logic.\n\n- Use Commander.js to define the CLI command and options.\n\n- Import functions to fetch and display weather data.\n\n- Handle the logic based on user input.\n\n- Use Redis for caching.\n\n- Configure OpenWeatherMap API.\n\nI should also write some unit tests to ensure that the functions work as expected, but that might be out of scope for now.\n\nLet me start by setting up the basic structure.\n\nFirst, install Commander.js and set up the bin script in package.json.\n\n```\n\n\"bin\": {\n\n  \"weather\": \"index.js\"\n\n}\n\n```\n\nThen, in index.js, set up the CLI command.\n\n```\n\nconst program = require('commander');\n\nprogram\n\n  .command('weather')\n\n  .option('-c, --city <city>', 'City name')\n\n  .option('-d, --coords <coords>', 'Coordinates in lat,lon format')\n\n  .action((options) => {\n\n    if (!options.city && !options.coords) {\n\n      console.error('Please provide either --city or --coords');\n\n      process.exit(1);\n\n    }\n\n    if (options.city) {\n\n      // Fetch and display weather for city\n\n    } else {\n\n      // Fetch and display weather for coordinates\n\n    }\n\n  });\n\nprogram.parse(process.argv);\n\n```\n\nNow, I need to implement the fetch functions and caching logic.\n\nI'll create a separate file, say weather.js, to handle the API calls and caching.\n\nIn weather.js:\n\n- Import required modules: axios, redis.\n\n- Define functions to fetch current weather and forecast.\n\n- Implement caching logic using Redis.\n\nIn index.js, import these functions and use them in the CLI action.\n\nI need to think about how to handle the cache keys. For city names, I can probably use the city name in lowercase and remove any spaces or special characters. For coordinates, I can use the lat,lon string as is, but maybe sanitize it to ensure no invalid characters.\n\nAlso, I need to handle different units for temperature, etc. Maybe I'll add an option for the user to specify the unit (Celsius, Fahrenheit).\n\nWait, OpenWeatherMap allows specifying the units in the API request. So, I can add an option for the user to choose between metric and imperial units.\n\nI'll add another option to the CLI, like --units metric|imperial.\n\nThen, pass the appropriate units parameter in the API requests.\n\nThis adds a bit more complexity, but it's a useful feature.\n\nNow, regarding the output format, I need to decide how to display the weather data.\n\nFor current weather, I can display something like:\n\nCurrent weather in London:\n\n- Temperature: 15\u00b0C\n\n- Description: Cloudy\n\n- Humidity: 78%\n\nFor the forecast, I can display the date and the corresponding weather conditions for each of the next 5 days.\n\nI need to make sure that the dates are formatted properly and that the data is easy to read.\n\nI should also handle cases where the API returns no data or incomplete data.\n\nNow, let's think about how to implement this step by step.\n\nFirst, set up the Redis connection and test if it's working.\n\nThen, create a function to fetch the current weather, implementing the caching logic.\n\nSimilarly, create a function for the forecast.\n\nThen, in the CLI action, based on the user's input (city or coordinates), call the appropriate functions and display the data.\n\nI need to make sure that the functions are asynchronous, using async/await for making API requests and Redis operations.\n\nAlso, handle any potential errors that may occur during these operations.\n\nLet me try writing a draft of the fetchCurrentWeather function.\n\n```\n\nconst axios = require('axios');\n\nconst redis = require('redis');\n\nconst client = redis.createClient();\n\nasync function fetchCurrentWeather(cityOrCoords, units) {\n\n  const cacheKey = generateCacheKey(cityOrCoords);\n\n  let data;\n\n  try {\n\n    const cachedData = await client.get(cacheKey);\n\n    if (cachedData) {\n\n      data = JSON.parse(cachedData);\n\n    } else {\n\n      const response = await axios.get(`${API_BASE_URL}/weather`, {\n\n        params: {\n\n          q: cityOrCoords,\n\n          appid: API_KEY,\n\n          units: units\n\n        }\n\n      });\n\n      data = response.data;\n\n      await client.set(cacheKey, JSON.stringify(data), 'EX', 3600); // 1 hour expiration\n\n    }\n\n    return data;\n\n  } catch (error) {\n\n    console.error('Error fetching current weather:', error.message);\n\n    throw error;\n\n  }\n\n}\n\nfunction generateCacheKey(cityOrCoords) {\n\n  // Implement key generation logic\n\n}\n\n```\n\nSimilarly, for the forecast.\n\nI need to implement the generateCacheKey function to create a unique and consistent key based on the input.\n\nFor city names, I can convert them to lowercase and replace spaces with underscores.\n\nFor coordinates, I can just use the lat,lon string.\n\n```\n\nfunction generateCacheKey(input) {\n\n  if (input.includes(',')) {\n\n    // Assuming it's coordinates\n\n    return `coords:${input}`;\n\n  } else {\n\n    // Assuming it's a city name\n\n    return `city:${input.toLowerCase().replace(/\\s+/g, '_')}`;\n\n  }\n\n}\n\n```\n\nThis should help standardize the cache keys.\n\nNow, I need to think about how to display the data.\n\nFor the current weather, I can extract relevant fields from the API response and format them into a readable string.\n\nSimilarly, for the forecast, I need to parse the forecast data and present it in a user-friendly way.\n\nI should also handle different units appropriately.\n\nWait, OpenWeatherMap provides temperature in different units based on the 'units' parameter. So, if the user selects metric, temperatures will be in Celsius, and for imperial, in Fahrenheit.\n\nI need to make sure that the displayed units match what the user selected.\n\nAdditionally, I can convert other measurements if needed.\n\nNow, I need to update the CLI options to include the units.\n\nIn Commander.js, I can add another option for units.\n\n```\n\nprogram\n\n  .command('weather')\n\n  .option('-c, --city <city>', 'City name')\n\n  .option('-d, --coords <coords>', 'Coordinates in lat,lon format')\n\n  .option('-u, --units <units>', 'Units: metric or imperial', 'metric')\n\n  .action(async (options) => {\n\n    if (!options.city && !options.coords) {\n\n      console.error('Please provide either --city or --coords');\n\n      process.exit(1);\n\n    }\n\n    let data;\n\n    if (options.city) {\n\n      data = await fetchCurrentWeather(options.city, options.units);\n\n      displayCurrentWeather(data, options.units);\n\n    } else {\n\n      data = await fetchCurrentWeather(options.coords, options.units);\n\n      displayCurrentWeather(data, options.units);\n\n    }\n\n  });\n\nprogram.parse(process.argv);\n\n```\n\nWait, in this setup, I'm only fetching the current weather based on the provided input. But the task also requires fetching a 5-day forecast.\n\nMaybe I should have options to choose what to fetch: current weather or forecast.\n\nAlternatively, always fetch both and display them together.\n\nBut to keep it simple, maybe fetch both by default and display current weather and forecast.\n\nI need to decide on the scope.\n\nTo make it more flexible, perhaps have separate commands or options for current weather and forecast.\n\nBut for now, I'll fetch and display both together for simplicity.\n\nSo, in the action, fetch both current weather and forecast, then display them.\n\nI need to create another function to fetch the forecast.\n\nOpenWeatherMap's forecast API provides data for the next 5 days, with data every 3 hours.\n\nI need to aggregate this data to show daily forecasts.\n\nPerhaps group the data by date and take the daily summary.\n\nI'll need to parse the forecast data and organize it by day.\n\nI can extract the date from each forecast entry and group them accordingly.\n\nThen, for each day, display the average temperature and a general weather description.\n\nNow, let's think about how to implement the forecast fetching and caching.\n\nSimilar to the current weather, but with a different API endpoint and possibly a different cache expiration time.\n\nIn OpenWeatherMap, the forecast API is `/forecast`, and it provides data for the next 5 days every 3 hours.\n\nI need to make sure that I'm handling the forecast data correctly.\n\nAlso, since the forecast data is larger, I might want to cache it separately from the current weather.\n\nIn terms of cache keys, I can use a similar key but append \"_forecast\" or something like that.\n\nFor example, if the cache key for current weather is \"city:london\", the forecast key can be \"city:london:forecast\".\n\nThis way, they are separate and can have different expiration times.\n\nNow, let's think about the display functions.\n\nFor current weather, I can display:\n\n- City name\n\n- Current temperature\n\n- Weather description\n\n- Humidity\n\n- Wind speed\n\nFor forecast, I can display:\n\n- Date\n\n- Max and min temperatures\n\n- Weather description\n\nI need to make sure that the dates are formatted properly, perhaps in a readable format like \"YYYY-MM-DD\".\n\nI should also handle time zones appropriately, but that might be complex. For simplicity, I can assume that the API returns data in a consistent time zone.\n\nNow, I need to implement the fetchForecast function.\n\nIt would be similar to fetchCurrentWeather but using the forecast endpoint.\n\n```\n\nasync function fetchForecast(cityOrCoords, units) {\n\n  const cacheKey = generateCacheKey(cityOrCoords) + ':forecast';\n\n  let data;\n\n  try {\n\n    const cachedData = await client.get(cacheKey);\n\n    if (cachedData) {\n\n      data = JSON.parse(cachedData);\n\n    } else {\n\n      const response = await axios.get(`${API_BASE_URL}/forecast`, {\n\n        params: {\n\n          q: cityOrCoords,\n\n          appid: API_KEY,\n\n          units: units\n\n        }\n\n      });\n\n      data = response.data;\n\n      await client.set(cacheKey, JSON.stringify(data), 'EX', 21600); // 6 hours expiration\n\n    }\n\n    return data;\n\n  } catch (error) {\n\n    console.error('Error fetching forecast:', error.message);\n\n    throw error;\n\n  }\n\n}\n\n```\n\nNow, in the CLI action, I can call both fetchCurrentWeather and fetchForecast, then display the data.\n\nI need to make sure that the functions are awaited properly since they are asynchronous.\n\nAlso, handle any errors that occur during fetching or displaying.\n\nNow, I need to implement the display functions.\n\nLet's start with displayCurrentWeather.\n\nAssuming the API response for current weather has the following structure:\n\n```\n\n{\n\n  \"coord\": { \"lon\": -0.13, \"lat\": 51.51 },\n\n  \"weather\": [{ \"id\": 300, \"main\": \"Drizzle\", \"description\": \"light intensity drizzle\", \"icon\": \"09d\" }],\n\n  \"base\": \"stations\",\n\n  \"main\": {\n\n    \"temp\": 280.32,\n\n    \"feels_like\": 275.43,\n\n    \"temp_min\": 279.82,\n\n    \"temp_max\": 281.48,\n\n    \"pressure\": 1012,\n\n    \"humidity\": 81\n\n  },\n\n  \"visibility\": 10000,\n\n  \"wind\": { \"speed\": 4.1, \"deg\": 80 },\n\n  \"clouds\": { \"all\": 90 },\n\n  \"dt\": 1560350645,\n\n  \"sys\": {\n\n    \"type\": 1,\n\n    \"id\": 5091,\n\n    \"message\": 0.0103,\n\n    \"country\": \"GB\",\n\n    \"sunrise\": 1560343627,\n\n    \"sunset\": 1560396563\n\n  },\n\n  \"timezone\": 3600,\n\n  \"id\": 2643743,\n\n  \"name\": \"London\",\n\n  \"cod\": 200\n\n}\n\n```\n\nI can extract the relevant information and format it.\n\nSimilarly, for the forecast, the response is an object with list of forecasts every 3 hours.\n\nI need to group them by date and calculate max and min temperatures for each day.\n\nI can use JavaScript's Date object to handle the timestamps.\n\nI need to make sure that I handle the timezone offset properly.\n\nBut for simplicity, I can assume that the timestamps are in UTC and convert them accordingly.\n\nNow, let's think about how to group the forecast data by date.\n\nI can iterate through the list of forecasts, extract the date from the dt value, and group the entries by date.\n\nThen, for each date, find the max and min temperatures and a representative weather description.\n\nOnce I have this grouped data, I can display it in a tabular format or list format.\n\nNow, I need to implement the display functions.\n\nLet me sketch out the displayCurrentWeather function.\n\n```\n\nfunction displayCurrentWeather(data, units) {\n\n  const temperatureUnit = units === 'metric' ? '\u00b0C' : '\u00b0F';\n\n  console.log(`Current weather in ${data.name}:`);\n\n  console.log(`- Temperature: ${data.main.temp} ${temperatureUnit}`);\n\n  console.log(`- Description: ${data.weather[0].description}`);\n\n  console.log(`- Humidity: ${data.main.humidity}%`);\n\n  console.log(`- Wind speed: ${data.wind.speed} m/s`);\n\n}\n\n```\n\nSimilarly, for the forecast.\n\nI need to group the forecast data by date.\n\nAssuming that each forecast entry has a dt value which is a Unix timestamp, I can convert it to a Date object and extract the date.\n\nThen, for each date, collect all the forecast entries for that date and find the max and min temperatures.\n\nAlso, choose a representative weather description, perhaps the one from the first entry of the day.\n\nHere's a rough idea:\n\n```\n\nfunction groupForecastByDate(forecastList) {\n\n  const grouped = {};\n\n  forecastList.forEach(item => {\n\n    const date = new Date(item.dt * 1000).toLocaleDateString();\n\n    if (!grouped[date]) {\n\n      grouped[date] = {\n\n        temps: [item.main.temp],\n\n        description: item.weather[0].description\n\n      };\n\n    } else {\n\n      grouped[date].temps.push(item.main.temp);\n\n    }\n\n  });\n\n  return Object.keys(grouped).map(date => {\n\n    const temps = grouped[date].temps;\n\n    return {\n\n      date,\n\n      maxTemp: Math.max(...temps),\n\n      minTemp: Math.min(...temps),\n\n      description: grouped[date].description\n\n    };\n\n  });\n\n}\n\n```\n\nThen, in displayForecast:\n\n```\n\nfunction displayForecast(data, units) {\n\n  const temperatureUnit = units === 'metric' ? '\u00b0C' : '\u00b0F';\n\n  const forecastList = data.list;\n\n  const groupedForecast = groupForecastByDate(forecastList);\n\n  console.log('\\n5-Day Forecast:');\n\n  groupedForecast.forEach(day => {\n\n    console.log(`- Date: ${day.date}`);\n\n    console.log(`  - Max Temperature: ${day.maxTemp} ${temperatureUnit}`);\n\n    console.log(`  - Min Temperature: ${day.minTemp} ${temperatureUnit}`);\n\n    console.log(`  - Description: ${day.description}`);\n\n  });\n\n}\n\n```\n\nThis should give a clear overview of the forecast for the next 5 days.\n\nNow, I need to make sure that the dates are displayed in a consistent and readable format.\n\nI can use the toLocaleDateString method with appropriate options to format the dates.\n\nAlso, handle any time zone adjustments if needed.\n\nBut for now, assuming UTC for simplicity.\n\nNow, let's think about error handling.\n\nThere are several points where errors can occur:\n\n- Invalid city name or coordinates provided by the user.\n\n- Failed API requests due to network issues or rate limiting.\n\n- Invalid responses from the API.\n\n- Cache-related errors.\n\nI need to handle these gracefully and provide meaningful error messages to the user.\n\nFor example, if the city name is invalid, the API might return a 404 status code with an error message.\n\nI need to check the API response status and handle errors accordingly.\n\nSimilarly, if there are issues with Redis, I need to catch those errors and inform the user.\n\nIn the CLI action, I can wrap the fetch functions in try-catch blocks and handle any thrown errors.\n\nNow, I need to ensure that the Redis connection is properly handled.\n\nI should probably connect to Redis at the start of the script and handle any connection errors.\n\nAlso, make sure to close the connection when the script exits.\n\nIn Node.js, I can use the 'exit' event to handle closing the Redis connection.\n\nNow, let's think about testing the tool.\n\nI can test it with known city names and coordinates to verify that it fetches and displays the data correctly.\n\nI should also test with invalid inputs to ensure that error handling works as expected.\n\nAdditionally, I can check the caching by making multiple requests and verifying that the data is retrieved from cache after the first request.\n\nI might need to use a testing library like Mocha or Jest to write unit tests, but for a CLI tool, integration testing might be more appropriate.\n\nAlternatively, I can manually test the tool by running it with different inputs and verifying the output.\n\nNow, I need to consider deploying this tool so that others can use it.\n\nSince it's a CLI tool, I can publish it to npm so that users can install it globally using npm install -g.\n\nI need to package the tool properly, including a bin script in package.json.\n\nAlso, ensure that all dependencies are listed correctly.\n\nI should also write a README file explaining how to install and use the tool.\n\nAdditionally, I need to handle the API key securely. Since it's sensitive information, I shouldn't hardcode it in the source code.\n\nInstead, I can rely on the user to set it as an environment variable.\n\nI'll need to document this in the README.\n\nNow, summarizing the steps:\n\n1. Set up a new Node.js project with necessary dependencies.\n\n2. Set up Redis connection and error handling.\n\n3. Implement functions to fetch current weather and forecast from OpenWeatherMap API.\n\n4. Implement caching logic using Redis with appropriate expiration times.\n\n5. Design the CLI tool using Commander.js to accept city name or coordinates and units.\n\n6. Implement functions to display the fetched weather data in a user-friendly format.\n\n7. Handle errors and edge cases gracefully.\n\n8. Test the tool with various inputs and scenarios.\n\n9. Package the tool for distribution, including documentation and installation instructions.\n\nThis seems like a comprehensive plan. I'll start implementing it step by step.\n\n## Final Solution\nTo create a weather forecast CLI tool in Node.js that fetches data from the OpenWeatherMap API and caches it in Redis, follow these steps:\n\n### Prerequisites\n\n1. **Node.js** installed.\n2. **Redis** server running locally or configure for a remote server.\n3. An API key from [OpenWeatherMap](https://openweathermap.org/api).\n\n### Project Structure\n\n```\nweather-cli/\n\u251c\u2500\u2500 node_modules/\n\u251c\u2500\u2500 bin/\n\u2502   \u2514\u2500\u2500 weather\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 index.js\n\u2502   \u251c\u2500\u2500 weather.js\n\u2502   \u2514\u2500\u2500 utils.js\n\u251c\u2500\u2500 .env\n\u251c\u2500\u2500 package.json\n\u2514\u2500\u2500 README.md\n```\n\n### Steps to Implement\n\n1. **Initialize the Project**\n\n   ```bash\n   mkdir weather-cli\n   cd weather-cli\n   npm init -y\n   ```\n\n2. **Install Dependencies**\n\n   ```bash\n   npm install commander redis axios dotenv\n   ```\n\n3. **Set Up Redis Connection**\n\n   In `src/utils.js`:\n\n   ```javascript\n   const redis = require('redis');\n\n   const client = redis.createClient();\n\n   client.on('error', (err) => console.log('Redis Client Error', err));\n\n   module.exports = client;\n   ```\n\n4. **Configure OpenWeatherMap API**\n\n   Create a `.env` file:\n\n   ```\n   OPENWEATHERMAP_API_KEY=your_api_key\n   ```\n\n5. **Fetch Weather Data**\n\n   In `src/weather.js`:\n\n   ```javascript\n   require('dotenv').config();\n   const axios = require('axios');\n   const redisClient = require('./utils');\n\n   const API_KEY = process.env.OPENWEATHERMAP_API_KEY;\n   const API_BASE_URL = 'https://api.openweathermap.org/data/2.5';\n\n   async function fetchCurrentWeather(cityOrCoords, units) {\n     const cacheKey = generateCacheKey(cityOrCoords, 'current');\n     let data;\n     try {\n       const cachedData = await redisClient.get(cacheKey);\n       if (cachedData) {\n         data = JSON.parse(cachedData);\n       } else {\n         const response = await axios.get(`${API_BASE_URL}/weather`, {\n           params: {\n             q: cityOrCoords,\n             appid: API_KEY,\n             units: units\n           }\n         });\n         data = response.data;\n         await redisClient.set(cacheKey, JSON.stringify(data), 'EX', 3600); // 1 hour expiration\n       }\n       return data;\n     } catch (error) {\n       console.error('Error fetching current weather:', error.message);\n       throw error;\n     }\n   }\n\n   async function fetchForecast(cityOrCoords, units) {\n     const cacheKey = generateCacheKey(cityOrCoords, 'forecast');\n     let data;\n     try {\n       const cachedData = await redisClient.get(cacheKey);\n       if (cachedData) {\n         data = JSON.parse(cachedData);\n       } else {\n         const response = await axios.get(`${API_BASE_URL}/forecast`, {\n           params: {\n             q: cityOrCoords,\n             appid: API_KEY,\n             units: units\n           }\n         });\n         data = response.data;\n         await redisClient.set(cacheKey, JSON.stringify(data), 'EX', 21600); // 6 hours expiration\n       }\n       return data;\n     } catch (error) {\n       console.error('Error fetching forecast:', error.message);\n       throw error;\n     }\n   }\n\n   function generateCacheKey(input, type) {\n     const baseKey = input.includes(',') ? `coords:${input}` : `city:${input.toLowerCase().replace(/\\s+/g, '_')}`;\n     return `${baseKey}:${type}`;\n   }\n\n   module.exports = {\n     fetchCurrentWeather,\n     fetchForecast\n   };\n   ```\n\n6. **CLI Tool Setup**\n\n   In `src/index.js`:\n\n   ```javascript\n   const program = require('commander');\n   const { fetchCurrentWeather, fetchForecast } = require('./weather');\n\n   program\n     .command('weather')\n     .option('-c, --city <city>', 'City name')\n     .option('-d, --coords <coords>', 'Coordinates in lat,lon format')\n     .option('-u, --units <units>', 'Units: metric or imperial', 'metric')\n     .action(async (options) => {\n       if (!options.city && !options.coords) {\n         console.error('Please provide either --city or --coords');\n         process.exit(1);\n       }\n\n       const location = options.city || options.coords;\n       try {\n         const currentWeather = await fetchCurrentWeather(location, options.units);\n         displayCurrentWeather(currentWeather, options.units);\n\n         const forecast = await fetchForecast(location, options.units);\n         displayForecast(forecast, options.units);\n       } catch (error) {\n         console.error('Failed to fetch weather data:', error.message);\n       }\n     });\n\n   function displayCurrentWeather(data, units) {\n     const temperatureUnit = units === 'metric' ? '\u00b0C' : '\u00b0F';\n     console.log(`Current weather in ${data.name}:`);\n     console.log(`- Temperature: ${data.main.temp} ${temperatureUnit}`);\n     console.log(`- Description: ${data.weather[0].description}`);\n     console.log(`- Humidity: ${data.main.humidity}%`);\n     console.log(`- Wind speed: ${data.wind.speed} m/s`);\n   }\n\n   function displayForecast(data, units) {\n     const temperatureUnit = units === 'metric' ? '\u00b0C' : '\u00b0F';\n     const forecastList = data.list;\n     const groupedForecast = groupForecastByDate(forecastList);\n     console.log('\\n5-Day Forecast:');\n     groupedForecast.forEach(day => {\n       console.log(`- Date: ${day.date}`);\n       console.log(`  - Max Temperature: ${day.maxTemp} ${temperatureUnit}`);\n       console.log(`  - Min Temperature: ${day.minTemp} ${temperatureUnit}`);\n       console.log(`  - Description: ${day.description}`);\n     });\n   }\n\n   function groupForecastByDate(forecastList) {\n     const grouped = {};\n     forecastList.forEach(item => {\n       const date = new Date(item.dt * 1000).toLocaleDateString();\n       if (!grouped[date]) {\n         grouped[date] = {\n           temps: [item.main.temp],\n           description: item.weather[0].description\n         };\n       } else {\n         grouped[date].temps.push(item.main.temp);\n       }\n     });\n     return Object.keys(grouped).map(date => {\n       const temps = grouped[date].temps;\n       return {\n         date,\n         maxTemp: Math.max(...temps),\n         minTemp: Math.min(...temps),\n         description: grouped[date].description\n       };\n     });\n   }\n\n   program.parse(process.argv);\n   ```\n\n7. **Make the CLI Tool Executable**\n\n   Create `bin/weather`:\n\n   ```bash\n   #!/usr/bin/env node\n   require('../src/index');\n   ```\n\n   Make it executable:\n\n   ```bash\n   chmod +x bin/weather\n   ```\n\n8. **Package Configuration**\n\n   In `package.json`:\n\n   ```json\n   {\n     \"name\": \"weather-cli\",\n     \"version\": \"1.0.0\",\n     \"description\": \"Weather forecast CLI tool\",\n     \"main\": \"index.js\",\n     \"bin\": {\n       \"weather\": \"bin/weather\"\n     },\n     \"scripts\": {\n       \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n     },\n     \"dependencies\": {\n       \"axios\": \"^0.21.1\",\n       \"commander\": \"^7.2.0\",\n       \"dotenv\": \"^8.2.0\",\n       \"redis\": \"^3.1.2\"\n     }\n   }\n   ```\n\n9. **Testing**\n\n   Run the tool:\n\n   ```bash\n   npm link\n   weather --city London\n   weather --coords 51.5074,-0.1278\n   ```\n\n### Conclusion\n\nThis weather forecast CLI tool fetches and displays current weather conditions and a 5-day forecast using OpenWeatherMap API, with caching implemented in Redis to minimize API calls. It's designed to be user-friendly and efficient, providing weather information quickly and reliably."
    }
]