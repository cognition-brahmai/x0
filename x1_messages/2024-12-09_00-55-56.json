[
    {
        "role": "user",
        "content": "Create a Python script that interacts with a PostgreSQL database to manage a simple task management system. Users can create tasks with a title, description, due date, and priority level. The script should support adding, updating, deleting, and listing tasks, as well as marking tasks as completed.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Alright, I've got this task to create a Python script that interacts with a PostgreSQL database for a simple task management system. The system should allow users to create tasks with a title, description, due date, and priority level. Additionally, users should be able to add, update, delete, list tasks, and mark tasks as completed.\n\nFirst things first, I need to set up the PostgreSQL database. I should create a table to store the tasks. Each task should have fields for the title, description, due date, priority level, and a completed status.\n\nLet me think about the database schema. I'll need something like this:\n\n- id: unique identifier for each task (primary key)\n\n- title: text, not null\n\n- description: text\n\n- due_date: date\n\n- priority: integer (1 for high, 2 for medium, 3 for low, for example)\n\n- completed: boolean\n\nI need to make sure that the database connection is handled properly in the Python script. I should use a library like `psycopg2` to connect to the PostgreSQL database.\n\nBefore I start coding, I should plan out the functions I'll need in the script:\n\n1. **Add Task**: Insert a new task into the database.\n\n2. **Update Task**: Modify an existing task's details.\n\n3. **Delete Task**: Remove a task from the database.\n\n4. **List Tasks**: Retrieve and display all tasks, possibly with filtering options.\n\n5. **Mark Task as Completed**: Update the completed status of a task.\n\nI should also consider how users will interact with this script. Since it's a command-line script, I'll need to handle user inputs and display outputs accordingly.\n\nLet me outline the steps for each function:\n\n**Add Task:**\n\n- Prompt the user for the task title, description, due date, and priority level.\n\n- Validate the inputs to ensure they meet the required formats.\n\n- Insert the new task into the database.\n\n**Update Task:**\n\n- Ask the user for the task ID to update.\n\n- Prompt for the new values for title, description, due date, and priority level.\n\n- Update the corresponding task in the database.\n\n**Delete Task:**\n\n- Ask the user for the task ID to delete.\n\n- Confirm with the user before deleting the task.\n\n- Remove the task from the database.\n\n**List Tasks:**\n\n- Retrieve all tasks from the database.\n\n- Optionally, allow filtering by priority or completed status.\n\n- Display the tasks in a readable format.\n\n**Mark Task as Completed:**\n\n- Ask the user for the task ID to mark as completed.\n\n- Update the completed status of the task in the database.\n\nI should also consider error handling, such as handling invalid task IDs, incorrect input formats, and database connection errors.\n\nLet me think about how to structure the script. I can create a menu-based system where the user can choose among the options: add, update, delete, list, mark as completed, and exit.\n\nHere's a rough sketch of how the menu could look:\n\n```\n\nTask Management System\n\nPlease choose an option:\n\n1. Add Task\n\n2. Update Task\n\n3. Delete Task\n\n4. List Tasks\n\n5. Mark Task as Completed\n\n6. Exit\n\n```\n\nAfter the user makes a choice, the script should perform the corresponding action and return to the menu.\n\nI need to make sure that the script connects to the database when it starts and closes the connection when it exits.\n\nAlso, for the due date, I should consider using Python's `datetime` module to handle date inputs and comparisons.\n\nLet me think about how to handle the priority level. I can assign numeric values to different priority levels, like 1 for high, 2 for medium, and 3 for low. I might want to display these as text in the list view for better readability.\n\nI should also consider sanitizing user inputs to prevent SQL injection attacks. Using parameterized queries with `psycopg2` should help with that.\n\nLet me outline the steps for setting up the database table:\n\n- Connect to the PostgreSQL database.\n\n- Create a table named `tasks` with the required fields.\n\nHere's a sample SQL statement for creating the table:\n\n```sql\n\nCREATE TABLE tasks (\n\n    id SERIAL PRIMARY KEY,\n\n    title VARCHAR(255) NOT NULL,\n\n    description TEXT,\n\n    due_date DATE,\n\n    priority INTEGER,\n\n    completed BOOLEAN DEFAULT FALSE\n\n);\n\n```\n\nI need to make sure that the script can connect to this database using the appropriate connection parameters.\n\nNow, let's think about the Python code structure.\n\nI can define functions for each menu option: add_task, update_task, delete_task, list_tasks, mark_as_completed.\n\nI'll also need a function to display the menu and handle user choices.\n\nI should create a main loop that keeps displaying the menu until the user chooses to exit.\n\nLet me sketch a basic structure in code:\n\n```python\n\nimport psycopg2\n\ndef connect_to_db():\n\n    # Code to connect to the PostgreSQL database\n\n    pass\n\ndef add_task():\n\n    # Code to add a new task\n\n    pass\n\ndef update_task():\n\n    # Code to update an existing task\n\n    pass\n\ndef delete_task():\n\n    # Code to delete a task\n\n    pass\n\ndef list_tasks():\n\n    # Code to list all tasks\n\n    pass\n\ndef mark_as_completed():\n\n    # Code to mark a task as completed\n\n    pass\n\ndef main():\n\n    conn = connect_to_db()\n\n    while True:\n\n        print(\"Task Management System\")\n\n        print(\"Please choose an option:\")\n\n        print(\"1. Add Task\")\n\n        print(\"2. Update Task\")\n\n        print(\"3. Delete Task\")\n\n        print(\"4. List Tasks\")\n\n        print(\"5. Mark Task as Completed\")\n\n        print(\"6. Exit\")\n\n        choice = input(\"Enter your choice: \")\n\n        if choice == '1':\n\n            add_task(conn)\n\n        elif choice == '2':\n\n            update_task(conn)\n\n        elif choice == '3':\n\n            delete_task(conn)\n\n        elif choice == '4':\n\n            list_tasks(conn)\n\n        elif choice == '5':\n\n            mark_as_completed(conn)\n\n        elif choice == '6':\n\n            break\n\n        else:\n\n            print(\"Invalid choice. Please try again.\")\n\n    conn.close()\n\nif __name__ == \"__main__\":\n\n    main()\n\n```\n\nI need to implement each of these functions, making sure to interact with the database correctly.\n\nLet's start with the `connect_to_db` function. I'll need to provide the database connection parameters, such as the database name, user, password, and host.\n\nI should consider storing these parameters in environment variables for security reasons.\n\nHere's an example of how to connect using `psycopg2`:\n\n```python\n\nimport os\n\nimport psycopg2\n\ndef connect_to_db():\n\n    db_name = os.getenv('DB_NAME', 'task_manager')\n\n    db_user = os.getenv('DB_USER', 'your_username')\n\n    db_password = os.getenv('DB_PASSWORD', 'your_password')\n\n    db_host = os.getenv('DB_HOST', 'localhost')\n\n    db_port = os.getenv('DB_PORT', '5432')\n\n    conn = psycopg2.connect(\n\n        dbname=db_name,\n\n        user=db_user,\n\n        password=db_password,\n\n        host=db_host,\n\n        port=db_port\n\n    )\n\n    return conn\n\n```\n\nMake sure to install the `psycopg2` library if it's not already installed. You can install it using pip:\n\n```\n\npip install psycopg2\n\n```\n\nor, if you're using psycopg2-binary for simplicity:\n\n```\n\npip install psycopg2-binary\n\n```\n\nNext, I'll work on the `add_task` function.\n\nIn this function, I need to prompt the user for the task details and insert them into the database.\n\nI should validate the inputs to ensure that the title is not empty, the due date is in the correct format, and the priority level is one of the allowed values.\n\nHere's a rough sketch of the `add_task` function:\n\n```python\n\ndef add_task(conn):\n\n    title = input(\"Enter task title: \")\n\n    if not title:\n\n        print(\"Title cannot be empty.\")\n\n        return\n\n    description = input(\"Enter task description: \")\n\n    due_date_str = input(\"Enter due date (YYYY-MM-DD): \")\n\n    try:\n\n        due_date = datetime.strptime(due_date_str, '%Y-%m-%d').date()\n\n    except ValueError:\n\n        print(\"Invalid date format. Please use YYYY-MM-DD.\")\n\n        return\n\n    priority = input(\"Enter priority (1=High, 2=Medium, 3=Low): \")\n\n    if priority not in ['1', '2', '3']:\n\n        print(\"Invalid priority level. Please choose 1, 2, or 3.\")\n\n        return\n\n    cur = conn.cursor()\n\n    cur.execute(\n\n        \"INSERT INTO tasks (title, description, due_date, priority, completed) VALUES (%s, %s, %s, %s, %s)\",\n\n        (title, description, due_date, priority, False)\n\n    )\n\n    conn.commit()\n\n    cur.close()\n\n    print(\"Task added successfully.\")\n\n```\n\nI need to make sure to handle exceptions properly, especially when converting the due date string to a date object.\n\nSimilarly, for the `update_task` function, I need to ask the user for the task ID and then prompt for the new values for the task details.\n\nI should retrieve the existing task first to display current values and allow the user to decide which fields to update.\n\nHere's a rough idea:\n\n```python\n\ndef update_task(conn):\n\n    task_id = input(\"Enter task ID to update: \")\n\n    cur = conn.cursor()\n\n    cur.execute(\"SELECT * FROM tasks WHERE id = %s\", (task_id,))\n\n    task = cur.fetchone()\n\n    if not task:\n\n        print(\"Task not found.\")\n\n        return\n\n    # Display current task details\n\n    print(\"Current task details:\")\n\n    print(f\"ID: {task[0]}\")\n\n    print(f\"Title: {task[1]}\")\n\n    print(f\"Description: {task[2]}\")\n\n    print(f\"Due Date: {task[3]}\")\n\n    print(f\"Priority: {task[4]}\")\n\n    print(f\"Completed: {task[5]}\")\n\n    # Prompt for new values\n\n    new_title = input(\"Enter new title (leave blank to keep current): \")\n\n    new_description = input(\"Enter new description (leave blank to keep current): \")\n\n    new_due_date_str = input(\"Enter new due date (YYYY-MM-DD, leave blank to keep current): \")\n\n    new_priority = input(\"Enter new priority (1=High, 2=Medium, 3=Low, leave blank to keep current): \")\n\n    # Prepare update query\n\n    update_fields = []\n\n    update_values = []\n\n    if new_title:\n\n        update_fields.append(\"title = %s\")\n\n        update_values.append(new_title)\n\n    if new_description:\n\n        update_fields.append(\"description = %s\")\n\n        update_values.append(new_description)\n\n    if new_due_date_str:\n\n        try:\n\n            new_due_date = datetime.strptime(new_due_date_str, '%Y-%m-%d').date()\n\n            update_fields.append(\"due_date = %s\")\n\n            update_values.append(new_due_date)\n\n        except ValueError:\n\n            print(\"Invalid date format. Please use YYYY-MM-DD.\")\n\n            return\n\n    if new_priority in ['1', '2', '3']:\n\n        update_fields.append(\"priority = %s\")\n\n        update_values.append(new_priority)\n\n    if not update_fields:\n\n        print(\"No fields to update.\")\n\n        return\n\n    # Build the UPDATE query\n\n    set_clause = \", \".join(update_fields)\n\n    update_values.append(task_id)\n\n    query = f\"UPDATE tasks SET {set_clause} WHERE id = %s\"\n\n    cur.execute(query, update_values)\n\n    conn.commit()\n\n    cur.close()\n\n    print(\"Task updated successfully.\")\n\n```\n\nFor the `delete_task` function, I need to ask for the task ID, confirm with the user, and then delete the task from the database.\n\nHere's a rough sketch:\n\n```python\n\ndef delete_task(conn):\n\n    task_id = input(\"Enter task ID to delete: \")\n\n    cur = conn.cursor()\n\n    cur.execute(\"SELECT title FROM tasks WHERE id = %s\", (task_id,))\n\n    task = cur.fetchone()\n\n    if not task:\n\n        print(\"Task not found.\")\n\n        return\n\n    confirm = input(f\"Are you sure you want to delete task '{task[0]}'? (yes/no): \")\n\n    if confirm.lower() != 'yes':\n\n        print(\"Deletion canceled.\")\n\n        return\n\n    cur.execute(\"DELETE FROM tasks WHERE id = %s\", (task_id,))\n\n    conn.commit()\n\n    cur.close()\n\n    print(\"Task deleted successfully.\")\n\n```\n\nThe `list_tasks` function should retrieve all tasks from the database and display them in a readable format.\n\nI can add options to filter tasks by priority or completed status.\n\nHere's a basic version:\n\n```python\n\ndef list_tasks(conn):\n\n    cur = conn.cursor()\n\n    cur.execute(\"SELECT * FROM tasks\")\n\n    tasks = cur.fetchall()\n\n    if not tasks:\n\n        print(\"No tasks found.\")\n\n        return\n\n    for task in tasks:\n\n        print(f\"ID: {task[0]}\")\n\n        print(f\"Title: {task[1]}\")\n\n        print(f\"Description: {task[2]}\")\n\n        print(f\"Due Date: {task[3]}\")\n\n        print(f\"Priority: {task[4]}\")\n\n        print(f\"Completed: {task[5]}\")\n\n        print(\"-\" * 20)\n\n    cur.close()\n\n```\n\nI can enhance this by mapping priority numbers to text labels (e.g., 1 -> High) and formatting the output better.\n\nLastly, the `mark_as_completed` function should allow the user to mark a task as completed by updating its completed status in the database.\n\nHere's a rough idea:\n\n```python\n\ndef mark_as_completed(conn):\n\n    task_id = input(\"Enter task ID to mark as completed: \")\n\n    cur = conn.cursor()\n\n    cur.execute(\"SELECT title FROM tasks WHERE id = %s\", (task_id,))\n\n    task = cur.fetchone()\n\n    if not task:\n\n        print(\"Task not found.\")\n\n        return\n\n    cur.execute(\"UPDATE tasks SET completed = TRUE WHERE id = %s\", (task_id,))\n\n    conn.commit()\n\n    cur.close()\n\n    print(f\"Task '{task[0]}' marked as completed.\")\n\n```\n\nI should also consider adding a feature to list tasks based on their completed status.\n\nAdditionally, I might want to add a function to initialize the database and create the tasks table if it doesn't exist.\n\nHere's how I can do that:\n\n```python\n\ndef init_db(conn):\n\n    cur = conn.cursor()\n\n    cur.execute(\"\"\n\n                \"CREATE TABLE IF NOT EXISTS tasks (\\n\"\n\n                \"    id SERIAL PRIMARY KEY,\\n\"\n\n                \"    title VARCHAR(255) NOT NULL,\\n\"\n\n                \"    description TEXT,\\n\"\n\n                \"    due_date DATE,\\n\"\n\n                \"    priority INTEGER,\\n\"\n\n                \"    completed BOOLEAN DEFAULT FALSE\\n\"\n\n                \");\"\n\n                \"\")\n\n    conn.commit()\n\n    cur.close()\n\n```\n\nI can call this function right after connecting to the database in the `main` function.\n\nAlso, to make the script more user-friendly, I can improve the way dates are handled and displayed.\n\nFor example, when listing tasks, I can format the due date to be more readable.\n\nMoreover, I can handle cases where the due date is missing or the priority level is not set.\n\nI should also think about error handling in case the database connection fails or other exceptions occur during database operations.\n\nLet me add some try-except blocks in the database-related functions to handle potential errors gracefully.\n\nHere's an updated version of the `connect_to_db` function with error handling:\n\n```python\n\ndef connect_to_db():\n\n    try:\n\n        db_name = os.getenv('DB_NAME', 'task_manager')\n\n        db_user = os.getenv('DB_USER', 'your_username')\n\n        db_password = os.getenv('DB_PASSWORD', 'your_password')\n\n        db_host = os.getenv('DB_HOST', 'localhost')\n\n        db_port = os.getenv('DB_PORT', '5432')\n\n        conn = psycopg2.connect(\n\n            dbname=db_name,\n\n            user=db_user,\n\n            password=db_password,\n\n            host=db_host,\n\n            port=db_port\n\n        )\n\n        return conn\n\n    except psycopg2.Error as e:\n\n        print(f\"Database error: {e}\")\n\n        return None\n\n```\n\nAnd in the `main` function, I can check if the connection is successful before proceeding.\n\nNow, to make the script more efficient, I can use a context manager for database connections and cursors.\n\nHere's an example of how to use a context manager for the cursor:\n\n```python\n\ndef add_task(conn):\n\n    title = input(\"Enter task title: \")\n\n    if not title:\n\n        print(\"Title cannot be empty.\")\n\n        return\n\n    description = input(\"Enter task description: \")\n\n    due_date_str = input(\"Enter due date (YYYY-MM-DD): \")\n\n    try:\n\n        due_date = datetime.strptime(due_date_str, '%Y-%m-%d').date()\n\n    except ValueError:\n\n        print(\"Invalid date format. Please use YYYY-MM-DD.\")\n\n        return\n\n    priority = input(\"Enter priority (1=High, 2=Medium, 3=Low): \")\n\n    if priority not in ['1', '2', '3']:\n\n        print(\"Invalid priority level. Please choose 1, 2, or 3.\")\n\n        return\n\n    with conn.cursor() as cur:\n\n        cur.execute(\n\n            \"INSERT INTO tasks (title, description, due_date, priority, completed) VALUES (%s, %s, %s, %s, %s)\",\n\n            (title, description, due_date, priority, False)\n\n        )\n\n        conn.commit()\n\n    print(\"Task added successfully.\")\n\n```\n\nThis way, I don't need to manually close the cursor.\n\nSimilarly, I can use the context manager in other functions.\n\nI should also consider adding a way to sort the tasks when listing them, perhaps by due date or priority.\n\nAdditionally, I can enhance the list view by mapping priority numbers to text labels.\n\nFor example, replace priority 1 with \"High\", 2 with \"Medium\", and 3 with \"Low\".\n\nHere's an improved `list_tasks` function:\n\n```python\n\ndef list_tasks(conn):\n\n    with conn.cursor() as cur:\n\n        cur.execute(\"SELECT * FROM tasks\")\n\n        tasks = cur.fetchall()\n\n        if not tasks:\n\n            print(\"No tasks found.\")\n\n            return\n\n        for task in tasks:\n\n            priority_str = {\n\n                1: \"High\",\n\n                2: \"Medium\",\n\n                3: \"Low\"\n\n            }.get(task[4], \"Unknown\")\n\n            completed_str = \"Yes\" if task[5] else \"No\"\n\n            print(f\"ID: {task[0]}\")\n\n            print(f\"Title: {task[1]}\")\n\n            print(f\"Description: {task[2]}\")\n\n            print(f\"Due Date: {task[3]}\")\n\n            print(f\"Priority: {priority_str}\")\n\n            print(f\"Completed: {completed_str}\")\n\n            print(\"-\" * 20)\n\n```\n\nThis makes the output more readable.\n\nI can also add filtering options to the list tasks function, such as listing only completed tasks or tasks with a specific priority.\n\nTo do this, I can prompt the user for filtering criteria before retrieving the tasks.\n\nHere's an enhanced `list_tasks` function with filtering:\n\n```python\n\ndef list_tasks(conn):\n\n    filter_option = input(\"Filter by:\\n1. All tasks\\n2. Completed tasks\\n3. Pending tasks\\n4. Specific priority\\nChoose an option: \")\n\n    query = \"SELECT * FROM tasks\"\n\n    params = []\n\n    if filter_option == '2':\n\n        query += \" WHERE completed = TRUE\"\n\n    elif filter_option == '3':\n\n        query += \" WHERE completed = FALSE\"\n\n    elif filter_option == '4':\n\n        priority = input(\"Enter priority (1=High, 2=Medium, 3=Low): \")\n\n        if priority in ['1', '2', '3']:\n\n            query += \" WHERE priority = %s\"\n\n            params.append(int(priority))\n\n        else:\n\n            print(\"Invalid priority level.\")\n\n            return\n\n    with conn.cursor() as cur:\n\n        cur.execute(query, params)\n\n        tasks = cur.fetchall()\n\n        if not tasks:\n\n            print(\"No tasks found.\")\n\n            return\n\n        for task in tasks:\n\n            priority_str = {\n\n                1: \"High\",\n\n                2: \"Medium\",\n\n                3: \"Low\"\n\n            }.get(task[4], \"Unknown\")\n\n            completed_str = \"Yes\" if task[5] else \"No\"\n\n            print(f\"ID: {task[0]}\")\n\n            print(f\"Title: {task[1]}\")\n\n            print(f\"Description: {task[2]}\")\n\n            print(f\"Due Date: {task[3]}\")\n\n            print(f\"Priority: {priority_str}\")\n\n            print(f\"Completed: {completed_str}\")\n\n            print(\"-\" * 20)\n\n```\n\nThis allows users to view tasks based on different criteria.\n\nFurthermore, I can add sorting options, such as sorting by due date or priority.\n\nTo implement sorting, I can ask the user how they want the tasks to be sorted and append an ORDER BY clause to the SQL query accordingly.\n\nHere's an example:\n\n```python\n\ndef list_tasks(conn):\n\n    filter_option = input(\"Filter by:\\n1. All tasks\\n2. Completed tasks\\n3. Pending tasks\\n4. Specific priority\\nChoose an option: \")\n\n    sort_option = input(\"Sort by:\\n1. Title\\n2. Due Date\\n3. Priority\\nChoose an option: \")\n\n    query = \"SELECT * FROM tasks\"\n\n    params = []\n\n    if filter_option == '2':\n\n        query += \" WHERE completed = TRUE\"\n\n    elif filter_option == '3':\n\n        query += \" WHERE completed = FALSE\"\n\n    elif filter_option == '4':\n\n        priority = input(\"Enter priority (1=High, 2=Medium, 3=Low): \")\n\n        if priority in ['1', '2', '3']:\n\n            query += \" WHERE priority = %s\"\n\n            params.append(int(priority))\n\n        else:\n\n            print(\"Invalid priority level.\")\n\n            return\n\n    if sort_option == '1':\n\n        query += \" ORDER BY title\"\n\n    elif sort_option == '2':\n\n        query += \" ORDER BY due_date\"\n\n    elif sort_option == '3':\n\n        query += \" ORDER BY priority\"\n\n    with conn.cursor() as cur:\n\n        cur.execute(query, params)\n\n        tasks = cur.fetchall()\n\n        if not tasks:\n\n            print(\"No tasks found.\")\n\n            return\n\n        for task in tasks:\n\n            priority_str = {\n\n                1: \"High\",\n\n                2: \"Medium\",\n\n                3: \"Low\"\n\n            }.get(task[4], \"Unknown\")\n\n            completed_str = \"Yes\" if task[5] else \"No\"\n\n            print(f\"ID: {task[0]}\")\n\n            print(f\"Title: {task[1]}\")\n\n            print(f\"Description: {task[2]}\")\n\n            print(f\"Due Date: {task[3]}\")\n\n            print(f\"Priority: {priority_str}\")\n\n            print(f\"Completed: {completed_str}\")\n\n            print(\"-\" * 20)\n\n```\n\nThis provides more flexibility to the user when viewing tasks.\n\nI should also consider paginating the results if there are many tasks to display.\n\nAdditionally, I can improve the user interface by using better formatting for the task list, perhaps using tabs or aligning the columns.\n\nFor example, using the `tabulate` library to format the output nicely.\n\nFirst, I need to install the `tabulate` library:\n\n```\n\npip install tabulate\n\n```\n\nThen, I can modify the `list_tasks` function to use it:\n\n```python\n\nfrom tabulate import tabulate\n\ndef list_tasks(conn):\n\n    # ... (rest of the function remains the same until retrieving tasks)\n\n    with conn.cursor() as cur:\n\n        cur.execute(query, params)\n\n        tasks = cur.fetchall()\n\n        if not tasks:\n\n            print(\"No tasks found.\")\n\n            return\n\n        # Prepare data for tabulate\n\n        headers = [\"ID\", \"Title\", \"Description\", \"Due Date\", \"Priority\", \"Completed\"]\n\n        table = []\n\n        for task in tasks:\n\n            priority_str = {\n\n                1: \"High\",\n\n                2: \"Medium\",\n\n                3: \"Low\"\n\n            }.get(task[4], \"Unknown\")\n\n            completed_str = \"Yes\" if task[5] else \"No\"\n\n            table.append([task[0], task[1], task[2], task[3], priority_str, completed_str])\n\n        print(tabulate(table, headers=headers, tablefmt=\"grid\"))\n\n```\n\nThis will display the tasks in a well-formatted table.\n\nI should also handle cases where the description is long by truncating it or wrapping the text properly.\n\nMoreover, I can add a feature to edit specific fields of a task without updating all fields in the `update_task` function.\n\nTo do this, I can ask the user which fields they want to update and prompt for only those fields.\n\nHere's an improved version of the `update_task` function:\n\n```python\n\ndef update_task(conn):\n\n    task_id = input(\"Enter task ID to update: \")\n\n    with conn.cursor() as cur:\n\n        cur.execute(\"SELECT * FROM tasks WHERE id = %s\", (task_id,))\n\n        task = cur.fetchone()\n\n        if not task:\n\n            print(\"Task not found.\")\n\n            return\n\n        # Display current task details\n\n        print(\"Current task details:\")\n\n        print(f\"ID: {task[0]}\")\n\n        print(f\"Title: {task[1]}\")\n\n        print(f\"Description: {task[2]}\")\n\n        print(f\"Due Date: {task[3]}\")\n\n        print(f\"Priority: {task[4]}\")\n\n        print(f\"Completed: {task[5]}\")\n\n        # Ask which fields to update\n\n        fields_to_update = input(\"Enter fields to update (title, description, due_date, priority): \").split()\n\n        update_values = []\n\n        set_clause = []\n\n        for field in fields_to_update:\n\n            if field not in ['title', 'description', 'due_date', 'priority']:\n\n                print(f\"Invalid field: {field}\")\n\n                continue\n\n            new_value = input(f\"Enter new {field}: \")\n\n            if field == 'due_date':\n\n                try:\n\n                    new_value = datetime.strptime(new_value, '%Y-%m-%d').date()\n\n                except ValueError:\n\n                    print(\"Invalid date format. Please use YYYY-MM-DD.\")\n\n                    return\n\n            elif field == 'priority':\n\n                if new_value not in ['1', '2', '3']:\n\n                    print(\"Invalid priority level. Please choose 1, 2, or 3.\")\n\n                    return\n\n            update_values.append(new_value)\n\n            set_clause.append(f\"{field} = %s\")\n\n        if not set_clause:\n\n            print(\"No fields to update.\")\n\n            return\n\n        # Build the UPDATE query\n\n        set_str = \", \".join(set_clause)\n\n        query = f\"UPDATE tasks SET {set_str} WHERE id = %s\"\n\n        update_values.append(task_id)\n\n        cur.execute(query, update_values)\n\n        conn.commit()\n\n        print(\"Task updated successfully.\")\n\n```\n\nThis way, the user can specify which fields to update, making the process more flexible.\n\nI should also consider adding a feature to mark multiple tasks as completed at once.\n\nTo implement this, I can create a new menu option to mark multiple tasks as completed by providing a list of task IDs.\n\nHere's an example of how to do that:\n\n```python\n\ndef mark_multiple_as_completed(conn):\n\n    task_ids = input(\"Enter task IDs to mark as completed (space separated): \").split()\n\n    if not task_ids:\n\n        print(\"No task IDs provided.\")\n\n        return\n\n    with conn.cursor() as cur:\n\n        for task_id in task_ids:\n\n            cur.execute(\"SELECT title FROM tasks WHERE id = %s\", (task_id,))\n\n            task = cur.fetchone()\n\n            if not task:\n\n                print(f\"Task {task_id} not found.\")\n\n                continue\n\n            cur.execute(\"UPDATE tasks SET completed = TRUE WHERE id = %s\", (task_id,))\n\n            print(f\"Task '{task[0]}' marked as completed.\")\n\n        conn.commit()\n\n```\n\nI can add this as a new option in the menu.\n\nAdditionally, I can add a feature to display statistics, such as the number of completed and pending tasks.\n\nHere's a sample function for that:\n\n```python\n\ndef show_stats(conn):\n\n    with conn.cursor() as cur:\n\n        cur.execute(\"SELECT COUNT(*) FROM tasks WHERE completed = TRUE\")\n\n        completed_count = cur.fetchone()[0]\n\n        cur.execute(\"SELECT COUNT(*) FROM tasks WHERE completed = FALSE\")\n\n        pending_count = cur.fetchone()[0]\n\n        print(f\"Completed tasks: {completed_count}\")\n\n        print(f\"Pending tasks: {pending_count}\")\n\n```\n\nI can add this as another option in the menu.\n\nFurthermore, to make the script more user-friendly, I can add options to sort and filter tasks based on multiple criteria.\n\nFor example, sorting tasks by due date and filtering by priority.\n\nI can achieve this by modifying the `list_tasks` function to accept multiple filters and sorts.\n\nHere's an enhanced version:\n\n```python\n\ndef list_tasks(conn):\n\n    filters = []\n\n    params = []\n\n    # Apply filters\n\n    filter_option = input(\"Filter by:\\n1. All tasks\\n2. Completed tasks\\n3. Pending tasks\\n4. Specific priority\\nChoose an option: \")\n\n    if filter_option == '2':\n\n        filters.append(\"completed = TRUE\")\n\n    elif filter_option == '3':\n\n        filters.append(\"completed = FALSE\")\n\n    elif filter_option == '4':\n\n        priority = input(\"Enter priority (1=High, 2=Medium, 3=Low): \")\n\n        if priority in ['1', '2', '3']:\n\n            filters.append(\"priority = %s\")\n\n            params.append(int(priority))\n\n        else:\n\n            print(\"Invalid priority level.\")\n\n            return\n\n    # Apply sorting\n\n    sort_option = input(\"Sort by:\\n1. Title\\n2. Due Date\\n3. Priority\\nChoose an option: \")\n\n    sort_by = {\n\n        '1': \"title\",\n\n        '2': \"due_date\",\n\n        '3': \"priority\"\n\n    }.get(sort_option, \"title\")\n\n    # Build the query\n\n    query = \"SELECT * FROM tasks\"\n\n    if filters:\n\n        query += \" WHERE \" + \" AND \".join(filters)\n\n    query += f\" ORDER BY {sort_by}\"\n\n    with conn.cursor() as cur:\n\n        cur.execute(query, params)\n\n        tasks = cur.fetchall()\n\n        if not tasks:\n\n            print(\"No tasks found.\")\n\n            return\n\n        # Prepare data for tabulate\n\n        headers = [\"ID\", \"Title\", \"Description\", \"Due Date\", \"Priority\", \"Completed\"]\n\n        table = []\n\n        for task in tasks:\n\n            priority_str = {\n\n                1: \"High\",\n\n                2: \"Medium\",\n\n                3: \"Low\"\n\n            }.get(task[4], \"Unknown\")\n\n            completed_str = \"Yes\" if task[5] else \"No\"\n\n            table.append([task[0], task[1], task[2], task[3], priority_str, completed_str])\n\n        print(tabulate(table, headers=headers, tablefmt=\"grid\"))\n\n```\n\nThis allows for more flexible filtering and sorting options.\n\nI should also consider adding a feature to set reminders for tasks based on their due dates.\n\nFor example, alerting the user if a task is due soon.\n\nTo implement this, I can add a function that checks for tasks with due dates approaching and notifies the user.\n\nHere's a simple version:\n\n```python\n\ndef check_due_tasks(conn):\n\n    today = date.today()\n\n    with conn.cursor() as cur:\n\n        cur.execute(\"SELECT * FROM tasks WHERE due_date = %s\", (today,))\n\n        due_tasks = cur.fetchall()\n\n        if due_tasks:\n\n            print(\"Tasks due today:\")\n\n            for task in due_tasks:\n\n                print(f\"ID: {task[0]}, Title: {task[1]}\")\n\n        else:\n\n            print(\"No tasks due today.\")\n\n```\n\nI can call this function periodically or add it as an option in the menu.\n\nAdditionally, I can add a feature to export tasks to a file, such as CSV or JSON, for backup or sharing purposes.\n\nHere's an example of how to export tasks to a CSV file:\n\n```python\n\nimport csv\n\ndef export_tasks(conn, filename):\n\n    with conn.cursor() as cur:\n\n        cur.execute(\"SELECT * FROM tasks\")\n\n        tasks = cur.fetchall()\n\n        if not tasks:\n\n            print(\"No tasks to export.\")\n\n            return\n\n        with open(filename, mode='w', newline='') as file:\n\n            writer = csv.writer(file)\n\n            writer.writerow([\"ID\", \"Title\", \"Description\", \"Due Date\", \"Priority\", \"Completed\"])\n\n            for task in tasks:\n\n                priority_str = {\n\n                    1: \"High\",\n\n                    2: \"Medium\",\n\n                    3: \"Low\"\n\n                }.get(task[4], \"Unknown\")\n\n                completed_str = \"Yes\" if task[5] else \"No\"\n\n                writer.writerow([task[0], task[1], task[2], task[3], priority_str, completed_str])\n\n        print(f\"Tasks exported to {filename}.\")\n\n```\n\nI can add this as another option in the menu.\n\nMoreover, to improve the user experience, I can add validation for task IDs to ensure they are integers and handle cases where the user enters invalid IDs.\n\nHere's an example of how to validate task IDs:\n\n```python\n\ndef get_valid_task_id(conn):\n\n    while True:\n\n        task_id_str = input(\"Enter task ID: \")\n\n        if not task_id_str.isdigit():\n\n            print(\"Invalid task ID. Please enter a number.\")\n\n            continue\n\n        task_id = int(task_id_str)\n\n        with conn.cursor() as cur:\n\n            cur.execute(\"SELECT id FROM tasks WHERE id = %s\", (task_id,))\n\n            if cur.fetchone():\n\n                return task_id\n\n            else:\n\n                print(\"Task not found. Please try again.\")\n\n```\n\nI can use this function in the `update_task`, `delete_task`, and `mark_as_completed` functions to ensure a valid task ID is provided.\n\nThis will make the script more robust and user-friendly.\n\nI should also consider adding a search functionality to search tasks by title or description.\n\nHere's an example of how to implement search:\n\n```python\n\ndef search_tasks(conn):\n\n    search_term = input(\"Enter search term: \")\n\n    if not search_term:\n\n        print(\"No search term provided.\")\n\n        return\n\n    with conn.cursor() as cur:\n\n        cur.execute(\n\n            \"SELECT * FROM tasks WHERE title ILIKE %s OR description ILIKE %s\",\n\n            (f'%{search_term}%', f'%{search_term}%')\n\n        )\n\n        tasks = cur.fetchall()\n\n        if not tasks:\n\n            print(\"No matching tasks found.\")\n\n            return\n\n        # Prepare data for tabulate\n\n        headers = [\"ID\", \"Title\", \"Description\", \"Due Date\", \"Priority\", \"Completed\"]\n\n        table = []\n\n        for task in tasks:\n\n            priority_str = {\n\n                1: \"High\",\n\n                2: \"Medium\",\n\n                3: \"Low\"\n\n            }.get(task[4], \"Unknown\")\n\n            completed_str = \"Yes\" if task[5] else \"No\"\n\n            table.append([task[0], task[1], task[2], task[3], priority_str, completed_str])\n\n        print(tabulate(table, headers=headers, tablefmt=\"grid\"))\n\n```\n\nThis allows users to search for tasks containing specific keywords in their title or description.\n\nI can add this as another option in the menu.\n\nFurthermore, to handle cases where the database is empty, I can provide appropriate messages to the user.\n\nFor example, in the `list_tasks` function, if no tasks are found, display \"No tasks found.\".\n\nI should also consider adding a feature to edit the completed status of a task, in case the user wants to mark a completed task as pending again.\n\nTo do this, I can modify the `mark_as_completed` function to allow toggling the completed status.\n\nHere's an example:\n\n```python\n\ndef toggle_completed_status(conn):\n\n    task_id = input(\"Enter task ID to toggle completed status: \")\n\n    with conn.cursor() as cur:\n\n        cur.execute(\"SELECT completed FROM tasks WHERE id = %s\", (task_id,))\n\n        task = cur.fetchone()\n\n        if not task:\n\n            print(\"Task not found.\")\n\n            return\n\n        current_status = task[0]\n\n        new_status = not current_status\n\n        cur.execute(\"UPDATE tasks SET completed = %s WHERE id = %s\", (new_status, task_id))\n\n        conn.commit()\n\n        status_str = \"completed\" if new_status else \"pending\"\n\n        print(f\"Task marked as {status_str}.\")\n\n```\n\nThis provides more flexibility in managing task statuses.\n\nI can also add a feature to set reminders for tasks, perhaps by integrating with an external service or using notifications.\n\nHowever, implementing such features would require additional setup and dependencies, which might be beyond the scope of this simple task management system.\n\nLastly, I should make sure to handle all potential exceptions and edge cases in the script to ensure it runs smoothly.\n\nI can add try-except blocks around database operations and user input handling to catch and report errors gracefully.\n\nHere's an example of how to handle exceptions in the `add_task` function:\n\n```python\n\ndef add_task(conn):\n\n    try:\n\n        title = input(\"Enter task title: \")\n\n        if not title:\n\n            print(\"Title cannot be empty.\")\n\n            return\n\n        description = input(\"Enter task description: \")\n\n        due_date_str = input(\"Enter due date (YYYY-MM-DD): \")\n\n        try:\n\n            due_date = datetime.strptime(due_date_str, '%Y-%m-%d').date()\n\n        except ValueError:\n\n            print(\"Invalid date format. Please use YYYY-MM-DD.\")\n\n            return\n\n        priority = input(\"Enter priority (1=High, 2=Medium, 3=Low): \")\n\n        if priority not in ['1', '2', '3']:\n\n            print(\"Invalid priority level. Please choose 1, 2, or 3.\")\n\n            return\n\n        with conn.cursor() as cur:\n\n            cur.execute(\n\n                \"INSERT INTO tasks (title, description, due_date, priority, completed) VALUES (%s, %s, %s, %s, %s)\",\n\n                (title, description, due_date, priority, False)\n\n            )\n\n            conn.commit()\n\n        print(\"Task added successfully.\")\n\n    except Exception as e:\n\n        print(f\"An error occurred: {e}\")\n\n```\n\nThis way, any unexpected errors will be caught and displayed to the user without crashing the script.\n\nI should apply similar exception handling to other functions as well.\n\nIn summary, I've outlined a plan to create a Python script that manages tasks in a PostgreSQL database. The script will support adding, updating, deleting, listing, and marking tasks as completed, with additional features for filtering, sorting, and exporting tasks.\n\nI need to implement each function carefully, ensuring that user inputs are validated and that the database operations are handled correctly.\n\nOnce all functions are implemented, I can test the script thoroughly to make sure it works as expected and handles various edge cases appropriately.\n\n## Final Solution\nTo create a Python script that interacts with a PostgreSQL database for a simple task management system, follow these steps:\n\n### Prerequisites\n\n1. **Install Required Libraries**:\n   - `psycopg2` for PostgreSQL database interactions.\n   - `tabulate` for formatting the task list output.\n\n   You can install these using pip:\n   ```sh\n   pip install psycopg2-binary tabulate\n   ```\n\n2. **Set Up PostgreSQL Database**:\n   - Create a database and a table named `tasks` with the required fields.\n\n   Sample SQL for creating the table:\n   ```sql\n   CREATE TABLE tasks (\n       id SERIAL PRIMARY KEY,\n       title VARCHAR(255) NOT NULL,\n       description TEXT,\n       due_date DATE,\n       priority INTEGER,\n       completed BOOLEAN DEFAULT FALSE\n   );\n   ```\n\n### Solution Code\n\n```python\nimport os\nimport psycopg2\nfrom tabulate import tabulate\nfrom datetime import datetime, date\n\n# Database connection function\ndef connect_to_db():\n    try:\n        db_name = os.getenv('DB_NAME', 'task_manager')\n        db_user = os.getenv('DB_USER', 'your_username')\n        db_password = os.getenv('DB_PASSWORD', 'your_password')\n        db_host = os.getenv('DB_HOST', 'localhost')\n        db_port = os.getenv('DB_PORT', '5432')\n        conn = psycopg2.connect(\n            dbname=db_name,\n            user=db_user,\n            password=db_password,\n            host=db_host,\n            port=db_port\n        )\n        return conn\n    except psycopg2.Error as e:\n        print(f\"Database error: {e}\")\n        return None\n\n# Function to initialize the database and create the tasks table if it doesn't exist\ndef init_db(conn):\n    with conn.cursor() as cur:\n        cur.execute(\"\"\"\n            CREATE TABLE IF NOT EXISTS tasks (\n                id SERIAL PRIMARY KEY,\n                title VARCHAR(255) NOT NULL,\n                description TEXT,\n                due_date DATE,\n                priority INTEGER,\n                completed BOOLEAN DEFAULT FALSE\n            );\n        \"\"\")\n        conn.commit()\n\n# Function to add a new task\ndef add_task(conn):\n    try:\n        title = input(\"Enter task title: \")\n        if not title:\n            print(\"Title cannot be empty.\")\n            return\n        description = input(\"Enter task description: \")\n        due_date_str = input(\"Enter due date (YYYY-MM-DD): \")\n        try:\n            due_date = datetime.strptime(due_date_str, '%Y-%m-%d').date()\n        except ValueError:\n            print(\"Invalid date format. Please use YYYY-MM-DD.\")\n            return\n        priority = input(\"Enter priority (1=High, 2=Medium, 3=Low): \")\n        if priority not in ['1', '2', '3']:\n            print(\"Invalid priority level. Please choose 1, 2, or 3.\")\n            return\n        with conn.cursor() as cur:\n            cur.execute(\n                \"INSERT INTO tasks (title, description, due_date, priority, completed) VALUES (%s, %s, %s, %s, %s)\",\n                (title, description, due_date, priority, False)\n            )\n            conn.commit()\n        print(\"Task added successfully.\")\n    except Exception as e:\n        print(f\"An error occurred: {e}\")\n\n# Function to update an existing task\ndef update_task(conn):\n    task_id = input(\"Enter task ID to update: \")\n    with conn.cursor() as cur:\n        cur.execute(\"SELECT * FROM tasks WHERE id = %s\", (task_id,))\n        task = cur.fetchone()\n        if not task:\n            print(\"Task not found.\")\n            return\n        print(\"Current task details:\")\n        print(f\"ID: {task[0]}\")\n        print(f\"Title: {task[1]}\")\n        print(f\"Description: {task[2]}\")\n        print(f\"Due Date: {task[3]}\")\n        print(f\"Priority: {task[4]}\")\n        print(f\"Completed: {task[5]}\")\n        fields_to_update = input(\"Enter fields to update (title, description, due_date, priority): \").split()\n        update_values = []\n        set_clause = []\n        for field in fields_to_update:\n            if field not in ['title', 'description', 'due_date', 'priority']:\n                print(f\"Invalid field: {field}\")\n                continue\n            new_value = input(f\"Enter new {field}: \")\n            if field == 'due_date':\n                try:\n                    new_value = datetime.strptime(new_value, '%Y-%m-%d').date()\n                except ValueError:\n                    print(\"Invalid date format. Please use YYYY-MM-DD.\")\n                    return\n            elif field == 'priority':\n                if new_value not in ['1', '2', '3']:\n                    print(\"Invalid priority level. Please choose 1, 2, or 3.\")\n                    return\n            update_values.append(new_value)\n            set_clause.append(f\"{field} = %s\")\n        if not set_clause:\n            print(\"No fields to update.\")\n            return\n        set_str = \", \".join(set_clause)\n        query = f\"UPDATE tasks SET {set_str} WHERE id = %s\"\n        update_values.append(task_id)\n        cur.execute(query, update_values)\n        conn.commit()\n        print(\"Task updated successfully.\")\n\n# Function to delete a task\ndef delete_task(conn):\n    task_id = input(\"Enter task ID to delete: \")\n    with conn.cursor() as cur:\n        cur.execute(\"SELECT title FROM tasks WHERE id = %s\", (task_id,))\n        task = cur.fetchone()\n        if not task:\n            print(\"Task not found.\")\n            return\n        confirm = input(f\"Are you sure you want to delete task '{task[0]}'? (yes/no): \")\n        if confirm.lower() != 'yes':\n            print(\"Deletion canceled.\")\n            return\n        cur.execute(\"DELETE FROM tasks WHERE id = %s\", (task_id,))\n        conn.commit()\n        print(\"Task deleted successfully.\")\n\n# Function to list tasks with filtering and sorting options\ndef list_tasks(conn):\n    filter_option = input(\"Filter by:\\n1. All tasks\\n2. Completed tasks\\n3. Pending tasks\\n4. Specific priority\\nChoose an option: \")\n    sort_option = input(\"Sort by:\\n1. Title\\n2. Due Date\\n3. Priority\\nChoose an option: \")\n    query = \"SELECT * FROM tasks\"\n    params = []\n    if filter_option == '2':\n        query += \" WHERE completed = TRUE\"\n    elif filter_option == '3':\n        query += \" WHERE completed = FALSE\"\n    elif filter_option == '4':\n        priority = input(\"Enter priority (1=High, 2=Medium, 3=Low): \")\n        if priority in ['1', '2', '3']:\n            query += \" WHERE priority = %s\"\n            params.append(int(priority))\n        else:\n            print(\"Invalid priority level.\")\n            return\n    if sort_option == '1':\n        query += \" ORDER BY title\"\n    elif sort_option == '2':\n        query += \" ORDER BY due_date\"\n    elif sort_option == '3':\n        query += \" ORDER BY priority\"\n    with conn.cursor() as cur:\n        cur.execute(query, params)\n        tasks = cur.fetchall()\n        if not tasks:\n            print(\"No tasks found.\")\n            return\n        headers = [\"ID\", \"Title\", \"Description\", \"Due Date\", \"Priority\", \"Completed\"]\n        table = []\n        for task in tasks:\n            priority_str = {1: \"High\", 2: \"Medium\", 3: \"Low\"}.get(task[4], \"Unknown\")\n            completed_str = \"Yes\" if task[5] else \"No\"\n            table.append([task[0], task[1], task[2], task[3], priority_str, completed_str])\n        print(tabulate(table, headers=headers, tablefmt=\"grid\"))\n\n# Function to mark a task as completed\ndef mark_as_completed(conn):\n    task_id = input(\"Enter task ID to mark as completed: \")\n    with conn.cursor() as cur:\n        cur.execute(\"SELECT title FROM tasks WHERE id = %s\", (task_id,))\n        task = cur.fetchone()\n        if not task:\n            print(\"Task not found.\")\n            return\n        cur.execute(\"UPDATE tasks SET completed = TRUE WHERE id = %s\", (task_id,))\n        conn.commit()\n        print(f\"Task '{task[0]}' marked as completed.\")\n\n# Function to toggle the completed status of a task\ndef toggle_completed_status(conn):\n    task_id = input(\"Enter task ID to toggle completed status: \")\n    with conn.cursor() as cur:\n        cur.execute(\"SELECT completed FROM tasks WHERE id = %s\", (task_id,))\n        task = cur.fetchone()\n        if not task:\n            print(\"Task not found.\")\n            return\n        current_status = task[0]\n        new_status = not current_status\n        cur.execute(\"UPDATE tasks SET completed = %s WHERE id = %s\", (new_status, task_id))\n        conn.commit()\n        status_str = \"completed\" if new_status else \"pending\"\n        print(f\"Task marked as {status_str}.\")\n\n# Function to export tasks to a CSV file\ndef export_tasks(conn, filename):\n    with conn.cursor() as cur:\n        cur.execute(\"SELECT * FROM tasks\")\n        tasks = cur.fetchall()\n        if not tasks:\n            print(\"No tasks to export.\")\n            return\n        with open(filename, mode='w', newline='') as file:\n            writer = csv.writer(file)\n            writer.writerow([\"ID\", \"Title\", \"Description\", \"Due Date\", \"Priority\", \"Completed\"])\n            for task in tasks:\n                priority_str = {1: \"High\", 2: \"Medium\", 3: \"Low\"}.get(task[4], \"Unknown\")\n                completed_str = \"Yes\" if task[5] else \"No\"\n                writer.writerow([task[0], task[1], task[2], task[3], priority_str, completed_str])\n        print(f\"Tasks exported to {filename}.\")\n\n# Main function to run the task management system\ndef main():\n    conn = connect_to_db()\n    if not conn:\n        print(\"Failed to connect to the database.\")\n        return\n    init_db(conn)\n    while True:\n        print(\"\\nTask Management System\")\n        print(\"Please choose an option:\")\n        print(\"1. Add Task\")\n        print(\"2. Update Task\")\n        print(\"3. Delete Task\")\n        print(\"4. List Tasks\")\n        print(\"5. Mark Task as Completed\")\n        print(\"6. Toggle Task Completion\")\n        print(\"7. Export Tasks\")\n        print(\"8. Exit\")\n        choice = input(\"Enter your choice: \")\n        if choice == '1':\n            add_task(conn)\n        elif choice == '2':\n            update_task(conn)\n        elif choice == '3':\n            delete_task(conn)\n        elif choice == '4':\n            list_tasks(conn)\n        elif choice == '5':\n            mark_as_completed(conn)\n        elif choice == '6':\n            toggle_completed_status(conn)\n        elif choice == '7':\n            filename = input(\"Enter filename to export tasks: \")\n            export_tasks(conn, filename)\n        elif choice == '8':\n            break\n        else:\n            print(\"Invalid choice. Please try again.\")\n    conn.close()\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n\n- **Database Setup**: The script connects to a PostgreSQL database and ensures the `tasks` table exists.\n- **Menu-Driven Interface**: Users interact through a menu to add, update, delete, list, and manage task completion statuses.\n- **Input Validation**: User inputs are validated to ensure data integrity and prevent errors.\n- **Data Handling**: Tasks are stored with details like title, description, due date, priority, and completion status.\n- **Reporting and Exporting**: Tasks can be listed with filters and sorted, and exported to CSV for backup or sharing.\n\nThis script provides a comprehensive task management system suitable for personal or small-team use, managed directly from the command line."
    }
]