[
    {
        "role": "user",
        "content": "Implement a trie data structure in C# for efficient string searching and matching.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Implementing a Trie Data Structure in C#\n\nA trie, also known as a prefix tree, is an efficient data structure for storing and retrieving strings. It is particularly useful for operations like auto-completion, spell-checking, and IP routing. In this guide, we'll implement a basic trie in C# that supports insertion and searching of strings.\n\n### Step 1: Understanding the Trie Structure\n\nA trie consists of nodes, where each node represents a character in a string. The root node is empty, and each path from the root to a leaf node forms a complete string. Each node may have multiple children, corresponding to different characters.\n\n### Step 2: Defining the Trie Node\n\nFirst, we need to define the structure of a trie node. Each node will contain:\n\n- A dictionary to hold its children nodes, mapped by character.\n- A boolean flag to indicate if the node represents the end of a string.\n\n```csharp\npublic class TrieNode\n{\n    public Dictionary<char, TrieNode> Children { get; set; }\n    public bool IsEndOfWord { get; set; }\n\n    public TrieNode()\n    {\n        Children = new Dictionary<char, TrieNode>();\n        IsEndOfWord = false;\n    }\n}\n```\n\n### Step 3: Implementing the Trie Class\n\nNext, we implement the Trie class, which will manage the root node and provide methods for insertion and searching.\n\n```csharp\npublic class Trie\n{\n    private TrieNode root;\n\n    public Trie()\n    {\n        root = new TrieNode();\n    }\n\n    // Insert a word into the trie\n    public void Insert(string word)\n    {\n        TrieNode current = root;\n        foreach (char c in word)\n        {\n            if (!current.Children.ContainsKey(c))\n            {\n                current.Children[c] = new TrieNode();\n            }\n            current = current.Children[c];\n        }\n        current.IsEndOfWord = true;\n    }\n\n    // Search for a word in the trie\n    public bool Search(string word)\n    {\n        TrieNode current = root;\n        foreach (char c in word)\n        {\n            if (!current.Children.ContainsKey(c))\n            {\n                return false;\n            }\n            current = current.Children[c];\n        }\n        return current.IsEndOfWord;\n    }\n\n    // Check if a prefix exists in the trie\n    public bool StartsWith(string prefix)\n    {\n        TrieNode current = root;\n        foreach (char c in prefix)\n        {\n            if (!current.Children.ContainsKey(c))\n            {\n                return false;\n            }\n            current = current.Children[c];\n        }\n        return true;\n    }\n}\n```\n\n### Step 4: Testing the Trie\n\nTo verify that our trie works correctly, we can write some test cases.\n\n```csharp\nclass Program\n{\n    static void Main()\n    {\n        Trie trie = new Trie();\n        trie.Insert(\"hello\");\n        trie.Insert(\"world\");\n\n        Console.WriteLine(trie.Search(\"hello\")); // Output: True\n        Console.WriteLine(trie.Search(\"world\")); // Output: True\n        Console.WriteLine(trie.Search(\"hey\"));   // Output: False\n\n        Console.WriteLine(trie.StartsWith(\"he\")); // Output: True\n        Console.WriteLine(trie.StartsWith(\"wo\")); // Output: True\n        Console.WriteLine(trie.StartsWith(\"abc\"));// Output: False\n    }\n}\n```\n\n### Explanation\n\n- **Insertion**: We traverse the trie character by character. If a character is not present in the current node's children, we create a new node for it. Finally, we mark the end node as the end of a word.\n- **Searching**: We traverse the trie following the characters of the word. If we reach the end of the word and the node has `IsEndOfWord` set to true, the word exists in the trie.\n- **Prefix Check**: Similar to searching, but we only need to traverse the prefix without checking if it's the end of a word.\n\nThis basic implementation can be extended with more features like deleting words, auto-completion suggestions, etc."
    }
]