[
    {
        "role": "user",
        "content": "Implement a C++ class representing a 3D vector, including methods for addition, subtraction, dot product, cross product, magnitude, normalization, and angle between vectors. Ensure proper encapsulation, and overload operators where appropriate for more intuitive usage of the class.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Implementing a 3D vector class in C++ with the specified functionalities is a great way to understand both vector mathematics and object-oriented programming principles in C++. Below is a step-by-step guide to creating such a class, ensuring proper encapsulation and operator overloading for intuitive use.\n\n### Step 1: Class Definition\n\nFirst, define the class with private member variables for the x, y, and z components of the vector. This encapsulates the data, preventing direct access and modification from outside the class.\n\n```cpp\nclass Vector3D {\nprivate:\n    double x, y, z;\n};\n```\n\n### Step 2: Constructors\n\nImplement constructors to initialize the vector. Provide a default constructor and a parameterized constructor.\n\n```cpp\npublic:\n    // Default constructor\n    Vector3D() : x(0), y(0), z(0) {}\n\n    // Parameterized constructor\n    Vector3D(double x, double y, double z) : x(x), y(y), z(z) {}\n```\n\n### Step 3: Getter and Setter Methods\n\nProvide methods to get and set the vector components to maintain encapsulation.\n\n```cpp\n    // Getter methods\n    double getX() const { return x; }\n    double getY() const { return y; }\n    double getZ() const { return z; }\n\n    // Setter methods\n    void setX(double value) { x = value; }\n    void setY(double value) { y = value; }\n    void setZ(double value) { z = value; }\n```\n\n### Step 4: Addition and Subtraction\n\nImplement methods for vector addition and subtraction.\n\n```cpp\n    // Addition\n    Vector3D add(const Vector3D& other) const {\n        return Vector3D(x + other.x, y + other.y, z + other.z);\n    }\n\n    // Subtraction\n    Vector3D subtract(const Vector3D& other) const {\n        return Vector3D(x - other.x, y - other.y, z - other.z);\n    }\n```\n\n### Step 5: Dot and Cross Products\n\nImplement methods for dot product and cross product.\n\n```cpp\n    // Dot product\n    double dot(const Vector3D& other) const {\n        return x * other.x + y * other.y + z * other.z;\n    }\n\n    // Cross product\n    Vector3D cross(const Vector3D& other) const {\n        return Vector3D(\n            y * other.z - z * other.y,\n            z * other.x - x * other.z,\n            x * other.y - y * other.x\n        );\n    }\n```\n\n### Step 6: Magnitude and Normalization\n\nImplement methods to calculate the magnitude of the vector and to normalize it.\n\n```cpp\n    // Magnitude\n    double magnitude() const {\n        return std::sqrt(x * x + y * y + z * z);\n    }\n\n    // Normalization\n    Vector3D normalize() const {\n        double mag = magnitude();\n        if (mag == 0) {\n            throw std::runtime_error(\"Cannot normalize a zero vector.\");\n        }\n        return Vector3D(x / mag, y / mag, z / mag);\n    }\n```\n\n### Step 7: Angle Between Vectors\n\nImplement a method to calculate the angle between two vectors in radians.\n\n```cpp\n    // Angle between two vectors in radians\n    double angleBetween(const Vector3D& other) const {\n        double dotProduct = dot(other);\n        double magThis = magnitude();\n        double magOther = other.magnitude();\n        if (magThis == 0 || magOther == 0) {\n            throw std::runtime_error(\"Cannot calculate angle with a zero vector.\");\n        }\n        return std::acos(dotProduct / (magThis * magOther));\n    }\n```\n\n### Step 8: Operator Overloading\n\nOverload operators to make vector operations more intuitive.\n\n```cpp\n    // Overload addition operator\n    Vector3D operator+(const Vector3D& other) const {\n        return add(other);\n    }\n\n    // Overload subtraction operator\n    Vector3D operator-(const Vector3D& other) const {\n        return subtract(other);\n    }\n\n    // Overload multiplication operator for scalar multiplication\n    Vector3D operator*(double scalar) const {\n        return Vector3D(x * scalar, y * scalar, z * scalar);\n    }\n\n    // Overload division operator for scalar division\n    Vector3D operator/(double scalar) const {\n        if (scalar == 0) {\n            throw std::runtime_error(\"Cannot divide by zero.\");\n        }\n        return Vector3D(x / scalar, y / scalar, z / scalar);\n    }\n\n    // Overload equality operator\n    bool operator==(const Vector3D& other) const {\n        return x == other.x && y == other.y && z == other.z;\n    }\n\n    // Overload inequality operator\n    bool operator!=(const Vector3D& other) const {\n        return !(*this == other);\n    }\n```\n\n### Step 9: Input and Output Operators\n\nOverload the input and output stream operators for easy input and output of vector objects.\n\n```cpp\n    // Overload insertion operator for output\n    friend std::ostream& operator<<(std::ostream& os, const Vector3D& vec) {\n        os << \"(\" << vec.x << \", \" << vec.y << \", \" << vec.z << \")\";\n        return os;\n    }\n\n    // Overload extraction operator for input\n    friend std::istream& operator>>(std::istream& is, Vector3D& vec) {\n        is >> vec.x >> vec.y >> vec.z;\n        return is;\n    }\n};\n```\n\n### Final Class\n\nCombining all the above parts, the final `Vector3D` class looks like this:\n\n```cpp\n#include <iostream>\n#include <cmath>\n#include <stdexcept>\n\nclass Vector3D {\nprivate:\n    double x, y, z;\n\npublic:\n    // Constructors\n    Vector3D() : x(0), y(0), z(0) {}\n    Vector3D(double x, double y, double z) : x(x), y(y), z(z) {}\n\n    // Getter methods\n    double getX() const { return x; }\n    double getY() const { return y; }\n    double getZ() const { return z; }\n\n    // Setter methods\n    void setX(double value) { x = value; }\n    void setY(double value) { y = value; }\n    void setZ(double value) { z = value; }\n\n    // Addition\n    Vector3D add(const Vector3D& other) const {\n        return Vector3D(x + other.x, y + other.y, z + other.z);\n    }\n\n    // Subtraction\n    Vector3D subtract(const Vector3D& other) const {\n        return Vector3D(x - other.x, y - other.y, z - other.z);\n    }\n\n    // Dot product\n    double dot(const Vector3D& other) const {\n        return x * other.x + y * other.y + z * other.z;\n    }\n\n    // Cross product\n    Vector3D cross(const Vector3D& other) const {\n        return Vector3D(\n            y * other.z - z * other.y,\n            z * other.x - x * other.z,\n            x * other.y - y * other.x\n        );\n    }\n\n    // Magnitude\n    double magnitude() const {\n        return std::sqrt(x * x + y * y + z * z);\n    }\n\n    // Normalization\n    Vector3D normalize() const {\n        double mag = magnitude();\n        if (mag == 0) {\n            throw std::runtime_error(\"Cannot normalize a zero vector.\");\n        }\n        return Vector3D(x / mag, y / mag, z / mag);\n    }\n\n    // Angle between two vectors in radians\n    double angleBetween(const Vector3D& other) const {\n        double dotProduct = dot(other);\n        double magThis = magnitude();\n        double magOther = other.magnitude();\n        if (magThis == 0 || magOther == 0) {\n            throw std::runtime_error(\"Cannot calculate angle with a zero vector.\");\n        }\n        return std::acos(dotProduct / (magThis * magOther));\n    }\n\n    // Operator overloads\n    Vector3D operator+(const Vector3D& other) const {\n        return add(other);\n    }\n\n    Vector3D operator-(const Vector3D& other) const {\n        return subtract(other);\n    }\n\n    Vector3D operator*(double scalar) const {\n        return Vector3D(x * scalar, y * scalar, z * scalar);\n    }\n\n    Vector3D operator/(double scalar) const {\n        if (scalar == 0) {\n            throw std::runtime_error(\"Cannot divide by zero.\");\n        }\n        return Vector3D(x / scalar, y / scalar, z / scalar);\n    }\n\n    bool operator==(const Vector3D& other) const {\n        return x == other.x && y == other.y && z == other.z;\n    }\n\n    bool operator!=(const Vector3D& other) const {\n        return !(*this == other);\n    }\n\n    // Stream operators\n    friend std::ostream& operator<<(std::ostream& os, const Vector3D& vec) {\n        os << \"(\" << vec.x << \", \" << vec.y << \", \" << vec.z << \")\";\n        return os;\n    }\n\n    friend std::istream& operator>>(std::istream& is, Vector3D& vec) {\n        is >> vec.x >> vec.y >> vec.z;\n        return is;\n    }\n};\n```\n\n### Explanation\n\n- **Encapsulation**: The vector components are private, accessible only through public methods.\n- **Methods**: Include operations like addition, subtraction, dot product, cross product, magnitude, normalization, and angle calculation.\n- **Operator Overloading**: Makes the class more intuitive to use, allowing operations like `vector1 + vector2` and `vector * scalar`.\n- **Error Handling**: Includes checks for operations that could lead to division by zero or other invalid operations.\n\nThis class provides a solid foundation for working with 3D vectors in C++, suitable for various applications in graphics, physics simulations, and more."
    }
]