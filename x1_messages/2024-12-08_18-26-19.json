[
    {
        "role": "user",
        "content": "Implement a multi-threaded C++ application that simulates a producer-consumer problem using condition variables and mutexes. The producer generates random numbers and adds them to a shared buffer, while the consumer removes and processes these numbers. The application should ensure proper synchronization between threads and avoid race conditions.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Implementing a multi-threaded C++ application that simulates the producer-consumer problem using condition variables and mutexes involves several key steps. This classic problem demonstrates how threads can interact with shared resources safely, avoiding issues like race conditions.\n\n### Approach\n\n1. **Shared Buffer**: Use a fixed-size buffer to store the items produced by the producer and consumed by the consumer.\n2. **Mutex**: Employ a mutex to protect access to the shared buffer, ensuring that only one thread modifies it at a time.\n3. **Condition Variables**: Use condition variables to handle the waiting and waking up of threads. Specifically:\n   - The producer should wait when the buffer is full.\n   - The consumer should wait when the buffer is empty.\n4. **Threads**: Create separate threads for the producer and consumer.\n5. **Random Numbers**: The producer generates random numbers to add to the buffer.\n6. **Processing**: The consumer processes (e.g., prints) the numbers it removes from the buffer.\n\n### Solution Code\n\n```cpp\n#include <iostream>\n#include <thread>\n#include <queue>\n#include <mutex>\n#include <condition_variable>\n#include <chrono>\n#include <random>\n\nstd::mutex buffer_mutex;\nstd::condition_variable cv;\nstd::queue<int> buffer;\nconst size_t buffer_size = 5;\nbool done = false;\n\nvoid producer() {\n    std::default_random_engine generator;\n    std::uniform_int_distribution<int> distribution(1, 100);\n    \n    while (true) {\n        int number = distribution(generator);\n        std::unique_lock<std::mutex> lock(buffer_mutex);\n        cv.wait(lock, []{ return buffer.size() < buffer_size; });\n        \n        buffer.push(number);\n        std::cout << \"Produced: \" << number << \", Buffer size: \" << buffer.size() << std::endl;\n        \n        lock.unlock();\n        cv.notify_one();\n        std::this_thread::sleep_for(std::chrono::milliseconds(100));\n    }\n}\n\nvoid consumer() {\n    while (true) {\n        std::unique_lock<std::mutex> lock(buffer_mutex);\n        cv.wait(lock, []{ return !buffer.empty() || done; });\n        \n        if (buffer.empty()) {\n            if (done) {\n                break;\n            }\n            continue;\n        }\n        \n        int number = buffer.front();\n        buffer.pop();\n        std::cout << \"Consumed: \" << number << \", Buffer size: \" << buffer.size() << std::endl;\n        \n        lock.unlock();\n        cv.notify_one();\n        std::this_thread::sleep_for(std::chrono::milliseconds(150));\n    }\n}\n\nint main() {\n    std::thread producer_thread(producer);\n    std::thread consumer_thread(consumer);\n    \n    // Let the threads run for some time\n    std::this_thread::sleep_for(std::chrono::seconds(5));\n    \n    {\n        std::unique_lock<std::mutex> lock(buffer_mutex);\n        done = true;\n    }\n    cv.notify_all();\n    \n    producer_thread.join();\n    consumer_thread.join();\n    \n    return 0;\n}\n```\n\n### Explanation\n\n1. **Shared Resources**:\n   - `buffer`: A queue to hold the produced numbers.\n   - `buffer_mutex`: A mutex to protect access to the buffer.\n   - `cv`: A condition variable to coordinate between the producer and consumer.\n   - `done`: A flag to indicate when the producer is done producing.\n\n2. **Producer Thread**:\n   - Generates random numbers and adds them to the buffer.\n   - Waits if the buffer is full using `cv.wait()`.\n   - Notifies the consumer after adding a number.\n\n3. **Consumer Thread**:\n   - Removes and processes (prints) numbers from the buffer.\n   - Waits if the buffer is empty using `cv.wait()`.\n   - Checks the `done` flag to exit gracefully.\n   - Notifies the producer after removing a number.\n\n4. **Main Function**:\n   - Starts the producer and consumer threads.\n   - Runs for a specified duration (5 seconds in this example).\n   - Sets the `done` flag and notifies all waiting threads to exit.\n\nThis implementation ensures that the producer and consumer threads synchronize correctly, avoiding race conditions and deadlocks through the use of mutexes and condition variables."
    }
]