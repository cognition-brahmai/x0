[
    {
        "role": "user",
        "content": "Write a Golang program that creates a WebSocket server that allows multiple clients to connect and send messages to each other. The server should broadcast incoming messages to all connected clients and maintain a history of the last 100 messages."
    },
    {
        "role": "assistant",
        "content": "Sure! I can help you with that. To create a WebSocket server in Go that allows multiple clients to connect and send messages to each other, we'll need to use the `gorilla/websocket` package, which is a popular WebSocket library for Go.\n\nFirst, make sure you have the `gorilla/websocket` package installed. You can install it using:\n\n```sh\ngo get github.com/gorilla/websocket\n```\n\nNow, let's outline the steps we need to implement:\n\n1. **Set up the WebSocket server:** We'll create a WebSocket endpoint that clients can connect to.\n\n2. **Handle multiple connections:** We need to manage multiple client connections concurrently.\n\n3. **Broadcast messages:** When a message is received from one client, it should be sent to all other connected clients.\n\n4. **Maintain message history:** Keep track of the last 100 messages and send them to new clients when they connect.\n\nLet's dive into the code.\n\n## Final Solution\nTo create a WebSocket server in Go that allows multiple clients to connect and send messages to each other, while broadcasting incoming messages and maintaining a history of the last 100 messages, you can use the following code:\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\nvar upgrader = websocket.Upgrader{\n\tReadBufferSize:  1024,\n\tWriteBufferSize: 1024,\n\tCheckOrigin: func(r *http.Request) bool {\n\t\treturn true\n\t},\n}\n\nvar clients = make(map[*websocket.Conn]bool) // connected clients\nvar broadcast = make(chan Message)           // broadcast channel\nvar messageHistory = make([]Message, 0)      // message history\n\n// Message is the structure of the message\ntype Message struct {\n\tUser   string `json:\"user\"`\n\tMessage string `json:\"message\"`\n\tTime   string `json:\"time\"`\n}\n\nfunc main() {\n\tfs := http.FileServer(http.Dir(\"public\"))\n\thttp.Handle(\"/\", fs)\n\thttp.HandleFunc(\"/ws\", handleConnections)\n\n\tgo handleMessages()\n\n\tlog.Println(\"Listening on :8000...\")\n\terr := http.ListenAndServe(\":8000\", nil)\n\tif err != nil {\n\t\tlog.Fatal(\"ListenAndServe: \", err)\n\t}\n}\n\nfunc handleConnections(w http.ResponseWriter, r *http.Request) {\n\tws, err := upgrader.Upgrade(w, r, nil)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer ws.Close()\n\n\tclients[ws] = true\n\n\t// Send history to the new client\n\tfor _, msg := range messageHistory {\n\t\terr := ws.WriteJSON(msg)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Error sending history: %v\", err)\n\t\t\tdelete(clients, ws)\n\t\t\treturn\n\t\t}\n\t}\n\n\tfor {\n\t\tvar msg Message\n\t\terr := ws.ReadJSON(&msg)\n\t\tif err != nil {\n\t\t\tdelete(clients, ws)\n\t\t\tfmt.Printf(\"Client disconnected: %v\", ws)\n\t\t\tbreak\n\t\t}\n\t\tmsg.Time = time.Now().Format(time.RFC1123)\n\t\tbroadcast <- msg\n\t}\n}\n\nfunc handleMessages() {\n\tfor {\n\t\tmsg := <-broadcast\n\t\tmessageHistory = append(messageHistory, msg)\n\t\tif len(messageHistory) > 100 {\n\t\t\tmessageHistory = messageHistory[len(messageHistory)-100:]\n\t\t}\n\t\tfor client := range clients {\n\t\t\terr := client.WriteJSON(msg)\n\t\t\tif err != nil {\n\t\t\t\tlog.Printf(\"Error broadcasting: %v\", err)\n\t\t\t\tclient.Close()\n\t\t\t\tdelete(clients, client)\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n### Explanation\n\n1. **Setting Up the WebSocket Server:**\n   - We use the `gorilla/websocket` package to handle WebSocket connections.\n   - The `upgrader` is configured to upgrade HTTP connections to WebSocket connections.\n\n2. **Handling Multiple Connections:**\n   - We maintain a map of connected clients (`clients`) to manage multiple connections.\n   - When a new client connects, their connection is added to the `clients` map.\n\n3. **Broadcasting Messages:**\n   - A broadcast channel (`broadcast`) is used to send messages to all connected clients.\n   - When a message is received from a client, it is sent through the broadcast channel.\n\n4. **Maintaining Message History:**\n   - We keep a slice of the last 100 messages in `messageHistory`.\n   - When a new client connects, we send the message history to them.\n   - Whenever a new message is broadcasted, it is added to the history, and if the history exceeds 100 messages, the oldest messages are removed.\n\nThis setup ensures that all connected clients receive all messages in real-time and that new clients get the latest 100 messages upon connection."
    }
]