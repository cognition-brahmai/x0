[
    {
        "role": "user",
        "content": "Write a Golang program to implement a stack data structure with push, pop, and peek operations. The stack should be able to store strings.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Sure! Below is a simple implementation of a stack data structure in Golang that can store strings. This implementation includes the push, pop, and peek operations.\n\n```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\n// Stack represents a stack data structure that stores strings.\ntype Stack struct {\n\titems []string\n}\n\n// Push adds a string to the top of the stack.\nfunc (s *Stack) Push(item string) {\n\ts.items = append(s.items, item)\n}\n\n// Pop removes and returns the string from the top of the stack.\n// It returns an error if the stack is empty.\nfunc (s *Stack) Pop() (string, error) {\n\tif len(s.items) == 0 {\n\t\treturn \"\", errors.New(\"stack is empty\")\n\t}\n\tindex := len(s.items) - 1\n\titem := s.items[index]\n\ts.items = s.items[:index]\n\treturn item, nil\n}\n\n// Peek returns the string from the top of the stack without removing it.\n// It returns an error if the stack is empty.\nfunc (s *Stack) Peek() (string, error) {\n\tif len(s.items) == 0 {\n\t\treturn \"\", errors.New(\"stack is empty\")\n\t}\n\treturn s.items[len(s.items)-1], nil\n}\n\n// IsEmpty checks if the stack is empty.\nfunc (s *Stack) IsEmpty() bool {\n\treturn len(s.items) == 0\n}\n\n// Size returns the number of items in the stack.\nfunc (s *Stack) Size() int {\n\treturn len(s.items)\n}\n\nfunc main() {\n\tstack := Stack{}\n\n\tstack.Push(\"Hello\")\n\tstack.Push(\"World\")\n\tfmt.Println(\"Stack size:\", stack.Size()) // Output: 2\n\n\tpeeked, err := stack.Peek()\n\tif err != nil {\n\t\tfmt.Println(err)\n\t} else {\n\t\tfmt.Println(\"Top item:\", peeked) // Output: World\n\t}\n\n\tpopped, err := stack.Pop()\n\tif err != nil {\n\t\tfmt.Println(err)\n\t} else {\n\t\tfmt.Println(\"Popped item:\", popped) // Output: World\n\t}\n\n\tfmt.Println(\"Stack size after pop:\", stack.Size()) // Output: 1\n\n\tfor !stack.IsEmpty() {\n\t\titem, err := stack.Pop()\n\t\tif err != nil {\n\t\t\tfmt.Println(err)\n\t\t} else {\n\t\t\tfmt.Println(\"Popped item:\", item)\n\t\t}\n\t}\n\n\tfmt.Println(\"Is stack empty?\", stack.IsEmpty()) // Output: true\n}\n```\n\n### Explanation:\n1. **Stack Structure**: A `Stack` type is defined with a slice of strings to store the items.\n2. **Push Operation**: Adds a string to the end of the slice, which represents the top of the stack.\n3. **Pop Operation**: Removes and returns the last item from the slice. If the stack is empty, it returns an error.\n4. **Peek Operation**: Returns the last item from the slice without removing it. If the stack is empty, it returns an error.\n5. **IsEmpty and Size Methods**: Utility methods to check if the stack is empty and to get the number of items in the stack, respectively.\n\nThis implementation ensures that the stack operations are performed efficiently, with push and pop operations being O(1) time complexity."
    }
]