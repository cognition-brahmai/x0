[
    {
        "role": "user",
        "content": "Implement a basic calculator using C++ that supports addition, subtraction, multiplication, and division operations on integers. The calculator should be able to parse input expressions in infix notation (e.g., \"5 + 3 * 2\") and return the correct result. Use object-oriented programming principles to design the calculator."
    },
    {
        "role": "assistant",
        "content": "Implementing a basic calculator in C++ that can handle addition, subtraction, multiplication, and division operations on integers, and parse input expressions in infix notation involves several steps. We'll use object-oriented programming principles to structure our code effectively. Here's a step-by-step guide to creating this calculator:\n\n### Step 1: Understand Infix Notation and Conversion to Postfix\n\nInfix notation is the common way of writing expressions, e.g., \"5 + 3 * 2\". However, to evaluate such expressions easily, it's helpful to convert them to postfix notation (also known as Reverse Polish Notation), which eliminates the need to consider operator precedence and parentheses.\n\n### Step 2: Design Classes\n\nWe'll design the following classes:\n\n1. **Token**: To represent different types of tokens in the expression (numbers, operators, parentheses).\n2. **Tokenizer**: To split the input string into tokens.\n3. **Operator**: To handle operators and their properties (precedence, associativity).\n4. **Calculator**: To handle the conversion from infix to postfix and evaluation of the postfix expression.\n\n### Step 3: Implement the Token Class\n\nThe Token class will represent different types of tokens.\n\n```cpp\nenum class TokenType {\n    NUMBER,\n    OPERATOR,\n    LEFT_PAREN,\n    RIGHT_PAREN\n};\n\nclass Token {\npublic:\n    TokenType type;\n    std::string value;\n\n    Token(TokenType type, const std::string& value) : type(type), value(value) {}\n};\n```\n\n### Step 4: Implement the Tokenizer Class\n\nThe Tokenizer class will break down the input string into a list of tokens.\n\n```cpp\nclass Tokenizer {\npublic:\n    std::string expression;\n    size_t position = 0;\n\n    Tokenizer(const std::string& expr) : expression(expr) {}\n\n    Token nextToken() {\n        // Implement tokenization logic here\n        // Skip whitespace\n        while (position < expression.size() && isspace(expression[position])) {\n            position++;\n        }\n        if (position >= expression.size()) {\n            return Token(TokenType::NUMBER, \"\");\n        }\n        if (isdigit(expression[position])) {\n            std::string number;\n            while (position < expression.size() && isdigit(expression[position])) {\n                number += expression[position++];\n            }\n            return Token(TokenType::NUMBER, number);\n        }\n        if (expression[position] == '+' || expression[position] == '-' ||\n            expression[position] == '*' || expression[position] == '/') {\n            char op = expression[position++];\n            return Token(TokenType::OPERATOR, std::string(1, op));\n        }\n        if (expression[position] == '(') {\n            position++;\n            return Token(TokenType::LEFT_PAREN, \"(\");\n        }\n        if (expression[position] == ')') {\n            position++;\n            return Token(TokenType::RIGHT_PAREN, \")\");\n        }\n        throw std::runtime_error(\"Invalid character in expression\");\n    }\n};\n```\n\n### Step 5: Implement the Operator Class\n\nThe Operator class will handle properties of operators.\n\n```cpp\nclass Operator {\npublic:\n    std::string symbol;\n    int precedence;\n    bool isLeftAssociative;\n\n    Operator(const std::string& symbol, int precedence, bool isLeftAssociative)\n        : symbol(symbol), precedence(precedence), isLeftAssociative(isLeftAssociative) {}\n};\n```\n\n### Step 6: Implement the Calculator Class\n\nThe Calculator class will handle the conversion from infix to postfix and evaluation.\n\n```cpp\nclass Calculator {\nprivate:\n    std::map<std::string, Operator> operators = {\n        {\"+\", Operator(\"+\", 2, true)},\n        {\"-\", Operator(\"-\", 2, true)},\n        {\"*\", Operator(\"*\", 3, true)},\n        {\"/\", Operator(\"/\", 3, true)},\n    };\n\n    bool isOperator(const std::string& token) {\n        return operators.find(token) != operators.end();\n    }\n\n    int precedence(const std::string& op) {\n        return operators[op].precedence;\n    }\n\n    bool isLeftAssociative(const std::string& op) {\n        return operators[op].isLeftAssociative;\n    }\n\n    std::vector<Token> infixToPostfix(const std::vector<Token>& infixTokens) {\n        std::vector<Token> postfixTokens;\n        std::stack<Token> operatorStack;\n\n        for (const auto& token : infixTokens) {\n            if (token.type == TokenType::NUMBER) {\n                postfixTokens.push_back(token);\n            } else if (token.type == TokenType::OPERATOR) {\n                while (!operatorStack.empty() && operatorStack.top().type == TokenType::OPERATOR) {\n                    auto topOp = operatorStack.top().value;\n                    if ((isLeftAssociative(topOp) && precedence(topOp) >= precedence(token.value)) ||\n                        (!isLeftAssociative(topOp) && precedence(topOp) > precedence(token.value))) {\n                        postfixTokens.push_back(operatorStack.top());\n                        operatorStack.pop();\n                    } else {\n                        break;\n                    }\n                }\n                operatorStack.push(token);\n            } else if (token.type == TokenType::LEFT_PAREN) {\n                operatorStack.push(token);\n            } else if (token.type == TokenType::RIGHT_PAREN) {\n                while (!operatorStack.empty() && operatorStack.top().type != TokenType::LEFT_PAREN) {\n                    postfixTokens.push_back(operatorStack.top());\n                    operatorStack.pop();\n                }\n                if (!operatorStack.empty() && operatorStack.top().type == TokenType::LEFT_PAREN) {\n                    operatorStack.pop();\n                } else {\n                    throw std::runtime_error(\"Mismatched parentheses\");\n                }\n            }\n        }\n\n        while (!operatorStack.empty()) {\n            if (operatorStack.top().type == TokenType::LEFT_PAREN || operatorStack.top().type == TokenType::RIGHT_PAREN) {\n                throw std::runtime_error(\"Mismatched parentheses\");\n            }\n            postfixTokens.push_back(operatorStack.top());\n            operatorStack.pop();\n        }\n\n        return postfixTokens;\n    }\n\n    int evaluatePostfix(const std::vector<Token>& postfixTokens) {\n        std::stack<int> stack;\n        for (const auto& token : postfixTokens) {\n            if (token.type == TokenType::NUMBER) {\n                stack.push(std::stoi(token.value));\n            } else if (token.type == TokenType::OPERATOR) {\n                if (stack.size() < 2) {\n                    throw std::runtime_error(\"Invalid expression\");\n                }\n                int b = stack.top();\n                stack.pop();\n                int a = stack.top();\n                stack.pop();\n                if (token.value == \"+\") {\n                    stack.push(a + b);\n                } else if (token.value == \"-\") {\n                    stack.push(a - b);\n                } else if (token.value == \"*\") {\n                    stack.push(a * b);\n                } else if (token.value == \"/\") {\n                    if (b == 0) {\n                        throw std::runtime_error(\"Division by zero\");\n                    }\n                    stack.push(a / b);\n                }\n            }\n        }\n        if (stack.size() != 1) {\n            throw std::runtime_error(\"Invalid expression\");\n        }\n        return stack.top();\n    }\n\npublic:\n    int calculate(const std::string& expression) {\n        Tokenizer tokenizer(expression);\n        std::vector<Token> tokens;\n        Token token = tokenizer.nextToken();\n        while (!token.value.empty()) {\n            tokens.push_back(token);\n            token = tokenizer.nextToken();\n        }\n\n        std::vector<Token> postfixTokens = infixToPostfix(tokens);\n        return evaluatePostfix(postfixTokens);\n    }\n};\n```\n\n### Step 7: Main Function\n\nFinally, implement the main function to use the Calculator class.\n\n```cpp\nint main() {\n    Calculator calculator;\n    std::string expression;\n    std::cout << \"Enter an expression (e.g., 5 + 3 * 2): \";\n    std::getline(std::cin, expression);\n    try {\n        int result = calculator.calculate(expression);\n        std::cout << \"Result: \" << result << std::endl;\n    } catch (const std::exception& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n    }\n    return 0;\n}\n```\n\n### Explanation\n\n1. **Tokenization**: The input expression is split into tokens (numbers, operators, parentheses).\n2. **Infix to Postfix Conversion**: Using the Shunting Yard algorithm, the infix expression is converted to postfix notation, which is easier to evaluate.\n3. **Postfix Evaluation**: The postfix expression is evaluated using a stack, performing operations as operators are encountered.\n\nThis approach ensures that the calculator correctly handles operator precedence and parentheses, providing accurate results for integer arithmetic operations.\n"
    }
]