[
    {
        "role": "user",
        "content": "In Java, write a program that implements a simple chat server using sockets. The server should be able to handle multiple clients concurrently. Each client should have a unique username and be able to send messages to all other connected clients."
    },
    {
        "role": "assistant",
        "content": "Implementing a multi-client chat server in Java using sockets involves several steps. We need to handle multiple clients concurrently, manage unique usernames, and broadcast messages to all connected clients. Below is a step-by-step guide along with the code to achieve this.\n\n### Step 1: Set Up the Server\n\nFirst, we need to create a server that listens for incoming client connections. The server will use a `ServerSocket` to accept incoming connections and spawn a new thread for each client to handle their communications concurrently.\n\n### Step 2: Handle Client Connections\n\nEach client connection will be handled by a separate thread. This thread will read messages from the client and broadcast them to all other connected clients.\n\n### Step 3: Manage Usernames\n\nEnsure that each client has a unique username. When a client connects, they will be prompted to choose a username. If the username is already taken, they will be asked to choose another one.\n\n### Step 4: Broadcast Messages\n\nWhen a client sends a message, it should be broadcast to all other connected clients.\n\n### Solution Code\n\n#### Server Class\n\n```java\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\n\npublic class ChatServer {\n    private static final int PORT = 12345;\n    private static List<ClientHandler> clients = new ArrayList<>();\n\n    public static void main(String[] args) throws IOException {\n        ServerSocket serverSocket = new ServerSocket(PORT);\n        System.out.println(\"Chat Server started on port \" + PORT);\n\n        while (true) {\n            Socket socket = serverSocket.accept();\n            ClientHandler clientHandler = new ClientHandler(socket);\n            clients.add(clientHandler);\n            new Thread(clientHandler).start();\n        }\n    }\n\n    public static void broadcastMessage(String message, ClientHandler sender) {\n        for (ClientHandler client : clients) {\n            if (client != sender) {\n                client.sendMessage(message);\n            }\n        }\n    }\n\n    public static void removeClient(ClientHandler client) {\n        clients.remove(client);\n    }\n}\n```\n\n#### ClientHandler Class\n\n```java\nimport java.io.*;\nimport java.net.*;\n\npublic class ClientHandler implements Runnable {\n    private Socket socket;\n    private BufferedReader in;\n    private PrintWriter out;\n    private String username;\n\n    public ClientHandler(Socket socket) {\n        this.socket = socket;\n    }\n\n    @Override\n    public void run() {\n        try {\n            in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n            out = new PrintWriter(socket.getOutputStream(), true);\n\n            // Get unique username\n            while (true) {\n                out.println(\"Enter your username:\");\n                username = in.readLine();\n                if (username == null || username.isEmpty()) {\n                    out.println(\"Username cannot be empty. Try again.\");\n                    continue;\n                }\n                if (isUsernameUnique(username)) {\n                    break;\n                } else {\n                    out.println(\"Username already exists. Choose another one.\");\n                }\n            }\n\n            out.println(\"Welcome, \" + username + \"!\");\n\n            // Notify all clients about new user\n            String joinedMessage = \"[ \" + username + \" has joined the chat ]\";\n            ChatServer.broadcastMessage(joinedMessage, this);\n\n            String message;\n            while ((message = in.readLine()) != null) {\n                if (message.equals(\"/quit\")) {\n                    break;\n                }\n                String formattedMessage = \"[\" + username + \"]: \" + message;\n                ChatServer.broadcastMessage(formattedMessage, this);\n            }\n\n            // User left\n            String leftMessage = \"[ \" + username + \" has left the chat ]\";\n            ChatServer.broadcastMessage(leftMessage, this);\n            ChatServer.removeClient(this);\n            socket.close();\n            System.out.println(username + \" disconnected.\");\n        } catch (IOException e) {\n            if (username != null) {\n                System.out.println(username + \" disconnected unexpectedly.\");\n                ChatServer.removeClient(this);\n            }\n        }\n    }\n\n    private boolean isUsernameUnique(String username) {\n        for (ClientHandler client : ChatServer.clients) {\n            if (client.username != null && client.username.equals(username)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public void sendMessage(String message) {\n        out.println(message);\n    }\n}\n```\n\n### Explanation\n\n1. **Server Setup**: The `ChatServer` class sets up a server socket to listen for incoming connections on a specified port (12345 in this case). For each incoming connection, it creates a new `ClientHandler` and starts a new thread to handle that client.\n\n2. **Client Handling**: The `ClientHandler` class handles communication with a single client. It reads messages from the client and broadcasts them to all other clients. It also manages unique usernames and handles client disconnections.\n\n3. **Broadcasting Messages**: The `broadcastMessage` method in `ChatServer` sends a message to all connected clients except the sender.\n\n4. **Removing Clients**: When a client disconnects, it is removed from the list of connected clients, and a disconnection message is broadcast to other clients.\n\nThis setup ensures that multiple clients can connect to the server, communicate with each other using unique usernames, and the server handles everything concurrently using threads."
    }
]