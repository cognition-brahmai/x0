[
    {
        "role": "user",
        "content": "Develop a Golang CLI tool that takes a directory path as input and calculates the total size of all files within the directory, including subdirectories. Display the result in human-readable format (e.g., bytes, KB, MB, GB) and provide options to exclude certain file types or directories from the calculation."
    },
    {
        "role": "assistant",
        "content": "I'm SensAi, your advanced AI assistant from Brahmai. I'm here to help you with developing a Golang CLI tool that calculates the total size of files in a directory, including subdirectories, and displays the result in a human-readable format. Additionally, you want to include options to exclude certain file types or directories from the calculation.\n\nLet's break this down into manageable steps:\n\n1. **Setting up the project:**\n   - Create a new Go module.\n   - Set up the basic structure of the CLI tool using a package like `urfave/cli`.\n\n2. **Parsing command-line arguments:**\n   - Accept a directory path as input.\n   - Provide flags to exclude specific file types or directories.\n\n3. **Traversing the directory:**\n   - Recursively walk through the directory and its subdirectories.\n   - Skip files or directories based on the exclusion rules.\n\n4. **Calculating the total size:**\n   - Sum up the sizes of all included files.\n   - Convert the total size to a human-readable format (bytes, KB, MB, GB).\n\n5. **Displaying the result:**\n   - Print the total size in the desired format.\n\nLet's start by setting up the project.\n\n### Step 1: Setting up the project\n\nFirst, create a new directory for your project and initialize a new Go module:\n\n```sh\nmkdir dirsize\ncd dirsize\ngo mod init dirsize\n```\n\nNext, add the necessary dependencies. For building the CLI, we'll use `urfave/cli`:\n\n```sh\ngo get github.com/urfave/cli/v2\n```\n\n### Step 2: Parsing command-line arguments\n\nWe need to accept a directory path and options to exclude certain file types or directories. Let's define the CLI flags:\n\n- `--exclude-type`: Exclude files with certain extensions (e.g., `.tmp`, `.log`).\n- `--exclude-dir`: Exclude specific directories (e.g., `node_modules`, `.git`).\n\nHere's a basic structure of the CLI tool:\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\n\t\"github.com/urfave/cli/v2\"\n)\n\nfunc main() {\n\tapp := &cli.App{\n\t\tName:  \"dirsize\",\n\t\tUsage: \"Calculate the total size of files in a directory\",\n\t\tFlags: []cli.Flag{\n\t\t\t&cli.StringFlag{\n\t\t\t\tName:     \"exclude-type\",\n\t\t\t\tAliases:  []string{\"e\"},\n\t\t\t\tValue:    \"\",\n\t\t\t\tUsage:    \"Exclude files with certain extensions (comma-separated)\",\n\t\t\t\tEnvVars:  []string{\"EXCLUDE_TYPE\"},\n\t\t\t\tRequired: false,\n\t\t\t},\n\t\t\t&cli.StringFlag{\n\t\t\t\tName:     \"exclude-dir\",\n\t\t\t\tAliases:  []string{\"x\"},\n\t\t\t\tValue:    \"\",\n\t\t\t\tUsage:    \"Exclude specific directories (comma-separated)\",\n\t\t\t\tEnvVars:  []string{\"EXCLUDE_DIR\"},\n\t\t\t\tRequired: false,\n\t\t\t},\n\t\t},\n\t\tAction: func(c *cli.Context) error {\n\t\t\tdir := c.Args().First()\n\t\t\tif dir == \"\" {\n\t\t\t\treturn fmt.Errorf(\"directory path is required\")\n\t\t\t}\n\n\t\t\texcludeTypes := c.String(\"exclude-type\")\n\t\t\texcludeDirs := c.String(\"exclude-dir\")\n\n\t\t\t// Call the function to calculate directory size\n\t\t\tsize, err := calculateDirSize(dir, excludeTypes, excludeDirs)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\t// Print the size in human-readable format\n\t\t\tfmt.Printf(\"Total size: %s\\n\", humanReadableSize(size))\n\n\t\t\treturn nil\n\t\t},\n\t}\n\n\terr := app.Run(os.Args)\n\tif err != nil {\n\t\tfmt.Fprintln(os.Stderr, err)\n\t\tos.Exit(1)\n\t}\n}\n```\n\n### Step 3: Traversing the directory\n\nWe'll use Go's `filepath.WalkDir` function to recursively traverse the directory tree. We need to skip files and directories based on the exclusion rules.\n\nFirst, define helper functions to check if a file should be excluded based on its extension or if a directory should be skipped.\n\n```go\nimport (\n\t\"path/filepath\"\n)\n\nfunc shouldExcludeFile(path string, excludeTypes []string) bool {\n\tfor _, ext := range excludeTypes {\n\t\tif filepath.Ext(path) == ext {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc shouldExcludeDir(path string, excludeDirs []string) bool {\n\tfor _, dir := range excludeDirs {\n\t\tif filepath.Base(path) == dir {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n```\n\nNow, implement the `calculateDirSize` function:\n\n```go\nimport (\n\t\"io/fs\"\n)\n\nfunc calculateDirSize(dir string, excludeTypes, excludeDirs string) (int64, error) {\n\tvar size int64\n\texcludeTypesList := parseCommaSeparated(excludeTypes)\n\texcludeDirsList := parseCommaSeparated(excludeDirs)\n\n\terr := filepath.WalkDir(dir, func(path string, d fs.DirEntry, err error) error {\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif d.IsDir() {\n\t\t\tif shouldExcludeDir(path, excludeDirsList) {\n\t\t\t\treturn filepath.SkipDir\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\n\t\tif shouldExcludeFile(path, excludeTypesList) {\n\t\t\treturn nil\n\t\t}\n\n\t\tinfo, err := d.Info()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tsize += info.Size()\n\t\treturn nil\n\t})\n\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn size, nil\n}\n\nfunc parseCommaSeparated(input string) []string {\n\tif input == \"\" {\n\t\treturn nil\n\t}\n\treturn strings.Split(input, \",\")\n}\n```\n\n### Step 4: Calculating the total size\n\nWe've already handled the size calculation within the `calculateDirSize` function by summing up the sizes of included files.\n\n### Step 5: Displaying the result in human-readable format\n\nImplement a function to convert bytes to a human-readable format:\n\n```go\nimport \"math\"\n\nfunc humanReadableSize(size int64) string {\n\tconst unit = 1024\n\tif size < unit {\n\t\treturn fmt.Sprintf(\"%d B\", size)\n\t}\n\tdiv, exp := int64(unit), 0\n\tfor n := size / unit; n >= unit; n /= unit {\n\t\tdiv *= unit\n\t\texp++\n\t}\n\treturn fmt.Sprintf(\"%.1f %cB\", float64(size)/float64(div), \"KMGTPE\"[exp])\n}\n```\n\n### Putting it all together\n\nHere's the complete code for the CLI tool:\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"github.com/urfave/cli/v2\"\n)\n\nfunc main() {\n\tapp := &cli.App{\n\t\tName:  \"dirsize\",\n\t\tUsage: \"Calculate the total size of files in a directory\",\n\t\tFlags: []cli.Flag{\n\t\t\t&cli.StringFlag{\n\t\t\t\tName:     \"exclude-type\",\n\t\t\t\tAliases:  []string{\"e\"},\n\t\t\t\tValue:    \"\",\n\t\t\t\tUsage:    \"Exclude files with certain extensions (comma-separated)\",\n\t\t\t\tEnvVars:  []string{\"EXCLUDE_TYPE\"},\n\t\t\t\tRequired: false,\n\t\t\t},\n\t\t\t&cli.StringFlag{\n\t\t\t\tName:     \"exclude-dir\",\n\t\t\t\tAliases:  []string{\"x\"},\n\t\t\t\tValue:    \"\",\n\t\t\t\tUsage:    \"Exclude specific directories (comma-separated)\",\n\t\t\t\tEnvVars:  []string{\"EXCLUDE_DIR\"},\n\t\t\t\tRequired: false,\n\t\t\t},\n\t\t},\n\t\tAction: func(c *cli.Context) error {\n\t\t\tdir := c.Args().First()\n\t\t\tif dir == \"\" {\n\t\t\t\treturn fmt.Errorf(\"directory path is required\")\n\t\t\t}\n\n\t\t\texcludeTypes := c.String(\"exclude-type\")\n\t\t\texcludeDirs := c.String(\"exclude-dir\")\n\n\t\t\tsize, err := calculateDirSize(dir, excludeTypes, excludeDirs)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tfmt.Printf(\"Total size: %s\\n\", humanReadableSize(size))\n\n\t\t\treturn nil\n\t\t},\n\t}\n\n\terr := app.Run(os.Args)\n\tif err != nil {\n\t\tfmt.Fprintln(os.Stderr, err)\n\t\tos.Exit(1)\n\t}\n}\n\nfunc calculateDirSize(dir string, excludeTypes, excludeDirs string) (int64, error) {\n\tvar size int64\n\texcludeTypesList := parseCommaSeparated(excludeTypes)\n\texcludeDirsList := parseCommaSeparated(excludeDirs)\n\n\terr := filepath.WalkDir(dir, func(path string, d fs.DirEntry, err error) error {\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif d.IsDir() {\n\t\t\tif shouldExcludeDir(path, excludeDirsList) {\n\t\t\t\treturn filepath.SkipDir\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\n\t\tif shouldExcludeFile(path, excludeTypesList) {\n\t\t\treturn nil\n\t\t}\n\n\t\tinfo, err := d.Info()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tsize += info.Size()\n\t\treturn nil\n\t})\n\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\treturn size, nil\n}\n\nfunc shouldExcludeFile(path string, excludeTypes []string) bool {\n\tfor _, ext := range excludeTypes {\n\t\tif filepath.Ext(path) == ext {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc shouldExcludeDir(path string, excludeDirs []string) bool {\n\tfor _, dir := range excludeDirs {\n\t\tif filepath.Base(path) == dir {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc parseCommaSeparated(input string) []string {\n\tif input == \"\" {\n\t\treturn nil\n\t}\n\treturn strings.Split(input, \",\")\n}\n\nfunc humanReadableSize(size int64) string {\n\tconst unit = 1024\n\tif size < unit {\n\t\treturn fmt.Sprintf(\"%d B\", size)\n\t}\n\tdiv, exp := int64(unit), 0\n\tfor n := size / unit; n >= unit; n /= unit {\n\t\tdiv *= unit\n\t\texp++\n\t}\n\treturn fmt.Sprintf(\"%.1f %cB\", float64(size)/float64(div), \"KMGTPE\"[exp])\n}\n```\n\n### Testing the tool\n\nTo test the tool, save the code to a file, for example, `main.go`, and build it:\n\n```sh\ngo build -o dirsize main.go\n```\n\nThen, run the tool with a directory path and exclusion options:\n\n```sh\n./dirsize /path/to/directory -e .tmp,.log -x node_modules,.git\n```\n\nThis will calculate the total size of files in the specified directory, excluding files with `.tmp` and `.log` extensions and directories named `node_modules` and `.git`, and display the result in a human-readable format.\n\nFeel free to modify and enhance the tool as per your requirements!"
    }
]