[
    {
        "role": "user",
        "content": "Write a C++ program that simulates a simple bank account management system. The program should use classes and objects to represent accounts, customers, and transactions. Customers can open accounts, deposit money, withdraw money, and check their balance. Transactions should be recorded with a timestamp, type (deposit or withdrawal), and amount.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Alright, I'm going to try to write a C++ program that simulates a simple bank account management system. I need to use classes and objects to represent accounts, customers, and transactions. Customers should be able to open accounts, deposit money, withdraw money, and check their balance. Also, transactions should be recorded with a timestamp, type (deposit or withdrawal), and amount.\n\nFirst, I need to plan out the structure of the program. I think I'll need at least three classes: Customer, Account, and Transaction.\n\nLet's start with the Transaction class. Each transaction should have a timestamp, type (deposit or withdrawal), and amount. I can represent the type using an enum for clarity.\n\nNext, the Account class should have methods to deposit money, withdraw money, and check balance. It should also keep a record of all transactions.\n\nThen, the Customer class will have personal information and a list of accounts associated with the customer.\n\nI need to decide how to handle the timestamp for transactions. In C++, I can use the `<ctime>` library to get the current time.\n\nAlso, I should think about how to store multiple accounts per customer. Maybe using a vector of Account objects in the Customer class.\n\nLet me sketch out some rough class definitions.\n\nStarting with Transaction:\n\n```cpp\nclass Transaction {\npublic:\n    enum Type { DEPOSIT, WITHDRAWAL };\n\n    Transaction(Type type, double amount);\n    std::string getTimestamp() const;\n    Type getType() const;\n    double getAmount() const;\n\nprivate:\n    time_t timestamp;\n    Type type;\n    double amount;\n};\n```\n\nThen, the Account class:\n\n```cpp\nclass Account {\npublic:\n    Account(int accountNumber);\n    void deposit(double amount);\n    bool withdraw(double amount);\n    double getBalance() const;\n    std::vector<Transaction> getTransactionHistory() const;\n\nprivate:\n    int accountNumber;\n    double balance;\n    std::vector<Transaction> transactions;\n};\n```\n\nAnd finally, the Customer class:\n\n```cpp\nclass Customer {\npublic:\n    Customer(std::string firstName, std::string lastName, std::string email);\n    void openAccount();\n    void deposit(int accountNumber, double amount);\n    bool withdraw(int accountNumber, double amount);\n    double checkBalance(int accountNumber) const;\n    std::vector<Account> getAccounts() const;\n\nprivate:\n    std::string firstName;\n    std::string lastName;\n    std::string email;\n    std::vector<Account> accounts;\n};\n```\n\nI need to think about how to assign account numbers. Maybe start from a certain number and increment for each new account.\n\nAlso, I need to handle cases where a customer tries to withdraw more money than they have in their account.\n\nLet me think about the main function. It should allow users to create customers, open accounts for them, deposit and withdraw money, and check balances.\n\nI might want to use a map to keep track of all customers, perhaps with their email as the key.\n\nWait, but multiple customers might have the same email. Maybe I need a unique customer ID.\n\nAlternatively, I can use a vector of customers and search by name or email.\n\nBut for simplicity, I'll use a map with email as the key, assuming emails are unique.\n\nNow, let's think about the implementation of each class.\n\nStarting with Transaction:\n\nI need to record the timestamp when a transaction is created. I can use `time(nullptr)` from `<ctime>` for this.\n\nI should also format the timestamp into a readable string.\n\nFor the type, I'll use the enum I defined.\n\nAnd the amount will be a double.\n\nIn the constructor, I'll set the timestamp to the current time, type and amount from the parameters.\n\nI'll also need getter functions for timestamp, type, and amount.\n\nFor the timestamp, I need to convert the time_t value to a readable string. I can use `std::ctime` for this, but it includes a newline character, so I need to remove that.\n\nNext, the Account class.\n\nEach account should have a unique account number.\n\nI'll need to keep track of the balance and a history of transactions.\n\nIn the constructor, I'll set the account number and initialize balance to zero.\n\nThe deposit method will add the amount to the balance and record a deposit transaction.\n\nThe withdraw method will subtract the amount from the balance if sufficient funds are available and record a withdrawal transaction.\n\nThe getBalance method will return the current balance.\n\nGetTransactionHistory will return the vector of transactions.\n\nNow, the Customer class.\n\nEach customer has a first name, last name, email, and a list of accounts.\n\nIn the constructor, I'll set the personal information and initialize an empty vector for accounts.\n\nThe openAccount method will create a new Account object, assign a unique account number, and add it to the customer's list of accounts.\n\nI need to think about how to generate unique account numbers. Maybe start from 1000 and increment by 1 for each new account.\n\nWait, but if I restart the program, the account numbers will reset. Maybe I should use a static variable to keep track of the last assigned account number.\n\nSimilarly, for customers, I need unique emails.\n\nIn deposit, withdraw, and checkBalance methods of the Customer class, I'll need to find the account with the given account number and call the respective methods on that account.\n\nI should also handle cases where the account number doesn't exist.\n\nIn the main function, I'll need a loop that allows users to choose options like creating a customer, opening an account, depositing, withdrawing, checking balance, etc.\n\nI should also handle input validation, like ensuring that the account number exists before performing operations on it.\n\nLet me think about the menu for the main function.\n\nSomething like:\n\n1. Create Customer\n\n2. Open Account\n\n3. Deposit\n\n4. Withdraw\n\n5. Check Balance\n\n6. Exit\n\nAfter each operation, I'll ask if the user wants to perform another operation.\n\nI need to keep track of all customers and their accounts across these operations.\n\nI should also handle cases where a customer tries to open multiple accounts.\n\nWait, customers can have multiple accounts, so I need to ensure that account numbers are unique across all customers.\n\nI'll need a centralized way to generate unique account numbers.\n\nMaybe have a static variable in the Account class that keeps track of the last assigned account number.\n\nNow, let's think about implementing the Transaction class.\n\nI need to handle the timestamp properly.\n\nIn the constructor:\n\n```cpp\nTransaction(Type type, double amount) : type(type), amount(amount) {\n    timestamp = time(nullptr);\n}\n```\n\nThen, for getting the timestamp as a string:\n\n```cpp\nstd::string getTimestamp() const {\n    char buffer[50];\n    struct tm* timeinfo = localtime(&timestamp);\n    strftime(buffer, sizeof(buffer), \"%Y-%m-%d %H:%M:%S\", timeinfo);\n    return buffer;\n}\n```\n\nThis will give me a formatted timestamp string without the newline.\n\nNext, the Account class.\n\nConstructor:\n\n```cpp\nAccount(int accountNumber) : accountNumber(accountNumber), balance(0.0) {}\n```\n\nDeposit method:\n\n```cpp\nvoid deposit(double amount) {\n    if (amount > 0) {\n        balance += amount;\n        transactions.push_back(Transaction(Transaction::Type::DEPOSIT, amount));\n    } else {\n        // Handle invalid deposit amount\n        std::cout << \"Invalid deposit amount.\" << std::endl;\n    }\n}\n```\n\nWithdraw method:\n\n```cpp\nbool withdraw(double amount) {\n    if (amount > 0 && amount <= balance) {\n        balance -= amount;\n        transactions.push_back(Transaction(Transaction::Type::WITHDRAWAL, amount));\n        return true;\n    } else {\n        // Insufficient funds or invalid amount\n        std::cout << \"Withdrawal failed.\" << std::endl;\n        return false;\n    }\n}\n```\n\nGet balance:\n\n```cpp\ndouble getBalance() const {\n    return balance;\n}\n```\n\nGet transaction history:\n\n```cpp\nstd::vector<Transaction> getTransactionHistory() const {\n    return transactions;\n}\n```\n\nNow, the Customer class.\n\nConstructor:\n\n```cpp\nCustomer(std::string firstName, std::string lastName, std::string email)\n    : firstName(firstName), lastName(lastName), email(email) {}\n```\n\nOpen account:\n\nI need to generate a unique account number.\n\nI'll make accountNumber a static variable in the Account class.\n\nIn Account.h:\n\n```cpp\nclass Account {\npublic:\n    static int lastAccountNumber;\n    // other methods\nprivate:\n    int accountNumber;\n    // other members\n};\n```\n\nIn Account.cpp:\n\n```cpp\nint Account::lastAccountNumber = 1000;\n\nAccount::Account() : accountNumber(++lastAccountNumber), balance(0.0) {}\n```\n\nWait, but in my earlier plan, I had Account(int accountNumber). I need to adjust that.\n\nActually, I can have the constructor generate the next account number without taking it as a parameter.\n\nSo, in Account.h:\n\n```cpp\nclass Account {\npublic:\n    Account();\n    // other methods\nprivate:\n    static int lastAccountNumber;\n    int accountNumber;\n    double balance;\n    std::vector<Transaction> transactions;\n};\n```\n\nIn Account.cpp:\n\n```cpp\nint Account::lastAccountNumber = 1000;\n\nAccount::Account() : accountNumber(++lastAccountNumber), balance(0.0) {}\n```\n\nThen, in Customer::openAccount():\n\n```cpp\nvoid openAccount() {\n    Account newAccount;\n    accounts.push_back(newAccount);\n}\n```\n\nBut then, how does the customer associate with the account?\n\nWait, I need to ensure that the account is associated with the customer.\n\nActually, in the Account constructor, I can pass the customer object, but that might create circular dependencies.\n\nAlternatively, I can have the Account class not worry about the customer, and in the Customer class, just manage the list of accounts.\n\nIn the main function, I'll have a map<std::string, Customer> to store customers by email.\n\nWhen a customer opens an account, I'll add an Account object to their list of accounts.\n\nThen, for operations like deposit, withdraw, and check balance, I'll need to find the customer by email, then find the account by account number within their list of accounts.\n\nI need to implement methods in Customer to handle these operations.\n\nFor example, Customer::deposit(int accountNumber, double amount):\n\n```cpp\nvoid deposit(int accountNumber, double amount) {\n    for (Account& acc : accounts) {\n        if (acc.getAccountNumber() == accountNumber) {\n            acc.deposit(amount);\n            return;\n        }\n    }\n    std::cout << \"Account not found.\" << std::endl;\n}\n```\n\nSimilarly for withdraw and checkBalance.\n\nI need to add a getAccountNumber method in Account:\n\n```cpp\nint getAccountNumber() const {\n    return accountNumber;\n}\n```\n\nAlso, in Customer::getAccounts(), return the vector of accounts.\n\nNow, in the main function, I need to handle user inputs for each menu option.\n\nFor creating a customer, I'll ask for first name, last name, and email, and create a Customer object with these details.\n\nFor opening an account, I'll ask for the customer's email, find the customer, and call openAccount().\n\nFor deposit, withdraw, and check balance, I'll ask for the customer's email and the account number, then perform the operations.\n\nI need to handle cases where the customer or account doesn't exist.\n\nI should also think about how to display the transaction history for an account.\n\nMaybe add a method in Account to print the transaction history.\n\nLike:\n\n```cpp\nvoid printTransactionHistory() const {\n    for (const Transaction& tx : transactions) {\n        std::cout << tx.getTimestamp() << \" \";\n        if (tx.getType() == Transaction::Type::DEPOSIT) {\n            std::cout << \"Deposit: \";\n        } else {\n            std::cout << \"Withdrawal: \";\n        }\n        std::cout << tx.getAmount() << std::endl;\n    }\n}\n```\n\nAnd perhaps add a method in Customer to print all account details.\n\nAlso, I need to include necessary headers and handle namespaces.\n\nI should use `std::` for standard library components.\n\nI need to include `<iostream>`, `<vector>`, `<map>`, `<ctime>`, and `<string>`.\n\nI should also handle possible errors, like invalid input from the user.\n\nFor example, if the user enters a non-numeric value for account number or amount, I need to handle that gracefully.\n\nI can use `std::stod` and `std::stoi` with try-catch blocks for conversion failures.\n\nAlternatively, I can use `std::cin` and check if the input was successful.\n\nI need to make sure that the program doesn't crash due to invalid input.\n\nNow, let's think about implementing the main function.\n\nI'll use a loop that displays the menu and asks for the user's choice.\n\nBased on the choice, it will perform the corresponding operation.\n\nI'll use a map<std::string, Customer> to store customers, with email as the key.\n\nFor creating a customer:\n\n- Ask for first name, last name, and email.\n\n- Check if the email already exists in the map.\n\n- If not, create a new Customer object and add it to the map.\n\nFor opening an account:\n\n- Ask for the customer's email.\n\n- Find the customer in the map.\n\n- If found, call openAccount() and inform the user of the assigned account number.\n\n- If not found, display an error message.\n\nFor deposit:\n\n- Ask for the customer's email and account number.\n\n- Find the customer, then find the account.\n\n- If found, call deposit().\n\n- If not, display an error message.\n\nSimilar logic for withdraw and check balance.\n\nI should also think about how to display the customer's account(s).\n\nMaybe add an option to list all accounts for a customer.\n\nI can add another menu option for that.\n\nLike:\n\n7. List Accounts\n\nWhich asks for the customer's email, finds the customer, and lists all their account numbers.\n\nAdditionally, I can add an option to view transaction history for a specific account.\n\nLike:\n\n8. View Transaction History\n\nWhich asks for the customer's email and account number, then displays the transaction history for that account.\n\nThis would make the program more feature-rich and user-friendly.\n\nNow, let's think about how to implement the menu in the main function.\n\nI can use a do-while loop that continues until the user chooses to exit.\n\nAfter each operation, I'll ask if they want to perform another operation.\n\nI need to handle user inputs carefully to avoid crashes.\n\nAlso, I should consider using functions for each menu option to keep the code organized.\n\nFor example, functions like createCustomer(), openAccount(), deposit(), etc.\n\nThis will make the main function cleaner and easier to manage.\n\nI need to make sure that the account numbers are unique across all customers.\n\nSince I'm using a static variable in the Account class to generate account numbers, that should take care of it.\n\nNow, let's think about how to implement the Customer class methods.\n\nFor openAccount():\n\n```cpp\nvoid Customer::openAccount() {\n    Account newAccount;\n    accounts.push_back(newAccount);\n    std::cout << \"Account opened with account number: \" << newAccount.getAccountNumber() << std::endl;\n}\n```\n\nFor deposit():\n\n```cpp\nvoid Customer::deposit(int accountNumber, double amount) {\n    for (Account& acc : accounts) {\n        if (acc.getAccountNumber() == accountNumber) {\n            acc.deposit(amount);\n            std::cout << \"Deposit successful.\" << std::endl;\n            return;\n        }\n    }\n    std::cout << \"Account not found.\" << std::endl;\n}\n```\n\nSimilar for withdraw() and checkBalance().\n\nI should also add a method to list all accounts for a customer.\n\nLike:\n\n```cpp\nvoid Customer::listAccounts() const {\n    std::cout << \"Accounts:\" << std::endl;\n    for (const Account& acc : accounts) {\n        std::cout << \"Account Number: \" << acc.getAccountNumber() << \", Balance: \" << acc.getBalance() << std::endl;\n    }\n}\n```\n\nAnd a method to view transaction history for a specific account.\n\n```cpp\nvoid Customer::viewTransactionHistory(int accountNumber) const {\n    for (const Account& acc : accounts) {\n        if (acc.getAccountNumber() == accountNumber) {\n            acc.printTransactionHistory();\n            return;\n        }\n    }\n    std::cout << \"Account not found.\" << std::endl;\n}\n```\n\nNow, in the main function, I'll need to handle user inputs for each menu option.\n\nI should also handle cases where the user enters invalid inputs, like non-numeric account numbers or amounts.\n\nI can use try-catch blocks with `std::stod` and `std::stoi` to handle conversion errors.\n\nAlternatively, I can use `std::cin` and check if the input was successful.\n\nI think using `std::cin` with input validation would be sufficient for this program.\n\nI need to include `<iomanip>` for formatting output, like balancing columns.\n\nBut for simplicity, I'll just use std::cout for now.\n\nI should also consider adding a welcome message and instructions for the user.\n\nNow, let's think about how to structure the main function.\n\nSomething like:\n\n```cpp\nint main() {\n    std::map<std::string, Customer> customers;\n\n    char choice;\n    do {\n        displayMenu();\n        std::cout << \"Enter your choice: \";\n        std::cin >> choice;\n\n        switch (choice) {\n            case '1':\n                createCustomer(customers);\n                break;\n            case '2':\n                openAccount(customers);\n                break;\n            case '3':\n                deposit(customers);\n                break;\n            case '4':\n                withdraw(customers);\n                break;\n            case '5':\n                checkBalance(customers);\n                break;\n            case '6':\n                listAccounts(customers);\n                break;\n            case '7':\n                viewTransactionHistory(customers);\n                break;\n            case '8':\n                std::cout << \"Exiting...\" << std::endl;\n                break;\n            default:\n                std::cout << \"Invalid choice. Please try again.\" << std::endl;\n        }\n\n    } while (choice != '8');\n\n    return 0;\n}\n```\n\nI need to implement each of these functions: displayMenu(), createCustomer(), openAccount(), deposit(), withdraw(), checkBalance(), listAccounts(), viewTransactionHistory().\n\nIn displayMenu(), I'll print the list of options.\n\nIn createCustomer(), I'll ask for first name, last name, and email, and add a new Customer to the map.\n\nIn openAccount(), I'll ask for email, find the customer, and call openAccount().\n\nIn deposit(), ask for email and account number, find the customer and account, and deposit the amount.\n\nSimilar for withdraw(), checkBalance(), listAccounts(), and viewTransactionHistory().\n\nI need to make sure that the email is case-sensitive, as it's used as the key in the map.\n\nAlternatively, I can convert emails to lowercase before using them as keys.\n\nI should also handle cases where the email doesn't exist in the map.\n\nIn that case, display an error message.\n\nNow, let's think about implementing createCustomer().\n\n```cpp\nvoid createCustomer(std::map<std::string, Customer>& customers) {\n    std::string firstName, lastName, email;\n\n    std::cout << \"Enter first name: \";\n    std::cin.ignore();\n    std::getline(std::cin, firstName);\n\n    std::cout << \"Enter last name: \";\n    std::getline(std::cin, lastName);\n\n    std::cout << \"Enter email: \";\n    std::getline(std::cin, email);\n\n    if (customers.find(email) != customers.end()) {\n        std::cout << \"Customer with this email already exists.\" << std::endl;\n    } else {\n        Customer newCustomer(firstName, lastName, email);\n        customers[email] = newCustomer;\n        std::cout << \"Customer created successfully.\" << std::endl;\n    }\n}\n```\n\nI need to include `<algorithm>` for std::transform if I want to convert email to lowercase.\n\nBut for now, I'll assume that emails are entered consistently.\n\nIn openAccount():\n\n```cpp\nvoid openAccount(std::map<std::string, Customer>& customers) {\n    std::string email;\n\n    std::cout << \"Enter customer's email: \";\n    std::getline(std::cin, email);\n\n    auto it = customers.find(email);\n    if (it != customers.end()) {\n        it->second.openAccount();\n    } else {\n        std::cout << \"Customer not found.\" << std::endl;\n    }\n}\n```\n\nSimilarly, for deposit():\n\n```cpp\nvoid deposit(std::map<std::string, Customer>& customers) {\n    std::string email;\n    int accountNumber;\n    double amount;\n\n    std::cout << \"Enter customer's email: \";\n    std::getline(std::cin, email);\n\n    auto it = customers.find(email);\n    if (it != customers.end()) {\n        std::cout << \"Enter account number: \";\n        std::cin >> accountNumber;\n\n        std::cout << \"Enter amount to deposit: \";\n        std::cin >> amount;\n\n        it->second.deposit(accountNumber, amount);\n    } else {\n        std::cout << \"Customer not found.\" << std::endl;\n    }\n}\n```\n\nI need to make sure that after reading accountNumber and amount, I clear the newline character from the input buffer.\n\nOtherwise, the next std::getline will read an empty line.\n\nI can use std::cin.ignore() after reading accountNumber and amount.\n\nSimilarly, for withdraw():\n\n```cpp\nvoid withdraw(std::map<std::string, Customer>& customers) {\n    std::string email;\n    int accountNumber;\n    double amount;\n\n    std::cout << \"Enter customer's email: \";\n    std::getline(std::cin, email);\n\n    auto it = customers.find(email);\n    if (it != customers.end()) {\n        std::cout << \"Enter account number: \";\n        std::cin >> accountNumber;\n\n        std::cout << \"Enter amount to withdraw: \";\n        std::cin >> amount;\n\n        it->second.withdraw(accountNumber, amount);\n    } else {\n        std::cout << \"Customer not found.\" << std::endl;\n    }\n}\n```\n\nFor checkBalance():\n\n```cpp\nvoid checkBalance(std::map<std::string, Customer>& customers) {\n    std::string email;\n    int accountNumber;\n\n    std::cout << \"Enter customer's email: \";\n    std::getline(std::cin, email);\n\n    auto it = customers.find(email);\n    if (it != customers.end()) {\n        std::cout << \"Enter account number: \";\n        std::cin >> accountNumber;\n\n        double balance = it->second.checkBalance(accountNumber);\n        if (balance >= 0) {\n            std::cout << \"Balance: \" << balance << std::endl;\n        } else {\n            std::cout << \"Account not found.\" << std::endl;\n        }\n    } else {\n        std::cout << \"Customer not found.\" << std::endl;\n    }\n}\n```\n\nI need to adjust the checkBalance() method in Customer to return -1 or some indicator if the account is not found, since balance can be zero.\n\nAlternatively, I can have checkBalance() return optional<double> and handle it accordingly.\n\nBut for simplicity, I'll return -1 to indicate account not found.\n\nSo, in Customer::checkBalance():\n\n```cpp\ndouble checkBalance(int accountNumber) const {\n    for (const Account& acc : accounts) {\n        if (acc.getAccountNumber() == accountNumber) {\n            return acc.getBalance();\n        }\n    }\n    return -1.0; // Account not found\n}\n```\n\nIn the main function, if balance is -1, display \"Account not found.\"\n\nNow, for listAccounts():\n\n```cpp\nvoid listAccounts(const std::map<std::string, Customer>& customers) {\n    std::string email;\n\n    std::cout << \"Enter customer's email: \";\n    std::getline(std::cin, email);\n\n    auto it = customers.find(email);\n    if (it != customers.end()) {\n        it->second.listAccounts();\n    } else {\n        std::cout << \"Customer not found.\" << std::endl;\n    }\n}\n```\n\nAnd for viewTransactionHistory():\n\n```cpp\nvoid viewTransactionHistory(const std::map<std::string, Customer>& customers) {\n    std::string email;\n    int accountNumber;\n\n    std::cout << \"Enter customer's email: \";\n    std::getline(std::cin, email);\n\n    auto it = customers.find(email);\n    if (it != customers.end()) {\n        std::cout << \"Enter account number: \";\n        std::cin >> accountNumber;\n\n        it->second.viewTransactionHistory(accountNumber);\n    } else {\n        std::cout << \"Customer not found.\" << std::endl;\n    }\n}\n```\n\nI need to make sure that after reading accountNumber, I clear the input buffer.\n\nI can add std::cin.ignore() after std::cin >> accountNumber;\n\nNow, in the main function, I need to handle the menu choices accordingly.\n\nI should also consider adding a welcome message and instructions.\n\nPerhaps display the menu in a loop until the user chooses to exit.\n\nAfter each operation, ask if they want to perform another operation.\n\nI can use a do-while loop for this.\n\nAlso, I need to include necessary headers and handle namespaces.\n\nNow, let's think about compiling and testing the program.\n\nI need to make sure that all classes and functions are properly defined and implemented.\n\nI should compile the program and test each feature step by step.\n\nStart by creating customers, opening accounts, depositing and withdrawing money, checking balances, listing accounts, and viewing transaction histories.\n\nI need to ensure that account numbers are unique and that transactions are recorded correctly with timestamps.\n\nI should also check for edge cases, like withdrawing more money than the balance, depositing negative amounts, etc.\n\nAdditionally, I need to make sure that the program doesn't crash due to invalid inputs.\n\nNow, I'll proceed to write the actual code based on this plan.\n\n## Final Solution\nTo solve this problem, we need to create a simple bank account management system using C++ that utilizes classes and objects to represent customers, accounts, and transactions. Customers should be able to open accounts, deposit and withdraw money, and check their balance, with all transactions recorded including a timestamp, type, and amount.\n\n### Approach\n1. **Classes and Objects:**\n   - **Transaction:** Records transaction details like timestamp, type (deposit or withdrawal), and amount.\n   - **Account:** Manages account operations like deposit, withdraw, and balance check, along with a transaction history.\n   - **Customer:** Manages customer information and their list of accounts.\n\n2. **Data Structures:**\n   - Use `std::vector` to handle multiple accounts per customer and transaction history per account.\n   - Use `std::map` to store customers with their email as the key for quick access.\n\n3. **Static Variables:**\n   - Use a static variable in the `Account` class to generate unique account numbers.\n\n4. **Input Handling:**\n   - Handle user inputs carefully to manage invalid data and ensure the program's robustness.\n\n### Solution Code\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <map>\n#include <ctime>\n#include <string>\n\nclass Transaction {\npublic:\n    enum Type { DEPOSIT, WITHDRAWAL };\n\n    Transaction(Type type, double amount);\n    std::string getTimestamp() const;\n    Type getType() const;\n    double getAmount() const;\n\nprivate:\n    time_t timestamp;\n    Type type;\n    double amount;\n};\n\nTransaction::Transaction(Type type, double amount) : type(type), amount(amount) {\n    timestamp = time(nullptr);\n}\n\nstd::string Transaction::getTimestamp() const {\n    char buffer[50];\n    struct tm* timeinfo = localtime(&timestamp);\n    strftime(buffer, sizeof(buffer), \"%Y-%m-%d %H:%M:%S\", timeinfo);\n    return buffer;\n}\n\nTransaction::Type Transaction::getType() const {\n    return type;\n}\n\ndouble Transaction::getAmount() const {\n    return amount;\n}\n\nclass Account {\npublic:\n    Account();\n    int getAccountNumber() const;\n    void deposit(double amount);\n    bool withdraw(double amount);\n    double getBalance() const;\n    std::vector<Transaction> getTransactionHistory() const;\n    void printTransactionHistory() const;\n\nprivate:\n    static int lastAccountNumber;\n    int accountNumber;\n    double balance;\n    std::vector<Transaction> transactions;\n};\n\nint Account::lastAccountNumber = 1000;\n\nAccount::Account() : accountNumber(++lastAccountNumber), balance(0.0) {}\n\nint Account::getAccountNumber() const {\n    return accountNumber;\n}\n\nvoid Account::deposit(double amount) {\n    if (amount > 0) {\n        balance += amount;\n        transactions.push_back(Transaction(Transaction::Type::DEPOSIT, amount));\n    } else {\n        std::cout << \"Invalid deposit amount.\" << std::endl;\n    }\n}\n\nbool Account::withdraw(double amount) {\n    if (amount > 0 && amount <= balance) {\n        balance -= amount;\n        transactions.push_back(Transaction(Transaction::Type::WITHDRAWAL, amount));\n        return true;\n    } else {\n        std::cout << \"Withdrawal failed.\" << std::endl;\n        return false;\n    }\n}\n\ndouble Account::getBalance() const {\n    return balance;\n}\n\nstd::vector<Transaction> Account::getTransactionHistory() const {\n    return transactions;\n}\n\nvoid Account::printTransactionHistory() const {\n    for (const Transaction& tx : transactions) {\n        std::cout << tx.getTimestamp() << \" \";\n        if (tx.getType() == Transaction::Type::DEPOSIT) {\n            std::cout << \"Deposit: \";\n        } else {\n            std::cout << \"Withdrawal: \";\n        }\n        std::cout << tx.getAmount() << std::endl;\n    }\n}\n\nclass Customer {\npublic:\n    Customer(std::string firstName, std::string lastName, std::string email);\n    void openAccount();\n    void deposit(int accountNumber, double amount);\n    bool withdraw(int accountNumber, double amount);\n    double checkBalance(int accountNumber) const;\n    void listAccounts() const;\n    void viewTransactionHistory(int accountNumber) const;\n    std::vector<Account> getAccounts() const;\n\nprivate:\n    std::string firstName;\n    std::string lastName;\n    std::string email;\n    std::vector<Account> accounts;\n};\n\nCustomer::Customer(std::string firstName, std::string lastName, std::string email)\n    : firstName(firstName), lastName(lastName), email(email) {}\n\nvoid Customer::openAccount() {\n    Account newAccount;\n    accounts.push_back(newAccount);\n    std::cout << \"Account opened with account number: \" << newAccount.getAccountNumber() << std::endl;\n}\n\nvoid Customer::deposit(int accountNumber, double amount) {\n    for (Account& acc : accounts) {\n        if (acc.getAccountNumber() == accountNumber) {\n            acc.deposit(amount);\n            std::cout << \"Deposit successful.\" << std::endl;\n            return;\n        }\n    }\n    std::cout << \"Account not found.\" << std::endl;\n}\n\nbool Customer::withdraw(int accountNumber, double amount) {\n    for (Account& acc : accounts) {\n        if (acc.getAccountNumber() == accountNumber) {\n            return acc.withdraw(amount);\n        }\n    }\n    std::cout << \"Account not found.\" << std::endl;\n    return false;\n}\n\ndouble Customer::checkBalance(int accountNumber) const {\n    for (const Account& acc : accounts) {\n        if (acc.getAccountNumber() == accountNumber) {\n            return acc.getBalance();\n        }\n    }\n    return -1.0; // Account not found\n}\n\nvoid Customer::listAccounts() const {\n    std::cout << \"Accounts:\" << std::endl;\n    for (const Account& acc : accounts) {\n        std::cout << \"Account Number: \" << acc.getAccountNumber() << \", Balance: \" << acc.getBalance() << std::endl;\n    }\n}\n\nvoid Customer::viewTransactionHistory(int accountNumber) const {\n    for (const Account& acc : accounts) {\n        if (acc.getAccountNumber() == accountNumber) {\n            acc.printTransactionHistory();\n            return;\n        }\n    }\n    std::cout << \"Account not found.\" << std::endl;\n}\n\nstd::vector<Account> Customer::getAccounts() const {\n    return accounts;\n}\n\nvoid displayMenu() {\n    std::cout << \"\\nBank Account Management System\" << std::endl;\n    std::cout << \"1. Create Customer\" << std::endl;\n    std::cout << \"2. Open Account\" << std::endl;\n    std::cout << \"3. Deposit\" << std::endl;\n    std::cout << \"4. Withdraw\" << std::endl;\n    std::cout << \"5. Check Balance\" << std::endl;\n    std::cout << \"6. List Accounts\" << std::endl;\n    std::cout << \"7. View Transaction History\" << std::endl;\n    std::cout << \"8. Exit\" << std::endl;\n}\n\nvoid createCustomer(std::map<std::string, Customer>& customers) {\n    std::string firstName, lastName, email;\n\n    std::cout << \"Enter first name: \";\n    std::cin.ignore();\n    std::getline(std::cin, firstName);\n\n    std::cout << \"Enter last name: \";\n    std::getline(std::cin, lastName);\n\n    std::cout << \"Enter email: \";\n    std::getline(std::cin, email);\n\n    if (customers.find(email) != customers.end()) {\n        std::cout << \"Customer with this email already exists.\" << std::endl;\n    } else {\n        Customer newCustomer(firstName, lastName, email);\n        customers[email] = newCustomer;\n        std::cout << \"Customer created successfully.\" << std::endl;\n    }\n}\n\nvoid openAccount(std::map<std::string, Customer>& customers) {\n    std::string email;\n\n    std::cout << \"Enter customer's email: \";\n    std::getline(std::cin, email);\n\n    auto it = customers.find(email);\n    if (it != customers.end()) {\n        it->second.openAccount();\n    } else {\n        std::cout << \"Customer not found.\" << std::endl;\n    }\n}\n\nvoid deposit(std::map<std::string, Customer>& customers) {\n    std::string email;\n    int accountNumber;\n    double amount;\n\n    std::cout << \"Enter customer's email: \";\n    std::getline(std::cin, email);\n\n    auto it = customers.find(email);\n    if (it != customers.end()) {\n        std::cout << \"Enter account number: \";\n        std::cin >> accountNumber;\n        std::cin.ignore(); // Consume newline character\n\n        std::cout << \"Enter amount to deposit: \";\n        std::cin >> amount;\n        std::cin.ignore(); // Consume newline character\n\n        it->second.deposit(accountNumber, amount);\n    } else {\n        std::cout << \"Customer not found.\" << std::endl;\n    }\n}\n\nvoid withdraw(std::map<std::string, Customer>& customers) {\n    std::string email;\n    int accountNumber;\n    double amount;\n\n    std::cout << \"Enter customer's email: \";\n    std::getline(std::cin, email);\n\n    auto it = customers.find(email);\n    if (it != customers.end()) {\n        std::cout << \"Enter account number: \";\n        std::cin >> accountNumber;\n        std::cin.ignore(); // Consume newline character\n\n        std::cout << \"Enter amount to withdraw: \";\n        std::cin >> amount;\n        std::cin.ignore(); // Consume newline character\n\n        it->second.withdraw(accountNumber, amount);\n    } else {\n        std::cout << \"Customer not found.\" << std::endl;\n    }\n}\n\nvoid checkBalance(std::map<std::string, Customer>& customers) {\n    std::string email;\n    int accountNumber;\n\n    std::cout << \"Enter customer's email: \";\n    std::getline(std::cin, email);\n\n    auto it = customers.find(email);\n    if (it != customers.end()) {\n        std::cout << \"Enter account number: \";\n        std::cin >> accountNumber;\n        std::cin.ignore(); // Consume newline character\n\n        double balance = it->second.checkBalance(accountNumber);\n        if (balance >= 0) {\n            std::cout << \"Balance: \" << balance << std::endl;\n        } else {\n            std::cout << \"Account not found.\" << std::endl;\n        }\n    } else {\n        std::cout << \"Customer not found.\" << std::endl;\n    }\n}\n\nvoid listAccounts(const std::map<std::string, Customer>& customers) {\n    std::string email;\n\n    std::cout << \"Enter customer's email: \";\n    std::getline(std::cin, email);\n\n    auto it = customers.find(email);\n    if (it != customers.end()) {\n        it->second.listAccounts();\n    } else {\n        std::cout << \"Customer not found.\" << std::endl;\n    }\n}\n\nvoid viewTransactionHistory(const std::map<std::string, Customer>& customers) {\n    std::string email;\n    int accountNumber;\n\n    std::cout << \"Enter customer's email: \";\n    std::getline(std::cin, email);\n\n    auto it = customers.find(email);\n    if (it != customers.end()) {\n        std::cout << \"Enter account number: \";\n        std::cin >> accountNumber;\n        std::cin.ignore(); // Consume newline character\n\n        it->second.viewTransactionHistory(accountNumber);\n    } else {\n        std::cout << \"Customer not found.\" << std::endl;\n    }\n}\n\nint main() {\n    std::map<std::string, Customer> customers;\n\n    char choice;\n    do {\n        displayMenu();\n        std::cout << \"Enter your choice: \";\n        std::cin >> choice;\n        std::cin.ignore(); // Consume newline character\n\n        switch (choice) {\n            case '1':\n                createCustomer(customers);\n                break;\n            case '2':\n                openAccount(customers);\n                break;\n            case '3':\n                deposit(customers);\n                break;\n            case '4':\n                withdraw(customers);\n                break;\n            case '5':\n                checkBalance(customers);\n                break;\n            case '6':\n                listAccounts(customers);\n                break;\n            case '7':\n                viewTransactionHistory(customers);\n                break;\n            case '8':\n                std::cout << \"Exiting...\" << std::endl;\n                break;\n            default:\n                std::cout << \"Invalid choice. Please try again.\" << std::endl;\n        }\n\n    } while (choice != '8');\n\n    return 0;\n}\n```\n\n### Explanation\n- **Transaction Class:** Manages transaction details with methods to retrieve timestamp, type, and amount.\n- **Account Class:** Handles account operations including deposit, withdraw, and balance check, along with maintaining a transaction history.\n- **Customer Class:** Manages customer information and their accounts, allowing account opening, depositing, withdrawing, and balance checking.\n- **Main Function:** Implements a menu-driven interface for user interactions, allowing creation of customers, managing accounts, and performing transactions. It uses a map to store customers and ensures unique account numbers through a static variable in the Account class."
    }
]