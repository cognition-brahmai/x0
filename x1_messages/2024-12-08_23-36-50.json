[
    {
        "role": "user",
        "content": "Write a Python program to implement the Bubble Sort algorithm for sorting an array of integers."
    },
    {
        "role": "assistant",
        "content": "Sure! Bubble sort is a simple sorting algorithm that repeatedly steps through the list, compares adjacent elements and swaps them if they are in the wrong order. The pass through the list is repeated until the list is sorted.\n\nHere's a Python implementation of the Bubble Sort algorithm:\n\n```python\ndef bubble_sort(arr):\n    n = len(arr)\n    \n    # Traverse through all array elements\n    for i in range(n):\n        # Last i elements are already in place\n        for j in range(0, n - i - 1):\n            # Traverse the array from 0 to n-i-1\n            # Swap if the element found is greater than the next element\n            if arr[j] > arr[j + 1]:\n                arr[j], arr[j + 1] = arr[j + 1], arr[j]\n\n# Example usage:\narr = [64, 34, 25, 12, 22, 11, 90]\nprint(\"Original array is:\", arr)\n\nbubble_sort(arr)\nprint(\"Sorted array is:\", arr)\n```\n\nIn this code:\n\n- The outer loop runs `n` times where `n` is the length of the array. This is because, in the worst case, we might need to make `n` passes to ensure the array is sorted.\n\n- The inner loop runs from the start of the array to `n - i - 1`. This is because after each pass of the outer loop, the largest element is bubbled to the end of the array, so we don't need to consider it again in the next passes.\n\n- If during a pass through the array, no swaps are made, it means the array is already sorted, and we can stop early. However, in this basic implementation, we don't check for this optimization.\n\nBubble sort has a worst-case and average time complexity of O(n\u00b2), where n is the number of items being sorted. This makes it inefficient on large lists, and generally, it is used for educational purposes or for small datasets.\n\nIf you have any questions or need further explanations, feel free to ask!"
    }
]