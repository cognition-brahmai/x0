[
    {
        "role": "user",
        "content": "Create a C++ implementation of a hash table with separate chaining for collision resolution, supporting basic operations like insert, delete, and search."
    },
    {
        "role": "assistant",
        "content": "Implementing a hash table with separate chaining in C++ involves several steps. We'll create a class that handles the hashing mechanism, collision resolution using linked lists, and the basic operations: insert, delete, and search.\n\n### Step 1: Understanding Hash Tables and Separate Chaining\n\nA hash table is a data structure that implements an associative array abstract data type, a structure that can map keys to values. It uses a hash function to compute an index into an array of buckets or slots, from which the desired value can be found.\n\n**Separate Chaining** is a method for handling collisions: instead of storing single elements in buckets, we store linked lists of elements that hash to the same index.\n\n### Step 2: Designing the Hash Table Class\n\nWe'll design a class named `HashTable` that will handle the operations. The class will contain:\n\n- An array of linked lists to handle collisions.\n- A hash function to compute the index.\n- Methods to insert, delete, and search for elements.\n\n### Step 3: Implementing the Hash Function\n\nFor simplicity, we'll use the modulo operator with the size of the array as the hash function. This will distribute the keys uniformly across the array.\n\n### Step 4: Implementing Separate Chaining\n\nEach bucket in the array will be a linked list. We'll use the standard library's `list` container for this purpose.\n\n### Step 5: Implementing Insert, Delete, and Search Operations\n\n- **Insert**: Compute the hash index and insert the element into the linked list at that index.\n- **Delete**: Compute the hash index and remove the element from the linked list at that index.\n- **Search**: Compute the hash index and search for the element in the linked list at that index.\n\n### Step 6: Writing the Code\n\nHere's the complete implementation:\n\n```cpp\n#include <iostream>\n#include <list>\n#include <string>\n\nclass HashTable {\nprivate:\n    static const int TABLE_SIZE = 10;\n    std::list<std::string> table[TABLE_SIZE];\n\n    int hash(const std::string& key) {\n        int hash = 0;\n        for (char c : key) {\n            hash += c;\n        }\n        return hash % TABLE_SIZE;\n    }\n\npublic:\n    void insert(const std::string& key) {\n        int index = hash(key);\n        table[index].push_back(key);\n    }\n\n    void remove(const std::string& key) {\n        int index = hash(key);\n        for (auto it = table[index].begin(); it != table[index].end(); ++it) {\n            if (*it == key) {\n                table[index].erase(it);\n                return;\n            }\n        }\n    }\n\n    bool search(const std::string& key) {\n        int index = hash(key);\n        for (const auto& k : table[index]) {\n            if (k == key) {\n                return true;\n            }\n        }\n        return false;\n    }\n};\n\nint main() {\n    HashTable ht;\n    ht.insert(\"apple\");\n    ht.insert(\"banana\");\n    ht.insert(\"cherry\");\n\n    std::cout << \"Search apple: \" << (ht.search(\"apple\") ? \"Found\" : \"Not Found\") << std::endl;\n    std::cout << \"Search banana: \" << (ht.search(\"banana\") ? \"Found\" : \"Not Found\") << std::endl;\n    std::cout << \"Search dragonfruit: \" << (ht.search(\"dragonfruit\") ? \"Found\" : \"Not Found\") << std::endl;\n\n    ht.remove(\"banana\");\n    std::cout << \"Search banana after removal: \" << (ht.search(\"banana\") ? \"Found\" : \"Not Found\") << std::endl;\n\n    return 0;\n}\n```\n\n### Explanation\n\n1. **Hash Function**: Sums the ASCII values of the characters in the string and takes the modulo with the table size.\n2. **Insert Operation**: Computes the hash index and appends the key to the linked list at that index.\n3. **Delete Operation**: Computes the hash index and removes the key from the linked list at that index if it exists.\n4. **Search Operation**: Computes the hash index and checks if the key exists in the linked list at that index.\n\nThis implementation provides a basic understanding of how hash tables with separate chaining work. For production code, consider using more sophisticated hash functions and dynamic resizing to handle larger datasets efficiently."
    }
]