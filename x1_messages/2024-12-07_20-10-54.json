[
    {
        "role": "user",
        "content": "Create a Golang program that implements a simple REST API for managing a list of tasks. The API should support the following operations: create, read, update, and delete tasks. Include the following requirements:\n    - Use an in-memory data structure to store tasks.\n    - Implement proper error handling and status codes.\n    - Allow filtering tasks by status (completed or pending).\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Alright, I've got this task to create a simple REST API for managing tasks in Golang. I need to implement the basic CRUD operations: Create, Read, Update, and Delete. And everything should be stored in memory, so no databases involved. Also, I need to handle errors properly and use the correct HTTP status codes. Additionally, there should be a way to filter tasks by their status, whether they're completed or pending.\n\nFirst, I need to set up a basic Golang project structure. I'll create a new directory for my project, say, \"task-api\", and inside it, I'll have a main.go file where I'll write my code.\n\nSince I'm building a REST API, I'll need to use net/http package for handling HTTP requests. But to make things easier, I'll use a popular gorilla/mux router for handling routes, as it's more flexible than the standard library's router.\n\nSo, first things first, I need to install the gorilla/mux package. I can do this using go get:\n\n```\ngo get -u github.com/gorilla/mux\n```\n\nNow, I need to think about how to structure my task data. Each task should have at least an ID, a description, and a status (completed or pending). Since I'm storing everything in memory, I'll use a slice of structs to hold the tasks.\n\nLet me define a Task struct:\n\n```go\ntype Task struct {\n    ID          string  `json:\"id\"`\n    Description string  `json:\"description\"`\n    Completed   bool    `json:\"completed\"`\n}\n```\n\nI'll need a global slice to hold all the tasks:\n\n```go\nvar tasks []Task\n```\n\nBut using a global slice might not be the best approach, especially if I want to add more features later. Maybe I should create a simple in-memory store with functions to handle CRUD operations.\n\nLet's define a TasksStore struct:\n\n```go\ntype TasksStore struct {\n    tasks []Task\n}\n```\n\nAnd then create methods for Create, Read, Update, and Delete operations.\n\nBut for now, to keep it simple, I'll use the global slice.\n\nNext, I need to set up the router and define the endpoints.\n\nFor CRUD operations, the standard REST endpoints are:\n\n- POST /tasks: Create a new task\n\n- GET /tasks: Get all tasks\n\n- GET /tasks/{id}: Get a specific task by ID\n\n- PUT /tasks/{id}: Update a task by ID\n\n- DELETE /tasks/{id}: Delete a task by ID\n\nAdditionally, I need to filter tasks by status. So, I can add a query parameter to the GET /tasks endpoint, like ?status=completed or ?status=pending.\n\nLet me start by setting up the router.\n\nFirst, import the necessary packages:\n\n```go\npackage main\n\nimport (\n    \"encoding/json\"\n    \"log\"\n    \"net/http\"\n\n    \"github.com/gorilla/mux\"\n)\n```\n\nThen, define the main function to set up the router and start the server:\n\n```go\nfunc main() {\n    router := mux.NewRouter()\n    // Define routes here\n    log.Fatal(http.ListenAndServe(\":8080\", router))\n}\n```\n\nNow, I need to define the handler functions for each endpoint.\n\nStarting with creating a new task (POST /tasks).\n\nI need to read the request body, which should contain the task description and status. Since status is optional, I can set a default value, say false for pending.\n\nLet me define the handler:\n\n```go\nfunc createTask(w http.ResponseWriter, r *http.Request) {\n    var newTask Task\n    err := json.NewDecoder(r.Body).Decode(&newTask)\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusBadRequest)\n        return\n    }\n    // Generate a unique ID for the task\n    newTask.ID = generateID()\n    tasks = append(tasks, newTask)\n    w.Header().Set(\"Content-Type\", \"application/json\")\n    json.NewEncoder(w).Encode(newTask)\n}\n```\n\nI need to implement a generateID function to create unique IDs for tasks. For simplicity, I'll use a counter.\n\nDefine a counter:\n\n```go\nvar idCounter int\n```\n\nAnd the generateID function:\n\n```go\nfunc generateID() string {\n    idCounter++\n    return fmt.Sprintf(\"task-%d\", idCounter)\n}\n```\n\nDon't forget to import fmt:\n\n```go\nimport \"fmt\"\n```\n\nNow, set up the route for creating a task:\n\n```go\nrouter.HandleFunc(\"/tasks\", createTask).Methods(\"POST\")\n```\n\nNext, getting all tasks (GET /tasks).\n\nI need to return all tasks in the slice, optionally filtered by status.\n\nI can check for a \"status\" query parameter in the request.\n\nDefine the readTasks handler:\n\n```go\nfunc readTasks(w http.ResponseWriter, r *http.Request) {\n    status := r.URL.Query().Get(\"status\")\n    var filteredTasks []Task\n    for _, task := range tasks {\n        if status == \"\" || (status == \"completed\" && task.Completed) || (status == \"pending\" && !task.Completed) {\n            filteredTasks = append(filteredTasks, task)\n        }\n    }\n    w.Header().Set(\"Content-Type\", \"application/json\")\n    json.NewEncoder(w).Encode(filteredTasks)\n}\n```\n\nSet up the route:\n\n```go\nrouter.HandleFunc(\"/tasks\", readTasks).Methods(\"GET\")\n```\n\nNow, getting a specific task by ID (GET /tasks/{id}).\n\nI need to extract the ID from the URL parameters and find the task with that ID.\n\nDefine the getTask handler:\n\n```go\nfunc getTask(w http.ResponseWriter, r *http.Request) {\n    params := mux.Vars(r)\n    taskID := params[\"id\"]\n    for _, task := range tasks {\n        if task.ID == taskID {\n            w.Header().Set(\"Content-Type\", \"application/json\")\n            json.NewEncoder(w).Encode(task)\n            return\n        }\n    }\n    http.NotFound(w, r)\n}\n```\n\nSet up the route:\n\n```go\nrouter.HandleFunc(\"/tasks/{id}\", getTask).Methods(\"GET\")\n```\n\nNext, updating a task by ID (PUT /tasks/{id}).\n\nI need to find the task by ID, update its fields based on the request body, and return the updated task.\n\nDefine the updateTask handler:\n\n```go\nfunc updateTask(w http.ResponseWriter, r *http.Request) {\n    params := mux.Vars(r)\n    taskID := params[\"id\"]\n    var updatedTask Task\n    err := json.NewDecoder(r.Body).Decode(&updatedTask)\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusBadRequest)\n        return\n    }\n    for index, task := range tasks {\n        if task.ID == taskID {\n            tasks[index].Description = updatedTask.Description\n            tasks[index].Completed = updatedTask.Completed\n            w.Header().Set(\"Content-Type\", \"application/json\")\n            json.NewEncoder(w).Encode(tasks[index])\n            return\n        }\n    }\n    http.NotFound(w, r)\n}\n```\n\nSet up the route:\n\n```go\nrouter.HandleFunc(\"/tasks/{id}\", updateTask).Methods(\"PUT\")\n```\n\nFinally, deleting a task by ID (DELETE /tasks/{id}).\n\nFind the task by ID and remove it from the slice.\n\nDefine the deleteTask handler:\n\n```go\nfunc deleteTask(w http.ResponseWriter, r *http.Request) {\n    params := mux.Vars(r)\n    taskID := params[\"id\"]\n    for index, task := range tasks {\n        if task.ID == taskID {\n            tasks = append(tasks[:index], tasks[index+1:]...)\n            w.WriteHeader(http.StatusNoContent)\n            return\n        }\n    }\n    http.NotFound(w, r)\n}\n```\n\nSet up the route:\n\n```go\nrouter.HandleFunc(\"/tasks/{id}\", deleteTask).Methods(\"DELETE\")\n```\n\nAlright, now I need to make sure that the server starts correctly.\n\nIn the main function, set up the router and start the server:\n\n```go\nfunc main() {\n    router := mux.NewRouter()\n    router.HandleFunc(\"/tasks\", createTask).Methods(\"POST\")\n    router.HandleFunc(\"/tasks\", readTasks).Methods(\"GET\")\n    router.HandleFunc(\"/tasks/{id}\", getTask).Methods(\"GET\")\n    router.HandleFunc(\"/tasks/{id}\", updateTask).Methods(\"PUT\")\n    router.HandleFunc(\"/tasks/{id}\", deleteTask).Methods(\"DELETE\")\n    log.Fatal(http.ListenAndServe(\":8080\", router))\n}\n```\n\nAlso, don't forget to initialize the tasks slice and the idCounter.\n\nDefine them outside of any functions:\n\n```go\nvar tasks []Task\nvar idCounter int\n```\n\nLet me also add some initial tasks for testing purposes.\n\nIn the main function, add some tasks:\n\n```go\nfunc main() {\n    tasks = append(tasks, Task{ID: generateID(), Description: \"Buy milk\", Completed: false})\n    tasks = append(tasks, Task{ID: generateID(), Description: \"Read a book\", Completed: true})\n    // Set up router and start server\n}\n```\n\nNow, to test the API, I can use tools like curl or Postman.\n\nFor example, to create a new task:\n\n```sh\ncurl -X POST -H \"Content-Type: application/json\" -d '{\"description\":\"Walk the dog\",\"completed\":false}' http://localhost:8080/tasks\n```\n\nTo get all tasks:\n\n```sh\ncurl http://localhost:8080/tasks\n```\n\nTo get completed tasks:\n\n```sh\ncurl http://localhost:8080/tasks?status=completed\n```\n\nAnd so on for updating and deleting tasks.\n\nI should also add some error handling, like checking if the request body is empty or if the ID is invalid.\n\nAlso, in the update and delete handlers, I need to make sure that the task exists before trying to update or delete it.\n\nI can improve the delete handler to return a message or a status code indicating success or failure.\n\nSimilarly, in the update handler, I can return the updated task or an appropriate error message.\n\nLet me also think about the status codes:\n\n- Created: 201 (for create)\n\n- OK: 200 (for read)\n\n- No Content: 204 (for delete)\n\n- Bad Request: 400 (for invalid requests)\n\n- Not Found: 404 (for missing resources)\n\nI need to make sure that I'm returning the correct status codes in each case.\n\nIn the createTask handler, after creating the task, I can return 201 Created:\n\n```go\nw.WriteHeader(http.StatusCreated)\njson.NewEncoder(w).Encode(newTask)\n```\n\nIn the readTasks handler, return 200 OK:\n\n```go\nw.WriteHeader(http.StatusOK)\njson.NewEncoder(w).Encode(filteredTasks)\n```\n\nIn the updateTask handler, return 200 OK with the updated task:\n\n```go\nw.WriteHeader(http.StatusOK)\njson.NewEncoder(w).Encode(tasks[index])\n```\n\nIn the deleteTask handler, return 204 No Content:\n\n```go\nw.WriteHeader(http.StatusNoContent)\n```\n\nIf the task is not found in any of these handlers, return 404 Not Found.\n\nAlso, if there are errors decoding the request body, return 400 Bad Request.\n\nI think that covers the basic requirements.\n\nLet me also consider how to handle duplicate IDs. Since I'm generating IDs using a counter, they should be unique. But if I change the generateID function, I need to ensure that IDs remain unique.\n\nAlternatively, I can use UUIDs for task IDs, which are universally unique.\n\nI can use the github.com/google/uuid package to generate UUIDs.\n\nFirst, install the package:\n\n```\ngo get -u github.com/google/uuid\n```\n\nThen, import it:\n\n```go\nimport \"github.com/google/uuid\"\n```\n\nAnd modify the generateID function:\n\n```go\nfunc generateID() string {\n    return uuid.New().String()\n}\n```\n\nThis is a better approach, as it ensures that IDs are truly unique.\n\nLet me make that change.\n\nAlso, I should consider making the TasksStore a proper struct with methods, to encapsulate the task operations and avoid using global variables.\n\nLet's refactor the code to use a TasksStore struct.\n\nDefine the struct:\n\n```go\ntype TasksStore struct {\n    tasks []Task\n}\n```\n\nThen, create a new instance of TasksStore:\n\n```go\nvar store = &TasksStore{\n    tasks: []Task{},\n}\n```\n\nNow, modify the handler functions to use store.tasks instead of the global tasks slice.\n\nFor example, in createTask:\n\n```go\nfunc createTask(w http.ResponseWriter, r *http.Request) {\n    var newTask Task\n    err := json.NewDecoder(r.Body).Decode(&newTask)\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusBadRequest)\n        return\n    }\n    newTask.ID = generateID()\n    store.tasks = append(store.tasks, newTask)\n    w.Header().Set(\"Content-Type\", \"application/json\")\n    json.NewEncoder(w).Encode(newTask)\n}\n```\n\nSimilarly, update the other handlers to use store.tasks.\n\nThis is a better design, as it separates the data store from the handler functions and makes the code more modular.\n\nI can also add initialization of some tasks in the store:\n\n```go\nvar store = &TasksStore{\n    tasks: []Task{\n        {ID: generateID(), Description: \"Buy milk\", Completed: false},\n        {ID: generateID(), Description: \"Read a book\", Completed: true},\n    },\n}\n```\n\nNow, in the main function, set up the router without initializing tasks globally.\n\nJust make sure that the store is initialized before starting the server.\n\nAlso, I should think about concurrency. Since this is an in-memory store and we're not using any synchronization primitives, this API isn't safe for concurrent access. In a real-world scenario, I'd need to use locks or other concurrency mechanisms to protect the tasks slice from simultaneous modifications.\n\nBut for this simple example, I'll overlook concurrency issues.\n\nAnother thing is that the ID generation uses a counter or UUID, but with UUIDs, it's less likely to have conflicts.\n\nI should also validate the request payloads to make sure that the required fields are present. For example, in creating a task, the description is mandatory, while completed is optional.\n\nIn the createTask handler, I can check if the description is empty and return a bad request if it is.\n\nSimilarly, in the updateTask handler, I can check if the description is provided and only update the fields that are present in the request.\n\nBut for simplicity, I'll assume that the request bodies are well-formed.\n\nLet me also think about how to return errors in a standardized way.\n\nI can create a custom error response struct:\n\n```go\ntype ErrorResponse struct {\n    Error string `json:\"error\"`\n}\n```\n\nAnd use it in the handler functions when an error occurs.\n\nFor example, in the createTask handler:\n\n```go\nfunc createTask(w http.ResponseWriter, r *http.Request) {\n    var newTask Task\n    err := json.NewDecoder(r.Body).Decode(&newTask)\n    if err != nil {\n        w.Header().Set(\"Content-Type\", \"application/json\")\n        w.WriteHeader(http.StatusBadRequest)\n        json.NewEncoder(w).Encode(ErrorResponse{Error: \"Bad request\"})\n        return\n    }\n    if newTask.Description == \"\" {\n        w.Header().Set(\"Content-Type\", \"application/json\")\n        w.WriteHeader(http.StatusBadRequest)\n        json.NewEncoder(w).Encode(ErrorResponse{Error: \"Description is required\"})\n        return\n    }\n    newTask.ID = generateID()\n    store.tasks = append(store.tasks, newTask)\n    w.Header().Set(\"Content-Type\", \"application/json\")\n    w.WriteHeader(http.StatusCreated)\n    json.NewEncoder(w).Encode(newTask)\n}\n```\n\nSimilarly, in other handlers, I can return ErrorResponse with appropriate error messages and status codes.\n\nThis makes the API responses more consistent and informative.\n\nAlso, in the updateTask handler, I can check if the task exists before trying to update it:\n\n```go\nfunc updateTask(w http.ResponseWriter, r *http.Request) {\n    params := mux.Vars(r)\n    taskID := params[\"id\"]\n    var updatedTask Task\n    err := json.NewDecoder(r.Body).Decode(&updatedTask)\n    if err != nil {\n        w.Header().Set(\"Content-Type\", \"application/json\")\n        w.WriteHeader(http.StatusBadRequest)\n        json.NewEncoder(w).Encode(ErrorResponse{Error: \"Bad request\"})\n        return\n    }\n    for index, task := range store.tasks {\n        if task.ID == taskID {\n            store.tasks[index].Description = updatedTask.Description\n            store.tasks[index].Completed = updatedTask.Completed\n            w.Header().Set(\"Content-Type\", \"application/json\")\n            w.WriteHeader(http.StatusOK)\n            json.NewEncoder(w).Encode(store.tasks[index])\n            return\n        }\n    }\n    w.Header().Set(\"Content-Type\", \"application/json\")\n    w.WriteHeader(http.StatusNotFound)\n    json.NewEncoder(w).Encode(ErrorResponse{Error: \"Task not found\"})\n}\n```\n\nDo the same for the getTask and deleteTask handlers.\n\nThis ensures that all handlers return JSON error responses with appropriate status codes.\n\nLet me also think about how to handle the case when filtering by status. The status query parameter should only accept \"completed\" or \"pending\" values. If an invalid value is provided, I should return an error.\n\nModify the readTasks handler to handle invalid status values:\n\n```go\nfunc readTasks(w http.ResponseWriter, r *http.Request) {\n    status := r.URL.Query().Get(\"status\")\n    var filteredTasks []Task\n    if status == \"\" {\n        filteredTasks = store.tasks\n    } else if status == \"completed\" || status == \"pending\" {\n        for _, task := range store.tasks {\n            if (status == \"completed\" && task.Completed) || (status == \"pending\" && !task.Completed) {\n                filteredTasks = append(filteredTasks, task)\n            }\n        }\n    } else {\n        w.Header().Set(\"Content-Type\", \"application/json\")\n        w.WriteHeader(http.StatusBadRequest)\n        json.NewEncoder(w).Encode(ErrorResponse{Error: \"Invalid status filter\"})\n        return\n    }\n    w.Header().Set(\"Content-Type\", \"application/json\")\n    w.WriteHeader(http.StatusOK)\n    json.NewEncoder(w).Encode(filteredTasks)\n}\n```\n\nThis way, if an invalid status is provided, the API returns a 400 Bad Request with an error message.\n\nI think this covers all the requirements.\n\nTo summarize, I've created a simple REST API in Golang for managing tasks with CRUD operations, in-memory storage using a slice of structs, proper error handling, and status filtering.\n\nThe API uses the gorilla/mux router for handling routes and returns JSON responses with appropriate HTTP status codes.\n\nI've also refactored the code to use a TasksStore struct to encapsulate the task data and operations, making the code more organized and easier to maintain.\n\n## Final Solution\nTo create a simple REST API for managing tasks in Golang, follow these steps:\n\n### Solution Code\n\n```go\npackage main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"log\"\n    \"net/http\"\n\n    \"github.com/google/uuid\"\n    \"github.com/gorilla/mux\"\n)\n\ntype Task struct {\n    ID          string  `json:\"id\"`\n    Description string  `json:\"description\"`\n    Completed   bool    `json:\"completed\"`\n}\n\ntype TasksStore struct {\n    tasks []Task\n}\n\ntype ErrorResponse struct {\n    Error string `json:\"error\"`\n}\n\nvar store = &TasksStore{\n    tasks: []Task{\n        {ID: generateID(), Description: \"Buy milk\", Completed: false},\n        {ID: generateID(), Description: \"Read a book\", Completed: true},\n    },\n}\n\nfunc generateID() string {\n    return uuid.New().String()\n}\n\nfunc createTask(w http.ResponseWriter, r *http.Request) {\n    var newTask Task\n    err := json.NewDecoder(r.Body).Decode(&newTask)\n    if err != nil {\n        w.Header().Set(\"Content-Type\", \"application/json\")\n        w.WriteHeader(http.StatusBadRequest)\n        json.NewEncoder(w).Encode(ErrorResponse{Error: \"Bad request\"})\n        return\n    }\n    if newTask.Description == \"\" {\n        w.Header().Set(\"Content-Type\", \"application/json\")\n        w.WriteHeader(http.StatusBadRequest)\n        json.NewEncoder(w).Encode(ErrorResponse{Error: \"Description is required\"})\n        return\n    }\n    newTask.ID = generateID()\n    store.tasks = append(store.tasks, newTask)\n    w.Header().Set(\"Content-Type\", \"application/json\")\n    w.WriteHeader(http.StatusCreated)\n    json.NewEncoder(w).Encode(newTask)\n}\n\nfunc readTasks(w http.ResponseWriter, r *http.Request) {\n    status := r.URL.Query().Get(\"status\")\n    var filteredTasks []Task\n    if status == \"\" {\n        filteredTasks = store.tasks\n    } else if status == \"completed\" || status == \"pending\" {\n        for _, task := range store.tasks {\n            if (status == \"completed\" && task.Completed) || (status == \"pending\" && !task.Completed) {\n                filteredTasks = append(filteredTasks, task)\n            }\n        }\n    } else {\n        w.Header().Set(\"Content-Type\", \"application/json\")\n        w.WriteHeader(http.StatusBadRequest)\n        json.NewEncoder(w).Encode(ErrorResponse{Error: \"Invalid status filter\"})\n        return\n    }\n    w.Header().Set(\"Content-Type\", \"application/json\")\n    w.WriteHeader(http.StatusOK)\n    json.NewEncoder(w).Encode(filteredTasks)\n}\n\nfunc getTask(w http.ResponseWriter, r *http.Request) {\n    params := mux.Vars(r)\n    taskID := params[\"id\"]\n    for _, task := range store.tasks {\n        if task.ID == taskID {\n            w.Header().Set(\"Content-Type\", \"application/json\")\n            json.NewEncoder(w).Encode(task)\n            return\n        }\n    }\n    w.Header().Set(\"Content-Type\", \"application/json\")\n    w.WriteHeader(http.StatusNotFound)\n    json.NewEncoder(w).Encode(ErrorResponse{Error: \"Task not found\"})\n}\n\nfunc updateTask(w http.ResponseWriter, r *http.Request) {\n    params := mux.Vars(r)\n    taskID := params[\"id\"]\n    var updatedTask Task\n    err := json.NewDecoder(r.Body).Decode(&updatedTask)\n    if err != nil {\n        w.Header().Set(\"Content-Type\", \"application/json\")\n        w.WriteHeader(http.StatusBadRequest)\n        json.NewEncoder(w).Encode(ErrorResponse{Error: \"Bad request\"})\n        return\n    }\n    for index, task := range store.tasks {\n        if task.ID == taskID {\n            store.tasks[index].Description = updatedTask.Description\n            store.tasks[index].Completed = updatedTask.Completed\n            w.Header().Set(\"Content-Type\", \"application/json\")\n            w.WriteHeader(http.StatusOK)\n            json.NewEncoder(w).Encode(store.tasks[index])\n            return\n        }\n    }\n    w.Header().Set(\"Content-Type\", \"application/json\")\n    w.WriteHeader(http.StatusNotFound)\n    json.NewEncoder(w).Encode(ErrorResponse{Error: \"Task not found\"})\n}\n\nfunc deleteTask(w http.ResponseWriter, r *http.Request) {\n    params := mux.Vars(r)\n    taskID := params[\"id\"]\n    for index, task := range store.tasks {\n        if task.ID == taskID {\n            store.tasks = append(store.tasks[:index], store.tasks[index+1:]...)\n            w.WriteHeader(http.StatusNoContent)\n            return\n        }\n    }\n    w.Header().Set(\"Content-Type\", \"application/json\")\n    w.WriteHeader(http.StatusNotFound)\n    json.NewEncoder(w).Encode(ErrorResponse{Error: \"Task not found\"})\n}\n\nfunc main() {\n    router := mux.NewRouter()\n    router.HandleFunc(\"/tasks\", createTask).Methods(\"POST\")\n    router.HandleFunc(\"/tasks\", readTasks).Methods(\"GET\")\n    router.HandleFunc(\"/tasks/{id}\", getTask).Methods(\"GET\")\n    router.HandleFunc(\"/tasks/{id}\", updateTask).Methods(\"PUT\")\n    router.HandleFunc(\"/tasks/{id}\", deleteTask).Methods(\"DELETE\")\n    log.Fatal(http.ListenAndServe(\":8080\", router))\n}\n```\n\n### Explanation\n\n1. **Setup:**\n   - Use `gorilla/mux` for routing.\n   - Define a `Task` struct to represent tasks.\n   - Use a `TasksStore` struct to manage tasks in memory.\n\n2. **Endpoints:**\n   - **POST /tasks:** Create a new task.\n   - **GET /tasks:** Retrieve all tasks, filter by status optionally.\n   - **GET /tasks/{id}:** Get a specific task by ID.\n   - **PUT /tasks/{id}:** Update a task by ID.\n   - **DELETE /tasks/{id}:** Delete a task by ID.\n\n3. **Error Handling:**\n   - Return appropriate HTTP status codes and JSON error messages for bad requests, not found, etc.\n\n4. **UUIDs:**\n   - Use UUIDs for task IDs to ensure uniqueness.\n\n5. **In-Memory Storage:**\n   - Tasks are stored in a slice within a `TasksStore` struct.\n\nThis solution provides a basic, yet functional, REST API for task management with proper error handling and status filtering capabilities."
    }
]