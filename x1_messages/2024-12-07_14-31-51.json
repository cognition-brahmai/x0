[
    {
        "role": "user",
        "content": "Using GoLang, create a RESTful API that interacts with a SQLite database. The API should support CRUD operations (Create, Read, Update, Delete) on a resource of your choice. PLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Alright, I'm going to create a RESTful API using GoLang that interacts with a SQLite database. I'll choose \"Books\" as the resource for this example. So, the API will allow users to perform CRUD operations on books.\n\nFirst, I need to set up the project structure. I'll create a directory called \"bookapi\" and inside it, I'll have the following files:\n\n- main.go: This will contain the main function and route definitions.\n\n- models/book.go: This will define the Book struct and database operations.\n\n- db.go: This will handle the database connection.\n\nI'll use the Gorilla Mux router for handling HTTP requests and the standard database/sql package for interacting with SQLite.\n\nLet's start by setting up the database connection in db.go.\n\n## Final Solution\nTo create a RESTful API in GoLang that interacts with a SQLite database to perform CRUD operations on a \"Book\" resource, follow these steps:\n\n### Project Structure\n```\n/bookapi\n    /models\n        book.go\n    db.go\n    main.go\n```\n\n### db.go\nHandle the database connection.\n\n```go\npackage main\n\nimport (\n    \"database/sql\"\n    \"fmt\"\n    _ \"github.com/mattn/go-sqlite3\"\n)\n\nvar db *sql.DB\n\nfunc initDB() {\n    var err error\n    db, err = sql.Open(\"sqlite3\", \"books.db\")\n    if err != nil {\n        panic(err)\n    }\n    fmt.Println(\"Database connection established\")\n}\n\nfunc closeDB() {\n    db.Close()\n    fmt.Println(\"Database connection closed\")\n}\n```\n\n### models/book.go\nDefine the Book struct and database operations.\n\n```go\npackage models\n\nimport (\n    \"database/sql\"\n    \"fmt\"\n    \"bookapi/db\"\n)\n\ntype Book struct {\n    ID     int    `json:\"id\"`\n    Title  string `json:\"title\"`\n    Author string `json:\"author\"`\n}\n\nvar db *sql.DB\n\nfunc init() {\n    db = db.GetDB()\n}\n\n// Create a new book\nfunc CreateBook(book Book) (Book, error) {\n    stmt, err := db.Prepare(\"INSERT INTO books(title, author) VALUES(?, ?)\")\n    if err != nil {\n        return book, err\n    }\n    res, err := stmt.Exec(book.Title, book.Author)\n    if err != nil {\n        return book, err\n    }\n    id, err := res.LastInsertId()\n    if err != nil {\n        return book, err\n    }\n    book.ID = int(id)\n    return book, nil\n}\n\n// Get all books\nfunc GetBooks() ([]Book, error) {\n    rows, err := db.Query(\"SELECT id, title, author FROM books\")\n    if err != nil {\n        return nil, err\n    }\n    defer rows.Close()\n    var books []Book\n    for rows.Next() {\n        var book Book\n        err := rows.Scan(&book.ID, &book.Title, &book.Author)\n        if err != nil {\n            return nil, err\n        }\n        books = append(books, book)\n    }\n    return books, nil\n}\n\n// Get a single book by ID\nfunc GetBook(id int) (Book, error) {\n    var book Book\n    err := db.QueryRow(\"SELECT id, title, author FROM books WHERE id = ?\", id).Scan(&book.ID, &book.Title, &book.Author)\n    if err != nil {\n        if err == sql.ErrNoRows {\n            return book, fmt.Errorf(\"Book not found\")\n        }\n        return book, err\n    }\n    return book, nil\n}\n\n// Update a book\nfunc UpdateBook(id int, book Book) (Book, error) {\n    stmt, err := db.Prepare(\"UPDATE books SET title = ?, author = ? WHERE id = ?\")\n    if err != nil {\n        return book, err\n    }\n    _, err = stmt.Exec(book.Title, book.Author, id)\n    if err != nil {\n        return book, err\n    }\n    book.ID = id\n    return book, nil\n}\n\n// Delete a book\nfunc DeleteBook(id int) error {\n    stmt, err := db.Prepare(\"DELETE FROM books WHERE id = ?\")\n    if err != nil {\n        return err\n    }\n    _, err = stmt.Exec(id)\n    if err != nil {\n        return err\n    }\n    return nil\n}\n```\n\n### main.go\nDefine the main function and route definitions.\n\n```go\npackage main\n\nimport (\n    \"bookapi/models\"\n    \"encoding/json\"\n    \"fmt\"\n    \"log\"\n    \"net/http\"\n\n    \"github.com/gorilla/mux\"\n)\n\nfunc main() {\n    initDB()\n    defer closeDB()\n\n    router := mux.NewRouter()\n    router.HandleFunc(\"/books\", createBook).Methods(\"POST\")\n    router.HandleFunc(\"/books\", getBooks).Methods(\"GET\")\n    router.HandleFunc(\"/books/{id}\", getBook).Methods(\"GET\")\n    router.HandleFunc(\"/books/{id}\", updateBook).Methods(\"PUT\")\n    router.HandleFunc(\"/books/{id}\", deleteBook).Methods(\"DELETE\")\n\n    log.Fatal(http.ListenAndServe(\":8000\", router))\n}\n\nfunc createBook(w http.ResponseWriter, r *http.Request) {\n    var book models.Book\n    err := json.NewDecoder(r.Body).Decode(&book)\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusBadRequest)\n        return\n    }\n    book, err = models.CreateBook(book)\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n        return\n    }\n    json.NewEncoder(w).Encode(book)\n}\n\nfunc getBooks(w http.ResponseWriter, r *http.Request) {\n    books, err := models.GetBooks()\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n        return\n    }\n    json.NewEncoder(w).Encode(books)\n}\n\nfunc getBook(w http.ResponseWriter, r *http.Request) {\n    params := mux.Vars(r)\n    id, err := strconv.Atoi(params[\"id\"])\n    if err != nil {\n        http.Error(w, \"Invalid ID\", http.StatusBadRequest)\n        return\n    }\n    book, err := models.GetBook(id)\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusNotFound)\n        return\n    }\n    json.NewEncoder(w).Encode(book)\n}\n\nfunc updateBook(w http.ResponseWriter, r *http.Request) {\n    params := mux.Vars(r)\n    id, err := strconv.Atoi(params[\"id\"])\n    if err != nil {\n        http.Error(w, \"Invalid ID\", http.StatusBadRequest)\n        return\n    }\n    var book models.Book\n    err = json.NewDecoder(r.Body).Decode(&book)\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusBadRequest)\n        return\n    }\n    book, err = models.UpdateBook(id, book)\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n        return\n    }\n    json.NewEncoder(w).Encode(book)\n}\n\nfunc deleteBook(w http.ResponseWriter, r *http.Request) {\n    params := mux.Vars(r)\n    id, err := strconv.Atoi(params[\"id\"])\n    if err != nil {\n        http.Error(w, \"Invalid ID\", http.StatusBadRequest)\n        return\n    }\n    err = models.DeleteBook(id)\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n        return\n    }\n    w.WriteHeader(http.StatusNoContent)\n}\n```\n\n### Explanation\n1. **Database Setup**: \n   - `db.go` handles the SQLite database connection using the `sqlite3` driver.\n   \n2. **Models and Operations**:\n   - `models/book.go` defines the `Book` struct and CRUD operations for books.\n   \n3. **API Endpoints**:\n   - `main.go` sets up routes for creating, reading, updating, and deleting books using Gorilla Mux router.\n   \n4. **HTTP Methods**:\n   - `POST /books`: Create a new book.\n   - `GET /books`: Get all books.\n   - `GET /books/{id}`: Get a single book by ID.\n   - `PUT /books/{id}`: Update a book by ID.\n   - `DELETE /books/{id}`: Delete a book by ID.\n   \nThis setup provides a fully functional RESTful API for managing books with SQLite as the backend database."
    }
]