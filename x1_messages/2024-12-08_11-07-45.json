[
    {
        "role": "user",
        "content": "Create a Python script that interacts with the Memcached caching system. The script should support basic operations like setting a key-value pair, getting the value of a key, deleting a key, and incrementing/decrementing the value of a numeric key. The script should also include error handling for cases where the Memcached server is not available or keys are not found.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Alright, I've got this task to create a Python script that interacts with Memcached. I need to implement basic operations like setting a key-value pair, getting a value by key, deleting a key, and also being able to increment or decrement numeric values associated with keys. Plus, I have to handle errors gracefully, especially if the Memcached server isn't available or if a requested key doesn't exist.\n\nFirst things first, I need to make sure I have Memcached installed and running on my machine. I think I have it installed, but I should check. I can do this by typing `memcached -v` in the terminal. If it's installed, it should show me the version and some other information. If not, I'll need to install it. For installation, I can use Homebrew on Mac or apt-get on Ubuntu.\n\nAssuming Memcached is installed, I need to choose a Python client for Memcached. The most popular ones are `pymemcache` and `python-memcached`. I think I'll go with `pymemcache` because it seems to be more actively maintained. I can install it using pip:\n\n```bash\npip install pymemcache\n```\n\nOkay, with the client installed, I can start writing the script. I should probably start by importing the necessary modules. For `pymemcache`, I need to import `Client` from `pymemcache.client.base`.\n\nHere's a rough outline of what the script should do:\n\n1. Connect to the Memcached server.\n\n2. Provide functions for setting, getting, deleting, incrementing, and decrementing key-value pairs.\n\n3. Handle errors like server unavailability or missing keys.\n\nLet me think about how to structure this. Maybe I can create a class that wraps the Memcached client and provides methods for each operation. That way, it's organized and easy to use.\n\nSo, something like:\n\n```python\nfrom pymemcache.client.base import Client\n\nclass MemcachedClient:\n    def __init__(self, server='127.0.0.1', port=11211):\n        self.client = Client((server, port))\n\n    def set(self, key, value):\n        # Set the key to hold the string value forever.\n        self.client.set(key, value)\n\n    def get(self, key):\n        # Retrieve the value of a key.\n        return self.client.get(key)\n\n    def delete(self, key):\n        # Delete the key and its associated value.\n        self.client.delete(key)\n\n    def increment(self, key, delta=1):\n        # Increment the value of a numeric key by delta.\n        self.client.increment(key, delta)\n\n    def decrement(self, key, delta=1):\n        # Decrement the value of a numeric key by delta.\n        self.client.decrement(key, delta)\n```\n\nThat seems straightforward. Now, I need to add error handling. For example, if the Memcached server is not running, connecting to it will fail. I should handle that gracefully, maybe by catching exceptions and printing a user-friendly message.\n\nSimilarly, when getting or deleting a key that doesn't exist, I don't want the script to crash. I should check if the key exists before performing operations on it, or handle the case where the key is not found.\n\nLooking at the `pymemcache` documentation, it seems that most operations return `None` if a key doesn't exist, and raise specific exceptions for other errors. So, I need to catch exceptions like `MemcacheError` for general errors.\n\nLet me update the methods to include try-except blocks.\n\nFor the `set` method, I can catch exceptions that occur during setting the key and inform the user.\n\nSimilarly, for `get`, if the key doesn't exist, returning `None` is fine, but if there's a connection error, I should handle that.\n\nFor `delete`, if the key doesn't exist, it's also fine to just return without doing anything, but again, handle connection errors.\n\nFor `increment` and `decrement`, these operations require that the key exists and holds an integer value. If the key doesn't exist or doesn't hold an integer, `pymemcache` should raise an exception, which I need to catch and handle.\n\nLet me think about how to handle the increment and decrement operations. According to the `pymemcache` documentation, the `increment` and `decrement` methods will return `None` if the key doesn't exist or if the value is not an integer. So, I can check for `None` and inform the user accordingly.\n\nWait, but in the `pymemcache` documentation, it seems that `increment` and `decrement` will raise a `MemcacheClientError` if the value is not an integer. So, I need to catch that exception.\n\nI should also consider that the user might try to set a non-numeric value and then try to increment or decrement it, which would cause an error.\n\nTo make it robust, I should ensure that keys intended for increment or decrement operations hold integer values.\n\nMaybe I should add type checking when setting the keys, to ensure that numeric keys are set with integer values.\n\nBut that might be overkill for this script. Perhaps it's sufficient to inform the user that increment and decrement operations expect keys with integer values.\n\nLet me proceed by implementing the error handling in each method.\n\nStarting with the `set` method:\n\n```python\ndef set(self, key, value):\n    try:\n        self.client.set(key, value)\n        print(f\"Key '{key}' set to '{value}' successfully.\")\n    except MemcacheError as e:\n        print(f\"Error setting key '{key}': {e}\")\n```\n\nFor the `get` method:\n\n```python\ndef get(self, key):\n    try:\n        value = self.client.get(key)\n        if value is not None:\n            print(f\"Key '{key}' has value: {value}\")\n        else:\n            print(f\"Key '{key}' not found.\")\n        return value\n    except MemcacheError as e:\n        print(f\"Error getting key '{key}': {e}\")\n        return None\n```\n\nFor the `delete` method:\n\n```python\ndef delete(self, key):\n    try:\n        success = self.client.delete(key)\n        if success:\n            print(f\"Key '{key}' deleted successfully.\")\n        else:\n            print(f\"Key '{key}' not found.\")\n    except MemcacheError as e:\n        print(f\"Error deleting key '{key}': {e}\")\n```\n\nFor the `increment` method:\n\n```python\ndef increment(self, key, delta=1):\n    try:\n        new_value = self.client.increment(key, delta)\n        if new_value is not None:\n            print(f\"Key '{key}' incremented by {delta} to {new_value}.\")\n        else:\n            print(f\"Key '{key}' not found or not an integer.\")\n    except MemcacheClientError as e:\n        print(f\"Error incrementing key '{key}': {e}\")\n```\n\nSimilarly, for the `decrement` method:\n\n```python\ndef decrement(self, key, delta=1):\n    try:\n        new_value = self.client.decrement(key, delta)\n        if new_value is not None:\n            print(f\"Key '{key}' decremented by {delta} to {new_value}.\")\n        else:\n            print(f\"Key '{key}' not found or not an integer.\")\n    except MemcacheClientError as e:\n        print(f\"Error decrementing key '{key}': {e}\")\n```\n\nI should also handle cases where the Memcached server is not running. Maybe in the `__init__` method, I can attempt to connect to the server and handle connection errors there.\n\nLet me update the `__init__` method:\n\n```python\ndef __init__(self, server='127.0.0.1', port=11211):\n    try:\n        self.client = Client((server, port))\n        # Test connection\n        self.client.stats()\n        print(\"Connected to Memcached server successfully.\")\n    except MemcacheError as e:\n        print(f\"Error connecting to Memcached server: {e}\")\n        self.client = None\n```\n\nThen, in each method, I should check if the client is connected before performing operations.\n\nFor example, in the `set` method:\n\n```python\ndef set(self, key, value):\n    if self.client is None:\n        print(\"Not connected to Memcached server.\")\n        return\n    try:\n        self.client.set(key, value)\n        print(f\"Key '{key}' set to '{value}' successfully.\")\n    except MemcacheError as e:\n        print(f\"Error setting key '{key}': {e}\")\n```\n\nI should do similar checks in all other methods.\n\nAlso, I should consider that Memcached stores values as bytes, so I might need to encode strings when setting them and decode them when getting them.\n\nWait, actually, `pymemcache` can handle serialization and deserialization automatically if I set the `serializer` and `deserializer` arguments when creating the client.\n\nTo make it easier, I can use the `json` serializer provided by `pymemcache`.\n\nFirst, I need to import the serializer:\n\n```python\nfrom pymemcache.serializers.json import JSONSerializer\n```\n\nThen, when creating the client:\n\n```python\nself.client = Client((server, port), serializer=JSONSerializer(), deserializer=JSONSerializer())\n```\n\nThis way, I can set and get values as Python objects, and they will be automatically serialized to JSON when stored in Memcached and deserialized when retrieved.\n\nThis is convenient because it allows me to store not just strings, but also dictionaries, lists, etc.\n\nBut for the purposes of this script, since we're mainly dealing with simple key-value pairs, strings, and numeric values, this should suffice.\n\nLet me update the `__init__` method:\n\n```python\nfrom pymemcache.client.base import Client\nfrom pymemcache.serializers.json import JSONSerializer\n\nclass MemcachedClient:\n    def __init__(self, server='127.0.0.1', port=11211):\n        try:\n            self.client = Client((server, port), serializer=JSONSerializer(), deserializer=JSONSerializer())\n            # Test connection\n            self.client.stats()\n            print(\"Connected to Memcached server successfully.\")\n        except MemcacheError as e:\n            print(f\"Error connecting to Memcached server: {e}\")\n            self.client = None\n```\n\nNow, when setting a key, I can pass a string or a numeric value, and it will be serialized to JSON automatically.\n\nWhen getting a key, it will be deserialized from JSON to the appropriate Python type.\n\nThis should make handling different data types easier.\n\nLet me also consider adding a method to list all keys in the cache, just for convenience.\n\nI recall that Memcached has a `stats items` command that can show the number of items in the cache, but to get all keys, I might need to use a trick, like iterating through the cache and collecting keys.\n\nHowever, Memcached doesn't support listing all keys directly through the API, as it's meant to be a high-performance caching system, not a persistent data store.\n\nBut for testing purposes, I can implement a method that iterates through the cache and collects keys, although this might not be efficient for large caches.\n\nAlternatively, I can inform the user that listing all keys is not supported.\n\nGiven that, I'll skip implementing a method to list all keys and inform the user that Memcached doesn't support this operation directly.\n\nNow, I need to think about how the user will interact with this script. Since it's a script, perhaps I can provide a simple command-line interface where the user can enter commands like \"set key value\", \"get key\", \"delete key\", etc.\n\nThis way, it's interactive, and the user can perform operations sequentially.\n\nI can use a loop that keeps asking for input until the user decides to exit.\n\nI'll need to parse the user's input to determine which operation to perform and extract the necessary parameters.\n\nFor example:\n\n- \"set key value\" -> call set(key, value)\n\n- \"get key\" -> call get(key)\n\n- \"delete key\" -> call delete(key)\n\n- \"increment key delta\" -> call increment(key, delta)\n\n- \"decrement key delta\" -> call decrement(key, delta)\n\n- \"exit\" or \"quit\" -> exit the loop and end the script\n\nI need to handle cases where the user enters incorrect commands or missing parameters.\n\nI should provide some instructions on how to use the script when it starts.\n\nSomething like:\n\n\"Welcome to the Memcached CLI!\n\nAvailable commands:\n\n- set <key> <value>\n\n- get <key>\n\n- delete <key>\n\n- increment <key> [delta]\n\n- decrement <key> [delta]\n\n- exit or quit to end the session\n\n\"\n\nThen, in the loop, I can read the user's input, split it into parts, and determine which operation to perform.\n\nI need to handle cases where the user doesn't provide enough parameters or provides too many.\n\nFor example, for \"set key value\", if the user only types \"set key\", I should inform them that the value is missing.\n\nSimilarly, for \"increment key delta\", if the user only types \"increment key\", I can assume a default delta of 1.\n\nWait, in my earlier method signatures, I set default values for delta in increment and decrement methods, so that should be fine.\n\nI need to make sure that delta is a numeric value.\n\nAlso, keys and values can have spaces in them, so I need to handle that.\n\nWait, no, in this simple CLI, I'm assuming that keys and values don't contain spaces, to keep it simple.\n\nAlternatively, I can require that values be enclosed in quotes if they contain spaces.\n\nBut to keep it straightforward, I'll assume that keys and values don't contain spaces.\n\nSo, in the parsing logic, I can split the input by spaces and expect each part to be a separate token.\n\nLet me sketch a rough outline of the loop:\n\nwhile True:\n\n    user_input = input(\"Enter command: \")\n\n    parts = user_input.split()\n\n    if len(parts) == 0:\n\n        continue  # Ignore empty input\n\n    command = parts[0].lower()\n\n    if command == \"set\":\n\n        if len(parts) != 3:\n\n            print(\"Set command requires key and value.\")\n\n            continue\n\n        key = parts[1]\n\n        value = parts[2]\n\n        mc.set(key, value)\n\n    elif command == \"get\":\n\n        if len(parts) != 2:\n\n            print(\"Get command requires a key.\")\n\n            continue\n\n        key = parts[1]\n\n        mc.get(key)\n\n    elif command == \"delete\":\n\n        if len(parts) != 2:\n\n            print(\"Delete command requires a key.\")\n\n            continue\n\n        key = parts[1]\n\n        mc.delete(key)\n\n    elif command == \"increment\":\n\n        if len(parts) == 2:\n\n            key = parts[1]\n\n            mc.increment(key)\n\n        elif len(parts) == 3:\n\n            key = parts[1]\n\n            try:\n\n                delta = int(parts[2])\n\n                mc.increment(key, delta)\n\n            except ValueError:\n\n                print(\"Delta must be an integer.\")\n\n        else:\n\n            print(\"Increment command requires a key and optional delta.\")\n\n    elif command == \"decrement\":\n\n        if len(parts) == 2:\n\n            key = parts[1]\n\n            mc.decrement(key)\n\n        elif len(parts) == 3:\n\n            key = parts[1]\n\n            try:\n\n                delta = int(parts[2])\n\n                mc.decrement(key, delta)\n\n            except ValueError:\n\n                print(\"Delta must be an integer.\")\n\n        else:\n\n            print(\"Decrement command requires a key and optional delta.\")\n\n    elif command in [\"exit\", \"quit\"]:\n\n        print(\"Goodbye!\")\n\n        break\n\n    else:\n\n        print(\"Invalid command. Type 'help' for available commands.\")\n\nI should also provide a \"help\" command to list available commands and their usage.\n\nLet me add that.\n\nSo, when the user types \"help\", I can print out the list of available commands and how to use them.\n\nHere's an updated version of the loop:\n\nwhile True:\n\n    user_input = input(\"Enter command: \")\n\n    parts = user_input.split()\n\n    if len(parts) == 0:\n\n        continue  # Ignore empty input\n\n    command = parts[0].lower()\n\n    if command == \"set\":\n\n        if len(parts) != 3:\n\n            print(\"Set command requires key and value.\")\n\n            continue\n\n        key = parts[1]\n\n        value = parts[2]\n\n        mc.set(key, value)\n\n    elif command == \"get\":\n\n        if len(parts) != 2:\n\n            print(\"Get command requires a key.\")\n\n            continue\n\n        key = parts[1]\n\n        mc.get(key)\n\n    elif command == \"delete\":\n\n        if len(parts) != 2:\n\n            print(\"Delete command requires a key.\")\n\n            continue\n\n        key = parts[1]\n\n        mc.delete(key)\n\n    elif command == \"increment\":\n\n        if len(parts) == 2:\n\n            key = parts[1]\n\n            mc.increment(key)\n\n        elif len(parts) == 3:\n\n            key = parts[1]\n\n            try:\n\n                delta = int(parts[2])\n\n                mc.increment(key, delta)\n\n            except ValueError:\n\n                print(\"Delta must be an integer.\")\n\n        else:\n\n            print(\"Increment command requires a key and optional delta.\")\n\n    elif command == \"decrement\":\n\n        if len(parts) == 2:\n\n            key = parts[1]\n\n            mc.decrement(key)\n\n        elif len(parts) == 3:\n\n            key = parts[1]\n\n            try:\n\n                delta = int(parts[2])\n\n                mc.decrement(key, delta)\n\n            except ValueError:\n\n                print(\"Delta must be an integer.\")\n\n        else:\n\n            print(\"Decrement command requires a key and optional delta.\")\n\n    elif command in [\"exit\", \"quit\"]:\n\n        print(\"Goodbye!\")\n\n        break\n\n    elif command == \"help\":\n\n        print(\"Available commands:\")\n\n        print(\"- set <key> <value>\")\n\n        print(\"- get <key>\")\n\n        print(\"- delete <key>\")\n\n        print(\"- increment <key> [delta]\")\n\n        print(\"- decrement <key> [delta]\")\n\n        print(\"- exit or quit to end the session\")\n\n    else:\n\n        print(\"Invalid command. Type 'help' for available commands.\")\n\nThis should cover the basic functionality.\n\nNow, I need to make sure that the script can be run as a standalone script.\n\nI can put the MemcachedClient class and the command loop in a single Python file.\n\nI should also handle the case where the Memcached server is not running when the script starts.\n\nIn the `__init__` method, I already have a connection test, so if the server is not running, it will set `self.client = None`, and the operations will be skipped with an error message.\n\nAdditionally, I can add a main block to create an instance of MemcachedClient and start the command loop.\n\nSomething like:\n\nif __name__ == \"__main__\":\n\n    print(\"Welcome to the Memcached CLI!\")\n\n    print(\"Type 'help' for available commands.\")\n\n    mc = MemcachedClient()\n\n    if mc.client is not None:\n\n        while True:\n\n            user_input = input(\"Enter command: \")\n\n            parts = user_input.split()\n\n            if len(parts) == 0:\n\n                continue  # Ignore empty input\n\n            command = parts[0].lower()\n\n            if command == \"set\":\n\n                if len(parts) != 3:\n\n                    print(\"Set command requires key and value.\")\n\n                    continue\n\n                key = parts[1]\n\n                value = parts[2]\n\n                mc.set(key, value)\n\n            elif command == \"get\":\n\n                if len(parts) != 2:\n\n                    print(\"Get command requires a key.\")\n\n                    continue\n\n                key = parts[1]\n\n                mc.get(key)\n\n            elif command == \"delete\":\n\n                if len(parts) != 2:\n\n                    print(\"Delete command requires a key.\")\n\n                    continue\n\n                key = parts[1]\n\n                mc.delete(key)\n\n            elif command == \"increment\":\n\n                if len(parts) == 2:\n\n                    key = parts[1]\n\n                    mc.increment(key)\n\n                elif len(parts) == 3:\n\n                    key = parts[1]\n\n                    try:\n\n                        delta = int(parts[2])\n\n                        mc.increment(key, delta)\n\n                    except ValueError:\n\n                        print(\"Delta must be an integer.\")\n\n                else:\n\n                    print(\"Increment command requires a key and optional delta.\")\n\n            elif command == \"decrement\":\n\n                if len(parts) == 2:\n\n                    key = parts[1]\n\n                    mc.decrement(key)\n\n                elif len(parts) == 3:\n\n                    key = parts[1]\n\n                    try:\n\n                        delta = int(parts[2])\n\n                        mc.decrement(key, delta)\n\n                    except ValueError:\n\n                        print(\"Delta must be an integer.\")\n\n                else:\n\n                    print(\"Decrement command requires a key and optional delta.\")\n\n            elif command in [\"exit\", \"quit\"]:\n\n                print(\"Goodbye!\")\n\n                break\n\n            elif command == \"help\":\n\n                print(\"Available commands:\")\n\n                print(\"- set <key> <value>\")\n\n                print(\"- get <key>\")\n\n                print(\"- delete <key>\")\n\n                print(\"- increment <key> [delta]\")\n\n                print(\"- decrement <key> [delta]\")\n\n                print(\"- exit or quit to end the session\")\n\n            else:\n\n                print(\"Invalid command. Type 'help' for available commands.\")\n\n    else:\n\n        print(\"Could not connect to Memcached server. Exiting.\")\n\nThat should cover it.\n\nI should also consider adding options to specify the Memcached server address and port when running the script, but for simplicity, I'll hardcode them to localhost:11211.\n\nIf I want to make it more flexible, I can add command-line arguments using the `argparse` module, but that might be beyond the scope of this task.\n\nFor now, hardcoding the server address and port should suffice.\n\nLet me think about potential improvements or additional features.\n\n- Logging: Instead of printing messages to the console, I could use the `logging` module to handle logs more effectively.\n\n- Better error handling: Maybe catch specific exceptions and provide more detailed error messages.\n\n- Support for different data types: Since we're using JSON serialization, we can store and retrieve different Python data types, like lists and dictionaries.\n\n- Expiration times: Memcached allows setting expiration times for keys. I could add an option to set expiration times when setting keys.\n\nBut for this basic script, I'll keep it simple and not include these features.\n\nI should also make sure that the script can handle cases where the user tries to increment or decrement a key that doesn't exist or isn't an integer.\n\nIn such cases, `pymemcache` should raise a `MemcacheClientError`, which I'm already catching and printing an error message.\n\nLet me test this logic.\n\nSuppose the user sets a key with a string value, then tries to increment it.\n\nIn this case, `increment` should fail because the value is not an integer.\n\nSimilarly, if the key doesn't exist, `increment` should return `None`, and I have logic to handle that.\n\nI think this should be sufficient.\n\nAnother consideration is that Memcached is in-memory only, so if the server is restarted, all data is lost.\n\nI should maybe inform the user about this, but it's beyond the scope of this script.\n\nI think I've covered all the necessary points.\n\nNow, I'll proceed to write the actual script accordingly.\n\n## Final Solution\nTo create a Python script that interacts with the Memcached caching system, you can follow the steps below. This script will support basic operations such as setting a key-value pair, getting the value of a key, deleting a key, and incrementing/decrementing the value of a numeric key. It also includes error handling for cases where the Memcached server is not available or keys are not found.\n\n### Solution Code\n\n```python\nfrom pymemcache.client.base import Client\nfrom pymemcache.serializers.json import JSONSerializer\nfrom pymemcache.exceptions import MemcacheError, MemcacheClientError\n\nclass MemcachedClient:\n    def __init__(self, server='127.0.0.1', port=11211):\n        try:\n            self.client = Client((server, port), serializer=JSONSerializer(), deserializer=JSONSerializer())\n            # Test connection\n            self.client.stats()\n            print(\"Connected to Memcached server successfully.\")\n        except MemcacheError as e:\n            print(f\"Error connecting to Memcached server: {e}\")\n            self.client = None\n\n    def set(self, key, value):\n        if self.client is None:\n            print(\"Not connected to Memcached server.\")\n            return\n        try:\n            self.client.set(key, value)\n            print(f\"Key '{key}' set to '{value}' successfully.\")\n        except MemcacheError as e:\n            print(f\"Error setting key '{key}': {e}\")\n\n    def get(self, key):\n        if self.client is None:\n            print(\"Not connected to Memcached server.\")\n            return None\n        try:\n            value = self.client.get(key)\n            if value is not None:\n                print(f\"Key '{key}' has value: {value}\")\n            else:\n                print(f\"Key '{key}' not found.\")\n            return value\n        except MemcacheError as e:\n            print(f\"Error getting key '{key}': {e}\")\n            return None\n\n    def delete(self, key):\n        if self.client is None:\n            print(\"Not connected to Memcached server.\")\n            return\n        try:\n            success = self.client.delete(key)\n            if success:\n                print(f\"Key '{key}' deleted successfully.\")\n            else:\n                print(f\"Key '{key}' not found.\")\n        except MemcacheError as e:\n            print(f\"Error deleting key '{key}': {e}\")\n\n    def increment(self, key, delta=1):\n        if self.client is None:\n            print(\"Not connected to Memcached server.\")\n            return\n        try:\n            new_value = self.client.increment(key, delta)\n            if new_value is not None:\n                print(f\"Key '{key}' incremented by {delta} to {new_value}.\")\n            else:\n                print(f\"Key '{key}' not found or not an integer.\")\n        except MemcacheClientError as e:\n            print(f\"Error incrementing key '{key}': {e}\")\n\n    def decrement(self, key, delta=1):\n        if self.client is None:\n            print(\"Not connected to Memcached server.\")\n            return\n        try:\n            new_value = self.client.decrement(key, delta)\n            if new_value is not None:\n                print(f\"Key '{key}' decremented by {delta} to {new_value}.\")\n            else:\n                print(f\"Key '{key}' not found or not an integer.\")\n        except MemcacheClientError as e:\n            print(f\"Error decrementing key '{key}': {e}\")\n\nif __name__ == \"__main__\":\n    print(\"Welcome to the Memcached CLI!\")\n    print(\"Type 'help' for available commands.\")\n    mc = MemcachedClient()\n\n    if mc.client is not None:\n        while True:\n            user_input = input(\"Enter command: \")\n            parts = user_input.split()\n            if len(parts) == 0:\n                continue  # Ignore empty input\n            command = parts[0].lower()\n            if command == \"set\":\n                if len(parts) != 3:\n                    print(\"Set command requires key and value.\")\n                    continue\n                key = parts[1]\n                value = parts[2]\n                mc.set(key, value)\n            elif command == \"get\":\n                if len(parts) != 2:\n                    print(\"Get command requires a key.\")\n                    continue\n                key = parts[1]\n                mc.get(key)\n            elif command == \"delete\":\n                if len(parts) != 2:\n                    print(\"Delete command requires a key.\")\n                    continue\n                key = parts[1]\n                mc.delete(key)\n            elif command == \"increment\":\n                if len(parts) == 2:\n                    key = parts[1]\n                    mc.increment(key)\n                elif len(parts) == 3:\n                    key = parts[1]\n                    try:\n                        delta = int(parts[2])\n                        mc.increment(key, delta)\n                    except ValueError:\n                        print(\"Delta must be an integer.\")\n                else:\n                    print(\"Increment command requires a key and optional delta.\")\n            elif command == \"decrement\":\n                if len(parts) == 2:\n                    key = parts[1]\n                    mc.decrement(key)\n                elif len(parts) == 3:\n                    key = parts[1]\n                    try:\n                        delta = int(parts[2])\n                        mc.decrement(key, delta)\n                    except ValueError:\n                        print(\"Delta must be an integer.\")\n                else:\n                    print(\"Decrement command requires a key and optional delta.\")\n            elif command in [\"exit\", \"quit\"]:\n                print(\"Goodbye!\")\n                break\n            elif command == \"help\":\n                print(\"Available commands:\")\n                print(\"- set <key> <value>\")\n                print(\"- get <key>\")\n                print(\"- delete <key>\")\n                print(\"- increment <key> [delta]\")\n                print(\"- decrement <key> [delta]\")\n                print(\"- exit or quit to end the session\")\n            else:\n                print(\"Invalid command. Type 'help' for available commands.\")\n    else:\n        print(\"Could not connect to Memcached server. Exiting.\")\n```\n\n### Explanation\n\n1. **Class Definition**:\n    - `MemcachedClient` class wraps the Memcached client and provides methods for setting, getting, deleting, incrementing, and decrementing key-value pairs.\n\n2. **Error Handling**:\n    - Connects to the Memcached server and handles connection errors.\n    - Handles cases where the server is unavailable or keys are not found.\n\n3. **Command-Line Interface**:\n    - Provides a simple CLI for user interaction.\n    - Supports commands like `set`, `get`, `delete`, `increment`, `decrement`, `help`, `exit`, and `quit`.\n\n4. **Serialization**:\n    - Uses JSON serialization for storing and retrieving Python objects.\n\nThis script offers a straightforward way to interact with Memcached, making it easy to perform common caching operations directly from the command line."
    }
]