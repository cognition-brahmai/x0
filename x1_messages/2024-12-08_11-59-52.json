[
    {
        "role": "user",
        "content": "Write a Golang program that reads data from a CSV file and inserts it into an SQLite database. The program should also include functionality to query the database and display results based on user input. Additionally, ensure proper error handling and validation of user inputs.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Alright, I've got this task to create a Golang program that handles reading data from a CSV file and inserting it into an SQLite database. Also, I need to add functionality for users to query the database and display results based on their input. Plus, I have to make sure that there's proper error handling and validation of user inputs. Okay, let's break this down step by step.\n\nFirst things first, I need to set up my Go environment and make sure I have the necessary packages. For handling CSV files, Go has a built-in package called \"encoding/csv\" which should suffice. For interacting with SQLite, I'll need to use the \"github.com/mattn/go-sqlite3\" driver. I should make sure that these are installed.\n\nNext, I need to plan out the structure of my program. I think it would be best to have separate functions for reading the CSV, inserting data into the database, and handling user queries. This way, the code is organized and easier to manage.\n\nLet's start with reading the CSV file. I need to consider that the CSV might have headers, so I should read the first line to get the column names and then read the subsequent rows as data. I'll need to handle any encoding issues or malformed lines in the CSV.\n\nOnce I have the data from the CSV, I need to insert it into an SQLite database. I'll need to create a table in the database with columns that match the CSV headers. I should also handle any duplicates or ensure that the data types are correct.\n\nFor the querying part, I need to allow users to input their queries. This could be in the form of SQL statements, but I have to be careful to prevent SQL injection attacks. Maybe I can provide a simple interface where users can select columns to filter or sort by, and the program constructs the SQL query accordingly.\n\nError handling is crucial here. At every step, I need to check for possible errors, such as file not found, database connection failures, invalid data in the CSV, or errors in the SQL queries. I should provide meaningful error messages to the user so they can understand what went wrong.\n\nValidation of user inputs is also important. For example, if the user is expected to enter a number, I need to make sure they don't enter a string. Similarly, for SQL queries, I need to sanitize the input to prevent injection attacks.\n\nLet me think about the flow of the program:\n\n1. The program starts by asking the user for the path to the CSV file.\n\n2. It reads the CSV file and extracts the headers and data.\n\n3. It connects to an SQLite database (creating it if it doesn't exist).\n\n4. It creates a table in the database with columns matching the CSV headers.\n\n5. It inserts the data from the CSV into the table.\n\n6. Then, it enters a loop where the user can input queries to retrieve data from the database.\n\n7. The program executes the query and displays the results.\n\n8. The loop continues until the user decides to exit.\n\nI need to make sure that the program can handle errors at each of these steps. For example, if the CSV file doesn't exist, I should inform the user and ask for another path. If there's an issue with the database connection, I need to catch that error and\u63d0\u793a\u7528\u6237\u3002\n\nFor the querying part, I need to decide how to handle user input. One approach is to allow users to enter raw SQL queries, but this is risky because of SQL injection. A better way might be to provide a menu-based system where users can select options like \"filter by column,\" \"sort by column,\" etc., and the program constructs the SQL query based on their selections.\n\nAlternatively, I could use parameterized queries to safely include user input in SQL statements. This way, even if a user tries to inject malicious SQL, it will be treated as plain text.\n\nI should also consider the performance implications, especially if the CSV file is large. Reading a huge file into memory might not be feasible, so I need to read the file in chunks or use a streaming approach.\n\nAnother thing to think about is data types. CSV files usually store data as strings, but in the database, columns might have different data types like integers, floats, or dates. I need to ensure that the data is correctly converted when inserting into the database.\n\nLet me consider an example. Suppose the CSV has columns: \"ID,\" \"Name,\" \"Age,\" \"Email.\" I need to create a table with these columns, perhaps with \"ID\" as an integer, \"Name\" and \"Email\" as text, and \"Age\" as an integer.\n\nWhen reading the CSV, I need to parse the \"ID\" and \"Age\" columns as integers before inserting them into the database.\n\nI should also handle any missing or invalid data. For example, if a row has an empty \"Age\" field, I need to decide how to handle that\u2014maybe set it to NULL in the database or skip that row.\n\nFor the user query functionality, I could provide options like:\n\n- List all records.\n\n- Filter records by a specific column value.\n\n- Sort records by a column.\n\n- Search for records containing a certain text in a specific column.\n\nEach of these options would correspond to a specific SQL query constructed based on the user's choices.\n\nI need to ensure that the program is user-friendly and provides clear instructions at each step. Error messages should be informative without exposing too much technical detail that might confuse the user.\n\nAlso, I should think about how to handle persistent storage. Since I'm using SQLite, which is file-based, I need to make sure that the database file is saved properly and that the program doesn't overwrite it accidentally.\n\nLet me outline the functions I'll need:\n\n1. `readCSV(filePath string) (headers []string, data [][]string, err error)`\n\n- This function reads the CSV file and returns the headers and data.\n\n2. `createTable(db *sql.DB, tableName string, headers []string) error`\n\n- This function creates a table in the database with columns based on the headers.\n\n3. `insertData(db *sql.DB, tableName string, headers []string, data [][]string) error`\n\n- This function inserts the data into the table.\n\n4. `queryDatabase(db *sql.DB, query string) ([]map[string]interface{}, error)`\n\n- This function executes a query and returns the results as a slice of maps, where each map represents a row.\n\n5. `getUserQuery() (string, error)`\n\n- This function prompts the user for a query and validates it.\n\n6. `main()`\n\n- This is the main function that orchestrates the flow of the program.\n\nI need to handle dependencies. I'll need to import \"database/sql\" for database operations, \"encoding/csv\" for reading CSV files, and \"github.com/mattn/go-sqlite3\" as the SQLite driver.\n\nI should also consider using transactions when inserting data to ensure data integrity.\n\nLet me think about error handling in more detail. For example, when reading the CSV file, if there's an issue with a particular row, I should log an error for that row but continue processing the rest of the file.\n\nSimilarly, when inserting data into the database, if there's a conflict (e.g., duplicate primary key), I should handle that gracefully, perhaps by skipping that row or prompting the user for how to proceed.\n\nFor user queries, I need to make sure that only allowed SQL statements are executed to prevent security issues. Maybe I can restrict the user to SELECT queries only.\n\nAlternatively, I could provide a predefined set of queries that the user can choose from, and they can only select options to filter or sort the data.\n\nThis might be a safer approach. I can create a menu where the user selects an option, inputs the necessary parameters, and the program constructs the SQL query accordingly.\n\nFor example:\n\n1. List all records.\n\n2. Filter records by column.\n\n3. Sort records by column.\n\n4. Search for text in a column.\n\n5. Exit.\n\nFor option 2, \"Filter records by column,\" I can ask the user to select a column, choose an operator (e.g., equal to, greater than), and provide a value.\n\nThen, I can construct the SQL WHERE clause based on their inputs.\n\nThis way, I can avoid directly executing user-input SQL and reduce the risk of injection attacks.\n\nI should also validate the user's inputs for each option. For example, if they choose to filter by a numeric column, I need to make sure they enter a number.\n\nLet me consider how to implement the menu system. I can use a loop that displays the menu and prompts the user for their choice. Based on the choice, it executes the corresponding functionality.\n\nI need to make sure that the program doesn't crash if the user enters invalid inputs and provides clear instructions on how to use the menu.\n\nNow, let's think about the database schema. Since the CSV can have varying headers, I need to create the table dynamically based on the headers.\n\nAssuming that all columns are of type TEXT initially, I can create the table with all columns as TEXT. If needed, I can add constraints or change data types later.\n\nBut ideally, I should detect the data types from the CSV and create columns with appropriate types.\n\nFor example, if a column contains only integers, I can set it as INTEGER in the database. If it contains decimal numbers, set it as REAL, and otherwise as TEXT.\n\nTo do this, I need to analyze the data in each column and determine the most appropriate data type.\n\nThis adds some complexity, but it's better for data integrity.\n\nAlternatively, for simplicity, I can just set all columns as TEXT and let the database handle the storage.\n\nGiven time constraints, I'll opt for setting all columns as TEXT for now, but I can consider adding data type detection in a future enhancement.\n\nMoving on, I need to think about how to map the CSV headers to database column names. SQL column names can't have spaces or special characters, so I need to sanitize the header names.\n\nI can replace spaces with underscores and remove any non-alphanumeric characters except underscores.\n\nFor example, \"User ID\" becomes \"User_ID\", and \"Email Address\" becomes \"Email_Address\".\n\nI need to ensure that the sanitized column names are unique.\n\nIf there are duplicates after sanitization, I can append a suffix like \"_1\", \"_2\", etc., to make them unique.\n\nNow, regarding inserting data into the database, I need to construct an INSERT statement with the appropriate number of placeholders based on the number of columns.\n\nI can use the \"??\" placeholder for SQLite to insert the values.\n\nI should also consider using batch inserts for better performance, especially if there are many rows in the CSV.\n\nAdditionally, I can wrap the insert operations in a transaction to improve efficiency and ensure atomicity.\n\nError handling during inserts is important. If a row fails to insert due to a constraint violation or type mismatch, I should log the error and continue with the other rows.\n\nFor the user query functionality, I need to handle SELECT statements carefully. I can restrict the user to only perform SELECT operations to prevent them from modifying the database accidentally.\n\nI can achieve this by checking the query string and ensuring it starts with \"SELECT\".\n\nMoreover, I can parameterize the queries to prevent SQL injection.\n\nFor example, if the user wants to filter records where a column equals a certain value, I can use a prepared statement like:\n\nstmt, _ := db.Prepare(\"SELECT * FROM table WHERE column = ?\")\n\nrows, _ := stmt.Query(userValue)\n\nThis way, userValue is treated as a parameter and not as part of the SQL code.\n\nI need to make sure that the user can't inject additional SQL by crafting clever inputs.\n\nFor the menu-based system, I can define functions for each option:\n\n- listAllRecords(db *sql.DB, tableName string) error\n\n- filterRecords(db *sql.DB, tableName string, column string, operator string, value string) error\n\n- sortRecords(db *sql.DB, tableName string, column string, order string) error\n\n- searchRecords(db *sql.DB, tableName string, column string, searchTerm string) error\n\nEach of these functions would construct the appropriate SQL query based on the user's inputs and execute it.\n\nI need to validate the user's inputs for column names, operators, sort orders, etc., to ensure they are valid and prevent injection.\n\nFor example, when asking for a column name, I can provide a list of available columns and ask the user to select one from the list.\n\nSimilarly, for operators, I can provide options like \"=\", \">\", \"<\", \"LIKE\", etc., and ask the user to choose one.\n\nThis way, the user can't input arbitrary strings that could be part of an injection attack.\n\nFor the search function, I can allow the user to enter a search term, and then construct a query with \"LIKE\" to search for rows where the specified column contains the search term.\n\nI should also handle wildcards in the search term, perhaps by defaulting to a partial match.\n\nNow, let's consider the main function. It should perform the following steps:\n\n1. Prompt the user for the path to the CSV file.\n\n2. Read the CSV file and extract headers and data.\n\n3. Connect to the SQLite database.\n\n4. Create a table with columns based on the CSV headers.\n\n5. Insert the data from the CSV into the table.\n\n6. Enter a loop where the user can choose query options until they decide to exit.\n\nIn each step, I need to handle potential errors and provide feedback to the user.\n\nI should also consider logging for errors and important events.\n\nFor example, I can print messages like \"Reading CSV file...\", \"Connecting to database...\", \"Inserting data into table...\", etc., to let the user know what's happening.\n\nIf an error occurs, I can print an error message and ask the user if they want to retry or exit.\n\nNow, let's think about how to test this program.\n\nI need to have sample CSV files with different scenarios:\n\n- A simple CSV with headers and a few rows.\n\n- A CSV with missing values.\n\n- A CSV with various data types.\n\n- A CSV with special characters in headers or data.\n\nI should also test the database operations:\n\n- Creating a table.\n\n- Inserting data.\n\n- Executing various SELECT queries.\n\n- Handling errors in queries.\n\nI can write unit tests for each function to ensure they work as expected.\n\nAdditionally, I can perform integration testing by running the program with different CSV files and verifying the database contents.\n\nI should also check for memory leaks and ensure that database connections are properly closed when the program exits.\n\nNow, let's consider some edge cases:\n\n- Empty CSV file.\n\n- CSV file with only headers.\n\n- CSV file with no headers.\n\n- CSV file with duplicate headers.\n\n- Database already exists with the same table.\n\n- Database errors, such as full disk space.\n\n- Invalid user inputs in the menu system.\n\nFor each of these cases, I need to think about how the program should handle them.\n\nFor example, if the CSV file is empty, I can inform the user that no data was found and skip creating the table and inserting data.\n\nIf the CSV has no headers, I can either skip those files or assign default column names like \"Column1,\" \"Column2,\" etc.\n\nIf the database already exists and the table already exists, I need to decide whether to overwrite it or append to it.\n\nTo handle this, I can check if the table exists before creating it, and if it does, either drop it and recreate it or prompt the user for how to proceed.\n\nRegarding database errors, I can catch the specific errors and provide meaningful messages to the user.\n\nFor instance, if there's a disk space issue, I can inform the user to free up space and try again.\n\nFor invalid user inputs in the menu system, I can handle errors like invalid menu choices, missing required inputs, or incorrect data types.\n\nI should provide clear error messages and reprompt the user for valid inputs.\n\nNow, let's think about the user interface.\n\nSince this is a command-line program, I need to design a text-based menu that's easy to navigate.\n\nThe menu should be displayed repeatedly until the user chooses to exit.\n\nEach option should be numbered, and the user can select an option by entering the corresponding number.\n\nAfter performing an action, the program should return to the menu.\n\nI need to make sure that the menu is user-friendly and that the options are clearly labeled.\n\nI should also handle cases where the user enters invalid menu choices, such as typing a letter instead of a number or entering a number outside the range of options.\n\nIn such cases, I can display an error message and prompt the user to enter a valid choice.\n\nFor querying the database, I need to design sub-menus or additional prompts based on the selected option.\n\nFor example, for filtering records, I can first ask the user to select a column to filter by, then choose an operator, and finally enter the value to filter.\n\nI need to ensure that the user can only select from available columns and valid operators for the column's data type.\n\nThis adds some complexity, but it's necessary for preventing errors and ensuring data integrity.\n\nI should also consider performance when executing queries, especially if the database contains a large number of rows.\n\nI can look into indexing certain columns to speed up queries, but that might be an advanced feature for this initial version.\n\nFor now, I'll focus on getting the basic functionality working correctly and efficiently.\n\nNow, let's consider how to handle data type detection in the CSV.\n\nAs I mentioned earlier, I can analyze the data in each column and determine the most appropriate data type.\n\nHere's a rough plan for data type detection:\n\n- Iterate through each column's data.\n\n- Check if all values are integers; if so, set the column as INTEGER.\n\n- If all values are floats, set as REAL.\n\n- If values contain dates in a specific format, set as DATE.\n\n- Otherwise, set as TEXT.\n\nI need to be cautious with this approach because a column might contain mostly integers but have one non-integer value, which would cause insertion errors.\n\nTo handle this, I can set a tolerance level, where if a certain percentage of values are of a particular type, the column is set to that type.\n\nAlternatively, I can set all columns as TEXT to avoid type conflicts and let the database store the values as strings.\n\nGiven time constraints, I'll opt for setting all columns as TEXT for now, but I'll keep in mind the possibility of enhancing this in the future.\n\nNow, let's think about the code structure.\n\nI can organize the code into separate functions for each task, as I outlined earlier.\n\nI'll need to define constants for the menu options and any other configurable parameters.\n\nI should also consider using structs to represent the data if needed, but for simplicity, using slices and maps should suffice.\n\nI need to ensure that the code is well-commented to explain what each section does, especially for error handling and data processing.\n\nAdditionally, I should follow Go's coding conventions, such as using meaningful variable names, keeping functions short and focused, and avoiding deep nesting.\n\nNow, let's start thinking about writing some code.\n\nFirst, I need to set up the database connection.\n\nI can use the \"database/sql\" package along with the \"github.com/mattn/go-sqlite3\" driver.\n\nI need to import these packages:\n\nimport (\n\n\t\"database/sql\"\n\n\t\"encoding/csv\"\n\n\t\"fmt\"\n\n\t\"os\"\n\n\t\"strings\"\n\n\t_ \"github.com/mattn/go-sqlite3\"\n\n)\n\nThen, I can define a function to create the database connection:\n\nfunc createDBConnection(dbName string) (*sql.DB, error) {\n\n\tdb, err := sql.Open(\"sqlite3\", dbName)\n\n\tif err != nil {\n\n\t\treturn nil, err\n\n\t}\n\n\treturn db, nil\n\n}\n\nI should also make sure to close the database connection when the program exits.\n\nNext, I need to read the CSV file.\n\nI can define a function like this:\n\nfunc readCSV(filePath string) (headers []string, data [][]string, err error) {\n\n\tfile, err := os.Open(filePath)\n\n\tif err != nil {\n\n\t\treturn nil, nil, err\n\n\t}\n\n\tdefer file.Close()\n\n\t\n\n\treader := csv.NewReader(file)\n\n\t\n\n\trecords, err := reader.ReadAll()\n\n\tif err != nil {\n\n\t\treturn nil, nil, err\n\n\t}\n\n\t\n\n\tif len(records) == 0 {\n\n\t\treturn nil, nil, fmt.Errorf(\"empty CSV file\")\n\n\t}\n\n\t\n\n\theaders = records[0]\n\n\tdata = records[1:]\n\n\t\n\n\treturn headers, data, nil\n\n}\n\nThis function opens the CSV file, reads all records, and separates the headers from the data.\n\nI need to handle cases where the file doesn't exist or can't be read.\n\nAlso, if the CSV is empty or doesn't have headers, I need to handle those scenarios appropriately.\n\nNext, I need to create a table in the database based on the CSV headers.\n\nI can define a function like this:\n\nfunc createTable(db *sql.DB, tableName string, headers []string) error {\n\n\t// Sanitize table name\n\n\tsanitizedTableName := sanitizeTableName(tableName)\n\n\t// Sanitize column names\n\n\tsanitizedHeaders := make([]string, len(headers))\n\n\tfor i, header := range headers {\n\n\t\tsanitizedHeaders[i] = sanitizeColumnName(header)\n\n\t}\n\n\t// Create table query\n\n\tquery := fmt.Sprintf(\"CREATE TABLE %s (\", sanitizedTableName)\n\n\tfor i, header := range sanitizedHeaders {\n\n\t\tquery += fmt.Sprintf(\"%s TEXT\", header)\n\n\t\tif i < len(sanitizedHeaders)-1 {\n\n\t\t\tquery += \", \"\n\n\t\t}\n\n\t}\n\n\tquery += \");\"\n\n\t// Execute query\n\n\t_, err := db.Exec(query)\n\n\treturn err\n\n}\n\nHere, I'm assuming all columns are of type TEXT. I'll need to define the sanitizeTableName and sanitizeColumnName functions to make sure the table and column names are valid for SQLite.\n\nFor sanitizing table and column names, I can replace spaces with underscores and remove non-alphanumeric characters.\n\nfunc sanitizeTableName(name string) string {\n\n\treturn sanitizeIdentifier(name)\n\n}\n\nfunc sanitizeColumnName(name string) string {\n\n\treturn sanitizeIdentifier(name)\n\n}\n\nfunc sanitizeIdentifier(name string) string {\n\n\treg, _ := regexp.Compile(`\\W+`)\n\n\tsanitized := reg.ReplaceAllString(name, \"_\")\n\n\treturn strings.Trim(sanitized, \"_\")\n\n}\n\nI need to import \"regexp\" for this.\n\nNow, I need to insert the data into the table.\n\nI can define a function like this:\n\nfunc insertData(db *sql.DB, tableName string, headers []string, data [][]string) error {\n\n\tsanitizedTableName := sanitizeTableName(tableName)\n\n\tsanitizedHeaders := make([]string, len(headers))\n\n\tfor i, header := range headers {\n\n\t\tsanitizedHeaders[i] = sanitizeColumnName(header)\n\n\t}\n\n\tcolumns := strings.Join(sanitizedHeaders, \", \")\n\nplaceholders := strings.Repeat(\"?,\", len(headers)-1) + \"?\"\n\nquery := fmt.Sprintf(\"INSERT INTO %s (%s) VALUES (%s)\", sanitizedTableName, columns, placeholders)\n\nstmt, err := db.Prepare(query)\n\nif err != nil {\n\nreturn err\n\n}\n\ndefer stmt.Close()\n\ntx, err := db.Begin()\n\nif err != nil {\n\nreturn err\n\n}\n\nfor _, row := range data {\n\n\t_, err := stmt.Exec(row...)\n\n\tif err != nil {\n\n\t\ttx.Rollback()\n\n\t\treturn err\n\n\t}\n\n}\n\nreturn tx.Commit()\n\n}\n\nThis function prepares an INSERT statement and uses a transaction to insert all rows. This should be efficient and ensure data consistency.\n\nI need to handle any errors that occur during the insert operations and roll back the transaction if necessary.\n\nNow, for the user query functionality, I need to design the menu system.\n\nI can define a menu structure like this:\n\ntype MenuOption struct {\n\n\tText string\n\n\tAction func(db *sql.DB) error\n\n}\n\nvar menuOptions = []MenuOption{\n\n{\n\nText: \"List all records\",\n\nAction: listAllRecords,\n\n},\n\n{\n\nText: \"Filter records by column\",\n\nAction: filterRecords,\n\n},\n\n{\n\nText: \"Sort records by column\",\n\nAction: sortRecords,\n\n},\n\n{\n\nText: \"Search for text in column\",\n\nAction: searchRecords,\n\n},\n\n{\n\nText: \"Exit\",\n\nAction: nil,\n\n},\n\n}\n\nThen, in the main loop, I can display the menu options and prompt the user to select one.\n\nBased on the selection, I can call the corresponding action function.\n\nHere's a rough sketch of the main loop:\n\nfor {\n\nfmt.Println(\"\\nPlease choose an option:\")\n\nfor i, option := range menuOptions {\n\nfmt.Printf(\"%d. %s\\n\", i+1, option.Text)\n\n}\n\nvar choice int\n\nfmt.Print(\"Enter your choice: \")\n\nfmt.Scanln(&choice)\n\nif choice < 1 || choice > len(menuOptions) {\n\nfmt.Println(\"Invalid choice. Please try again.\")\n\ncontinue\n\n}\n\nselectedOption := menuOptions[choice-1]\n\nif selectedOption.Action == nil {\n\nbreak // Exit the loop\n\n}\n\nerr := selectedOption.Action(db)\n\nif err != nil {\n\nfmt.Printf(\"Error: %s\\n\", err)\n\n}\n\n}\n\nEach action function, such as listAllRecords, filterRecords, etc., would handle the specific query logic.\n\nFor example, listAllRecords could be implemented like this:\n\nfunc listAllRecords(db *sql.DB, tableName string) error {\n\n\tsanitizedTableName := sanitizeTableName(tableName)\n\n\tquery := fmt.Sprintf(\"SELECT * FROM %s\", sanitizedTableName)\n\n\trows, err := db.Query(query)\n\n\tif err != nil {\n\n\t\treturn err\n\n\t}\n\n\tdefer rows.Close()\n\n\tcolumns, err := rows.Columns()\n\n\tif err != nil {\n\n\t\treturn err\n\n\t}\n\n\tfor rows.Next() {\n\n\t\tvalues := make([]interface{}, len(columns))\n\n\t\tfor i := range values {\n\n\t\t\tvalues[i] = new(string)\n\n\t\t}\n\n\t\terr := rows.Scan(values...)\n\n\t\tif err != nil {\n\n\t\t\treturn err\n\n\t\t}\n\n\t\tfor i, col := range columns {\n\n\t\t\tval := *(values[i].(*string))\n\n\t\t\tfmt.Printf(\"%s: %s\\n\", col, val)\n\n\t\t}\n\n\t\tfmt.Println()\n\n\t}\n\n\treturn nil\n\n}\n\nThis function executes a SELECT * query and prints all rows.\n\nSimilarly, filterRecords would prompt the user for the column to filter, the operator, and the value, then construct and execute the corresponding query.\n\nI need to ensure that the column exists, the operator is valid, and the value is correctly formatted for the column's data type.\n\nThis requires additional validation and input handling.\n\nFor example:\n\nfunc filterRecords(db *sql.DB, tableName string, headers []string) error {\n\n\tsanitizedTableName := sanitizeTableName(tableName)\n\n\tfmt.Println(\"Available columns:\")\n\n\tfor i, header := range headers {\n\n\t\tfmt.Printf(\"%d. %s\\n\", i+1, header)\n\n\t}\n\n\tvar columnChoice int\n\n\tfmt.Print(\"Select a column to filter by: \")\n\n\tfmt.Scanln(&columnChoice)\n\n\tif columnChoice < 1 || columnChoice > len(headers) {\n\n\t\treturn fmt.Errorf(\"invalid column choice\")\n\n\t}\n\n\tselectedColumn := sanitizeColumnName(headers[columnChoice-1])\n\n\t\n\n\tfmt.Println(\"Available operators:\n\n1. Equal to (=)\n\n2. Not equal to (!=)\n\n3. Greater than (>)\n\n4. Less than (<)\n\n5. Contains (LIKE)\n\n\")\n\n\tvar operatorChoice int\n\n\tfmt.Print(\"Select an operator: \")\n\n\tfmt.Scanln(&operatorChoice)\n\n\tif operatorChoice < 1 || operatorChoice > 5 {\n\n\t\treturn fmt.Errorf(\"invalid operator choice\")\n\n\t}\n\n\toperators := map[int]string{\n\n\t\t1: \"=\",\n\n\t\t2: \"!=\",\n\n\t\t3: \">\",\n\n\t\t4: \"<\",\n\n\t\t5: \"LIKE\",\n\n\t}\n\n\tselectedOperator := operators[operatorChoice]\n\n\t\n\n\tvar value string\n\n\tfmt.Print(\"Enter the value to filter by: \")\n\n\tfmt.Scanln(&value)\n\n\tif selectedOperator == \"LIKE\" {\n\n\t\tvalue = \"%\" + value + \"%\"\n\n\t}\n\n\t\n\n\tquery := fmt.Sprintf(\"SELECT * FROM %s WHERE %s %s ?\", sanitizedTableName, selectedColumn, selectedOperator)\n\n\tstmt, err := db.Prepare(query)\n\n\tif err != nil {\n\n\t\treturn err\n\n\t}\n\n\tdefer stmt.Close()\n\n\t\n\n\trows, err := stmt.Query(value)\n\n\tif err != nil {\n\n\t\treturn err\n\n\t}\n\n\tdefer rows.Close()\n\n\t\n\n\tcolumns, err := rows.Columns()\n\n\tif err != nil {\n\n\t\treturn err\n\n\t}\n\n\tfor rows.Next() {\n\n\t\tvalues := make([]interface{}, len(columns))\n\n\t\tfor i := range values {\n\n\t\t\tvalues[i] = new(string)\n\n\t\t}\n\n\t\terr := rows.Scan(values...)\n\n\t\tif err != nil {\n\n\t\t\treturn err\n\n\t\t}\n\n\t\tfor i, col := range columns {\n\n\t\t\tval := *(values[i].(*string))\n\n\t\t\tfmt.Printf(\"%s: %s\\n\", col, val)\n\n\t\t}\n\n\t\tfmt.Println()\n\n\t}\n\n\treturn nil\n\n}\n\nThis function first lists the available columns, then asks the user to select one, choose an operator, and enter a value.\n\nIt constructs a SELECT query with a WHERE clause using the selected column, operator, and value.\n\nIt uses a prepared statement to prevent SQL injection.\n\nSimilarly, I can implement sortRecords and searchRecords functions.\n\nFor sortRecords, I can ask the user to select a column to sort by and the order (ASC or DESC).\n\nThen, construct the SELECT query with ORDER BY clause.\n\nFor searchRecords, I can ask for a column and a search term, and use the LIKE operator to find rows where the column contains the search term.\n\nI need to handle wildcards in the search term appropriately.\n\nNow, let's think about the main function.\n\nIt should perform the following steps:\n\n1. Prompt the user for the CSV file path.\n\n2. Read the CSV file and extract headers and data.\n\n3. Prompt the user for the database name (or use a default name).\n\n4. Connect to the SQLite database.\n\n5. Create a table with columns based on the CSV headers.\n\n6. Insert the data from the CSV into the table.\n\n7. Enter the menu loop for user queries.\n\nHere's a rough sketch:\n\nfunc main() {\n\n\tvar csvPath string\n\n\tfmt.Print(\"Enter the path to the CSV file: \")\n\n\tfmt.Scanln(&csvPath)\n\n\t\n\n\theaders, data, err := readCSV(csvPath)\n\n\tif err != nil {\n\n\t\tfmt.Printf(\"Error reading CSV: %s\n\n\", err)\n\n\t\treturn\n\n\t}\n\n\t\n\n\tvar dbName string\n\n\tfmt.Print(\"Enter the database name (default: data.db): \")\n\n\tfmt.Scanln(&dbName)\n\n\tif dbName == \"\" {\n\n\t\tdbName = \"data.db\"\n\n\t}\n\n\t\n\n\tdb, err := createDBConnection(dbName)\n\n\tif err != nil {\n\n\t\tfmt.Printf(\"Error connecting to database: %s\n\n\", err)\n\n\t\treturn\n\n\t}\n\n\tdefer db.Close()\n\n\t\n\n\ttableName := \"data_table\" // or use a user-provided name\n\n\terr = createTable(db, tableName, headers)\n\n\tif err != nil {\n\n\t\tfmt.Printf(\"Error creating table: %s\n\n\", err)\n\n\t\treturn\n\n\t}\n\n\t\n\n\terr = insertData(db, tableName, headers, data)\n\n\tif err != nil {\n\n\t\tfmt.Printf(\"Error inserting data: %s\n\n\", err)\n\n\t\treturn\n\n\t}\n\n\t\n\n\t// Enter menu loop\n\n\tmenuOptions := getMenuOptions(db, tableName, headers)\n\n\tfor {\n\n\t\tfmt.Println(\"\\nPlease choose an option:\")\n\n\t\tfor i, option := range menuOptions {\n\n\t\t\tfmt.Printf(\"%d. %s\n\n\", i+1, option.Text)\n\n\t\t}\n\n\t\tvar choice int\n\n\t\tfmt.Print(\"Enter your choice: \")\n\n\t\tfmt.Scanln(&choice)\n\n\t\tif choice < 1 || choice > len(menuOptions) {\n\n\t\t\tfmt.Println(\"Invalid choice. Please try again.\")\n\n\t\t\tcontinue\n\n\t\t}\n\n\t\tselectedOption := menuOptions[choice-1]\n\n\t\tif selectedOption.Action == nil {\n\n\t\t\tbreak // Exit the loop\n\n\t\t}\n\n\t\terr := selectedOption.Action(db, tableName, headers)\n\n\t\tif err != nil {\n\n\t\t\tfmt.Printf(\"Error: %s\n\n\", err)\n\n\t\t}\n\n\t}\n\n}\n\nIn this sketch, I'm assuming that the menu options are defined in a function getMenuOptions, which returns a slice of MenuOption structs, each with a text description and an action function that takes db, tableName, and headers as arguments.\n\nEach action function would perform the corresponding database query and display the results.\n\nI need to make sure that the menu options are properly defined and that the action functions handle errors appropriately.\n\nNow, I need to consider how to handle user inputs in the menu system.\n\nFor example, in filterRecords, I need to ensure that the user selects a valid column and operator, and enters a value that's appropriate for the operator.\n\nI should also handle cases where the user enters empty values or cancels the input.\n\nSimilarly, for sortRecords, I need to ask the user to select a column to sort by and choose the sort order (ascending or descending).\n\nI can provide options like:\n\n1. Ascending\n\n2. Descending\n\nThen, construct the SELECT query with ORDER BY clause accordingly.\n\nFor searchRecords, I can ask the user to select a column and enter a search term.\n\nI can use the LIKE operator to perform a case-insensitive search containing the search term.\n\nI should also consider performance implications if the table is large, as LIKE searches without indexes can be slow.\n\nBut for now, I'll focus on getting the basic functionality working.\n\nNow, let's think about error handling in the menu system.\n\nEach action function should return an error if something goes wrong, and the main loop should catch it and display an error message to the user.\n\nI should also make sure that the program doesn't crash if the user inputs invalid data, but instead provides helpful error messages and allows the user to try again.\n\nAdditionally, I need to handle cases where the database operations fail, such as if the table doesn't exist or if there are issues with the SQL syntax.\n\nI should also consider logging errors for debugging purposes, but for a simple command-line tool, printing to stderr might suffice.\n\nNow, let's consider how to test this program.\n\nI can create sample CSV files with different contents and structures to test various scenarios.\n\nFor example:\n\n- A CSV with headers and multiple rows of data.\n\n- A CSV with headers and no data.\n\n- A CSV with no headers.\n\n- A CSV with special characters in headers or data.\n\n- A CSV with missing values in some rows.\n\nI can also test the database operations by inspecting the database file using an SQLite browser or by running queries directly on the database to verify that the data was inserted correctly.\n\nFor the user query functionality, I can test different query options and verify that the results are as expected.\n\nI should also test error scenarios, such as trying to filter by a non-existent column or entering invalid values for filters.\n\nTo make the program more robust, I can add input validation and provide clear instructions to the user.\n\nFor example, when asking for a column to filter by, I can list the available columns and ask the user to select one by number.\n\nSimilarly, for operators, I can provide a list of options and ask the user to choose one.\n\nThis way, the user can't enter invalid inputs, reducing the chance of errors.\n\nI should also handle cases where the user enters non-numeric values for menu choices or when selecting columns and operators.\n\nIn such cases, I can display an error message and reprompt the user for valid input.\n\nNow, let's think about how to implement the search function.\n\nIn the searchRecords function, I need to ask the user to select a column and enter a search term.\n\nThen, construct a SELECT query with a WHERE clause using the LIKE operator to search for rows where the specified column contains the search term.\n\nI need to make sure that the search is case-insensitive, so I can use the COLLATE NOCASE option in SQLite.\n\nHere's a rough implementation:\n\nfunc searchRecords(db *sql.DB, tableName string, headers []string) error {\n\n\tsanitizedTableName := sanitizeTableName(tableName)\n\n\tfmt.Println(\"Available columns:\")\n\n\tfor i, header := range headers {\n\n\t\tfmt.Printf(\"%d. %s\n\n\", i+1, header)\n\n\t}\n\n\tvar columnChoice int\n\n\tfmt.Print(\"Select a column to search in: \")\n\n\tfmt.Scanln(&columnChoice)\n\n\tif columnChoice < 1 || columnChoice > len(headers) {\n\n\t\treturn fmt.Errorf(\"invalid column choice\")\n\n\t}\n\n\tselectedColumn := sanitizeColumnName(headers[columnChoice-1])\n\n\t\n\n\tvar searchTerm string\n\n\tfmt.Print(\"Enter the search term: \")\n\n\tfmt.Scanln(&searchTerm)\n\n\t\n\n\tquery := fmt.Sprintf(\"SELECT * FROM %s WHERE %s LIKE ? ESCAPE '' COLLATE NOCASE\", sanitizedTableName, selectedColumn)\n\n\tstmt, err := db.Prepare(query)\n\n\tif err != nil {\n\n\t\treturn err\n\n\t}\n\n\tdefer stmt.Close()\n\n\t\n\n\t// Escape any wildcard characters in the search term\n\n\tescapedSearchTerm := strings.ReplaceAll(searchTerm, \"?\", \"\\?\")\n\n\tescapedSearchTerm = strings.ReplaceAll(escapedSearchTerm, \"%\", \"\\%\")\n\n\t// Add wildcards for partial matching\n\n\tlikeTerm := \"%\" + escapedSearchTerm + \"%\"\n\n\t\n\n\trows, err := stmt.Query(likeTerm)\n\n\tif err != nil {\n\n\t\treturn err\n\n\t}\n\n\tdefer rows.Close()\n\n\t\n\n\tcolumns, err := rows.Columns()\n\n\tif err != nil {\n\n\t\treturn err\n\n\t}\n\n\tfor rows.Next() {\n\n\t\tvalues := make([]interface{}, len(columns))\n\n\t\tfor i := range values {\n\n\t\t\tvalues[i] = new(string)\n\n\t\t}\n\n\t\terr := rows.Scan(values...)\n\n\t\tif err != nil {\n\n\t\t\treturn err\n\n\t\t}\n\n\t\tfor i, col := range columns {\n\n\t\t\tval := *(values[i].(*string))\n\n\t\t\tfmt.Printf(\"%s: %s\n\n\", col, val)\n\n\t\t}\n\n\t\tfmt.Println()\n\n\t}\n\n\treturn nil\n\n}\n\nIn this function, I first list the available columns and ask the user to select one.\n\nThen, I ask for the search term and construct a SELECT query with a LIKE clause that performs a case-insensitive search containing the search term.\n\nI also escape any wildcard characters in the search term to prevent them from being interpreted as wildcards in the LIKE expression.\n\nThis should allow users to search for text within a specific column effectively.\n\nNow, let's consider how to handle sorting.\n\nIn the sortRecords function, I need to ask the user to select a column to sort by and choose the sort order (ascending or descending).\n\nThen, construct a SELECT query with an ORDER BY clause accordingly.\n\nHere's a rough implementation:\n\nfunc sortRecords(db *sql.DB, tableName string, headers []string) error {\n\n\tsanitizedTableName := sanitizeTableName(tableName)\n\n\tfmt.Println(\"Available columns:\")\n\n\tfor i, header := range headers {\n\n\t\tfmt.Printf(\"%d. %s\n\n\", i+1, header)\n\n\t}\n\n\tvar columnChoice int\n\n\tfmt.Print(\"Select a column to sort by: \")\n\n\tfmt.Scanln(&columnChoice)\n\n\tif columnChoice < 1 || columnChoice > len(headers) {\n\n\t\treturn fmt.Errorf(\"invalid column choice\")\n\n\t}\n\n\tselectedColumn := sanitizeColumnName(headers[columnChoice-1])\n\n\t\n\n\tfmt.Println(\"Sort order:\n\n1. Ascending (ASC)\n\n2. Descending (DESC)\n\n\")\n\n\tvar orderChoice int\n\n\tfmt.Print(\"Select sort order: \")\n\n\tfmt.Scanln(&orderChoice)\n\n\tif orderChoice != 1 && orderChoice != 2 {\n\n\t\treturn fmt.Errorf(\"invalid sort order choice\")\n\n\t}\n\n\tsortOrder := map[int]string{1: \"ASC\", 2: \"DESC\"}[orderChoice]\n\n\t\n\n\tquery := fmt.Sprintf(\"SELECT * FROM %s ORDER BY %s %s\", sanitizedTableName, selectedColumn, sortOrder)\n\n\trows, err := db.Query(query)\n\n\tif err != nil {\n\n\t\treturn err\n\n\t}\n\n\tdefer rows.Close()\n\n\t\n\n\tcolumns, err := rows.Columns()\n\n\tif err != nil {\n\n\t\treturn err\n\n\t}\n\n\tfor rows.Next() {\n\n\t\tvalues := make([]interface{}, len(columns))\n\n\t\tfor i := range values {\n\n\t\t\tvalues[i] = new(string)\n\n\t\t}\n\n\t\terr := rows.Scan(values...)\n\n\t\tif err != nil {\n\n\t\t\treturn err\n\n\t\t}\n\n\t\tfor i, col := range columns {\n\n\t\t\tval := *(values[i].(*string))\n\n\t\t\tfmt.Printf(\"%s: %s\n\n\", col, val)\n\n\t\t}\n\n\t\tfmt.Println()\n\n\t}\n\n\treturn nil\n\n}\n\nThis function first lists the available columns, asks the user to select one, and then chooses the sort order.\n\nIt constructs a SELECT query with an ORDER BY clause using the selected column and sort order.\n\nThis should allow users to sort the data based on their preferences.\n\nNow, I need to think about how to handle the menu system in a way that's reusable and maintainable.\n\nI can define a struct to hold the menu options, where each option has a description and a function to execute.\n\nI can also pass necessary parameters like db, tableName, and headers to these functions.\n\nHere's an improved structure:\n\ntype MenuOption struct {\n\n\tText    string\n\n\tAction  func(db *sql.DB, tableName string, headers []string) error\n\n}\n\nvar menuOptions = []MenuOption{\n\n{\n\nText: \"List all records\",\n\nAction: listAllRecords,\n\n},\n\n{\n\nText: \"Filter records by column\",\n\nAction: filterRecords,\n\n},\n\n{\n\nText: \"Sort records by column\",\n\nAction: sortRecords,\n\n},\n\n{\n\nText: \"Search for text in column\",\n\nAction: searchRecords,\n\n},\n\n{\n\nText: \"Exit\",\n\nAction: nil,\n\n},\n\n}\n\nThen, in the main loop, I can call the action functions with the appropriate arguments.\n\nThis makes the code cleaner and more organized.\n\nI should also consider extracting common functionality, such as executing queries and printing results, into helper functions to avoid code duplication.\n\nFor example, I can create a function that executes a query and prints the results given the query string and parameters.\n\nThis way, each action function can focus on constructing the query and handling user inputs, while the helper function takes care of executing the query and displaying the results.\n\nThis approach improves code reusability and reduces the chance of errors.\n\nNow, let's think about how to implement this helper function.\n\nHere's a possible implementation:\n\nfunc executeQueryAndPrintResults(db *sql.DB, query string, args ...interface{}) error {\n\n\trows, err := db.Query(query, args...)\n\n\tif err != nil {\n\n\t\treturn err\n\n\t}\n\n\tdefer rows.Close()\n\n\t\n\n\tcolumns, err := rows.Columns()\n\n\tif err != nil {\n\n\t\treturn err\n\n\t}\n\n\tfor rows.Next() {\n\n\t\tvalues := make([]interface{}, len(columns))\n\n\t\tfor i := range values {\n\n\t\t\tvalues[i] = new(string)\n\n\t\t}\n\n\t\terr := rows.Scan(values...)\n\n\t\tif err != nil {\n\n\t\t\treturn err\n\n\t\t}\n\n\t\tfor i, col := range columns {\n\n\t\t\tval := *(values[i].(*string))\n\n\t\t\tfmt.Printf(\"%s: %s\n\n\", col, val)\n\n\t\t}\n\n\t\tfmt.Println()\n\n\t}\n\n\treturn nil\n\n}\n\nThis function takes a query string and optional arguments, executes the query, and prints the results row by row.\n\nEach action function can then call this helper function with the constructed query and parameters.\n\nThis reduces code duplication and makes the action functions cleaner.\n\nFor example, the listAllRecords function can be simplified to:\n\nfunc listAllRecords(db *sql.DB, tableName string) error {\n\n\tsanitizedTableName := sanitizeTableName(tableName)\n\n\tquery := fmt.Sprintf(\"SELECT * FROM %s\", sanitizedTableName)\n\n\treturn executeQueryAndPrintResults(db, query)\n\n}\n\nSimilarly, filterRecords can be rewritten as:\n\nfunc filterRecords(db *sql.DB, tableName string, headers []string) error {\n\n\tsanitizedTableName := sanitizeTableName(tableName)\n\n\tfmt.Println(\"Available columns:\")\n\n\tfor i, header := range headers {\n\n\t\tfmt.Printf(\"%d. %s\n\n\", i+1, header)\n\n\t}\n\n\tvar columnChoice int\n\n\tfmt.Print(\"Select a column to filter by: \")\n\n\tfmt.Scanln(&columnChoice)\n\n\tif columnChoice < 1 || columnChoice > len(headers) {\n\n\t\treturn fmt.Errorf(\"invalid column choice\")\n\n\t}\n\n\tselectedColumn := sanitizeColumnName(headers[columnChoice-1])\n\n\t\n\n\tfmt.Println(\"Available operators:\n\n1. Equal to (=)\n\n2. Not equal to (!=)\n\n3. Greater than (>)\n\n4. Less than (<)\n\n5. Contains (LIKE)\n\n\")\n\n\tvar operatorChoice int\n\n\tfmt.Print(\"Select an operator: \")\n\n\tfmt.Scanln(&operatorChoice)\n\n\tif operatorChoice < 1 || operatorChoice > 5 {\n\n\t\treturn fmt.Errorf(\"invalid operator choice\")\n\n\t}\n\n\toperators := map[int]string{\n\n\t\t1: \"=\",\n\n\t\t2: \"!=\",\n\n\t\t3: \">\",\n\n\t\t4: \"<\",\n\n\t\t5: \"LIKE\",\n\n\t}\n\n\tselectedOperator := operators[operatorChoice]\n\n\t\n\n\tvar value string\n\n\tfmt.Print(\"Enter the value to filter by: \")\n\n\tfmt.Scanln(&value)\n\n\tif selectedOperator == \"LIKE\" {\n\n\t\tvalue = \"%\" + value + \"%\"\n\n\t}\n\n\t\n\n\tquery := fmt.Sprintf(\"SELECT * FROM %s WHERE %s %s ?\", sanitizedTableName, selectedColumn, selectedOperator)\n\n\treturn executeQueryAndPrintResults(db, query, value)\n\n}\n\nThis makes the action functions more concise and easier to maintain.\n\nNow, I need to consider how to handle user inputs in a consistent manner across different action functions.\n\nFor example, selecting a column from a list is a common task in filterRecords, sortRecords, and searchRecords.\n\nI can create a helper function to prompt the user to select a column by number and return the sanitized column name.\n\nHere's an example:\n\nfunc selectColumn(headers []string) (string, error) {\n\n\tfmt.Println(\"Available columns:\")\n\n\tfor i, header := range headers {\n\n\t\tfmt.Printf(\"%d. %s\n\n\", i+1, header)\n\n\t}\n\n\tvar choice int\n\n\tfmt.Print(\"Select a column: \")\n\n\tfmt.Scanln(&choice)\n\n\tif choice < 1 || choice > len(headers) {\n\n\t\treturn \"\", fmt.Errorf(\"invalid column choice\")\n\n\t}\n\n\tselectedHeader := headers[choice-1]\n\n\tsanitizedColumnName := sanitizeColumnName(selectedHeader)\n\n\treturn sanitizedColumnName, nil\n\n}\n\nThis function displays the available columns, prompts the user to select one by number, and returns the sanitized column name.\n\nI can use this function in filterRecords, sortRecords, and searchRecords to select the column to operate on.\n\nSimilarly, I can create helper functions for selecting operators, sort orders, and handling user inputs for values.\n\nThis will make the code more modular and easier to manage.\n\nNow, let's think about how to handle different data types in the columns.\n\nSince I'm setting all columns as TEXT in the database, I need to handle comparisons appropriately in the queries.\n\nFor example, if a column contains numeric data, comparing it as text might not give the expected results.\n\nTo handle this, I can consider casting the column to the appropriate type in the SQL query.\n\nFor example, if a column is supposed to be an integer, I can cast it to INTEGER in the WHERE clause.\n\nBut determining the data type automatically adds complexity, so for now, I'll treat all columns as text.\n\nUsers can still perform text-based comparisons, which should suffice for basic use cases.\n\nIn the future, I can enhance the program to detect data types and handle comparisons accordingly.\n\nNow, let's consider how to handle large CSV files without loading the entire file into memory.\n\nCurrently, the readCSV function reads all records at once using reader.ReadAll().\n\nThis can be problematic for very large CSV files.\n\nTo handle large files, I can read the CSV file row by row using reader.Read() in a loop and insert each row into the database one at a time.\n\nThis approach is more memory-efficient but might be slower for inserting data.\n\nHowever, since SQLite transactions can batch multiple inserts efficiently, I can collect a batch of rows and insert them in a single transaction to balance memory usage and performance.\n\nHere's an outline of how to implement batched inserts:\n\n- Define a batch size, say 1000 rows.\n\n- Read rows from the CSV one by one.\n\n- Collect rows in a slice until the batch size is reached.\n\n- Insert the batch into the database within a transaction.\n\n- Repeat until all rows are processed.\n\nThis way, only a limited number of rows are held in memory at any time, making it feasible to handle large CSV files.\n\nI need to implement this in the readCSV and insertData functions.\n\nFirst, modify readCSV to read rows one by one:\n\nfunc readCSV(filePath string) (headers []string, data <-chan []string, err error) {\n\n\tfile, err := os.Open(filePath)\n\n\tif err != nil {\n\n\t\treturn nil, nil, err\n\n\t}\n\n\tdefer file.Close()\n\n\t\n\n\treader := csv.NewReader(file)\n\n\t\n\n\trecords := make(chan []string)\n\n\tgo func() {\n\n\t\tdefer close(records)\n\n\t\tvar headersRead bool\n\n\t\tfor {\n\n\t\t\trecord, err := reader.Read()\n\n\t\t\tif err == io.EOF {\n\n\t\t\t\tbreak\n\n\t\t\t}\n\n\t\t\tif err != nil {\n\n\t\t\t\tfmt.Printf(\"Error reading CSV: %s\n\n\", err)\n\n\t\t\t\tcontinue\n\n\t\t\t}\n\n\t\t\tif !headersRead {\n\n\t\t\t\theaders = record\n\n\t\t\t\theadersRead = true\n\n\t\t\t\tcontinue\n\n\t\t\t}\n\n\t\t\trecords <- record\n\n\t\t}\n\n\t}()\n\n\treturn headers, records, nil\n\n}\n\nIn this version, readCSV returns a channel of []string for the data rows, allowing the caller to read rows one by one.\n\nThen, modify insertData to accept a channel of rows and perform batched inserts:\n\nfunc insertData(db *sql.DB, tableName string, headers []string, rows <-chan []string) error {\n\n\tsanitizedTableName := sanitizeTableName(tableName)\n\n\tsanitizedHeaders := make([]string, len(headers))\n\n\tfor i, header := range headers {\n\n\t\tsanitizedHeaders[i] = sanitizeColumnName(header)\n\n\t}\n\n\tcolumns := strings.Join(sanitizedHeaders, \", \")\n\nplaceholders := strings.Repeat(\"?,\", len(headers)-1) + \"?\"\n\nquery := fmt.Sprintf(\"INSERT INTO %s (%s) VALUES (%s)\", sanitizedTableName, columns, placeholders)\n\nstmt, err := db.Prepare(query)\n\nif err != nil {\n\nreturn err\n\n}\n\ndefer stmt.Close()\n\nbatchSize := 1000\n\nvar batch [][]interface{}\n\nfor row := range rows {\n\nif len(row) != len(headers) {\n\nfmt.Printf(\"Skipping invalid row: %v\n\n\", row)\n\ncontinue\n\n}\n\nvalues := make([]interface{}, len(row))\n\nfor i, value := range row {\n\nvalues[i] = value\n\n}\n\nbatch = append(batch, values)\n\nif len(batch) >= batchSize {\n\nerr := executeBatchInsert(stmt, batch)\n\nif err != nil {\n\nreturn err\n\n}\n\nbatch = nil\n\n}\n\n}\n\n// Insert any remaining rows in the batch\n\nif len(batch) > 0 {\n\nerr := executeBatchInsert(stmt, batch)\n\nif err != nil {\n\nreturn err\n\n}\n\n}\n\nreturn nil\n\n}\n\nfunc executeBatchInsert(stmt *sql.Stmt, batch [][]interface{}) error {\n\n\ttx, err := db.Begin()\n\nif err != nil {\n\nreturn err\n\n}\n\nfor _, values := range batch {\n\n_, err := stmt.Exec(values...)\n\nif err != nil {\n\ntx.Rollback()\n\nreturn err\n\n}\n\n}\n\nreturn tx.Commit()\n\n}\n\nThis implementation reads rows from the channel one by one, collects them in batches, and inserts each batch within a transaction.\n\nThis approach should handle large CSV files more efficiently.\n\nI need to ensure that the channel is properly closed after all rows have been read to prevent the insertData function from blocking indefinitely.\n\nNow, let's consider how to handle errors during the insertion process.\n\nIf a row fails to insert due to a constraint violation or type mismatch, I need to log the error and continue with the other rows.\n\nIn the current implementation, if a row is invalid (e.g., incorrect number of fields), I skip it and continue with the next row.\n\nSimilarly, if there's an error executing the insert statement, I roll back the transaction and return the error.\n\nHowever, in a large CSV file, some errors might be acceptable, and I might want to continue processing the remaining rows.\n\nTo handle this, I can maintain a count of failed inserts and log the errors without stopping the entire insertion process.\n\nI can also provide an option for the user to choose whether to stop on the first error or continue processing.\n\nThis adds complexity, so for now, I'll keep it simple and stop on the first error.\n\nUsers can choose to fix the CSV file and retry or handle errors manually.\n\nNow, let's think about how to improve the user interface.\n\nThe current menu system is basic, displaying options with numbers and prompting the user to enter a choice.\n\nI can enhance it by clearing the screen between menu displays or providing more descriptive messages.\n\nAdditionally, I can handle user inputs more gracefully, such as ignoring case for menu choices or allowing partial matches.\n\nHowever, for simplicity, I'll stick with numeric choices.\n\nI should also consider adding a help option to the menu that explains each option in more detail.\n\nThis can be useful for users who are not familiar with SQL or the available options.\n\nNow, let's consider how to handle multiple tables in the database.\n\nCurrently, the program creates a single table based on the CSV file.\n\nIf the user wants to import multiple CSV files into different tables, I need to modify the program to handle multiple tables.\n\nThis would require prompting the user for the table name for each CSV file and creating\u76f8\u5e94\u7684\u8868\u3002\n\n\u4e3a\u4e86\u7b80\u5316\uff0c\u6211\u5c06\u5047\u8bbe\u6bcf\u4e2a\u8fd0\u884c\u5b9e\u4f8b\u53ea\u5904\u7406\u4e00\u4e2a CSV \u6587\u4ef6\u548c\u4e00\u4e2a\u8868\u3002\u5982\u679c\u9700\u8981\u5904\u7406\u591a\u4e2a CSV \u6587\u4ef6\uff0c\u53ef\u4ee5\u8003\u8651\u5c06\u7a0b\u5e8f\u6539\u4e3a\u5faa\u73af\uff0c\u5141\u8bb8\u7528\u6237\u8fde\u7eed\u5bfc\u5165\u591a\u4e2a\u6587\u4ef6\uff0c\u6bcf\u4e2a\u6587\u4ef6\u521b\u5efa\u4e00\u4e2a\u5355\u72ec\u7684\u8868\u3002\n\n\u53e6\u5916\uff0c\u6211\u53ef\u4ee5\u6dfb\u52a0\u4e00\u4e2a\u9009\u9879\uff0c\u8ba9\u7528\u6237\u9009\u62e9\u662f\u5426\u8986\u76d6\u73b0\u6709\u7684\u8868\uff0c\u6216\u8005\u8ffd\u52a0\u6570\u636e\u5230\u73b0\u6709\u7684\u8868\u4e2d\u3002\n\n\u8fd9\u9700\u8981\u5728\u521b\u5efa\u8868\u4e4b\u524d\u68c0\u67e5\u8868\u662f\u5426\u5b58\u5728\uff0c\u5e76\u6839\u636e\u7528\u6237\u7684\u9009\u62e9\u8fdb\u884c\u76f8\u5e94\u7684\u64cd\u4f5c\u3002\n\n\u73b0\u5728\uff0c\u8ba9\u6211\u603b\u7ed3\u4e00\u4e0b\u7a0b\u5e8f\u7684\u4e3b\u8981\u529f\u80fd\u548c\u6b65\u9aa4\uff1a\n\n1. **\u8bfb\u53d6 CSV \u6587\u4ef6**\uff1a\n\n- \u63d0\u793a\u7528\u6237\u8f93\u5165 CSV \u6587\u4ef6\u8def\u5f84\u3002\n\n- \u8bfb\u53d6 CSV \u6587\u4ef6\u7684\u5934\u90e8\u548c\u6570\u636e\u3002\n\n2. **\u8fde\u63a5\u5230 SQLite \u6570\u636e\u5e93**\uff1a\n\n- \u63d0\u793a\u7528\u6237\u8f93\u5165\u6570\u636e\u5e93\u540d\u79f0\uff08\u6216\u4f7f\u7528\u9ed8\u8ba4\u540d\u79f0\uff09\u3002\n\n- \u8fde\u63a5\u5230 SQLite \u6570\u636e\u5e93\u3002\n\n3. **\u521b\u5efa\u8868\u683c**\uff1a\n\n- \u6839\u636e CSV \u6587\u4ef6\u7684\u5934\u90e8\u521b\u5efa\u76f8\u5e94\u7684\u8868\u683c\u3002\n\n4. **\u63d2\u5165\u6570\u636e**\uff1a\n\n- \u5c06 CSV \u6570\u636e\u63d2\u5165\u5230\u6570\u636e\u5e93\u8868\u683c\u4e2d\u3002\n\n5. **\u7528\u6237\u67e5\u8be2\u529f\u80fd**\uff1a\n\n- \u63d0\u4f9b\u83dc\u5355\u9009\u9879\uff0c\u5141\u8bb8\u7528\u6237\u6267\u884c\u4e0d\u540c\u7684\u67e5\u8be2\u64cd\u4f5c\uff0c\u5982\u5217\u51fa\u6240\u6709\u8bb0\u5f55\u3001\u8fc7\u6ee4\u8bb0\u5f55\u3001\u6392\u5e8f\u8bb0\u5f55\u548c\u641c\u7d22\u8bb0\u5f55\u3002\n\n- \u6bcf\u4e2a\u67e5\u8be2\u64cd\u4f5c\u90fd\u6784\u9020\u76f8\u5e94\u7684 SQL \u67e5\u8be2\uff0c\u5e76\u6267\u884c\u548c\u663e\u793a\u7ed3\u679c\u3002\n\n6. **\u9519\u8bef\u5904\u7406\u548c\u8f93\u5165\u9a8c\u8bc1**\uff1a\n\n- \u5728\u6bcf\u4e2a\u6b65\u9aa4\u4e2d\u5904\u7406\u53ef\u80fd\u7684\u9519\u8bef\uff0c\u5e76\u63d0\u4f9b\u6709\u610f\u4e49\u7684\u9519\u8bef\u6d88\u606f\u3002\n\n- \u9a8c\u8bc1\u7528\u6237\u8f93\u5165\uff0c\u9632\u6b62 SQL \u6ce8\u5165\u7b49\u5b89\u5168\u95ee\u9898\u3002\n\n\u6700\u540e\uff0c\u6211\u9700\u8981\u786e\u4fdd\u7a0b\u5e8f\u662f\u7528\u6237\u53cb\u597d\u7684\uff0c\u63d0\u4f9b\u6e05\u6670\u7684\u6307\u4ee4\u548c\u53cd\u9988\uff0c\u5e76\u4e14\u5728\u51fa\u73b0\u9519\u8bef\u65f6\u4e0d\u4f1a\u5d29\u6e83\u3002\n\n\u73b0\u5728\uff0c\u6211\u5c06\u5f00\u59cb\u7f16\u5199\u5b9e\u9645\u7684\u4ee3\u7801\uff0c\u5b9e\u73b0\u4e0a\u8ff0\u529f\u80fd\u3002\n\n## \u6700\u7ec8\u89e3\u51b3\u65b9\u6848\n\u4e3a\u4e86\u5b8c\u6210\u8fd9\u4e2a\u4efb\u52a1\uff0c\u6211\u5c06\u7f16\u5199\u4e00\u4e2aGo\u8bed\u8a00\u7a0b\u5e8f\uff0c\u8be5\u7a0b\u5e8f\u80fd\u591f\u8bfb\u53d6CSV\u6587\u4ef6\u5e76\u5c06\u6570\u636e\u63d2\u5165\u5230SQLite\u6570\u636e\u5e93\u4e2d\u3002\u6b64\u5916\uff0c\u7a0b\u5e8f\u8fd8\u5c06\u63d0\u4f9b\u7528\u6237\u67e5\u8be2\u529f\u80fd\uff0c\u5141\u8bb8\u7528\u6237\u6839\u636e\u8f93\u5165\u67e5\u8be2\u6570\u636e\u5e93\u5e76\u663e\u793a\u7ed3\u679c\u3002\u7a0b\u5e8f\u5c06\u5305\u542b\u9519\u8bef\u5904\u7406\u548c\u7528\u6237\u8f93\u5165\u9a8c\u8bc1\uff0c\u4ee5\u786e\u4fdd\u7a33\u5065\u6027\u548c\u5b89\u5168\u6027\u3002\n\n### \u76ee\u6807\n\n1. **\u8bfb\u53d6CSV\u6587\u4ef6**\uff1a\u4ece\u6307\u5b9a\u7684CSV\u6587\u4ef6\u4e2d\u8bfb\u53d6\u6570\u636e\u548c\u5934\u90e8\u4fe1\u606f\u3002\n2. **\u521b\u5efa\u548c\u64cd\u4f5cSQLite\u6570\u636e\u5e93**\uff1a\u521b\u5efa\u4e00\u4e2aSQLite\u6570\u636e\u5e93\uff0c\u5e76\u6839\u636eCSV\u6587\u4ef6\u7684\u5934\u90e8\u4fe1\u606f\u521b\u5efa\u8868\uff0c\u7136\u540e\u5c06\u6570\u636e\u63d2\u5165\u8868\u4e2d\u3002\n3. **\u7528\u6237\u67e5\u8be2\u529f\u80fd**\uff1a\u63d0\u4f9b\u83dc\u5355\u9a71\u52a8\u7684\u754c\u9762\uff0c\u5141\u8bb8\u7528\u6237\u6267\u884c\u4e0d\u540c\u7684\u67e5\u8be2\u64cd\u4f5c\uff0c\u5982\u5217\u51fa\u6240\u6709\u8bb0\u5f55\u3001\u8fc7\u6ee4\u8bb0\u5f55\u3001\u6392\u5e8f\u8bb0\u5f55\u548c\u641c\u7d22\u8bb0\u5f55\u3002\n4. **\u9519\u8bef\u5904\u7406\u548c\u8f93\u5165\u9a8c\u8bc1**\uff1a\u786e\u4fdd\u7a0b\u5e8f\u80fd\u591f\u5904\u7406\u5404\u79cd\u9519\u8bef\u60c5\u51b5\uff0c\u5e76\u9a8c\u8bc1\u7528\u6237\u8f93\u5165\u4ee5\u9632\u6b62SQL\u6ce8\u5165\u7b49\u5b89\u5168\u95ee\u9898\u3002\n\n### \u89e3\u51b3\u65b9\u6848\u4ee3\u7801\n\n```go\npackage main\n\nimport (\n\t\"database/sql\"\n\t\"encoding/csv\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"strings\"\n\t_ \"github.com/mattn/go-sqlite3\"\n)\n\nfunc main() {\n\tvar csvPath string\n\tfmt.Print(\"Enter the path to the CSV file: \")\n\tfmt.Scanln(&csvPath)\n\n\theaders, rows, err := readCSV(csvPath)\n\tif err != nil {\n\t\tfmt.Printf(\"Error reading CSV: %s\\n\", err)\n\t\treturn\n\t}\n\n\tvar dbName string\n\tfmt.Print(\"Enter the database name (default: data.db): \")\n\tfmt.Scanln(&dbName)\n\tif dbName == \"\" {\n\t\tdbName = \"data.db\"\n\t}\n\n\tdb, err := sql.Open(\"sqlite3\", dbName)\n\tif err != nil {\n\t\tfmt.Printf(\"Error connecting to database: %s\\n\", err)\n\t\treturn\n\t}\n\tdefer db.Close()\n\n\ttableName := \"data_table\"\n\terr = createTable(db, tableName, headers)\n\tif err != nil {\n\t\tfmt.Printf(\"Error creating table: %s\\n\", err)\n\t\treturn\n\t}\n\n\terr = insertData(db, tableName, headers, rows)\n\tif err != nil {\n\t\tfmt.Printf(\"Error inserting data: %s\\n\", err)\n\t\treturn\n\t}\n\n\t// Menu options\n\tmenuOptions := []MenuOption{\n\t\t{\"List all records\", listAllRecords},\n\t\t{\"Filter records by column\", filterRecords},\n\t\t{\"Sort records by column\", sortRecords},\n\t\t{\"Search for text in column\", searchRecords},\n\t\t{\"Exit\", nil},\n\t}\n\n\tfor {\n\t\tfmt.Println(\"\\nPlease choose an option:\")\n\t\tfor i, option := range menuOptions {\n\t\t\tfmt.Printf(\"%d. %s\\n\", i+1, option.Text)\n\t\t}\n\t\tvar choice int\n\t\tfmt.Print(\"Enter your choice: \")\n\t\tfmt.Scanln(&choice)\n\t\tif choice < 1 || choice > len(menuOptions) {\n\t\t\tfmt.Println(\"Invalid choice. Please try again.\")\n\t\t\tcontinue\n\t\t}\n\t\tselectedOption := menuOptions[choice-1]\n\t\tif selectedOption.Action == nil {\n\t\t\tbreak // Exit the loop\n\t\t}\n\t\terr := selectedOption.Action(db, tableName, headers)\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"Error: %s\\n\", err)\n\t\t}\n\t}\n}\n\nfunc readCSV(filePath string) ([]string, <-chan []string, error) {\n\tfile, err := os.Open(filePath)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tdefer file.Close()\n\n\treader := csv.NewReader(file)\n\n\trecords := make(chan []string)\n\tgo func() {\n\t\tdefer close(records)\n\t\tvar headersRead bool\n\t\tfor {\n\t\t\trecord, err := reader.Read()\n\t\t\tif err == io.EOF {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tif err != nil {\n\t\t\t\tfmt.Printf(\"Error reading CSV: %s\\n\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif !headersRead {\n\t\t\t\theadersRead = true\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\trecords <- record\n\t\t}\n\t}()\n\n\t// Read headers separately\n\theaders, err := reader.Read()\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\treturn headers, records, nil\n}\n\nfunc createTable(db *sql.DB, tableName string, headers []string) error {\n\tsanitizedHeaders := make([]string, len(headers))\n\tfor i, header := range headers {\n\t\tsanitizedHeaders[i] = sanitizeColumnName(header)\n\t}\n\tcolumns := strings.Join(sanitizedHeaders, \" TEXT, \")\n\tquery := fmt.Sprintf(\"CREATE TABLE IF NOT EXISTS %s (%s TEXT)\", tableName, columns)\n\t_, err := db.Exec(query)\n\treturn err\n}\n\nfunc insertData(db *sql.DB, tableName string, headers []string, rows <-chan []string) error {\n\tsanitizedHeaders := make([]string, len(headers))\n\tfor i, header := range headers {\n\t\tsanitizedHeaders[i] = sanitizeColumnName(header)\n\t}\n\tcolumns := strings.Join(sanitizedHeaders, \", \")\n\tplaceholders := strings.Repeat(\"?,\", len(headers)-1) + \"?\"\n\tquery := fmt.Sprintf(\"INSERT INTO %s (%s) VALUES (%s)\", tableName, columns, placeholders)\n\tstmt, err := db.Prepare(query)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer stmt.Close()\n\n\tbatchSize := 1000\n\tvar batch [][]interface{}\n\tfor row := range rows {\n\t\tif len(row) != len(headers) {\n\t\t\tfmt.Printf(\"Skipping invalid row: %v\\n\", row)\n\t\t\tcontinue\n\t\t}\n\t\tvalues := make([]interface{}, len(row))\n\t\tfor i, value := range row {\n\t\t\tvalues[i] = value\n\t\t}\n\t\tbatch = append(batch, values)\n\t\tif len(batch) >= batchSize {\n\t\t\terr := executeBatchInsert(stmt, batch)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tbatch = nil\n\t\t}\n\t}\n\t// Insert any remaining rows in the batch\n\tif len(batch) > 0 {\n\t\terr := executeBatchInsert(stmt, batch)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc executeBatchInsert(stmt *sql.Stmt, batch [][]interface{}) error {\n\ttx, err := stmt.DB().Begin()\n\tif err != nil {\n\t\treturn err\n\t}\n\tfor _, values := range batch {\n\t\t_, err := stmt.Exec(values...)\n\t\tif err != nil {\n\t\t\ttx.Rollback()\n\t\t\treturn err\n\t\t}\n\t}\n\treturn tx.Commit()\n}\n\nfunc listAllRecords(db *sql.DB, tableName string, headers []string) error {\n\tquery := fmt.Sprintf(\"SELECT * FROM %s\", tableName)\n\treturn executeQueryAndPrintResults(db, query)\n}\n\nfunc filterRecords(db *sql.DB, tableName string, headers []string) error {\n\tsanitizedHeaders := make([]string, len(headers))\n\tfor i, header := range headers {\n\t\tsanitizedHeaders[i] = sanitizeColumnName(header)\n\t}\n\tfmt.Println(\"Available columns:\")\n\tfor i, header := range headers {\n\t\tfmt.Printf(\"%d. %s\\n\", i+1, header)\n\t}\n\tvar columnChoice int\n\tfmt.Print(\"Select a column to filter by: \")\n\tfmt.Scanln(&columnChoice)\n\tif columnChoice < 1 || columnChoice > len(headers) {\n\t\treturn fmt.Errorf(\"invalid column choice\")\n\t}\n\tselectedColumn := sanitizedHeaders[columnChoice-1]\n\n\tfmt.Println(\"Available operators:\\n1. Equal to (=)\\n2. Not equal to (!=)\\n3. Greater than (>)\\n4. Less than (<)\\n5. Contains (LIKE)\\n\")\n\tvar operatorChoice int\n\tfmt.Print(\"Select an operator: \")\n\tfmt.Scanln(&operatorChoice)\n\tif operatorChoice < 1 || operatorChoice > 5 {\n\t\treturn fmt.Errorf(\"invalid operator choice\")\n\t}\n\toperators := map[int]string{\n\t\t1: \"=\",\n\t\t2: \"!=\",\n\t\t3: \">\",\n\t\t4: \"<\",\n\t\t5: \"LIKE\",\n\t}\n\tselectedOperator := operators[operatorChoice]\n\n\tvar value string\n\tfmt.Print(\"Enter the value to filter by: \")\n\tfmt.Scanln(&value)\n\tif selectedOperator == \"LIKE\" {\n\t\tvalue = \"%\" + value + \"%\"\n\t}\n\n\tquery := fmt.Sprintf(\"SELECT * FROM %s WHERE %s %s ?\", tableName, selectedColumn, selectedOperator)\n\treturn executeQueryAndPrintResults(db, query, value)\n}\n\nfunc sortRecords(db *sql.DB, tableName string, headers []string) error {\n\tsanitizedHeaders := make([]string, len(headers))\n\tfor i, header := range headers {\n\t\tsanitizedHeaders[i] = sanitizeColumnName(header)\n\t}\n\tfmt.Println(\"Available columns:\")\n\tfor i, header := range headers {\n\t\tfmt.Printf(\"%d. %s\\n\", i+1, header)\n\t}\n\tvar columnChoice int\n\tfmt.Print(\"Select a column to sort by: \")\n\tfmt.Scanln(&columnChoice)\n\tif columnChoice < 1 || columnChoice > len(headers) {\n\t\treturn fmt.Errorf(\"invalid column choice\")\n\t}\n\tselectedColumn := sanitizedHeaders[columnChoice-1]\n\n\tfmt.Println(\"Sort order:\\n1. Ascending (ASC)\\n2. Descending (DESC)\\n\")\n\tvar orderChoice int\n\tfmt.Print(\"Select sort order: \")\n\tfmt.Scanln(&orderChoice)\n\tif orderChoice != 1 && orderChoice != 2 {\n\t\treturn fmt.Errorf(\"invalid sort order choice\")\n\t}\n\tsortOrder := map[int]string{1: \"ASC\", 2: \"DESC\"}[orderChoice]\n\n\tquery := fmt.Sprintf(\"SELECT * FROM %s ORDER BY %s %s\", tableName, selectedColumn, sortOrder)\n\treturn executeQueryAndPrintResults(db, query)\n}\n\nfunc searchRecords(db *sql.DB, tableName string, headers []string) error {\n\tsanitizedHeaders := make([]string, len(headers))\n\tfor i, header := range headers {\n\t\tsanitizedHeaders[i] = sanitizeColumnName(header)\n\t}\n\tfmt.Println(\"Available columns:\")\n\tfor i, header := range headers {\n\t\tfmt.Printf(\"%d. %s\\n\", i+1, header)\n\t}\n\tvar columnChoice int\n\tfmt.Print(\"Select a column to search in: \")\n\tfmt.Scanln(&columnChoice)\n\tif columnChoice < 1 || columnChoice > len(headers) {\n\t\treturn fmt.Errorf(\"invalid column choice\")\n\t}\n\tselectedColumn := sanitizedHeaders[columnChoice-1]\n\n\tvar searchTerm string\n\tfmt.Print(\"Enter the search term: \")\n\tfmt.Scanln(&searchTerm)\n\n\tquery := fmt.Sprintf(\"SELECT * FROM %s WHERE %s LIKE ? ESCAPE '' COLLATE NOCASE\", tableName, selectedColumn)\n\tstmt, err := db.Prepare(query)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer stmt.Close()\n\n\t// Escape any wildcard characters in the search term\n\tescapedSearchTerm := strings.ReplaceAll(searchTerm, \"?\", \"\\\\?\")\n\tescapedSearchTerm = strings.ReplaceAll(escapedSearchTerm, \"%\", \"\\\\%\")\n\t// Add wildcards for partial matching\n\tlikeTerm := \"%\" + escapedSearchTerm + \"%\"\n\n\trows, err := stmt.Query(likeTerm)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer rows.Close()\n\n\tcolumns, err := rows.Columns()\n\tif err != nil {\n\t\treturn err\n\t}\n\tfor rows.Next() {\n\t\tvalues := make([]interface{}, len(columns))\n\t\tfor i := range values {\n\t\t\tvalues[i] = new(string)\n\t\t}\n\t\terr := rows.Scan(values...)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfor i, col := range columns {\n\t\t\tval := *(values[i].(*string))\n\t\t\tfmt.Printf(\"%s: %s\\n\", col, val)\n\t\t}\n\t\tfmt.Println()\n\t}\n\treturn nil\n}\n\nfunc executeQueryAndPrintResults(db *sql.DB, query string, args ...interface{}) error {\n\trows, err := db.Query(query, args...)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer rows.Close()\n\n\tcolumns, err := rows.Columns()\n\tif err != nil {\n\t\treturn err\n\t}\n\tfor rows.Next() {\n\t\tvalues := make([]interface{}, len(columns))\n\t\tfor i := range values {\n\t\t\tvalues[i] = new(string)\n\t\t}\n\t\terr := rows.Scan(values...)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tfor i, col := range columns {\n\t\t\tval := *(values[i].(*string))\n\t\t\tfmt.Printf(\"%s: %s\\n\", col, val)\n\t\t}\n\t\tfmt.Println()\n\t}\n\treturn nil\n}\n\nfunc sanitizeColumnName(name string) string {\n\treturn strings.ReplaceAll(name, \" \", \"_\")\n}\n\ntype MenuOption struct {\n\tText    string\n\tAction  func(db *sql.DB, tableName string, headers []string) error\n}\n```\n\n### \u89e3\u91ca\n\n1. **\u8bfb\u53d6CSV\u6587\u4ef6**\uff1a\n   - \u4f7f\u7528`csv.NewReader`\u8bfb\u53d6CSV\u6587\u4ef6\uff0c\u8df3\u8fc7\u5934\u90e8\uff0c\u9010\u884c\u8bfb\u53d6\u6570\u636e\u3002\n   \n2. **\u521b\u5efa\u548c\u64cd\u4f5cSQLite\u6570\u636e\u5e93**\uff1a\n   - \u4f7f\u7528`database/sql`\u5305\u548c`github.com/mattn/go-sqlite3`\u9a71\u52a8\u8fde\u63a5SQLite\u6570\u636e\u5e93\u3002\n   - \u6839\u636eCSV\u5934\u90e8\u521b\u5efa\u8868\uff0c\u5e76\u5c06\u6570\u636e\u63d2\u5165\u8868\u4e2d\u3002\n\n3. **\u7528\u6237\u67e5\u8be2\u529f\u80fd**\uff1a\n   - \u63d0\u4f9b\u83dc\u5355\u9009\u9879\uff0c\u5305\u62ec\u5217\u51fa\u6240\u6709\u8bb0\u5f55\u3001\u8fc7\u6ee4\u8bb0\u5f55\u3001\u6392\u5e8f\u8bb0\u5f55\u548c\u641c\u7d22\u8bb0\u5f55\u3002\n   - \u6bcf\u4e2a\u9009\u9879\u5bf9\u5e94\u4e00\u4e2a\u51fd\u6570\uff0c\u6267\u884c\u76f8\u5e94\u7684SQL\u67e5\u8be2\u5e76\u663e\u793a\u7ed3\u679c\u3002\n\n4. **\u9519\u8bef\u5904\u7406\u548c\u8f93\u5165\u9a8c\u8bc1**\uff1a\n   - \u5728\u8bfb\u53d6CSV\u3001\u521b\u5efa\u8868\u3001\u63d2\u5165\u6570\u636e\u548c\u6267\u884c\u67e5\u8be2\u7b49\u6b65\u9aa4\u4e2d\u5904\u7406\u53ef\u80fd\u7684\u9519\u8bef\u3002\n   - \u9a8c\u8bc1\u7528\u6237\u8f93\u5165\uff0c\u9632\u6b62SQL\u6ce8\u5165\uff0c\u4f7f\u7528\u53c2\u6570\u5316\u67e5\u8be2\u3002\n\n\u8fd9\u4e2a\u7a0b\u5e8f\u63d0\u4f9b\u4e86\u4e00\u4e2a\u5b8c\u6574\u7684\u4eceCSV\u5230SQLite\u6570\u636e\u5e93\u7684\u5bfc\u5165\u548c\u67e5\u8be2\u89e3\u51b3\u65b9\u6848\uff0c\u540c\u65f6\u786e\u4fdd\u4e86\u7528\u6237\u8f93\u5165\u7684\u5b89\u5168\u6027\u548c\u7a0b\u5e8f\u7684\u5065\u58ee\u6027\u3002"
    }
]