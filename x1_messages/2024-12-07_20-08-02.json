[
    {
        "role": "user",
        "content": "Create a Golang web server with endpoints for creating, reading, updating, and deleting records in a PostgreSQL database. The server should use prepared statements to prevent SQL injection attacks.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Alright, I'm going to guide you through creating a simple Golang web server that interacts with a PostgreSQL database. We'll set up endpoints for CRUD operations (Create, Read, Update, Delete) and use prepared statements to ensure safety against SQL injection.\n\nFirst, make sure you have Go and PostgreSQL installed on your machine. You'll also need to install the necessary Go packages for handling HTTP requests and interacting with PostgreSQL.\n\n### Step 1: Set Up Your Go Environment\n\nCreate a new directory for your project and initialize a new Go module:\n\n```bash\nmkdir go-crud-server\ncd go-crud-server\ngo mod init crud-server\n```\n\n### Step 2: Install Required Packages\n\nYou'll need the following packages:\n\n- `gorilla/mux` for routing\n- `lib/pq` for PostgreSQL database access\n\nInstall them using:\n\n```bash\ngo get -u github.com/gorilla/mux\ngo get -u github.com/lib/pq\n```\n\n### Step 3: Set Up Your Database\n\nFirst, create a new PostgreSQL database and a table for your records. For this example, let's create a `users` table.\n\n```sql\nCREATE DATABASE crud_db;\n\n\\c crud_db\n\nCREATE TABLE users (\n    id SERIAL PRIMARY KEY,\n    name VARCHAR(100),\n    email VARCHAR(100) UNIQUE\n);\n```\n\n### Step 4: Connect to the Database in Go\n\nCreate a `db.go` file to handle the database connection:\n\n```go\npackage main\n\nimport (\n    \"database/sql\"\n    \"fmt\"\n    \"log\"\n\n    _ \"github.com/lib/pq\"\n)\n\nconst (\n    host     = \"localhost\"\n    port     = 5432\n    user     = \"your_username\"\n    password = \"your_password\"\n    dbname   = \"crud_db\"\n)\n\nfunc ConnectDB() (*sql.DB, error) {\n   \tpsqlInfo := fmt.Sprintf(\"host=%s port=%d user=%s password=%s dbname=%s sslmode=disable\",\n        host, port, user, password, dbname)\n    db, err := sql.Open(\"postgres\", psqlInfo)\n    if err != nil {\n        return nil, err\n    }\n    err = db.Ping()\n    if err != nil {\n        return nil, err\n    }\n    log.Println(\"Connected to database\")\n    return db, nil\n}\n```\n\nReplace `your_username` and `your_password` with your PostgreSQL credentials.\n\n### Step 5: Create the CRUD Functions\n\nCreate a `user.go` file to handle user operations:\n\n```go\npackage main\n\nimport (\n    \"database/sql\"\n    \"fmt\"\n    \"log\"\n\n    \"github.com/lib/pq\"\n)\n\ntype User struct {\n    ID    int    `json:\"id\"`\n    Name  string `json:\"name\"`\n    Email string `json:\"email\"`\n}\n\nvar db *sql.DB\n\nfunc initDB() {\n    var err error\n    db, err = ConnectDB()\n    if err != nil {\n        log.Fatalf(\"Failed to connect to database: %v\", err)\n    }\n}\n\nfunc createUser(name, email string) (int, error) {\n    sqlStatement := `INSERT INTO users(name, email) VALUES($1, $2) RETURNING id;`\n    var id int\n    err := db.QueryRow(sqlStatement, name, email).Scan(&id)\n    if err != nil {\n        if pqErr, ok := err.(*pq.Error); ok {\n            switch pqErr.Code.Name() {\n            case \"unique_violation\":\n                return 0, fmt.Errorf(\"email already exists\")\n            }\n        }\n        return 0, err\n    }\n    return id, nil\n}\n\nfunc getUser(id int) (*User, error) {\n    sqlStatement := `SELECT id, name, email FROM users WHERE id=$1;`\n    row := db.QueryRow(sqlStatement, id)\n\n    var user User\n    err := row.Scan(&user.ID, &user.Name, &user.Email)\n    if err != nil {\n        if err == sql.ErrNoRows {\n            return nil, fmt.Errorf(\"user not found\")\n        }\n        return nil, err\n    }\n    return &user, nil\n}\n\nfunc updateUser(id, name, email string) error {\n    sqlStatement := `UPDATE users SET name=$1, email=$2 WHERE id=$3;`\n    _, err := db.Exec(sqlStatement, name, email, id)\n    if err != nil {\n        return err\n    }\n    return nil\n}\n\nfunc deleteUser(id string) error {\n    sqlStatement := `DELETE FROM users WHERE id=$1;`\n    _, err := db.Exec(sqlStatement, id)\n    if err != nil {\n        return err\n    }\n    return nil\n}\n```\n\n### Step 6: Set Up the HTTP Server\n\nCreate a `main.go` file to set up the HTTP server and routes:\n\n```go\npackage main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"log\"\n    \"net/http\"\n\n    \"github.com/gorilla/mux\"\n)\n\nfunc main() {\n    initDB()\n    defer db.Close()\n\n    r := mux.NewRouter()\n\n    r.HandleFunc(\"/users\", createUserHandler).Methods(\"POST\")\n    r.HandleFunc(\"/users/{id}\", getUserHandler).Methods(\"GET\")\n    r.HandleFunc(\"/users/{id}\", updateUserHandler).Methods(\"PUT\")\n    r.HandleFunc(\"/users/{id}\", deleteUserHandler).Methods(\"DELETE\")\n\n    log.Println(\"Starting server at port 8000\")\n    log.Fatal(http.ListenAndServe(\":8000\", r))\n}\n\nfunc createUserHandler(w http.ResponseWriter, r *http.Request) {\n    var user User\n    err := json.NewDecoder(r.Body).Decode(&user)\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusBadRequest)\n        return\n    }\n    id, err := createUser(user.Name, user.Email)\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusBadRequest)\n        return\n    }\n    w.WriteHeader(http.StatusCreated)\n    json.NewEncoder(w).Encode(map[string]int{\"id\": id})\n}\n\nfunc getUserHandler(w http.ResponseWriter, r *http.Request) {\n    params := mux.Vars(r)\n    id, err := strconv.Atoi(params[\"id\"])\n    if err != nil {\n        http.Error(w, \"Invalid user ID\", http.StatusBadRequest)\n        return\n    }\n    user, err := getUser(id)\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusNotFound)\n        return\n    }\n    json.NewEncoder(w).Encode(user)\n}\n\nfunc updateUserHandler(w http.ResponseWriter, r *http.Request) {\n    params := mux.Vars(r)\n    id := params[\"id\"]\n\n    var user User\n    err := json.NewDecoder(r.Body).Decode(&user)\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusBadRequest)\n        return\n    }\n\n    err = updateUser(id, user.Name, user.Email)\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n        return\n    }\n    w.WriteHeader(http.StatusOK)\n    fmt.Fprint(w, \"User updated successfully\")\n}\n\nfunc deleteUserHandler(w http.ResponseWriter, r *http.Request) {\n    params := mux.Vars(r)\n    id := params[\"id\"]\n\n    err := deleteUser(id)\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n        return\n    }\n    w.WriteHeader(http.StatusOK)\n    fmt.Fprint(w, \"User deleted successfully\")\n}\n```\n\n### Step 7: Run Your Server\n\nMake sure your PostgreSQL server is running, then start your Go server:\n\n```bash\ngo run main.go\n```\n\nYour server should now be running at `http://localhost:8000`. You can use tools like Postman or curl to test the endpoints.\n\n### Summary\n\n- **Create User:** POST to `/users` with JSON body `{ \"name\": \"John Doe\", \"email\": \"john@example.com\" }`\n- **Get User:** GET to `/users/{id}`\n- **Update User:** PUT to `/users/{id}` with JSON body containing fields to update\n- **Delete User:** DELETE to `/users/{id}`\n\nThis setup uses prepared statements (`$1`, `$2`, etc.) to prevent SQL injection, ensuring your database is safe from such attacks.\n\n### Final Notes\n\n- Always handle errors appropriately in production code.\n- Consider adding more robust validation and logging.\n- For security, never hardcode credentials in your code. Use environment variables or configuration files.\n- This is a basic example. In a real-world application, you might want to handle more edge cases and improve performance.\n\nHappy coding!"
    }
]