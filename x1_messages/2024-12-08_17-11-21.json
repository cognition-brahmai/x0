[
    {
        "role": "user",
        "content": "Create a Python implementation of a singly linked list with methods for adding elements at the beginning, end, and specified position, as well as deleting elements by value or position.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Sure! I'd be happy to help you with that. So, you want a Python implementation of a singly linked list, right? And you need methods to add elements at the beginning, at the end, and at a specified position. Also, you want methods to delete elements by value or by position. Got it.\n\nFirst, let's understand what a singly linked list is. It's a data structure where each element, called a node, contains some data and a reference to the next node in the sequence. The last node points to None, indicating the end of the list.\n\nSo, to implement this in Python, we'll need to define a Node class and a LinkedList class.\n\nThe Node class will be simple. It will have an __init__ method that takes the data for the node and initializes the next pointer to None.\n\nclass Node:\ndef __init__(self, data):\nself.data = data\nself.next = None\n\nAlright, now for the LinkedList class. This will be where most of the functionality lies.\n\nclass LinkedList:\ndef __init__(self):\nself.head = None\n\nSo, the LinkedList starts with a head pointer set to None, meaning an empty list.\n\nFirst, let's implement the method to add an element at the beginning of the list. This should be straightforward. We create a new node with the given data, and set its next pointer to the current head. Then, we update the head to point to this new node.\n\ndef add_beginning(self, data):\nnew_node = Node(data)\nnew_node.next = self.head\nself.head = new_node\n\nGreat. Now, adding at the end. For this, we need to traverse the list to the last node and set its next pointer to the new node.\n\ndef add_end(self, data):\nnew_node = Node(data)\nif self.head is None:\nself.head = new_node\nreturn\ncurrent = self.head\nwhile current.next:\ncurrent = current.next\ncurrent.next = new_node\n\nAlright, and adding at a specified position. We need to consider that positions start from 0, where 0 is the beginning of the list.\n\ndef add_at_position(self, data, position):\nif position == 0:\nself.add_beginning(data)\nreturn\nnew_node = Node(data)\ncurrent = self.head\nprev = None\ncount = 0\nwhile current and count < position:\nprev = current\ncurrent = current.next\ncount += 1\nif count == position:\nprev.next = new_node\nnew_node.next = current\nelse:\nprint(\"Position out of range\")\n\nSo, if the position is 0, we just call add_beginning. Otherwise, we traverse the list to find the node at the specified position, keep track of the previous node, and then insert the new node between prev and current.\n\nNext, deleting an element by value. We need to find the first node that matches the value and remove it.\n\ndef delete_by_value(self, value):\nif self.head is None:\nprint(\"List is empty\")\nreturn\nif self.head.data == value:\nself.head = self.head.next\nreturn\ncurrent = self.head\nprev = None\nwhile current and current.data != value:\nprev = current\ncurrent = current.next\nif current:\nprev.next = current.next\nelse:\nprint(\"Value not found in the list\")\n\nHere, if the head node contains the value, we simply update the head to the next node. Otherwise, we traverse the list to find the node with the value and remove it by adjusting the previous node's next pointer.\n\nNow, deleting by position. Positions start from 0.\n\ndef delete_by_position(self, position):\nif self.head is None:\nprint(\"List is empty\")\nreturn\nif position == 0:\nself.head = self.head.next\nreturn\ncurrent = self.head\nprev = None\ncount = 0\nwhile current and count < position:\nprev = current\ncurrent = current.next\ncount += 1\nif count == position and current:\nprev.next = current.next\nelse:\nprint(\"Position out of range\")\n\nSimilar to adding at a position, we handle the head separately and then traverse to the position, updating pointers accordingly.\n\nLastly, it's always good to have a method to display the list to verify operations.\n\ndef display(self):\ncurrent = self.head\nwhile current:\nprint(current.data, end=\" -> \")\ncurrent = current.next\nprint(\"None\")\n\nAlright, let's put it all together.\n\nclass Node:\ndef __init__(self, data):\nself.data = data\nself.next = None\n\nclass LinkedList:\ndef __init__(self):\nself.head = None\n\ndef add_beginning(self, data):\nnew_node = Node(data)\nnew_node.next = self.head\nself.head = new_node\n\ndef add_end(self, data):\nnew_node = Node(data)\nif self.head is None:\nself.head = new_node\nreturn\ncurrent = self.head\nwhile current.next:\ncurrent = current.next\ncurrent.next = new_node\n\ndef add_at_position(self, data, position):\nif position == 0:\nself.add_beginning(data)\nreturn\nnew_node = Node(data)\ncurrent = self.head\nprev = None\ncount = 0\nwhile current and count < position:\nprev = current\ncurrent = current.next\ncount += 1\nif count == position:\nprev.next = new_node\nnew_node.next = current\nelse:\nprint(\"Position out of range\")\n\ndef delete_by_value(self, value):\nif self.head is None:\nprint(\"List is empty\")\nreturn\nif self.head.data == value:\nself.head = self.head.next\nreturn\ncurrent = self.head\nprev = None\nwhile current and current.data != value:\nprev = current\ncurrent = current.next\nif current:\nprev.next = current.next\nelse:\nprint(\"Value not found in the list\")\n\ndef delete_by_position(self, position):\nif self.head is None:\nprint(\"List is empty\")\nreturn\nif position == 0:\nself.head = self.head.next\nreturn\ncurrent = self.head\nprev = None\ncount = 0\nwhile current and count < position:\nprev = current\ncurrent = current.next\ncount += 1\nif count == position and current:\nprev.next = current.next\nelse:\nprint(\"Position out of range\")\n\ndef display(self):\ncurrent = self.head\nwhile current:\nprint(current.data, end=\" -> \")\ncurrent = current.next\nprint(\"None\")\n\n# Example usage:\nif __name__ == \"__main__\":\nll = LinkedList()\nll.add_end(5)\nll.add_end(10)\nll.add_beginning(0)\nll.add_at_position(3, 2)\nll.display()  # Output: 0 -> 5 -> 3 -> 10 -> None\nll.delete_by_value(5)\nll.display()  # Output: 0 -> 3 -> 10 -> None\nll.delete_by_position(2)\nll.display()  # Output: 0 -> 3 -> None\n\nThere you go! This should cover all the requirements you mentioned. You can test it with the example usage provided at the bottom.\n\n**Final Solution**\nTo implement a singly linked list in Python with methods for adding elements at the beginning, end, and specified position, as well as deleting elements by value or position, you can use the following code:\n\n```python\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\nclass LinkedList:\n    def __init__(self):\n        self.head = None\n\n    def add_beginning(self, data):\n        new_node = Node(data)\n        new_node.next = self.head\n        self.head = new_node\n\n    def add_end(self, data):\n        new_node = Node(data)\n        if self.head is None:\n            self.head = new_node\n            return\n        current = self.head\n        while current.next:\n            current = current.next\n        current.next = new_node\n\n    def add_at_position(self, data, position):\n        if position == 0:\n            self.add_beginning(data)\n            return\n        new_node = Node(data)\n        current = self.head\n        prev = None\n        count = 0\n        while current and count < position:\n            prev = current\n            current = current.next\n            count += 1\n        if count == position:\n            prev.next = new_node\n            new_node.next = current\n        else:\n            print(\"Position out of range\")\n\n    def delete_by_value(self, value):\n        if self.head is None:\n            print(\"List is empty\")\n            return\n        if self.head.data == value:\n            self.head = self.head.next\n            return\n        current = self.head\n        prev = None\n        while current and current.data != value:\n            prev = current\n            current = current.next\n        if current:\n            prev.next = current.next\n        else:\n            print(\"Value not found in the list\")\n\n    def delete_by_position(self, position):\n        if self.head is None:\n            print(\"List is empty\")\n            return\n        if position == 0:\n            self.head = self.head.next\n            return\n        current = self.head\n        prev = None\n        count = 0\n        while current and count < position:\n            prev = current\n            current = current.next\n            count += 1\n        if count == position and current:\n            prev.next = current.next\n        else:\n            print(\"Position out of range\")\n\n    def display(self):\n        current = self.head\n        while current:\n            print(current.data, end=\" -> \")\n            current = current.next\n        print(\"None\")\n\n# Example usage:\nif __name__ == \"__main__\":\n    ll = LinkedList()\n    ll.add_end(5)\n    ll.add_end(10)\n    ll.add_beginning(0)\n    ll.add_at_position(3, 2)\n    ll.display()  # Output: 0 -> 5 -> 3 -> 10 -> None\n    ll.delete_by_value(5)\n    ll.display()  # Output: 0 -> 3 -> 10 -> None\n    ll.delete_by_position(2)\n    ll.display()  # Output: 0 -> 3 -> None\n```\n\n### Explanation:\n1. **Node Class**: Represents a single node in the linked list with `data` and `next` attributes.\n2. **LinkedList Class**: Manages the linked list operations.\n   - `add_beginning(data)`: Adds a new node with the given data at the beginning of the list.\n   - `add_end(data)`: Adds a new node with the given data at the end of the list.\n   - `add_at_position(data, position)`: Adds a new node with the given data at the specified position.\n   - `delete_by_value(value)`: Deletes the first node that matches the given value.\n   - `delete_by_position(position)`: Deletes the node at the specified position.\n   - `display()`: Prints the linked list in readable format.\n\nThis implementation ensures that all specified operations are performed efficiently, and the list is correctly managed and displayed."
    }
]