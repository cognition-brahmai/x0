[
    {
        "role": "user",
        "content": "Create a JavaScript/Node.js script that generates a static website from markdown files in a specified directory. The script should convert each markdown file into an HTML page with a consistent header, footer, and navigation menu. Additionally, the script should support command line arguments for the input directory, output directory, and site title.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Alright, I have this task to create a JavaScript/Node.js script that generates a static website from markdown files in a specified directory. So, basically, I need to write a script that takes markdown files, converts them into HTML, and organizes them into a website structure with a common header, footer, and navigation menu. Also, it should accept command line arguments for the input directory, output directory, and the site title.\n\nFirst, I need to understand what tools and modules I might need for this task. Since it's Node.js, I can use built-in modules and also install additional packages if necessary.\n\nStarting with reading markdown files, I know that Node.js has fs module for file system operations, so I can read the markdown files from the input directory. For converting markdown to HTML, I can use a package like markdown-it or showdown. I think markdown-it is quite popular and has good features.\n\nSo, step one: Install markdown-it.\n\nI can do this by running:\n\n```bash\n\nnpm install markdown-it\n\n```\n\nNext, I need to read all the markdown files from the input directory. I can use fs.readdir to list all files in the directory and then filter out the markdown files, probably with .md extension.\n\nOnce I have the list of markdown files, I need to read each file's content using fs.readFileSync or fs.promises.readFile, convert the markdown to HTML using markdown-it, and then wrap this HTML content with a common header, footer, and navigation menu.\n\nThe header and footer can be predefined HTML templates that I can read from separate files or define directly in the script. For now, I'll consider defining them directly in the script to keep things simple.\n\nThe navigation menu should list all the pages (markdown files) with links to their corresponding HTML pages. So, I need to generate this menu dynamically based on the list of markdown files.\n\nAfter generating the complete HTML for each page, I need to write them to the output directory with appropriate filenames.\n\nAlso, I need to handle command line arguments for input directory, output directory, and site title. For parsing command line arguments, I can use the minimist package or the built-in yargs.\n\nI think yargs provides a more user-friendly way to define and parse arguments, so I'll go with that.\n\nFirst, install yargs:\n\n```bash\n\nnpm install yargs\n\n```\n\nThen, in my script, I can define the expected arguments and their types.\n\nFor example:\n\n- --input or -i: input directory path (required)\n\n- --output or -o: output directory path (required)\n\n- --title or -t: site title (optional, default to \"My Static Site\")\n\nNext, I need to ensure that the output directory exists or create it if it doesn't.\n\nI can use fs.existsSync to check if the directory exists and fs.mkdirSync to create it if needed.\n\nNow, let's think about the structure of the generated website.\n\nEach HTML page should have:\n\n- A header with the site title\n\n- A navigation menu with links to all pages\n\n- The main content converted from markdown\n\n- A footer with some common information\n\nI need to ensure that the navigation menu is consistent across all pages and correctly links to each page.\n\nAssuming that the markdown files are directly in the input directory without any subdirectories, I can generate HTML files with the same basename in the output directory, but with .html extension.\n\nFor example, if there's a markdown file input/about.md, it should be converted to output/about.html.\n\nI also need to handle any assets like CSS or JavaScript files. For simplicity, I'll assume that all styles are inline or included via CDN, but ideally, there should be a way to include static assets.\n\nWait, maybe I should have a separate directory for static assets, like input/assets, and copy its content to output/assets.\n\nThat sounds reasonable.\n\nSo, additional step: copy the contents of input/assets to output/assets.\n\nNow, let's outline the steps in code:\n\n1. Parse command line arguments using yargs.\n\n2. Check if input and output directories are provided; exit with error if not.\n\n3. Check if the input directory exists; exit with error if not.\n\n4. Create the output directory if it doesn't exist.\n\n5. Copy the contents of input/assets to output/assets.\n\n6. Read all markdown files from the input directory.\n\n7. For each markdown file:\n\na. Read its content.\n\nb. Convert markdown to HTML using markdown-it.\n\nc. Generate the complete HTML page by wrapping the content with header, nav, and footer.\n\nd. Write the HTML to the output directory with .html extension.\n\n8. Optionally, open the index.html in a web browser.\n\nWait, opening in a browser might not be necessary for a command-line tool, but it could be a nice feature.\n\nI can add an optional flag like --open or -o to open the index.html in a browser.\n\nFor that, I can use the built-in module 'open'.\n\nFirst, install it:\n\n```bash\n\nnpm install open\n\n```\n\nThen, in the script, if the --open flag is provided, use open to open output/index.html.\n\nNow, regarding the header, nav, and footer:\n\nI can define them as template strings in the script.\n\nFor the nav, I need to generate list items for each markdown file.\n\nAssuming that the markdown files correspond to the pages, I can extract the page title from the markdown file's frontmatter or just use the filename without extension.\n\nWait, to make it more flexible, perhaps I can expect each markdown file to have a YAML frontmatter that specifies the title and other metadata.\n\nSo, I need a markdown parser that can handle frontmatter.\n\nmarkdown-it has a plugin called markdown-it-frontmatter that can parse frontmatter.\n\nSo, install that:\n\n```bash\n\nnpm install markdown-it-frontmatter\n\n```\n\nThen, in the script, use this plugin to extract frontmatter data from each markdown file.\n\nThis way, I can get the page title from the frontmatter.\n\nIf frontmatter is not present, fallback to using the filename without extension.\n\nAlso, I need to decide on the base URL for the links in the nav menu.\n\nAssuming that all HTML files are in the output directory at the same level, relative links should work.\n\nSo, in the nav menu, links can be straightforward like \"page1.html\", \"page2.html\", etc.\n\nNow, potential issues:\n\n- If there are many pages, the nav menu might become too long.\n\n- Need to handle special cases, like index.html being the homepage.\n\n- Ensure that the current page in the nav menu is marked as active or something.\n\n- Handle cases where input directory or output directory are invalid.\n\n- Ensure that the script doesn't overwrite existing files in the output directory without warning.\n\nWait, maybe add a --force or -f flag to overwrite existing files in the output directory.\n\nOtherwise, prompt the user to confirm overwriting.\n\nBut for simplicity, I'll assume that the output directory is empty or doesn't exist.\n\nOr, if it exists, it's okay to overwrite its contents.\n\nAnother consideration: handling errors during file operations and logging appropriate messages.\n\nAlso, providing verbose output to show what the script is doing, like \"Converting file X.md to X.html\", etc.\n\nI can add a --verbose or -v flag for that.\n\nNow, let's think about the structure of the script.\n\nI can define functions for each main task:\n\n- parseArgs: parse command line arguments using yargs\n\n- copyAssets: copy input/assets to output/assets\n\n- generatePages: read markdown files, convert to HTML, and write to output directory\n\n- buildNavMenu: generate the navigation menu HTML based on the list of pages\n\n- buildHtmlPage: wrap the content with header, nav, and footer\n\nAlso, I need to require necessary modules at the top.\n\nSo, the top of the script would look like:\n\n```javascript\n\nconst fs = require('fs');\n\nconst path = require('path');\n\nconst markdownIt = require('markdown-it');\n\nconst markdownItFrontmatter = require('markdown-it-frontmatter');\n\nconst yargs = require('yargs/yargs');\n\nconst { hideBin } = require('yargs/helpers');\n\nconst open = require('open');\n\n```\n\nThen, define the parseArgs function:\n\n```javascript\n\nfunction parseArgs() {\n\nconst argv = yargs(hideBin(process.argv))\n\n.option('input', {\n\nalias: 'i',\n\ndescribe: 'Input directory containing markdown files',\n\ntype: 'string',\n\ndemandOption: true\n\n})\n\n.option('output', {\n\nalias: 'o',\n\ndescribe: 'Output directory for generated HTML files',\n\ntype: 'string',\n\ndemandOption: true\n\n})\n\n.option('title', {\n\nalias: 't',\n\ndescribe: 'Site title',\n\ntype: 'string',\n\ndefault: 'My Static Site'\n\n})\n\n.option('open', {\n\nalias: 'o',\n\ndescribe: 'Open index.html in default browser after building',\n\ntype: 'boolean',\n\ndefault: false\n\n})\n\n.help()\n\n.alias('help', 'h')\n\n.argv;\n\nreturn argv;\n\n}\n\n```\n\nWait, I have two options using the same alias 'o' for output and open. That's confusing.\n\nI should use different aliases.\n\nLet's use:\n\n- --input or -i for input directory\n\n- --output or -o for output directory\n\n- --title or -t for site title\n\n- --open or -b for open in browser\n\nBetter.\n\nNow, in parseArgs function, adjust accordingly.\n\nNext, check if the input and output directories exist.\n\nUse fs.existsSync for that.\n\nIf not, throw an error and exit.\n\nThen, create the output directory if it doesn't exist.\n\nUse fs.mkdirSync with { recursive: true } to handle nested directories.\n\nNext, copy assets from input/assets to output/assets.\n\nI can use fs.copyFileSync or a package like shutil.\n\nBut since Node.js fs module doesn't have a recursive copy function, it's better to use a package like 'shutil'.\n\nWait, 'shutil' is a Python module. In Node.js, I can use 'copy-dir'.\n\nInstall it:\n\n```bash\n\nnpm install copy-dir\n\n```\n\nThen, in the script:\n\n```javascript\n\nconst copyDir = require('copy-dir');\n\n```\n\nAnd use copyDir(src, dest, callback) to copy the assets.\n\nHandle any errors accordingly.\n\nNow, read all files in the input directory.\n\nUse fs.readdirSync(inputDir) to get the list of files.\n\nFilter out only markdown files, i.e., those ending with .md.\n\nFor each markdown file:\n\n- Read its content using fs.readFileSync\n\n- Parse frontmatter to get title and other metadata\n\n- Convert markdown content to HTML using markdown-it\n\n- Build the complete HTML page by wrapping with header, nav, and footer\n\n- Write the HTML to output directory with .html extension\n\nLet's define the markdown parser.\n\nInitialize markdown-it with the frontmatter plugin:\n\n```javascript\n\nconst md = markdownIt()\n\n.use(markdownItFrontmatter)\n\n```\n\nThen, for each markdown file:\n\n```javascript\n\nconst fileContent = fs.readFileSync(path.join(inputDir, filename), 'utf8');\n\nconst { data, content } = md.parse(fileContent, { plain: true });\n\nconst pageTitle = data.title || path.basename(filename, '.md');\n\nconst htmlContent = md.render(content);\n\n```\n\nWait, actually, markdown-it-frontmatter parses the frontmatter and returns data and content.\n\nI need to adjust that.\n\nLooking at the markdown-it-frontmatter documentation, it seems that the parsed tokens have frontmatter data.\n\nI might need to handle that appropriately.\n\nAlternatively, I can use a different approach to extract frontmatter.\n\nPerhaps use a dedicated frontmatter parser.\n\nThere's a package called 'gray-matter' that is commonly used for this purpose.\n\nI can install that:\n\n```bash\n\nnpm install gray-matter\n\n```\n\nThen, in the script:\n\n```javascript\n\nconst matter = require('gray-matter');\n\n```\n\nAnd for each markdown file:\n\n```javascript\n\nconst fileContent = fs.readFileSync(path.join(inputDir, filename), 'utf8');\n\nconst { data, content } = matter(fileContent);\n\nconst pageTitle = data.title || path.basename(filename, '.md');\n\nconst htmlContent = md.render(content);\n\n```\n\nThis seems cleaner.\n\nNow, build the navigation menu.\n\nI need to generate an HTML unordered list with links to each page.\n\nAssume that each markdown file corresponds to a page, and the link is the filename without extension plus .html.\n\nSo, for example, about.md becomes about.html.\n\nDefine a function buildNavMenu(pages) that takes a list of page objects, each containing title and filename, and returns the nav HTML.\n\nSomething like:\n\n```javascript\n\nfunction buildNavMenu(pages, currentFilename) {\n\nlet navHtml = '<ul>';\n\npages.forEach(page => {\n\nconst isActive = page.filename === currentFilename ? ' class=\"active\"' : '';\n\nnavHtml += `<li><a href=\"${page.filename}.html\"${isActive}>${page.title}</a></li>`;\n\n});\n\nnavHtml += '</ul>';\n\nreturn navHtml;\n\n}\n\n```\n\nAssuming that pages is an array of objects like { title: 'About', filename: 'about' }.\n\nAlso, mark the current page as active with a class.\n\nNow, build the complete HTML page.\n\nDefine a function buildHtmlPage(title, navHtml, contentHtml, siteTitle) that returns the complete HTML string.\n\nSomething like:\n\n```javascript\n\nfunction buildHtmlPage(title, navHtml, contentHtml, siteTitle) {\n\nreturn `\n\n<!DOCTYPE html>\n\n<html lang=\"en\">\n\n<head>\n\n<meta charset=\"UTF-8\">\n\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n\n<title>${title} - ${siteTitle}</title>\n\n<style>\n\n/* Add some basic styles */\n\nbody { font-family: Arial, sans-serif; }\n\nheader, nav, footer { background: #333; color: #fff; padding: 10px; }\n\nnav ul { list-style-type: none; padding: 0; }\n\nnav ul li { display: inline; margin-right: 10px; }\n\n.active { font-weight: bold; }\n\n</style>\n\n</head>\n\n<body>\n\n<header>\n\n<h1>${siteTitle}</h1>\n\n</header>\n\n<nav>\n\n${navHtml}\n\n</nav>\n\n<main>\n\n<article>\n\n<h2>${title}</h2>\n\n${contentHtml}\n\n</article>\n\n</main>\n\n<footer>\n\n<p>&copy; 2023 ${siteTitle}. All rights reserved.</p>\n\n</footer>\n\n</body>\n\n</html>\n\n`;\n\n}\n\n```\n\nThis is a basic template. Depending on requirements, it can be expanded.\n\nNow, for each markdown file, generate the page and write it to the output directory.\n\nAlso, keep a list of all pages for the nav menu.\n\nAfter generating all pages, if --open flag is provided, open output/index.html in the default browser using the 'open' module.\n\nNow, potential improvements:\n\n- Support for nested directories and subpages.\n\n- Option to specify a base URL for deployment.\n\n- Handling of images and other assets in markdown files.\n\n- Adding pagination or archiving for blogs.\n\n- Support for different markup languages besides markdown.\n\nBut for the initial version, keeping it simple with flat structure should suffice.\n\nI need to ensure that the script is robust, handles errors gracefully, and provides useful output to the user.\n\nAlso, consider adding a README or usage instructions for the script.\n\nAlright, I think this covers the main aspects of the task. Now, I'll proceed to implement the script accordingly.\n\n## Final Solution\nTo create a static website generator from Markdown files using Node.js, follow these steps to set up and run the script.\n\n### Prerequisites\n\n- Node.js installed on your system.\n\n### Solution Code\n\n```javascript\nconst fs = require('fs');\nconst path = require('path');\nconst markdownIt = require('markdown-it');\nconst matter = require('gray-matter');\nconst yargs = require('yargs/yargs');\nconst { hideBin } = require('yargs/helpers');\nconst copyDir = require('copy-dir');\nconst open = require('open');\n\n// Function to parse command line arguments\nfunction parseArgs() {\n    const argv = yargs(hideBin(process.argv))\n        .option('input', {\n            alias: 'i',\n            describe: 'Input directory containing markdown files',\n            type: 'string',\n            demandOption: true\n        })\n        .option('output', {\n            alias: 'o',\n            describe: 'Output directory for generated HTML files',\n            type: 'string',\n            demandOption: true\n        })\n        .option('title', {\n            alias: 't',\n            describe: 'Site title',\n            type: 'string',\n            default: 'My Static Site'\n        })\n        .option('open', {\n            alias: 'b',\n            describe: 'Open index.html in default browser after building',\n            type: 'boolean',\n            default: false\n        })\n        .help()\n        .alias('help', 'h')\n        .argv;\n    return argv;\n}\n\n// Function to copy assets from input/assets to output/assets\nfunction copyAssets(inputDir, outputDir) {\n    const assetsSrc = path.join(inputDir, 'assets');\n    const assetsDest = path.join(outputDir, 'assets');\n    if (fs.existsSync(assetsSrc)) {\n        copyDir.sync(assetsSrc, assetsDest);\n    }\n}\n\n// Function to build navigation menu HTML\nfunction buildNavMenu(pages, currentFilename) {\n    let navHtml = '<ul>';\n    pages.forEach(page => {\n        const isActive = page.filename === currentFilename ? ' class=\"active\"' : '';\n        navHtml += `<li><a href=\"${page.filename}.html\"${isActive}>${page.title}</a></li>`;\n    });\n    return navHtml + '</ul>';\n}\n\n// Function to build complete HTML page\nfunction buildHtmlPage(title, navHtml, contentHtml, siteTitle) {\n    return `\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>${title} - ${siteTitle}</title>\n    <style>\n        body { font-family: Arial, sans-serif; }\n        header, nav, footer { background: #333; color: #fff; padding: 10px; }\n        nav ul { list-style-type: none; padding: 0; }\n        nav ul li { display: inline; margin-right: 10px; }\n        .active { font-weight: bold; }\n    </style>\n</head>\n<body>\n    <header>\n        <h1>${siteTitle}</h1>\n    </header>\n    <nav>\n        ${navHtml}\n    </nav>\n    <main>\n        <article>\n            <h2>${title}</h2>\n            ${contentHtml}\n        </article>\n    </main>\n    <footer>\n        <p>&copy; 2023 ${siteTitle}. All rights reserved.</p>\n    </footer>\n</body>\n</html>\n`;\n}\n\n// Main function to generate static site\nfunction generateStaticSite(inputDir, outputDir, siteTitle, openBrowser) {\n    // Create output directory if it doesn't exist\n    if (!fs.existsSync(outputDir)) {\n        fs.mkdirSync(outputDir, { recursive: true });\n    }\n\n    // Copy assets\n    copyAssets(inputDir, outputDir);\n\n    // Read markdown files\n    const files = fs.readdirSync(inputDir);\n    const markdownFiles = files.filter(file => path.extname(file) === '.md');\n\n    // Prepare pages list\n    const pages = [];\n\n    // Initialize markdown parser\n    const md = markdownIt();\n\n    // Process each markdown file\n    markdownFiles.forEach(file => {\n        const filename = path.basename(file, '.md');\n        const fileContent = fs.readFileSync(path.join(inputDir, file), 'utf8');\n        const { data, content } = matter(fileContent);\n        const pageTitle = data.title || filename;\n        const htmlContent = md.render(content);\n        const navHtml = buildNavMenu(pages, filename);\n        const html = buildHtmlPage(pageTitle, navHtml, htmlContent, siteTitle);\n        fs.writeFileSync(path.join(outputDir, `${filename}.html`), html);\n        pages.push({ title: pageTitle, filename: filename });\n    });\n\n    // Open index.html in browser if requested\n    if (openBrowser && markdownFiles.includes('index.md')) {\n        open(path.join(outputDir, 'index.html'));\n    }\n}\n\n// Entry point\nfunction main() {\n    const argv = parseArgs();\n    generateStaticSite(argv.input, argv.output, argv.title, argv.open);\n}\n\nif (require.main === module) {\n    main();\n}\n```\n\n### Instructions\n\n1. **Install Required Packages:**\n   Ensure you have Node.js installed. Then, install the required packages by running:\n   ```bash\n   npm install markdown-it gray-matter yargs copy-dir open\n   ```\n\n2. **Create Input Directory Structure:**\n   - Create an `input` directory containing your Markdown files (e.g., `index.md`, `about.md`).\n   - Optionally, create an `input/assets` directory for CSS, JavaScript, or image files.\n\n3. **Run the Script:**\n   Use the following command to generate the static site:\n   ```bash\n   node script.js --input input --output output --title \"My Static Site\" --open\n   ```\n\n   - `--input` or `-i`: Path to the input directory containing Markdown files.\n   - `--output` or `-o`: Path to the output directory for generated HTML files.\n   - `--title` or `-t`: Site title (optional, defaults to \"My Static Site\").\n   - `--open` or `-b`: Open `index.html` in the default browser after building (optional).\n\nThis script reads Markdown files from the specified input directory, converts them to HTML, and generates a static website with a consistent header, footer, and navigation menu. It also optionally copies static assets and opens the site in your browser upon completion."
    }
]