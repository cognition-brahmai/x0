[
    {
        "role": "user",
        "content": "Develop a Node.js Express server with two endpoints: one for uploading images in JPEG format and another for resizing the uploaded images to a specified width and height using the Sharp library. The resized images should be saved in a separate folder, maintaining the original aspect ratio."
    },
    {
        "role": "assistant",
        "content": "Alright, I'm going to try to create this Node.js Express server with the features you've described. I've got some experience with Express and Node.js, but I'm not too familiar with the Sharp library, so I might need to look some things up.\n\nFirst things first, I need to set up a new Node.js project. I'll create a new directory for this project and initialize it with npm.\n\n```\nmkdir image-resizer\ncd image-resizer\nnpm init -y\n```\n\nNext, I need to install the necessary dependencies. I'll need Express for the server, Multer for handling file uploads since Express doesn't handle multipart/form-data by default, and Sharp for image processing.\n\n```\nnpm install express multer sharp\n```\n\nNow, I need to plan out the structure of my application. I think I'll have the following directories:\n\n- `uploads/`: for storing the original uploaded images.\n\n- `resized/`: for storing the resized images.\n\nI should also decide on the endpoints. You mentioned two endpoints:\n\n1. One for uploading images in JPEG format.\n\n2. Another for resizing the uploaded images to a specified width and height, maintaining the original aspect ratio.\n\nFor the upload endpoint, I'll probably use a POST request to `/upload`. For the resize endpoint, maybe `/resize?width=XXX&height=YYY`, where XXX and YYY are the desired dimensions.\n\nBut wait, should the resize endpoint take the image file again, or should it refer to an already uploaded image? I think it would make more sense for the resize endpoint to take the filename of the uploaded image and the desired dimensions, then resize that specific image and save it in the resized folder.\n\nSo, perhaps the resize endpoint would be something like `/resize/:filename?width=XXX&height=YYY`.\n\nAlternatively, I could have the resize endpoint accept the filename and dimensions via a POST request with a JSON body or form data.\n\nI need to think about how these endpoints will interact.\n\nLet me sketch a rough plan:\n\n1. User uploads a JPEG image to `/upload` via POST, with the file in form data.\n\n2. The server saves the image to the `uploads/` directory.\n\n3. User makes a request to `/resize`, providing the filename from the uploads directory and the desired width and height.\n\n4. The server uses Sharp to resize the image from `uploads/filename` to the specified dimensions, maintaining the aspect ratio.\n\n5. The resized image is saved to the `resized/` directory.\n\n6. The server can return a URL or path to the resized image.\n\nI should also consider error handling, like invalid file types, missing files, invalid dimensions, etc.\n\nAlso, I need to make sure that only JPEG files are accepted for upload.\n\nLet me start by setting up the basic Express server.\n\nI'll create an `index.js` file.\n\nFirst, I'll require the necessary modules:\n\n```javascript\nconst express = require('express');\nconst multer = require('multer');\nconst sharp = require('sharp');\nconst path = require('path');\nconst fs = require('fs');\n```\n\nI need to set up storage for uploaded files using Multer.\n\nI'll define a storage object for Multer to save files to the `uploads/` directory.\n\n```javascript\nconst upload = multer({\n  dest: 'uploads/',\n  limits: {\n    fileSize: 1000000 // 1MB limit\n  },\n  fileFilter(req, file, cb) {\n    if (!file.originalname.match(/\\.(jpg|jpeg)$/)) {\n      return cb(new Error('Only JPEG images are allowed!'));\n    }\n    cb(null, true);\n  }\n});\n```\n\nHere, I'm setting a file size limit of 1MB and only allowing files with .jpg or .jpeg extensions.\n\nNext, I'll set up the Express app.\n\n```javascript\nconst app = express();\nconst port = process.env.PORT || 3000;\n```\n\nNow, I'll create the upload endpoint.\n\n```javascript\napp.post('/upload', upload.single('image'), (req, res) => {\n  if (!req.file) {\n    return res.status(400).send('No file uploaded.');\n  }\n  res.status(200).send(`File uploaded successfully: ${req.file.filename}`);\n});\n```\n\nThis will accept a single file with the form field name 'image' and save it to the uploads directory.\n\nNow, for the resize endpoint, I need to handle resizing the image.\n\nI need to think about the URL structure. Maybe have `/resize/:filename` and accept query parameters for width and height.\n\n```javascript\napp.get('/resize/:filename', (req, res) => {\n  const { filename } = req.params;\n  const { width, height } = req.query;\n\n  if (!width || !height) {\n    return res.status(400).send('Width and height are required.');\n  }\n\n  const uploadPath = path.join(__dirname, 'uploads', filename);\n  const resizePath = path.join(__dirname, 'resized', `${filename}-resized.jpg`);\n\n  // Check if the original file exists\n  if (!fs.existsSync(uploadPath)) {\n    return res.status(404).send('Original file not found.');\n  }\n\n  // Resize the image using Sharp\n  sharp(uploadPath)\n    .resize(parseInt(width), parseInt(height), { fit: 'inside' })\n    .toFile(resizePath)\n    .then(info => {\n      res.status(200).send(`Resized image saved to: ${resizePath}`);\n    })\n    .catch(err => {\n      res.status(500).send('Error resizing image.');\n    });\n});\n```\n\nHere, I'm using Sharp to resize the image while maintaining the aspect ratio by using the `fit: 'inside'` option. This should ensure that the image is resized to fit within the specified dimensions without distorting it.\n\nI should also handle cases where the resized directory doesn't exist and create it if necessary.\n\nLet me add that.\n\n```javascript\nconst resizedDir = path.join(__dirname, 'resized');\nif (!fs.existsSync(resizedDir)) {\n  fs.mkdirSync(resizedDir);\n}\n```\n\nI can place this at the top of the file, after requiring the modules.\n\nAlso, I should add error handling for the Sharp resize operation.\n\nAdditionally, I might want to return the resized image directly to the user instead of saving it to a file. But for now, I'll stick with saving it to a file.\n\nLet me test this setup.\n\nFirst, I need to make sure that the directories exist.\n\nI'll create them manually for now.\n\n```\nmkdir uploads\nmkdir resized\n```\n\nNow, I'll start the server.\n\n```\nnode index.js\n```\n\nThen, I'll use a tool like Postman to test the upload endpoint.\n\nI'll make a POST request to `http://localhost:3000/upload` with a JPEG file in the form data.\n\nIf successful, it should return a message like \"File uploaded successfully: filename\".\n\nNext, I'll make a GET request to `http://localhost:3000/resize/filename?width=200&height=200`.\n\nIt should resize the image and save it to the resized directory.\n\nI need to check if the resized image is created and if it maintains the aspect ratio.\n\nWait, I need to make sure that the resize operation maintains the aspect ratio correctly.\n\nSharp's `fit: 'inside'` should scale the image to fit within the specified dimensions without cropping.\n\nAlternatively, if I want to fill the entire specified dimensions, I could use `fit: 'cover'`, which might crop the image.\n\nBut since the requirement is to maintain the original aspect ratio, `fit: 'inside'` should be appropriate.\n\nI should also consider adding more options, like choosing the fit mode via a query parameter.\n\nMoreover, I need to ensure that only JPEG files are uploaded and resized appropriately.\n\nI should also validate the width and height parameters to make sure they are positive integers.\n\nLet me add some validation for the dimensions.\n\n```javascript\nif (!width || !height) {\n  return res.status(400).send('Width and height are required.');\n}\n\nconst widthInt = parseInt(width);\nconst heightInt = parseInt(height);\n\nif (isNaN(widthInt) || isNaN(heightInt) || widthInt <= 0 || heightInt <= 0) {\n  return res.status(400).send('Width and height must be positive integers.');\n}\n```\n\nThis should ensure that width and height are valid positive integers.\n\nAlso, I should consider adding error handling for file operations and Sharp operations.\n\nFor example, if there's an issue with reading the original file or writing the resized file.\n\nI can add try-catch blocks around the file operations.\n\nFurthermore, I should think about how to handle filenames to avoid overwriting existing files.\n\nMulter by default assigns unique filenames using a timestamp, so the chance of filename conflicts should be minimal.\n\nBut I should still ensure that the resized filenames are unique.\n\nPerhaps I can include the dimensions in the resized filename.\n\nFor example, `filename-resized-200x200.jpg`.\n\nLet me adjust the resizePath accordingly.\n\n```javascript\nconst resizePath = path.join(resizedDir, `${filename}-resized-${width}x${height}.jpg`);\n```\n\nThis way, each resized image will have a unique filename based on its dimensions.\n\nAlso, I should make sure that the user cannot manipulate the filename to access unauthorized files.\n\nFor example, by including ../ in the filename to traverse directories.\n\nBut since Multer handles the filename assignment, and I'm using the filename from req.params.filename, which is derived from the uploaded files, it should be safe.\n\nStill, I can sanitize the filename to prevent any potential issues.\n\nI can use `path.basename` to get the base filename without any path information.\n\n```javascript\nconst filenameBase = path.basename(filename);\nconst resizePath = path.join(resizedDir, `${filenameBase}-resized-${width}x${height}.jpg`);\n```\n\nThis should help prevent any path traversal vulnerabilities.\n\nAdditionally, I should consider implementing authentication or at least some form of access control to prevent unauthorized uploads and resizes.\n\nBut for the sake of this exercise, I'll skip that part.\n\nAnother consideration is performance and resource usage, especially for large images or multiple concurrent requests.\n\nSharp is designed to be efficient, but I might need to think about optimizing the image processing, like limiting the memory usage or adding request throttling.\n\nBut again, for this basic implementation, I'll leave that out.\n\nI should also think about how to handle already existing resized images for the same dimensions.\n\nMaybe I can check if the resized file already exists and return it without processing if it does.\n\nThis can save time and resources.\n\nHere's how I can implement that:\n\n```javascript\nif (fs.existsSync(resizePath)) {\n  res.status(200).send(`Resized image already exists: ${resizePath}`);\n} else {\n  sharp(uploadPath)\n    .resize(widthInt, heightInt, { fit: 'inside' })\n    .toFile(resizePath)\n    .then(info => {\n      res.status(200).send(`Resized image saved to: ${resizePath}`);\n    })\n    .catch(err => {\n      res.status(500).send('Error resizing image.');\n    });\n}\n```\n\nThis way, if the resized image already exists, I can skip the processing.\n\nNow, I need to make sure that the server is set up to handle file uploads properly, especially regarding file sizes and types.\n\nI already have limits set in Multer for file size, and I'm filtering for JPEG files.\n\nBut I should also consider adding more robust error handling for Multer.\n\nFor example, handling errors from file filtering and size limits.\n\nI can do this by providing an error-handling middleware for Multer.\n\n```javascript\napp.post('/upload', upload.single('image'), (req, res) => {\n  if (!req.file) {\n    return res.status(400).send('No file uploaded.');\n  }\n  res.status(200).send(`File uploaded successfully: ${req.file.filename}`);\n}, (err, req, res, next) => {\n  if (err instanceof multer.MulterError) {\n    // A Multer error occurred when uploading.\n    return res.status(500).send(err.message);\n  } else if (err) {\n    // An unknown error occurred when uploading.\n    return res.status(500).send(err.message);\n  }\n});\n```\n\nThis way, any errors from Multer will be caught and returned to the user.\n\nSimilarly, I should add a general error handler for the app.\n\n```javascript\napp.use((err, req, res, next) => {\n  console.error(err.stack);\n  res.status(500).send('Something broke!');\n});\n```\n\nNow, I need to consider how to serve the uploaded and resized images to the user.\n\nCurrently, the resize endpoint just returns a message with the path to the resized image.\n\nBut it might be more useful to serve the image directly to the user.\n\nI can achieve this by using Express's `res.sendFile` method.\n\nHere's how I can modify the resize endpoint:\n\n```javascript\napp.get('/resize/:filename', (req, res) => {\n  const { filename } = req.params;\n  const { width, height } = req.query;\n\n  if (!width || !height) {\n    return res.status(400).send('Width and height are required.');\n  }\n\n  const widthInt = parseInt(width);\n  const heightInt = parseInt(height);\n\n  if (isNaN(widthInt) || isNaN(heightInt) || widthInt <= 0 || heightInt <= 0) {\n    return res.status(400).send('Width and height must be positive integers.');\n  }\n\n  const filenameBase = path.basename(filename);\n  const resizePath = path.join(resizedDir, `${filenameBase}-resized-${width}x${height}.jpg`);\n\n  // Check if the resized file already exists\n  if (fs.existsSync(resizePath)) {\n    res.sendFile(resizePath);\n  } else {\n    const uploadPath = path.join(__dirname, 'uploads', filenameBase);\n\n    // Check if the original file exists\n    if (!fs.existsSync(uploadPath)) {\n      return res.status(404).send('Original file not found.');\n    }\n\n    // Resize the image using Sharp\n    sharp(uploadPath)\n      .resize(widthInt, heightInt, { fit: 'inside' })\n      .toFile(resizePath)\n      .then(info => {\n        res.sendFile(resizePath);\n      })\n      .catch(err => {\n        res.status(500).send('Error resizing image.');\n      });\n  }\n});\n```\n\nNow, the resize endpoint will send the resized image file directly to the user.\n\nThis is more convenient for the user, as they can directly use the image in their application.\n\nSimilarly, I can create an endpoint to serve the original uploaded images.\n\n```javascript\napp.get('/uploads/:filename', (req, res) => {\n  const { filename } = req.params;\n  const uploadPath = path.join(__dirname, 'uploads', filename);\n\n  if (!fs.existsSync(uploadPath)) {\n    return res.status(404).send('File not found.');\n  }\n\n  res.sendFile(uploadPath);\n});\n```\n\nThis way, users can access both the original and resized images via their respective endpoints.\n\nI should also think about cleaning up the uploaded and resized files, especially if I'm running this server indefinitely.\n\nPerhaps implementing a mechanism to delete files after a certain period or when they are no longer needed.\n\nBut for now, I'll leave that out.\n\nAnother consideration is logging. It would be useful to log upload and resize activities for monitoring and debugging purposes.\n\nI can use the `morgan` middleware for HTTP request logging.\n\nFirst, I need to install it:\n\n```\nnpm install morgan\n```\n\nThen, I can set it up in my app:\n\n```javascript\nconst morgan = require('morgan');\n\napp.use(morgan('combined'));\n```\n\nThis will log requests to the console in a combined format.\n\nNow, I need to make sure that all the necessary modules are required at the top of the file.\n\nHere's the updated list of requires:\n\n```javascript\nconst express = require('express');\nconst multer = require('multer');\nconst sharp = require('sharp');\nconst path = require('path');\nconst fs = require('fs');\nconst morgan = require('morgan');\n```\n\nI should also ensure that the directories exist before starting the server.\n\nI can add code to create the uploads and resized directories if they don't already exist.\n\n```javascript\nconst uploadsDir = path.join(__dirname, 'uploads');\nconst resizedDir = path.join(__dirname, 'resized');\n\nif (!fs.existsSync(uploadsDir)) {\n  fs.mkdirSync(uploadsDir);\n}\n\nif (!fs.existsSync(resizedDir)) {\n  fs.mkdirSync(resizedDir);\n}\n```\n\nI can place this code at the top of the file, after requiring the necessary modules.\n\nFinally, I need to start the server.\n\n```javascript\napp.listen(port, () => {\n  console.log(`Server is running on port ${port}`);\n});\n```\n\nNow, I'll put all the code together in `index.js`.\n\nHere's the complete code:\n\n```javascript\nconst express = require('express');\nconst multer = require('multer');\nconst sharp = require('sharp');\nconst path = require('path');\nconst fs = require('fs');\nconst morgan = require('morgan');\n\nconst app = express();\nconst port = process.env.PORT || 3000;\n\n// Directory setup\nconst uploadsDir = path.join(__dirname, 'uploads');\nconst resizedDir = path.join(__dirname, 'resized');\n\nif (!fs.existsSync(uploadsDir)) {\n  fs.mkdirSync(uploadsDir);\n}\n\nif (!fs.existsSync(resizedDir)) {\n  fs.mkdirSync(resizedDir);\n}\n\n// Logging\napp.use(morgan('combined'));\n\n// Multer storage configuration\nconst upload = multer({\n  dest: uploadsDir,\n  limits: {\n    fileSize: 1000000 // 1MB limit\n  },\n  fileFilter(req, file, cb) {\n    if (!file.originalname.match(/\\.(jpg|jpeg)$/)) {\n      return cb(new Error('Only JPEG images are allowed!'));\n    }\n    cb(null, true);\n  }\n});\n\n// Upload endpoint\napp.post('/upload', upload.single('image'), (req, res) => {\n  if (!req.file) {\n    return res.status(400).send('No file uploaded.');\n  }\n  res.status(200).send(`File uploaded successfully: ${req.file.filename}`);\n}, (err, req, res, next) => {\n  if (err instanceof multer.MulterError) {\n    // A Multer error occurred when uploading.\n    return res.status(500).send(err.message);\n  } else if (err) {\n    // An unknown error occurred when uploading.\n    return res.status(500).send(err.message);\n  }\n});\n\n// Resize endpoint\napp.get('/resize/:filename', (req, res) => {\n  const { filename } = req.params;\n  const { width, height } = req.query;\n\n  if (!width || !height) {\n    return res.status(400).send('Width and height are required.');\n  }\n\n  const widthInt = parseInt(width);\n  const heightInt = parseInt(height);\n\n  if (isNaN(widthInt) || isNaN(heightInt) || widthInt <= 0 || heightInt <= 0) {\n    return res.status(400).send('Width and height must be positive integers.');\n  }\n\n  const filenameBase = path.basename(filename);\n  const resizePath = path.join(resizedDir, `${filenameBase}-resized-${width}x${height}.jpg`);\n\n  // Check if the resized file already exists\n  if (fs.existsSync(resizePath)) {\n    res.sendFile(resizePath);\n  } else {\n    const uploadPath = path.join(__dirname, 'uploads', filenameBase);\n\n    // Check if the original file exists\n    if (!fs.existsSync(uploadPath)) {\n      return res.status(404).send('Original file not found.');\n    }\n\n    // Resize the image using Sharp\n    sharp(uploadPath)\n      .resize(widthInt, heightInt, { fit: 'inside' })\n      .toFile(resizePath)\n      .then(info => {\n        res.sendFile(resizePath);\n      })\n      .catch(err => {\n        res.status(500).send('Error resizing image.');\n      });\n  }\n});\n\n// Serve original uploaded images\napp.get('/uploads/:filename', (req, res) => {\n  const { filename } = req.params;\n  const uploadPath = path.join(__dirname, 'uploads', filename);\n\n  if (!fs.existsSync(uploadPath)) {\n    return res.status(404).send('File not found.');\n  }\n\n  res.sendFile(uploadPath);\n});\n\n// Error handler\napp.use((err, req, res, next) => {\n  console.error(err.stack);\n  res.status(500).send('Something broke!');\n});\n\n// Start the server\napp.listen(port, () => {\n  console.log(`Server is running on port ${port}`);\n});\n```\n\nNow, I can test this server using tools like Postman or curl.\n\nFirst, start the server:\n\n```\nnode index.js\n```\n\nThen, upload an image:\n\n```\ncurl -X POST -H \"Content-Type: multipart/form-data\" -F \"image=@path/to/image.jpg\" http://localhost:3000/upload\n```\n\nThis should return a message like:\n\n```\nFile uploaded successfully: filename\n```\n\nNext, resize the image:\n\n```\ncurl -X GET \"http://localhost:3000/resize/filename?width=200&height=200\" -o resized_image.jpg\n```\n\nThis should download the resized image to `resized_image.jpg`.\n\nI need to make sure that the aspect ratio is maintained and that the image is correctly resized.\n\nAlso, I should test various scenarios, such as:\n\n- Uploading a non-JPEG file.\n\n- Specifying invalid dimensions.\n\n- Requesting a resize for a non-existent file.\n\n- Resizing an image multiple times with the same dimensions (to test caching).\n\n- Resizing an image with different dimensions.\n\nI should also check the file sizes and ensure that the resized images are smaller than the originals, as expected.\n\nAdditionally, I can consider adding more features, like:\n\n- Allowing different image formats.\n\n- Providing options for different resize fit modes (inside, cover, etc.).\n\n- Implementing authentication or API keys for accessing the endpoints.\n\n- Adding more robust logging and monitoring.\n\n- Implementing file expiration or automatic cleanup.\n\nBut for now, this should satisfy the initial requirements.\n\n## Final Solution\nTo create a Node.js Express server that handles uploading and resizing of JPEG images, follow these steps:\n\n### Prerequisites\n- Node.js installed on your machine.\n- Basic understanding of Node.js, Express, and command line operations.\n\n### Solution Code\n\n1. **Initialize Project:**\n   Create a new directory and initialize a Node.js project.\n   ```bash\n   mkdir image-resizer\n   cd image-resizer\n   npm init -y\n   ```\n\n2. **Install Dependencies:**\n   Install Express, Multer, Sharp, and Morgan.\n   ```bash\n   npm install express multer sharp morgan\n   ```\n\n3. **Set Up Directory Structure:**\n   Create directories for uploads and resized images.\n   ```bash\n   mkdir uploads resized\n   ```\n\n4. **Create `index.js`:**\n   Set up the server with endpoints for uploading and resizing images.\n\n   ```javascript\n   const express = require('express');\n   const multer = require('multer');\n   const sharp = require('sharp');\n   const path = require('path');\n   const fs = require('fs');\n   const morgan = require('morgan');\n\n   const app = express();\n   const port = process.env.PORT || 3000;\n\n   // Directory setup\n   const uploadsDir = path.join(__dirname, 'uploads');\n   const resizedDir = path.join(__dirname, 'resized');\n\n   if (!fs.existsSync(uploadsDir)) {\n     fs.mkdirSync(uploadsDir);\n   }\n\n   if (!fs.existsSync(resizedDir)) {\n     fs.mkdirSync(resizedDir);\n   }\n\n   // Logging\n   app.use(morgan('combined'));\n\n   // Multer storage configuration\n   const upload = multer({\n     dest: uploadsDir,\n     limits: {\n       fileSize: 1000000 // 1MB limit\n     },\n     fileFilter(req, file, cb) {\n       if (!file.originalname.match(/\\.(jpg|jpeg)$/)) {\n         return cb(new Error('Only JPEG images are allowed!'));\n       }\n       cb(null, true);\n     }\n   });\n\n   // Upload endpoint\n   app.post('/upload', upload.single('image'), (req, res) => {\n     if (!req.file) {\n       return res.status(400).send('No file uploaded.');\n     }\n     res.status(200).send(`File uploaded successfully: ${req.file.filename}`);\n   }, (err, req, res, next) => {\n     if (err instanceof multer.MulterError) {\n       return res.status(500).send(err.message);\n     } else if (err) {\n       return res.status(500).send(err.message);\n     }\n   });\n\n   // Resize endpoint\n   app.get('/resize/:filename', (req, res) => {\n     const { filename } = req.params;\n     const { width, height } = req.query;\n\n     if (!width || !height) {\n       return res.status(400).send('Width and height are required.');\n     }\n\n     const widthInt = parseInt(width);\n     const heightInt = parseInt(height);\n\n     if (isNaN(widthInt) || isNaN(heightInt) || widthInt <= 0 || heightInt <= 0) {\n       return res.status(400).send('Width and height must be positive integers.');\n     }\n\n     const filenameBase = path.basename(filename);\n     const resizePath = path.join(resizedDir, `${filenameBase}-resized-${width}x${height}.jpg`);\n\n     // Check if the resized file already exists\n     if (fs.existsSync(resizePath)) {\n       res.sendFile(resizePath);\n     } else {\n       const uploadPath = path.join(__dirname, 'uploads', filenameBase);\n\n       // Check if the original file exists\n       if (!fs.existsSync(uploadPath)) {\n         return res.status(404).send('Original file not found.');\n       }\n\n       // Resize the image using Sharp\n       sharp(uploadPath)\n         .resize(widthInt, heightInt, { fit: 'inside' })\n         .toFile(resizePath)\n         .then(info => {\n           res.sendFile(resizePath);\n         })\n         .catch(err => {\n           res.status(500).send('Error resizing image.');\n         });\n     }\n   });\n\n   // Serve original uploaded images\n   app.get('/uploads/:filename', (req, res) => {\n     const { filename } = req.params;\n     const uploadPath = path.join(__dirname, 'uploads', filename);\n\n     if (!fs.existsSync(uploadPath)) {\n       return res.status(404).send('File not found.');\n     }\n\n     res.sendFile(uploadPath);\n   });\n\n   // Error handler\n   app.use((err, req, res, next) => {\n     console.error(err.stack);\n     res.status(500).send('Something broke!');\n   });\n\n   // Start the server\n   app.listen(port, () => {\n     console.log(`Server is running on port ${port}`);\n   });\n   ```\n\n### Usage\n\n1. **Start the Server:**\n   ```bash\n   node index.js\n   ```\n\n2. **Upload an Image:**\n   Use a tool like Postman or cURL to send a POST request to `http://localhost:3000/upload` with a JPEG file in the form data.\n\n3. **Resize an Image:**\n   Make a GET request to `http://localhost:3000/resize/filename?width=200&height=200`, replacing `filename` with the name of the uploaded file and specifying the desired width and height.\n\nThis setup ensures that only JPEG images are uploaded, and resized images are cached to avoid redundant processing. Adjustments can be made for different image formats, additional error handling, or more features as needed."
    }
]