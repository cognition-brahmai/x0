[
    {
        "role": "user",
        "content": "Write a Python program that implements the Dijkstra's shortest path algorithm for a given graph represented as an adjacency matrix. The program should take the source node as input and output the shortest distance from the source to all other nodes in the graph."
    },
    {
        "role": "assistant",
        "content": "Sure! I can help you with that. Dijkstra's algorithm is a popular method for finding the shortest paths between nodes in a graph, which works particularly well for graphs with non-negative edge weights.\n\nTo implement Dijkstra's algorithm in Python, we'll need to follow these steps:\n\n1. **Initialization**: Set the distance to the source node as 0 and to all other nodes as infinity. Create a set to keep track of nodes that have already been visited.\n\n2. **Select the node with the smallest distance**: This will be the current node to explore.\n\n3. **Update distances**: For the current node, consider all its unvisited neighbors and calculate their tentative distances through the current node. If this new path's distance is less than the previously recorded distance, update the distance.\n\n4. **Mark the current node as visited**: Once all neighbors have been considered, mark the current node as visited.\n\n5. **Repeat steps 2-4** until all nodes have been visited or the smallest distance among the unvisited nodes is infinity (which means there are no connections left).\n\n6. **Output the distances**: Once done, print or return the distances from the source to all other nodes.\n\nLet's dive into the code. First, we need to represent the graph. Since you've specified an adjacency matrix, we'll use a 2D list where `graph[i][j]` represents the weight of the edge from node `i` to node `j`. If there is no edge, we'll represent it with a large number (indicating infinity).\n\nHere's a step-by-step implementation:\n\n```python\nimport sys\n\ndef dijkstra(graph, source):\n    n = len(graph)\n    distances = [sys.maxsize] * n  # Initialize distances to infinity\n    distances[source] = 0  # Distance from source to itself is 0\n    visited = [False] * n  # Track visited nodes\n    \n    for _ in range(n):\n        # Select the node with the smallest distance\n        min_distance = sys.maxsize\n        min_index = -1\n        for v in range(n):\n            if not visited[v] and distances[v] < min_distance:\n                min_distance = distances[v]\n                min_index = v\n        \n        # Mark the selected node as visited\n        visited[min_index] = True\n        \n        # Update distances of the adjacent vertices\n        for v in range(n):\n            if (\n                graph[min_index][v] != 0  # There is an edge\n                and not visited[v]  # The neighbor is not visited\n                and distances[v] > distances[min_index] + graph[min_index][v]\n            ):\n                distances[v] = distances[min_index] + graph[min_index][v]\n    \n    # Print the distances\n    print(\"Node\\tDistance from Source\")\n    for node in range(n):\n        print(f\"{node}\\t{distances[node]}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    # Example graph represented as an adjacency matrix\n    # graph = [\n    #     [0, 2, 0, 6, 0],\n    #     [2, 0, 3, 8, 5],\n    #     [0, 3, 0, 0, 7],\n    #     [6, 8, 0, 0, 9],\n    #     [0, 5, 7, 9, 0]\n    # ]\n    # Source node\n    # source = 0\n    # dijkstra(graph, source)\n    \n    # Uncomment the above lines and provide your own graph and source node\n    pass\n```\n\n### Explanation:\n\n1. **Initialization**:\n   - We set the distance to the source node as 0 and to all other nodes as `sys.maxsize` (which represents infinity).\n   - We maintain a list `visited` to keep track of nodes that have already been processed.\n\n2. **Select the node with the smallest distance**:\n   - In each iteration, we select the node with the smallest distance from the source that hasn't been visited yet.\n\n3. **Update distances**:\n   - For the selected node, we check all its neighbors. If the distance to a neighbor can be shortened by going through the current node, we update the distance.\n\n4. **Mark the node as visited**:\n   - Once all neighbors have been considered, we mark the node as visited.\n\n5. **Repeat**:\n   - We repeat the process until all nodes have been visited.\n\n6. **Output**:\n   - Finally, we print the distances from the source to all other nodes.\n\nYou can uncomment the example graph and source node in the `if __name__ == \"__main__\":` block to test the function. Make sure to provide your own adjacency matrix and source node as needed.\n\nThis implementation has a time complexity of O(V^2), where V is the number of vertices. For graphs with a large number of vertices, you might want to use a min-heap to improve the efficiency, but for simplicity, this implementation uses a list to track distances and visited nodes."
    }
]