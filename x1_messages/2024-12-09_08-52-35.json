[
    {
        "role": "user",
        "content": "Write a Python script that generates a random maze using Prim's algorithm. The maze should be represented as a 2D grid, where each cell can be either a wall or a path. Print the generated maze as ASCII art. PLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Sure, I can help you with that! Generating a maze using Prim's algorithm is an interesting application of the algorithm, which is typically used for finding minimum spanning trees in graphs. Here, we'll adapt it to create a maze.\n\nFirst, let's understand how Prim's algorithm can be used to generate a maze:\n\n1. **Initialization**: Consider each cell in the grid as a node in a graph. Walls between cells are the edges.\n2. **Start Point**: Choose a starting cell and mark it as part of the maze.\n3. **Frontier**: Maintain a list of walls that are between explored and unexplobed cells (the frontier).\n4. **Expansion**: Randomly select a wall from the frontier. If the adjacent cell on the other side of the wall hasn't been visited yet, remove the wall and mark the new cell as part of the maze. Add the new cell's walls to the frontier.\n5. **Repeat**: Continue this process until there are no walls left in the frontier.\n\nThis method ensures that the maze is a perfect maze, meaning there are no loops and exactly one path between any two cells.\n\nNow, let's implement this in Python. We'll represent the maze as a 2D grid, where each cell can be either a wall or a path. For simplicity, we'll use characters to represent the maze cells: let's say '#' for walls and ' ' (space) for paths.\n\nHere's a step-by-step breakdown of the implementation:\n\n- **Step 1**: Initialize the grid with all walls.\n- **Step 2**: Choose a starting cell and mark it as a path.\n- **Step 3**: Collect all walls adjacent to the starting cell.\n- **Step 4**: While there are walls in the frontier:\n  - Pick a random wall from the frontier.\n  - If the adjacent cell is unvisited:\n    - Remove the wall.\n    - Mark the new cell as a path.\n    - Add the new cell's walls to the frontier.\n  - Remove the wall from the frontier.\n- **Step 5**: Print the maze in ASCII art.\n\nTo handle the grid and the frontier efficiently, we'll need to keep track of cell positions and their adjacent walls. We'll represent each wall by the positions of the cells it separates.\n\nLet's proceed to write the code accordingly.\n\n## Final Solution\nTo generate a random maze using Prim's algorithm and print it as ASCII art, we can follow these steps:\n\n1. Initialize the grid with all walls.\n2. Choose a starting cell and mark it as a path.\n3. Collect all walls adjacent to the starting cell.\n4. While there are walls in the frontier:\n   - Pick a random wall from the frontier.\n   - If the adjacent cell is unvisited:\n     - Remove the wall.\n     - Mark the new cell as a path.\n     - Add the new cell's walls to the frontier.\n   - Remove the wall from the frontier.\n5. Print the maze in ASCII art.\n\nHere's the Python code to achieve this:\n\n```python\nimport random\n\ndef generate_maze(width, height):\n    # Initialize the grid with walls\n    maze = [['#'] * (2 * width + 1) for _ in range(2 * height + 1)]\n    \n    def is_inside(x, y):\n        return 0 < x < width and 0 < y < height\n    \n    def get_walls(x, y):\n        walls = []\n        if x > 0:\n            walls.append(((x, y), (x - 1, y)))\n        if x < width - 1:\n            walls.append(((x, y), (x + 1, y)))\n        if y > 0:\n            walls.append(((x, y), (x, y - 1)))\n        if y < height - 1:\n            walls.append(((x, y), (x, y + 1)))\n        return walls\n    \n    # Choose a starting cell\n    start_x, start_y = random.randint(0, width - 1), random.randint(0, height - 1)\n    maze[2 * start_y + 1][2 * start_x + 1] = ' '\n    frontier = get_walls(start_x, start_y)\n    \n    while frontier:\n        wall = random.choice(frontier)\n        (x1, y1), (x2, y2) = wall\n        if not is_inside(x2, y2) or maze[2 * y2 + 1][2 * x2 + 1] == '#':\n            # Remove the wall\n            mx, my = min(x1, x2), min(y1, y2)\n            maze[2 * my + 1 + abs(y1 - y2)][2 * mx + 1 + abs(x1 - x2)] = ' '\n            # Mark the new cell as a path\n            maze[2 * y2 + 1][2 * x2 + 1] = ' '\n            # Add the new cell's walls to the frontier\n            frontier.extend(get_walls(x2, y2))\n        # Remove the wall from the frontier\n        frontier.remove(wall)\n    \n    return maze\n\ndef print_maze(maze):\n    for row in maze:\n        print(''.join(row))\n\nif __name__ == \"__main__\":\n    width = 10  # Adjust the width of the maze\n    height = 10  # Adjust the height of the maze\n    maze = generate_maze(width, height)\n    print_maze(maze)\n```\n\n### Explanation:\n1. **Grid Initialization**: We create a grid of walls using `#` characters.\n2. **Starting Cell**: A random cell is chosen as the starting point and marked as a path (` `).\n3. **Frontier Management**: We maintain a list of walls adjacent to explored cells.\n4. **Maze Generation**:\n   - Randomly select a wall from the frontier.\n   - If the adjacent cell is unvisited, remove the wall and mark the cell as a path.\n   - Add the new cell's walls to the frontier.\n5. **Printing the Maze**: The maze is printed as ASCII art using characters for walls and paths."
    }
]