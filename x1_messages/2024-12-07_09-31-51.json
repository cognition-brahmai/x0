[
    {
        "role": "user",
        "content": "Implement a simple LRU (Least Recently Used) cache in Python that supports get and put operations with O(1) time complexity.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Implementing an LRU (Least Recently Used) cache in Python that supports get and put operations with O(1) time complexity requires careful consideration of data structures. The combination of a dictionary and a doubly-linked list is commonly used to achieve this efficiency.\n\n### Approach\n\n1. **Dictionary:** This will store keys mapped to their corresponding nodes in the doubly-linked list, allowing O(1) access to any node.\n2. **Doubly-Linked List:** This will maintain the order of elements based on their usage. The least recently used item will be at the head, and the most recently used will be at the tail.\n\n### Solution Code\n\n```python\nclass ListNode:\n    def __init__(self, key=0, value=0):\n        self.key = key\n        self.value = value\n        self.prev = None\n        self.next = None\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = {}\n        self.size = 0\n        self.head = ListNode()  # Dummy head node\n        self.tail = ListNode()  # Dummy tail node\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    def _remove_node(self, node):\n        prev_node = node.prev\n        next_node = node.next\n        prev_node.next = next_node\n        next_node.prev = prev_node\n\n    def _add_node(self, node):\n        # Add new node right before the tail\n        prev_node = self.tail.prev\n        prev_node.next = node\n        node.prev = prev_node\n        node.next = self.tail\n        self.tail.prev = node\n\n    def get(self, key: int) -> int:\n        if key in self.cache:\n            node = self.cache[key]\n            # Move the accessed node to the end (most recently used)\n            self._remove_node(node)\n            self._add_node(node)\n            return node.value\n        return -1\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            # Update the value and move to the end (most recently used)\n            node = self.cache[key]\n            node.value = value\n            self._remove_node(node)\n            self._add_node(node)\n        else:\n            new_node = ListNode(key, value)\n            self.cache[key] = new_node\n            self._add_node(new_node)\n            self.size += 1\n            if self.size > self.capacity:\n                # Remove the least recently used node (head's next)\n                lru_node = self.head.next\n                self._remove_node(lru_node)\n                del self.cache[lru_node.key]\n                self.size -= 1\n```\n\n### Explanation\n\n1. **Initialization:**\n   - `capacity`: The maximum number of items the cache can hold.\n   - `cache`: A dictionary to store keys mapped to their corresponding `ListNode` objects.\n   - `size`: Current number of items in the cache.\n   - `head` and `tail`: Dummy nodes to simplify adding and removing nodes.\n\n2. **Get Operation:**\n   - If the key exists in the cache, retrieve the node and move it to the end of the list (most recently used) by first removing it and then adding it back.\n   - If the key does not exist, return -1.\n\n3. **Put Operation:**\n   - If the key already exists, update its value and move the node to the end of the list.\n   - If the key does not exist, create a new node and add it to the cache and the list.\n   - If the cache exceeds its capacity after adding the new node, remove the least recently used node (the node after the head)."
    }
]