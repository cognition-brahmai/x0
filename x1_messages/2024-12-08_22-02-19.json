[
    {
        "role": "user",
        "content": "Write a Ruby script that parses an XML document representing a family tree and outputs the data as a nested dictionary (hash) structure."
    },
    {
        "role": "assistant",
        "content": "Certainly! To parse an XML document representing a family tree and output it as a nested dictionary (hash) in Ruby, you can use the Nokogiri gem, which is a powerful and flexible gem for working with XML and HTML documents.\n\nFirst, make sure you have Nokogiri installed. You can add it to your Gemfile or install it via the command line:\n\n```sh\ngem install nokogiri\n```\n\nNext, let's assume your XML document looks something like this:\n\n```xml\n<family>\n  <person id=\"1\" name=\"John\" spouse=\"2\">\n    <child id=\"3\" name=\"Alice\"/>\n    <child id=\"4\" name=\"Bob\"/>\n  </person>\n  <person id=\"2\" name=\"Jane\" spouse=\"1\"/>\n  <person id=\"3\" name=\"Alice\" parent=\"1\"/>\n  <person id=\"4\" name=\"Bob\" parent=\"1\"/>\n</family>\n```\n\nIn this XML, each `<person>` element represents a family member, with attributes for their ID, name, spouse, and children.\n\nNow, let's write a Ruby script to parse this XML and convert it into a nested hash structure.\n\n## Final Solution\nTo achieve this, we will use the Nokogiri gem to parse the XML document and then construct a nested hash that represents the family tree structure.\n\n### Approach\n1. **Parse the XML**: Use Nokogiri to load and parse the XML document.\n2. **Create Person Hashes**: For each `<person>` element, create a hash with keys for `id`, `name`, `spouse`, and `children`.\n3. **Build Relationships**: Use the attributes to establish relationships between persons, such as spouses and children.\n4. **Output the Result**: Print the resulting nested hash structure.\n\n### Solution Code\n\n```ruby\nrequire 'nokogiri'\n\ndef parse_family_tree(xml_content)\n  # Parse the XML content\n  doc = Nokogiri::XML(xml_content)\n\n  # Initialize a hash to store person data\n  persons = {}\n\n  # Iterate over each <person> element\n  doc.xpath('//person').each do |person_element|\n    id = person_element.attribute('id').value\n    name = person_element.attribute('name').value\n    spouse_id = person_element.attribute('spouse')&.value\n    children = person_element.xpath('child').map { |child| child.attribute('id').value }\n\n    # Create person hash\n    person = {\n      id: id,\n      name: name,\n      spouse: spouse_id,\n      children: children\n    }\n\n    # Add person to the persons hash\n    persons[id] = person\n  end\n\n  # Resolve spouse references\n  persons.each do |id, person|\n    if person[:spouse]\n      spouse = persons[person[:spouse]]\n      person[:spouse] = spouse unless spouse.nil?\n    end\n  end\n\n  # Resolve children references\n  persons.each do |id, person|\n    person[:children] = person[:children].map { |child_id| persons[child_id] }\n  end\n\n  # Find the root of the family tree (person with no parent)\n  root_id = nil\n  persons.each do |id, person|\n    if person[:parent].nil?\n      root_id = id\n      break\n    end\n  end\n\n  # Return the root person\n  persons[root_id]\nend\n\n# Example usage\nxml_content = <<-XML\n<family>\n  <person id=\"1\" name=\"John\" spouse=\"2\">\n    <child id=\"3\" name=\"Alice\"/>\n    <child id=\"4\" name=\"Bob\"/>\n  </person>\n  <person id=\"2\" name=\"Jane\" spouse=\"1\"/>\n  <person id=\"3\" name=\"Alice\" parent=\"1\"/>\n  <person id=\"4\" name=\"Bob\" parent=\"1\"/>\n</family>\nXML\n\nfamily_tree = parse_family_tree(xml_content)\nputs family_tree\n```\n\n### Explanation\n1. **Parsing the XML**: We use Nokogiri to parse the XML content.\n2. **Creating Person Hashes**: For each `<person>` element, we extract attributes and create a hash representing the person.\n3. **Resolving Relationships**:\n   - **Spouse**: Replace the spouse ID with the actual spouse hash.\n   - **Children**: Replace child IDs with their corresponding hashes.\n4. **Finding the Root**: Identify the root of the family tree (person with no parent) and return their hash.\n\nThis approach ensures that the family tree is represented as a nested hash, making it easy to navigate relationships between family members."
    }
]