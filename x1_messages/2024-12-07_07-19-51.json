[
    {
        "role": "user",
        "content": "Write a Golang program that creates a WebSocket server that allows multiple clients to connect and send messages to each other. The server should broadcast incoming messages to all connected clients and maintain a history of the last 100 messages.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Alright, I'm going to try to write a Go program that sets up a WebSocket server. This server should let multiple clients connect and send messages that get broadcasted to all other connected clients. Also, it needs to keep a history of the last 100 messages.\n\nFirst, I need to make sure I have the right packages. For WebSockets in Go, the \"github.com/gorilla/websocket\" package is commonly used. I should import that.\n\nI'll also need some standard libraries like \"net/http\" for handling HTTP connections, and maybe \"sync\" for synchronization if needed.\n\nSo, the imports might look like this:\n\n```go\nimport (\n    \"github.com/gorilla/websocket\"\n    \"net/http\"\n    \"sync\"\n)\n```\n\nNext, I need to set up a list to hold the connections of all connected clients. Since multiple goroutines will be accessing this list, I should use a mutex to handle concurrent access.\n\nMaybe something like this:\n\n```go\ntype client struct {\n    conn *websocket.Conn\n    send chan []byte\n}\n\nvar (\n    clients    = make(map[*client]bool)\n    broadcast  = make(chan []byte)\n    register   = make(chan *client)\n    unregister = make(chan *client)\n    mu         sync.Mutex\n)\n```\n\nHere, I'm defining a client struct that holds the WebSocket connection and a channel for sending messages to the client.\n\nI have channels for registering new clients, unregistering them, and broadcasting messages.\n\nI need to handle these channels in a separate goroutine.\n\nLet me think about the message history. I need to keep the last 100 messages. I can use a slice for this and append new messages to it, and when it exceeds 100, remove the oldest one.\n\nSomething like:\n\n```go\nvar messages []string\nconst maxHistory = 100\n```\n\nWhen a new message comes in, I'll add it to the slice and if the slice length exceeds 100, remove the first element.\n\nBut actually, since I'm broadcasting bytes, maybe I should keep the messages as []byte.\n\nSo:\n\n```go\nvar messages = make([][]byte, 0, maxHistory)\n```\n\nAnd when adding a new message:\n\n```go\nmessages = append(messages, msg)\nif len(messages) > maxHistory {\n    messages = messages[1:]\n}\n```\n\nOkay, now for the server setup.\n\nI need to upgrade HTTP requests to WebSocket connections.\n\nI can use the gorilla websocket Upgrader for this.\n\nHere's an example of how to set it up:\n\n```go\nvar upgrader = websocket.Upgrader{\n    ReadBufferSize:  1024,\n    WriteBufferSize: 1024,\n    CheckOrigin: func(r *http.Request) bool {\n        return true\n    },\n}\n```\n\nI need to handle the WebSocket endpoint, probably \"/ws\", and upgrade the connection there.\n\nIn the handler, I'll accept the connection, add the client to the map, and start pumping messages to and from the client.\n\nSomething like:\n\n```go\nfunc handleConnections(w http.ResponseWriter, r *http.Request) {\n    ws, err := upgrader.Upgrade(w, r, nil)\n    if err != nil {\n        log.Fatal(err)\n    }\n    client := &client{conn: ws, send: make(chan []byte, 256)}\n    register <- client\n\n    go client.writePump()\n}\n\nfunc writePump() {\n    for {\n        select {\n        case message, ok := <-send:\n            if !ok {\n                // The send channel was closed, so stop pumping.\n                return\n            }\n            if err := conn.WriteMessage(websocket.TextMessage, message); err != nil {\n                return\n            }\n        }\n    }\n}\n```\n\nAlso, I need to handle unregistering clients when they disconnect.\n\nI should have a readPump function that reads messages from the client and broadcasts them.\n\nLike:\n\n```go\nfunc readPump() {\n    defer func() {\n        unregister <- client\n        conn.Close()\n    }()\n    for {\n        _, message, err := conn.ReadMessage()\n        if err != nil {\n            return\n        }\n        broadcast <- message\n    }\n}\n```\n\nAnd in the main server loop, I need to handle registering, unregistering, and broadcasting.\n\nMaybe in a separate goroutine:\n\n```go\ngo func() {\n    for {\n        select {\n        case client := <-register:\n            mu.Lock()\n            clients[client] = true\n            for _, msg := range messages {\n                client.send <- msg\n            }\n            mu.Unlock()\n        case client := <-unregister:\n            mu.Lock()\n            delete(clients, client)\n            mu.Unlock()\n        case message := <-broadcast:\n            mu.Lock()\n            messages = append(messages, message)\n            if len(messages) > maxHistory {\n                messages = messages[1:]\n            }\n            for client := range clients {\n                select {\n                case client.send <- message:\n                default:\n                    delete(clients, client)\n                }\n            }\n            mu.Unlock()\n        }\n    }\n}()\n```\n\nWait, in the register case, I'm sending the history to the new client.\n\nThat makes sense.\n\nAlso, in the unregister case, I'm removing the client from the map.\n\nIn the broadcast case, I'm updating the message history and sending the message to all clients.\n\nI think that covers the basics.\n\nI need to make sure that the client's send channel doesn't block forever if the client is not reading.\n\nThat's why in the broadcast case, I have a select with a default case to handle when the send channel is full.\n\nIf the send fails, I remove the client.\n\nI should also handle client disconnections properly in the readPump and writePump functions.\n\nMaybe set a timeout or something.\n\nAlso, I need to make sure that the client's send channel is closed when the client disconnects.\n\nIn the unregister case, I should close the send channel.\n\nLike:\n\n```go\ncase client := <-unregister:\n    mu.Lock()\n    delete(clients, client)\n    close(client.send)\n    mu.Unlock()\n```\n\nAnd in the writePump function, when the send channel is closed, exit the loop.\n\nI think that should handle most cases.\n\nLet me think about error handling.\n\nI should log errors instead of just returning.\n\nAlso, maybe I can send error messages back to the client.\n\nBut for simplicity, I'll just log them for now.\n\nI need to set up the HTTP server and start listening on a port.\n\nProbably port 8080 or something.\n\nLike:\n\n```go\nhttp.HandleFunc(\"/ws\", handleConnections)\nlog.Fatal(http.ListenAndServe(\":8080\", nil))\n```\n\nI should also consider using environment variables for the port.\n\nBut for now, hardcoding is fine.\n\nLet me think about security.\n\nThe Upgrader has a CheckOrigin function, which I've set to always return true.\n\nIn a production setting, I should restrict this to allowed origins.\n\nBut for this example, it's okay.\n\nI think that's a basic implementation.\n\nI can test it by using websocket clients like websocket-client in the browser or tools like wrk for load testing.\n\nI should also think about scaling and performance, but for now, this should suffice.\n\nI might need to add more features like user authentication or message formatting, but that's beyond the scope of this task.\n\nSo, summarizing the steps:\n\n1. Import necessary packages.\n\n2. Define data structures for clients and message history.\n\n3. Set up channels for registering, unregistering clients, and broadcasting messages.\n\n4. Create an Upgrader for WebSocket connections.\n\n5. Handle WebSocket connections, registering and unregistering clients.\n\n6. Pump messages to and from clients.\n\n7. Broadcast incoming messages to all clients and maintain message history.\n\nI need to write the actual code accordingly.\n\n## Final Solution\nTo create a WebSocket server in Golang that allows multiple clients to connect and send messages to each other, while maintaining a history of the last 100 messages, you can follow the steps below.\n\n### Solution Code\n\n```go\npackage main\n\nimport (\n\t\"log\"\n\t\"net/http\"\n\t\"sync\"\n\n\t\"github.com/gorilla/websocket\"\n)\n\nvar (\n\tupgrader = websocket.Upgrader{\n\t\tReadBufferSize:  1024,\n\t\tWriteBufferSize: 1024,\n\t\tCheckOrigin: func(r *http.Request) bool {\n\t\t\treturn true\n\t\t},\n\t}\n\tclients    = make(map[*client]bool)\n\tbroadcast  = make(chan []byte)\n\tregister   = make(chan *client)\n\tunregister = make(chan *client)\n\tmessages   = make([][]byte, 0, 100)\n\tmu         sync.Mutex\n)\n\ntype client struct {\n\tconn *websocket.Conn\n\tsend chan []byte\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/ws\", handleConnections)\n\tgo serverLoop()\n\tlog.Fatal(http.ListenAndServe(\":8080\", nil))\n}\n\nfunc handleConnections(w http.ResponseWriter, r *http.Request) {\n(ws, err := upgrader.Upgrade(w, r, nil)\nif err != nil {\n\tlog.Println(\"Error upgrading to WebSocket:\", err)\n\treturn\n}\n\nclient := &client{conn: ws, send: make(chan []byte, 256)}\nregister <- client\n\ngo client.writePump()\ngo client.readPump()\n}\n\nfunc serverLoop() {\n\tfor {\n\t\tselect {\n\t\tcase client := <-register:\n\t\t\tmu.Lock()\n\t\t\tclients[client] = true\n\t\t\tfor _, msg := range messages {\n\t\t\t\tclient.send <- msg\n\t\t\t}\n\t\t\tmu.Unlock()\n\t\tcase client := <-unregister:\n\t\t\tmu.Lock()\n\t\t\tdelete(clients, client)\n\t\t\tclose(client.send)\n\t\t\tmu.Unlock()\n\t\tcase message := <-broadcast:\n\t\t\tmu.Lock()\n\t\t\tmessages = append(messages, message)\n\t\t\tif len(messages) > 100 {\n\t\t\t\tmessages = messages[1:]\n\t\t\t}\n\t\t\tfor client := range clients {\n\t\t\t\tselect {\n\t\t\t\tcase client.send <- message:\n\t\t\t\tdefault:\n\t\t\t\t\tdelete(clients, client)\n\t\t\t\t}\n\t\t\t}\n\t\t\tmu.Unlock()\n\t\t}\n\t}\n}\n\nfunc (c *client) readPump() {\n\tdefer func() {\n\t\tunregister <- c\n\t\tc.conn.Close()\n\t}()\n\tfor {\n\t\t_, message, err := c.conn.ReadMessage()\n\t\tif err != nil {\n\t\t\tlog.Println(\"Read error:\", err)\n\t\t\tbreak\n\t\t}\n\t\tbroadcast <- message\n\t}\n}\n\nfunc (c *client) writePump() {\n\tdefer func() {\n\t\tclose(c.send)\n\t\tc.conn.Close()\n\t}()\n\tfor {\n\t\tselect {\n\t\tcase message, ok := <-c.send:\n\t\t\tif !ok {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif err := c.conn.WriteMessage(websocket.TextMessage, message); err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n### Explanation\n\n1. **Imports and Setup**:\n   - Import necessary packages, including `github.com/gorilla/websocket` for WebSocket handling.\n   - Define channels for registering and unregistering clients, as well as broadcasting messages.\n   - Create a buffer to hold the last 100 messages.\n\n2. **Client Structure**:\n   - Define a `client` struct to hold each client's WebSocket connection and a channel for sending messages.\n\n3. **Upgrader Configuration**:\n   - Configure the WebSocket upgrader to handle incoming HTTP requests and upgrade them to WebSocket connections.\n\n4. **HTTP Handler**:\n   - Set up an HTTP handler for the \"/ws\" endpoint to manage WebSocket connections.\n   - Register new clients and start pump routines for reading from and writing to the client.\n\n5. **Server Loop**:\n   - Manage client registrations, unregistrations, and message broadcasts.\n   - Maintain a history of the last 100 messages and broadcast incoming messages to all connected clients.\n\n6. **Client Routines**:\n   - `readPump`: Read messages from the client and broadcast them.\n   - `writePump`: Send messages to the client from the send channel.\n\nThis setup ensures that multiple clients can connect to the server, send messages to each other, and have access to a history of recent messages."
    }
]