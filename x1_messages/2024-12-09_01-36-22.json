[
    {
        "role": "user",
        "content": "Create a Java program that simulates a simple chat server using WebSockets. The server should support multiple clients, broadcast messages to all connected clients, and allow clients to set their display names.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Sure! I can help you create a simple chat server using WebSockets in Java. We'll use the Java API for WebSocket, which is part of the Java EE platform but can also be used in standalone applications with some additional setup.\n\nHere's a step-by-step guide to creating this chat server:\n\n### Step 1: Set Up the Project\n\nFirst, you need to set up a Java project. You can use any IDE like IntelliJ IDEA or Eclipse. For this example, I'll assume you're using Maven for dependency management.\n\nAdd the following dependencies to your `pom.xml`:\n\n```xml\n<dependencies>\n    <!-- WebSocket API -->\n    <dependency>\n        <groupId>javax.websocket</groupId>\n        <artifactId>javax.websocket-api</artifactId>\n        <version>1.1</version>\n    </dependency>\n    <!-- Servlet API for embedding the server -->\n    <dependency>\n        <groupId>javax.servlet</groupId>\n        <artifactId>javax.servlet-api</artifactId>\n        <version>3.1.0</version>\n        <scope>provided</scope>\n    </dependency>\n    <!-- Jetty for embedding a WebSocket server -->\n    <dependency>\n        <groupId>org.eclipse.jetty</groupId>\n        <artifactId>jetty-websocket</artifactId>\n        <version>9.4.35.v20201120</version>\n    </dependency>\n    <dependency>\n        <groupId>org.eclipse.jetty</groupId>\n        <artifactId>jetty-server</artifactId>\n        <version>9.4.35.v20201120</version>\n    </dependency>\n</dependencies>\n```\n\n### Step 2: Create the WebSocket Endpoint\n\nCreate a class that will handle WebSocket connections. This class will manage client connections, broadcast messages, and handle display names.\n\n```java\nimport javax.websocket.OnClose;\nimport javax.websocket.OnError;\nimport javax.websocket.OnMessage;\nimport javax.websocket.OnOpen;\nimport javax.websocket.Session;\nimport javax.websocket.server.ServerEndpoint;\nimport java.io.IOException;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Set;\n\n@ServerEndpoint(\"/chat\")\npublic class ChatServer {\n\n    // Set of all connected sessions\n    private static Set<Session> sessions = Collections.synchronizedSet(new HashSet<>());\n\n    @OnOpen\n    public void onOpen(Session session) {\n        sessions.add(session);\n        System.out.println(\"New connection: \" + session.getId());\n    }\n\n    @OnMessage\n    public void onMessage(String message, Session session) {\n        System.out.println(\"Message from \" + session.getId() + \": \" + message);\n        // Broadcast the message to all connected clients\n        broadcast(message, session);\n    }\n\n    @OnClose\n    public void onClose(Session session) {\n        sessions.remove(session);\n        System.out.println(\"Connection closed: \" + session.getId());\n    }\n\n    @OnError\n    public void onError(Session session, Throwable throwable) {\n        System.out.println(\"Error on session \" + session.getId());\n        throwable.printStackTrace();\n    }\n\n    private void broadcast(String message, Session excludeSession) {\n        synchronized (sessions) {\n            for (Session session : sessions) {\n                if (session != excludeSession && session.isOpen()) {\n                    try {\n                        session.getBasicRemote().sendText(message);\n                    } catch (IOException e) {\n                        System.out.println(\"Error broadcasting message to session \" + session.getId());\n                        e.printStackTrace();\n                    }\n                }\n            }\n        }\n    }\n}\n```\n\n### Step 3: Embed a WebSocket Server\n\nTo run the WebSocket server, we'll use Jetty, which is a popular servlet container that supports WebSockets.\n\nCreate a class to start the server:\n\n```java\nimport org.eclipse.jetty.server.Server;\nimport org.eclipse.jetty.servlet.ServletContextHandler;\nimport org.eclipse.jetty.websocket.jsr356.server.deploy.WebSocketServerContainerInitializer;\n\npublic class WebSocketServer {\n\n    public static void main(String[] args) {\n        Server server = new Server(8080);\n\n        ServletContextHandler context = new ServletContextHandler(ServletContextHandler.SESSIONS);\n        context.setContextPath(\"/\");\n        server.setHandler(context);\n\n        try {\n            WebSocketServerContainerInitializer.configure(context, null);\n            server.start();\n            server.join();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n### Step 4: Run the Server\n\nCompile and run your `WebSocketServer` class. The server should start on port 8080, and your chat server will be accessible at `ws://localhost:8080/chat`.\n\n### Step 5: Create a Simple Client\n\nTo test your chat server, you can create a simple HTML page with JavaScript to connect to the WebSocket server.\n\nCreate an `index.html` file:\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Chat Client</title>\n</head>\n<body>\n    <div>\n        <input type=\"text\" id=\"displayName\" placeholder=\"Display Name\">\n        <button onclick=\"setDisplayName()\">Set Display Name</button>\n    </div>\n    <div>\n        <input type=\"text\" id=\"message\" placeholder=\"Message\">\n        <button onclick=\"sendMessage()\">Send</button>\n    </div>\n    <ul id=\"chatMessages\"></ul>\n\n    <script>\n        const socket = new WebSocket('ws://localhost:8080/chat');\n        const chatMessages = document.getElementById('chatMessages');\n\n        socket.onmessage = function(event) {\n            const li = document.createElement('li');\n            li.textContent = event.data;\n            chatMessages.appendChild(li);\n        };\n\n        function setDisplayName() {\n            const displayName = document.getElementById('displayName').value;\n            socket.send(`SetName:${displayName}`);\n        }\n\n        function sendMessage() {\n            const message = document.getElementById('message').value;\n            socket.send(message);\n        }\n    </script>\n</body>\n</html>\n```\n\n### Step 6: Handle Display Names\n\nModify the `ChatServer` class to handle display names. When a client sets a display name, store it and prepend the name to messages sent by that client.\n\nUpdate the `ChatServer` class:\n\n```java\nimport javax.websocket.OnClose;\nimport javax.websocket.OnError;\nimport javax.websocket.OnMessage;\nimport javax.websocket.OnOpen;\nimport javax.websocket.Session;\nimport javax.websocket.server.ServerEndpoint;\nimport java.io.IOException;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\n@ServerEndpoint(\"/chat\")\npublic class ChatServer {\n\n    // Map of sessions to display names\n    private static Map<Session, String> displayNames = new ConcurrentHashMap<>();\n\n    // Set of all connected sessions\n    private static Set<Session> sessions = Collections.synchronizedSet(new HashSet<>());\n\n    @OnOpen\n    public void onOpen(Session session) {\n        sessions.add(session);\n        displayNames.put(session, \"Anonymous\");\n        System.out.println(\"New connection: \" + session.getId());\n    }\n\n    @OnMessage\n    public void onMessage(String message, Session session) {\n        if (message.startsWith(\"SetName:\")) {\n            String displayName = message.substring(8);\n            displayNames.put(session, displayName);\n            System.out.println(\"Set display name for \" + session.getId() + \" to \" + displayName);\n        } else {\n            String senderName = displayNames.get(session);\n            String broadcastMessage = senderName + \": \" + message;\n            System.out.println(\"Message from \" + senderName + \": \" + message);\n            // Broadcast the message to all connected clients\n            broadcast(broadcastMessage, session);\n        }\n    }\n\n    @OnClose\n    public void onClose(Session session) {\n        sessions.remove(session);\n        String displayName = displayNames.remove(session);\n        System.out.println(\"Connection closed: \" + displayName + \" (\" + session.getId() + \")\");\n    }\n\n    @OnError\n    public void onError(Session session, Throwable throwable) {\n        System.out.println(\"Error on session \" + session.getId());\n        throwable.printStackTrace();\n    }\n\n    private void broadcast(String message, Session excludeSession) {\n        synchronized (sessions) {\n            for (Session session : sessions) {\n                if (session != excludeSession && session.isOpen()) {\n                    try {\n                        session.getBasicRemote().sendText(message);\n                    } catch (IOException e) {\n                        System.out.println(\"Error broadcasting message to session \" + session.getId());\n                        e.printStackTrace();\n                    }\n                }\n            }\n        }\n    }\n}\n```\n\n### Step 7: Test the Chat Server\n\n1. Start the `WebSocketServer` class.\n2. Open multiple browser tabs or windows with `index.html`.\n3. Set display names for each client.\n4. Send messages and observe that they are broadcast to all connected clients, prefixed with the sender's display name.\n\nThat's it! You've created a simple chat server using WebSockets in Java that supports multiple clients, broadcasts messages, and allows setting display names."
    }
]