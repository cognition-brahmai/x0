[
    {
        "role": "user",
        "content": "Write a C++ program that implements a simple stack data structure with push, pop, and peek operations. Include exception handling for cases when the stack is empty or full.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Alright, I'm going to write a C++ program that implements a simple stack data structure with push, pop, and peek operations. I'll also include exception handling for cases when the stack is empty or full.\n\nFirst, I need to understand what a stack is. A stack is a linear data structure that follows the Last In, First Out (LIFO) principle, meaning the last element added to the stack is the first one to be removed.\n\nI'll need to create a class for the stack, let's call it `Stack`. This class should have private members to store the stack elements and keep track of the top of the stack. I'll also need to decide on the size of the stack. Since the user wants to handle the case when the stack is full, I'll make it a fixed-size stack.\n\nLet me think about the operations:\n\n1. **Push**: Adds an element to the top of the stack. If the stack is full, it should handle that exception.\n\n2. **Pop**: Removes the element from the top of the stack and returns it. If the stack is empty, it should handle that exception.\n\n3. **Peek**: Returns the element at the top of the stack without removing it. Again, if the stack is empty, handle the exception.\n\nI need to implement exception handling for both empty and full stack scenarios. In C++, I can use the standard exception classes or create custom exceptions.\n\nMaybe I'll create two custom exceptions: `StackEmptyException` and `StackFullException`. This way, I can provide more meaningful error messages.\n\nAlright, let's start by defining the custom exceptions.\n\nI can define these exceptions by deriving them from the standard `std::exception` class.\n\nHere's how I can define them:\n\n```cpp\nclass StackEmptyException : public std::exception {\npublic:\n    const char* what() const throw() {\n        return \"Stack is empty\";\n    }\n};\n\nclass StackFullException : public std::exception {\npublic:\n    const char* what() const throw() {\n        return \"Stack is full\";\n    }\n};\n```\n\nNext, I'll define the `Stack` class.\n\nI need to decide on the data type that the stack will hold. For simplicity, let's assume it's a stack of integers.\n\nI'll also need to set a fixed size for the stack. I can make this a constant or allow it to be set at creation time. To keep it simple, I'll make it a constant for now.\n\nLet's set the stack size to, say, 100. But I should make it flexible, so maybe I'll allow the user to specify the size when creating a Stack object.\n\nOkay, so the `Stack` class will have:\n\n- A private integer array to hold the stack elements.\n\n- A private integer variable to keep track of the top of the stack.\n\n- A constructor that initializes the top to -1 (indicating an empty stack) and sets the size of the stack.\n\n- Public methods: push, pop, peek.\n\n- Exception handling in push and pop methods.\n\nLet me sketch out the class structure:\n\n```cpp\nclass Stack {\nprivate:\n    static const int MAX_SIZE = 100; // or allow size to be set via constructor\n    int arr[MAX_SIZE];\n    int top;\n\npublic:\n    Stack() : top(-1) {}\n\n    void push(int value) {\n        if (top >= MAX_SIZE - 1) {\n            throw StackFullException();\n        }\n        arr[++top] = value;\n    }\n\n    int pop() {\n        if (top < 0) {\n            throw StackEmptyException();\n        }\n        return arr[top--];\n    }\n\n    int peek() {\n        if (top < 0) {\n            throw StackEmptyException();\n        }\n        return arr[top];\n    }\n};\n```\n\nWait a minute, I set MAX_SIZE to 100, but I want to make it flexible. Maybe I should allow the user to specify the size when creating a Stack object.\n\nI can do this by modifying the constructor to take a size parameter and use dynamic memory allocation for the array.\n\nHere's an improved version:\n\n```cpp\nclass Stack {\nprivate:\n    int* arr;\n    int top;\n    int capacity;\n\npublic:\n    Stack(int size) : capacity(size), top(-1) {\n        arr = new int[capacity];\n    }\n\n    ~Stack() {\n        delete[] arr;\n    }\n\n    void push(int value) {\n        if (top >= capacity - 1) {\n            throw StackFullException();\n        }\n        arr[++top] = value;\n    }\n\n    int pop() {\n        if (top < 0) {\n            throw StackEmptyException();\n        }\n        return arr[top--];\n    }\n\n    int peek() {\n        if (top < 0) {\n            throw StackEmptyException();\n        }\n        return arr[top];\n    }\n};\n```\n\nThis looks better. Now, the user can specify the size of the stack when creating a Stack object.\n\nI should also implement the destructor to free the dynamically allocated memory.\n\nNow, I need to write a main function to test this Stack class.\n\nI'll write a simple program that creates a Stack object, pushes some elements onto it, pops them off, and handles any exceptions that may occur.\n\nHere's a rough idea of what the main function might look like:\n\n```cpp\n#include <iostream>\n\nint main() {\n    Stack stack(5); // Create a stack of size 5\n\n    try {\n        stack.push(1);\n        stack.push(2);\n        stack.push(3);\n        stack.push(4);\n        stack.push(5);\n        stack.push(6); // This should throw StackFullException\n\n    } catch (const StackFullException& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n    }\n\n    try {\n        std::cout << \"Top element is: \" << stack.peek() << std::endl;\n        std::cout << \"Popped element: \" << stack.pop() << std::endl;\n        std::cout << \"Popped element: \" << stack.pop() << std::endl;\n        std::cout << \"Popped element: \" << stack.pop() << std::endl;\n        std::cout << \"Popped element: \" << stack.pop() << std::endl;\n        std::cout << \"Popped element: \" << stack.pop() << std::endl;\n        std::cout << \"Popped element: \" << stack.pop() << std::endl; // This should throw StackEmptyException\n    } catch (const StackEmptyException& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n    }\n\n    return 0;\n}\n```\n\nThis should test both the StackFullException and StackEmptyException.\n\nWait, but in the push section, pushing 6 should throw StackFullException, and in the pop section, popping more than 5 times should throw StackEmptyException.\n\nI should make sure that the exceptions are being caught and handled properly.\n\nAlso, I should consider what happens if the user tries to peek at an empty stack.\n\nLet me add a peek operation in the test when the stack is empty.\n\nHere's an updated main function:\n\n```cpp\n#include <iostream>\n\nint main() {\n    Stack stack(5); // Create a stack of size 5\n\n    try {\n        stack.push(1);\n        stack.push(2);\n        stack.push(3);\n        stack.push(4);\n        stack.push(5);\n        stack.push(6); // This should throw StackFullException\n\n    } catch (const StackFullException& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n    }\n\n    try {\n        std::cout << \"Top element is: \" << stack.peek() << std::endl;\n        std::cout << \"Popped element: \" << stack.pop() << std::endl;\n        std::cout << \"Popped element: \" << stack.pop() << std::endl;\n        std::cout << \"Popped element: \" << stack.pop() << std::endl;\n        std::cout << \"Popped element: \" << stack.pop() << std::endl;\n        std::cout << \"Popped element: \" << stack.pop() << std::endl;\n        std::cout << \"Popped element: \" << stack.pop() << std::endl; // This should throw StackEmptyException\n    } catch (const StackEmptyException& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n    }\n\n    try {\n        std::cout << \"Top element is: \" << stack.peek() << std::endl; // This should throw StackEmptyException\n    } catch (const StackEmptyException& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n    }\n\n    return 0;\n}\n```\n\nThis should cover all the exception scenarios.\n\nLet me also think about whether I need to handle any other exceptions.\n\nFor example, what if the user provides a negative size when creating the Stack object?\n\nI should add a check in the constructor to handle invalid sizes.\n\nLet me modify the constructor to handle that:\n\n```cpp\nStack(int size) : capacity(size > 0 ? size : 1), top(-1) {\n    if (size <= 0) {\n        std::cerr << \"Invalid stack size. Using default size of 1.\" << std::endl;\n    }\n    arr = new int[capacity];\n}\n```\n\nThis way, if the user provides a non-positive size, it will use a default size of 1 and print a warning message.\n\nAlso, I should consider what happens when the stack is full and the user tries to push more elements.\n\nI've already got the StackFullException in place for that.\n\nSimilarly, for pop and peek operations on an empty stack, I've got StackEmptyException.\n\nI think this covers the basic requirements.\n\nLet me compile this in my mind.\n\n- Custom exceptions for empty and full stack.\n\n- Stack class with push, pop, and peek operations.\n\n- Dynamic memory allocation for the stack array based on user-specified size.\n\n- Exception handling in main function to catch and handle exceptions properly.\n\n- Basic test cases to verify that exceptions are thrown and caught as expected.\n\nI should also consider adding some output statements to show the normal flow of the program, not just the exceptions.\n\nFor example, showing the elements being pushed and popped.\n\nHere's an improved main function with more output:\n\n```cpp\n#include <iostream>\n\nint main() {\n    int stackSize;\n    std::cout << \"Enter the size of the stack: \";\n    std::cin >> stackSize;\n\n    Stack stack(stackSize); // Create a stack of user-specified size\n\n    try {\n        for (int i = 1; i <= stackSize + 1; ++i) {\n            stack.push(i);\n            std::cout << \"Pushed \" << i << \" onto the stack.\" << std::endl;\n        }\n    } catch (const StackFullException& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n    }\n\n    try {\n        while (true) {\n            std::cout << \"Popped element: \" << stack.pop() << std::endl;\n        }\n    } catch (const StackEmptyException& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n    }\n\n    try {\n        std::cout << \"Top element is: \" << stack.peek() << std::endl;\n    } catch (const StackEmptyException& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n    }\n\n    return 0;\n}\n```\n\nThis way, the user can input the size of the stack, and the program will push elements up to the stack's capacity plus one to trigger the StackFullException, and then try to pop more elements than available to trigger the StackEmptyException.\n\nI should also think about edge cases, like a stack of size 1, or size 0 (which we already handle by setting a default size of 1).\n\nLet me consider a stack of size 1:\n\n- Push 1: succeeds\n\n- Push 2: throws StackFullException\n\n- Pop: returns 1\n\n- Pop: throws StackEmptyException\n\n- Peek: throws StackEmptyException\n\nSeems correct.\n\nAnother thing to consider is that after popping all elements, the top should be reset to -1.\n\nIn the pop method, after decrementing top, it should be fine.\n\nLet me check the pop method:\n\n```cpp\nint pop() {\n    if (top < 0) {\n        throw StackEmptyException();\n    }\n    return arr[top--];\n}\n```\n\nYes, top is decremented after returning the value, so when the stack is empty, top is -1.\n\nSimilarly, in the push method:\n\n```cpp\nvoid push(int value) {\n    if (top >= capacity - 1) {\n        throw StackFullException();\n    }\n    arr[++top] = value;\n}\n```\n\ntop is incremented before assigning the value, which is correct.\n\nI should also consider that the stack doesn't shrink or grow dynamically; it's a fixed size.\n\nIf I wanted a dynamic stack, I could implement it with resizing, but for simplicity, I'll keep it fixed size.\n\nAnother thing to think about is whether to provide a method to check the current size or whether the stack is full or empty.\n\nFor example, methods like `isFull()`, `isEmpty()`, or `size()`.\n\nThese can be useful for the user without having to catch exceptions.\n\nLet me add these methods to the Stack class.\n\nHere's how I can implement them:\n\n```cpp\nclass Stack {\nprivate:\n    int* arr;\n    int top;\n    int capacity;\n\npublic:\n    Stack(int size) : capacity(size > 0 ? size : 1), top(-1) {\n        arr = new int[capacity];\n    }\n\n    ~Stack() {\n        delete[] arr;\n    }\n\n    bool isEmpty() {\n        return top == -1;\n    }\n\n    bool isFull() {\n        return top >= capacity - 1;\n    }\n\n    int size() {\n        return top + 1;\n    }\n\n    void push(int value) {\n        if (isFull()) {\n            throw StackFullException();\n        }\n        arr[++top] = value;\n    }\n\n    int pop() {\n        if (isEmpty()) {\n            throw StackEmptyException();\n        }\n        return arr[top--];\n    }\n\n    int peek() {\n        if (isEmpty()) {\n            throw StackEmptyException();\n        }\n        return arr[top];\n    }\n};\n```\n\nNow, the user can check if the stack is empty or full without having to catch exceptions.\n\nThis can be useful in scenarios where they want to avoid exceptions for flow control.\n\nFor example:\n\n```cpp\nif (!stack.isFull()) {\n    stack.push(value);\n} else {\n    std::cout << \"Stack is full. Cannot push.\" << std::endl;\n}\n```\n\nSimilarly for popping:\n\n```cpp\nif (!stack.isEmpty()) {\n    int value = stack.pop();\n    std::cout << \"Popped: \" << value << std::endl;\n} else {\n    std::cout << \"Stack is empty. Cannot pop.\" << std::endl;\n}\n```\n\nThis can make the code cleaner and more efficient, as exceptions are generally more expensive in terms of performance.\n\nHowever, in some cases, using exceptions for error handling is more appropriate, especially when the error is truly exceptional and not part of the normal control flow.\n\nIn this program, since the user wants exception handling for empty and full stack cases, I'll keep the exceptions in place.\n\nBut providing the additional methods gives more flexibility to the user.\n\nNow, I should update the main function to demonstrate the use of these new methods.\n\nHere's an updated main function:\n\n```cpp\n#include <iostream>\n\nint main() {\n    int stackSize;\n    std::cout << \"Enter the size of the stack: \";\n    std::cin >> stackSize;\n\n    Stack stack(stackSize); // Create a stack of user-specified size\n\n    // Push elements onto the stack\n    for (int i = 1; i <= stackSize + 1; ++i) {\n        try {\n            if (!stack.isFull()) {\n                stack.push(i);\n                std::cout << \"Pushed \" << i << \" onto the stack.\" << std::endl;\n            } else {\n                std::cout << \"Stack is full. Cannot push \" << i << \".\" << std::endl;\n                break;\n            }\n        } catch (const StackFullException& e) {\n            std::cerr << \"Error: \" << e.what() << std::endl;\n            break;\n        }\n    }\n\n    // Pop elements from the stack\n    while (!stack.isEmpty()) {\n        try {\n            int value = stack.pop();\n            std::cout << \"Popped \" << value << \" from the stack.\" << std::endl;\n        } catch (const StackEmptyException& e) {\n            std::cerr << \"Error: \" << e.what() << std::endl;\n            break;\n        }\n    }\n\n    // Try to peek at an empty stack\n    try {\n        std::cout << \"Top element is: \" << stack.peek() << std::endl;\n    } catch (const StackEmptyException& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n    }\n\n    return 0;\n}\n```\n\nThis version uses the `isFull()` and `isEmpty()` methods to control the push and pop operations, which is more efficient than relying on exceptions for control flow.\n\nHowever, I've still kept the try-catch blocks to handle any unexpected exceptions that might occur.\n\nThis is a good practice, as it ensures that the program doesn't crash unexpectedly.\n\nAdditionally, I should consider what happens if the user enters an invalid size, such as a negative number.\n\nIn the Stack constructor, I've already handled this by setting a default size of 1 and printing a warning message.\n\nLet me test this scenario.\n\nIf the user enters -5, the capacity will be set to 1, and a warning message will be printed.\n\nThen, the program will create a stack of size 1 and proceed accordingly.\n\nThis seems acceptable.\n\nAnother consideration is to ensure that the stack doesn't have any memory leaks.\n\nI've implemented the destructor to delete the dynamically allocated array, which is good.\n\nBut I should also consider the Rule of Three in C++. Since I'm managing dynamic memory, I need to make sure that copying and assigning Stack objects is handled properly.\n\nIn C++, if a class manages resources like dynamic memory, it's important to define a copy constructor and an assignment operator to handle these resources correctly.\n\nOtherwise, copying objects can lead to double deletions or other memory issues.\n\nLet me add a copy constructor and an assignment operator to the Stack class.\n\nHere's how I can implement them:\n\n```cpp\nclass Stack {\nprivate:\n    int* arr;\n    int top;\n    int capacity;\n\npublic:\n    Stack(int size) : capacity(size > 0 ? size : 1), top(-1) {\n        arr = new int[capacity];\n    }\n\n    Stack(const Stack& other) : capacity(other.capacity), top(other.top) {\n        arr = new int[capacity];\n        for (int i = 0; i <= top; ++i) {\n            arr[i] = other.arr[i];\n        }\n    }\n\n    Stack& operator=(const Stack& other) {\n        if (this != &other) {\n            delete[] arr;\n            capacity = other.capacity;\n            top = other.top;\n            arr = new int[capacity];\n            for (int i = 0; i <= top; ++i) {\n                arr[i] = other.arr[i];\n            }\n        }\n        return *this;\n    }\n\n    ~Stack() {\n        delete[] arr;\n    }\n\n    // Other methods...\n};\n```\n\nNow, the Stack class properly handles copying and assignment.\n\nThis is important to prevent issues with dynamic memory when copying objects.\n\nI should also consider implementing move semantics for better performance, but for simplicity, I'll leave it at this.\n\nAnother point to consider is whether to use standard containers like `std::vector` instead of raw arrays.\n\nUsing `std::vector` would handle dynamic memory management automatically and provide more functionality, but since the task is to implement a simple stack from scratch, I'll stick with the raw array.\n\nHowever, in real-world scenarios, using `std::vector` or other standard containers is generally recommended for their safety and convenience.\n\nNow, let's think about how to compile and run this program.\n\nI need to make sure that the user has a C++ compiler installed, such as g++.\n\nThe user can compile the program using a command like:\n\n```\ng++ -o stack_program stack_program.cpp\n```\n\nAnd then run it with:\n\n```\n./stack_program\n```\n\nI should also consider adding comments to the code to make it more readable and maintainable.\n\nProperly commented code helps others (and future you) understand the purpose and functionality of each part of the program.\n\nLet me add some comments to the Stack class and the main function.\n\nHere's an example of how comments can be added:\n\n```cpp\nclass Stack {\nprivate:\n    int* arr; // Pointer to the dynamic array storing stack elements\n    int top; // Index of the top element in the stack\n    int capacity; // Maximum capacity of the stack\n\npublic:\n    // Constructor to initialize the stack with a given size\n    Stack(int size) : capacity(size > 0 ? size : 1), top(-1) {\n        arr = new int[capacity];\n    }\n\n    // Copy constructor to handle deep copy of the stack\n    Stack(const Stack& other) : capacity(other.capacity), top(other.top) {\n        arr = new int[capacity];\n        for (int i = 0; i <= top; ++i) {\n            arr[i] = other.arr[i];\n        }\n    }\n\n    // Assignment operator to handle assignment of one stack to another\n    Stack& operator=(const Stack& other) {\n        if (this != &other) {\n            delete[] arr;\n            capacity = other.capacity;\n            top = other.top;\n            arr = new int[capacity];\n            for (int i = 0; i <= top; ++i) {\n                arr[i] = other.arr[i];\n            }\n        }\n        return *this;\n    }\n\n    // Destructor to free the dynamically allocated memory\n    ~Stack() {\n        delete[] arr;\n    }\n\n    // Check if the stack is empty\n    bool isEmpty() {\n        return top == -1;\n    }\n\n    // Check if the stack is full\n    bool isFull() {\n        return top >= capacity - 1;\n    }\n\n    // Return the current size of the stack\n    int size() {\n        return top + 1;\n    }\n\n    // Push an element onto the stack\n    void push(int value) {\n        if (isFull()) {\n            throw StackFullException();\n        }\n        arr[++top] = value;\n    }\n\n    // Pop an element from the stack\n    int pop() {\n        if (isEmpty()) {\n            throw StackEmptyException();\n        }\n        return arr[top--];\n    }\n\n    // Peek at the top element of the stack without removing it\n    int peek() {\n        if (isEmpty()) {\n            throw StackEmptyException();\n        }\n        return arr[top];\n    }\n};\n```\n\nAnd in the main function:\n\n```cpp\nint main() {\n    int stackSize;\n    std::cout << \"Enter the size of the stack: \";\n    std::cin >> stackSize;\n\n    Stack stack(stackSize); // Create a stack of user-specified size\n\n    // Push elements onto the stack\n    for (int i = 1; i <= stackSize + 1; ++i) {\n        try {\n            if (!stack.isFull()) {\n                stack.push(i);\n                std::cout << \"Pushed \" << i << \" onto the stack.\" << std::endl;\n            } else {\n                std::cout << \"Stack is full. Cannot push \" << i << \".\" << std::endl;\n                break;\n            }\n        } catch (const StackFullException& e) {\n            std::cerr << \"Error: \" << e.what() << std::endl;\n            break;\n        }\n    }\n\n    // Pop elements from the stack\n    while (!stack.isEmpty()) {\n        try {\n            int value = stack.pop();\n            std::cout << \"Popped \" << value << \" from the stack.\" << std::endl;\n        } catch (const StackEmptyException& e) {\n            std::cerr << \"Error: \" << e.what() << std::endl;\n            break;\n        }\n    }\n\n    // Try to peek at an empty stack\n    try {\n        std::cout << \"Top element is: \" << stack.peek() << std::endl;\n    } catch (const StackEmptyException& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n    }\n\n    return 0;\n}\n```\n\nWith these comments, the code is easier to understand.\n\nI should also consider adding a header comment at the top of the file, describing the purpose of the program.\n\nFor example:\n\n```cpp\n/**\n * Simple Stack Implementation in C++\n *\n * This program demonstrates a basic implementation of a stack data structure in C++.\n * It includes push, pop, and peek operations with exception handling for empty and full stack scenarios.\n */\n```\n\nThis provides context for anyone reading the code.\n\nNow, let's think about potential improvements or extensions to this program.\n\n- **Generic Stack**: Currently, the stack holds integers. We could make it a template class to hold any data type.\n\n- **Exception Safety**: Ensure that the stack operations are exception-safe, meaning that no resources are leaked even if an exception is thrown.\n\n- **Iterator Support**: Provide iterator methods to traverse the stack, although this is less common for stacks.\n\n- **Additional Methods**: Implement methods like `clear()` to remove all elements from the stack.\n\n- **Unit Tests**: Write unit tests to verify the correctness of the stack operations.\n\nFor now, I'll keep the implementation as is, focusing on the basic requirements.\n\nIn summary, I've implemented a simple stack class in C++ with push, pop, and peek operations, along with exception handling for empty and full stack scenarios. I've also provided a main function to test these operations and handle exceptions appropriately.\n\n**Final Solution**\n\nTo implement a simple stack data structure in C++ with push, pop, and peek operations, including exception handling for cases when the stack is empty or full, follow the steps below.\n\n## Approach\n\n1. **Custom Exceptions**: Define custom exceptions `StackEmptyException` and `StackFullException` to handle errors when the stack is empty or full.\n2. **Stack Class**: Implement a `Stack` class with:\n   - Private members to store stack elements and track the top of the stack.\n   - Constructor to initialize the stack with a specified size.\n   - Methods for push, pop, peek, and utility methods to check if the stack is empty, full, or to get its size.\n3. **Main Function**: Create a `main` function to test stack operations and handle exceptions.\n\n## Solution Code\n\n```cpp\n#include <iostream>\n#include <exception>\n\n// Custom exceptions\nclass StackEmptyException : public std::exception {\npublic:\n    const char* what() const throw() {\n        return \"Stack is empty\";\n    }\n};\n\nclass StackFullException : public std::exception {\npublic:\n    const char* what() const throw() {\n        return \"Stack is full\";\n    }\n};\n\n// Stack class\nclass Stack {\nprivate:\n    int* arr;\n    int top;\n    int capacity;\n\npublic:\n    Stack(int size) : capacity(size > 0 ? size : 1), top(-1) {\n        arr = new int[capacity];\n    }\n\n    Stack(const Stack& other) : capacity(other.capacity), top(other.top) {\n        arr = new int[capacity];\n        for (int i = 0; i <= top; ++i) {\n            arr[i] = other.arr[i];\n        }\n    }\n\n    Stack& operator=(const Stack& other) {\n        if (this != &other) {\n            delete[] arr;\n            capacity = other.capacity;\n            top = other.top;\n            arr = new int[capacity];\n            for (int i = 0; i <= top; ++i) {\n                arr[i] = other.arr[i];\n            }\n        }\n        return *this;\n    }\n\n    ~Stack() {\n        delete[] arr;\n    }\n\n    bool isEmpty() {\n        return top == -1;\n    }\n\n    bool isFull() {\n        return top >= capacity - 1;\n    }\n\n    int size() {\n        return top + 1;\n    }\n\n    void push(int value) {\n        if (isFull()) {\n            throw StackFullException();\n        }\n        arr[++top] = value;\n    }\n\n    int pop() {\n        if (isEmpty()) {\n            throw StackEmptyException();\n        }\n        return arr[top--];\n    }\n\n    int peek() {\n        if (isEmpty()) {\n            throw StackEmptyException();\n        }\n        return arr[top];\n    }\n};\n\n// Main function to test the Stack class\nint main() {\n    int stackSize;\n    std::cout << \"Enter the size of the stack: \";\n    std::cin >> stackSize;\n\n    Stack stack(stackSize); // Create a stack of user-specified size\n\n    // Push elements onto the stack\n    for (int i = 1; i <= stackSize + 1; ++i) {\n        try {\n            if (!stack.isFull()) {\n                stack.push(i);\n                std::cout << \"Pushed \" << i << \" onto the stack.\" << std::endl;\n            } else {\n                std::cout << \"Stack is full. Cannot push \" << i << \".\" << std::endl;\n                break;\n            }\n        } catch (const StackFullException& e) {\n            std::cerr << \"Error: \" << e.what() << std::endl;\n            break;\n        }\n    }\n\n    // Pop elements from the stack\n    while (!stack.isEmpty()) {\n        try {\n            int value = stack.pop();\n            std::cout << \"Popped \" << value << \" from the stack.\" << std::endl;\n        } catch (const StackEmptyException& e) {\n            std::cerr << \"Error: \" << e.what() << std::endl;\n            break;\n        }\n    }\n\n    // Try to peek at an empty stack\n    try {\n        std::cout << \"Top element is: \" << stack.peek() << std::endl;\n    } catch (const StackEmptyException& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n    }\n\n    return 0;\n}\n```\n\n## Explanation\n\n1. **Custom Exceptions**: We create two custom exceptions, `StackEmptyException` and `StackFullException`, derived from `std::exception`, to handle specific error conditions.\n2. **Stack Class**:\n   - **Members and Constructor**: The stack uses a dynamic array to store elements, with size determined at creation. It includes methods to check if the stack is empty, full, or to get its current size.\n   - **Push Operation**: Adds an element to the top of the stack. Throws `StackFullException` if the stack is full.\n   - **Pop Operation**: Removes the top element from the stack and returns it. Throws `StackEmptyException` if the stack is empty.\n   - **Peek Operation**: Returns the top element without removing it. Throws `StackEmptyException` if the stack is empty.\n3. **Main Function**: \n   - Reads the stack size from the user.\n   - Pushes elements onto the stack and handles full stack exceptions.\n   - Pops elements from the stack and handles empty stack exceptions.\n   - Attempts to peek at the top element of an empty stack and handles the exception."
    }
]