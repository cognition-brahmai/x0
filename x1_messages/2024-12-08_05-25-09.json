[
    {
        "role": "user",
        "content": "Develop a Python script that takes a directory path as a command-line argument and compresses all files within the specified directory into a single ZIP archive. The script should also display the total size of the compressed files and the compression ratio achieved.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Alright, I've got this task to create a Python script that compresses all files in a given directory into a single ZIP archive. I need to take the directory path from a command-line argument, create the ZIP file, and then show the total size of the compressed files along with the compression ratio.\n\nFirst, I need to make sure I understand what's being asked. So, the script should:\n\n1. Accept a directory path from the command line.\n\n2. Compress all files in that directory into a single ZIP archive.\n\n3. Calculate and display the total size of the compressed files.\n\n4. Calculate and display the compression ratio achieved.\n\nI need to handle this in Python, so I should look into the modules that Python provides for handling ZIP files and command-line arguments.\n\nI know that the `zipfile` module in Python is used for creating and reading ZIP files. Also, for command-line arguments, I can use the `sys` module, which provides access to command-line arguments passed to the script.\n\nLet me think about the steps I need to implement in the script:\n\n1. Check if the correct number of command-line arguments is provided. The script should expect one argument: the directory path.\n\n2. Validate if the provided path is a valid directory.\n\n3. List all the files in the directory.\n\n4. Create a ZIP archive and add all the files to it.\n\n5. Calculate the total size of the original files.\n\n6. Calculate the size of the ZIP archive.\n\n7. Compute the compression ratio.\n\n8. Display the results.\n\nI should also consider edge cases, like:\n\n- The directory path does not exist.\n\n- The directory is empty.\n\n- There are subdirectories within the specified directory; should I include files in subdirectories or only files in the top-level directory?\n\nFor now, I'll assume that I only need to compress files in the top-level directory and not recurse into subdirectories. But maybe I should make it an option.\n\nWait, to keep it simple, I'll stick to compressing only the files in the top-level directory.\n\nLet me start by sketching a rough structure of the script.\n\nI'll need to import the necessary modules:\n\n```python\n\nimport sys\n\nimport os\n\nimport zipfile\n\n```\n\nThen, check the number of command-line arguments:\n\n```python\n\nif len(sys.argv) != 2:\n\n    print(\"Usage: python script.py <directory_path>\")\n\n    sys.exit(1)\n\n```\n\nNext, assign the directory path from the command-line argument:\n\n```python\n\ndirectory = sys.argv[1]\n\n```\n\nValidate if the directory exists and is a directory:\n\n```python\n\nif not os.path.exists(directory):\n\n    print(f\"Error: The directory {directory} does not exist.\")\n\n    sys.exit(1)\n\nif not os.path.isdir(directory):\n\n    print(f\"Error: {directory} is not a directory.\")\n\n    sys.exit(1)\n\n```\n\nThen, list all files in the directory:\n\n```python\n\nfiles = [f for f in os.listdir(directory) if os.path.isfile(os.path.join(directory, f))]\n\n```\n\nNow, create a ZIP archive and add files to it:\n\n```python\n\nwith zipfile.ZipFile('archive.zip', 'w') as zipf:\n\n    for file in files:\n\n        zipf.write(os.path.join(directory, file), arcname=file)\n\n```\n\nI need to calculate the total size of the original files:\n\n```python\n\ntotal_original_size = sum(os.path.getsize(os.path.join(directory, file)) for file in files)\n\n```\n\nAnd the size of the ZIP archive:\n\n```python\n\nzip_file_size = os.path.getsize('archive.zip')\n\n```\n\nThen, compute the compression ratio:\n\n```python\n\ncompression_ratio = (zip_file_size / total_original_size) * 100\n\n```\n\nFinally, display the results:\n\n```python\n\nprint(f\"Total original size: {total_original_size} bytes\")\n\nprint(f\"Compressed size: {zip_file_size} bytes\")\n\nprint(f\"Compression ratio: {compression_ratio:.2f}%\")\n\n```\n\nWait, actually, compression ratio is usually expressed as the percentage of the original size that the compressed size represents. So, if the compressed size is smaller, the percentage should be less than 100%.\n\nBut I think it's more common to express how much space is saved, like \"compressed to x% of original size\" or \"achieved y% compression\".\n\nMaybe I should calculate the percentage of space saved:\n\n```python\n\nspace_saved = 100 - (zip_file_size / total_original_size * 100)\n\nprint(f\"Space saved: {space_saved:.2f}%\")\n\n```\n\nAlternatively, I can keep both:\n\n- Compression ratio: compressed size as a percentage of original size.\n\n- Space saved: the percentage of space reduced.\n\nSo, in the print statements:\n\n```python\n\nprint(f\"Total original size: {total_original_size} bytes\")\n\nprint(f\"Compressed size: {zip_file_size} bytes\")\n\nprint(f\"Compression ratio: {zip_file_size / total_original_size * 100:.2f}% of original size\")\n\nprint(f\"Space saved: {100 - (zip_file_size / total_original_size * 100):.2f}%\")\n\n```\n\nI should also handle the case where the directory is empty, meaning there are no files to compress.\n\nIn that case, the list of files will be empty, and the ZIP file will be created but will be empty. The total original size would be 0, which could cause a division by zero error in the compression ratio calculation.\n\nSo, I need to add a check for that:\n\n```python\n\nif len(files) == 0:\n\n    print(\"The directory is empty. No files to compress.\")\n\n    sys.exit(0)\n\n```\n\nPlace this check after listing the files.\n\nAlso, I should consider whether to overwrite an existing ZIP file with the same name.\n\nMaybe I should include the directory name in the ZIP file name to make it unique.\n\nFor example, if the directory is \"my_files\", the ZIP file could be \"my_files.zip\".\n\nI can extract the base name of the directory and use that for the ZIP file name.\n\nUsing `os.path.basename(directory)` to get the directory name.\n\nThen, the ZIP file can be named `{dirname}.zip`.\n\nI should also check if the ZIP file already exists and handle that case, maybe by renaming it or asking the user.\n\nBut to keep it simple, I'll just overwrite the existing ZIP file if it exists.\n\nAdditionally, I should handle any potential errors that may occur during file operations, like permission errors or disk full errors.\n\nI can wrap the file operations in try-except blocks to catch and report any errors gracefully.\n\nLet me think about the final structure of the script:\n\n- Import necessary modules.\n\n- Check for correct number of command-line arguments.\n\n- Assign directory path from command line.\n\n- Validate if the directory exists and is a directory.\n\n- List all files in the top-level directory.\n\n- If no files, exit gracefully.\n\n- Calculate total original size of files.\n\n- Create a ZIP archive with the files.\n\n- Calculate the size of the ZIP archive.\n\n- Compute and display the total original size, compressed size, and compression ratio.\n\nI should also make sure that the script runs correctly by testing it with different scenarios:\n\n- Directory with multiple files.\n\n- Directory with a single file.\n\n- Empty directory.\n\n- Non-existent directory.\n\n- Directory containing files with different extensions.\n\n- Directory path with spaces.\n\nI need to ensure that the script handles all these cases correctly.\n\nMoreover, I should consider using appropriate naming conventions and adding comments to make the script readable.\n\nI can also add a docstring at the beginning of the script to explain what it does.\n\nLet me start writing the script based on the structure I've outlined.\n\n## Final Solution\nTo solve this problem, we need to create a Python script that compresses all files in a specified directory into a single ZIP archive and provides the total size of the compressed files along with the compression ratio achieved.\n\n### Approach\n\n1. **Accept Directory Path**: Retrieve the directory path from the command-line argument.\n2. **Validate Directory**: Check if the provided path exists and is a directory.\n3. **List Files**: List all files in the top-level directory.\n4. **Compress Files**: Create a ZIP archive containing these files.\n5. **Calculate Sizes**: Compute the total size of original files and the size of the ZIP archive.\n6. **Compute Compression Ratio**: Determine the compression ratio achieved.\n7. **Display Results**: Print the total original size, compressed size, and compression ratio.\n\n### Solution Code\n\n```python\nimport sys\nimport os\nimport zipfile\n\ndef main():\n    # Check for correct number of command-line arguments\n    if len(sys.argv) != 2:\n        print(\"Usage: python script.py <directory_path>\")\n        sys.exit(1)\n    \n    # Assign directory path from command line\n    directory = sys.argv[1]\n    \n    # Validate if the directory exists and is a directory\n    if not os.path.exists(directory):\n        print(f\"Error: The directory {directory} does not exist.\")\n        sys.exit(1)\n    if not os.path.isdir(directory):\n        print(f\"Error: {directory} is not a directory.\")\n        sys.exit(1)\n    \n    # List all files in the directory\n    files = [f for f in os.listdir(directory) if os.path.isfile(os.path.join(directory, f))]\n    \n    # If no files, exit gracefully\n    if len(files) == 0:\n        print(\"The directory is empty. No files to compress.\")\n        sys.exit(0)\n    \n    # Calculate total original size of files\n    total_original_size = sum(os.path.getsize(os.path.join(directory, file)) for file in files)\n    \n    # Create ZIP file name based on directory name\n    dirname = os.path.basename(directory)\n    zip_filename = f\"{dirname}.zip\"\n    \n    # Create ZIP archive\n    with zipfile.ZipFile(zip_filename, 'w') as zipf:\n        for file in files:\n            zipf.write(os.path.join(directory, file), arcname=file)\n    \n    # Calculate the size of the ZIP archive\n    zip_file_size = os.path.getsize(zip_filename)\n    \n    # Compute compression ratio\n    compression_ratio = (zip_file_size / total_original_size) * 100\n    space_saved = 100 - compression_ratio\n    \n    # Display results\n    print(f\"Total original size: {total_original_size} bytes\")\n    print(f\"Compressed size: {zip_file_size} bytes\")\n    print(f\"Compression ratio: {compression_ratio:.2f}% of original size\")\n    print(f\"Space saved: {space_saved:.2f}%\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n\n1. **Command-Line Argument Handling**: The script checks if exactly one directory path is provided as a command-line argument. If not, it prints usage information and exits.\n2. **Directory Validation**: It verifies if the provided path exists and is a directory.\n3. **File Listing**: It lists all files in the top-level directory, ignoring subdirectories.\n4. **ZIP Archive Creation**: It creates a ZIP archive named after the directory containing the files.\n5. **Size Calculations**: It calculates the total size of original files and the size of the ZIP archive.\n6. **Compression Ratio Calculation**: It computes the compression ratio and space saved.\n7. **Output**: It prints the total original size, compressed size, compression ratio, and space saved.\n\nThis script provides a straightforward way to compress directory contents and analyze the compression efficiency."
    }
]