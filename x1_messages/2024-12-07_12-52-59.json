[
    {
        "role": "user",
        "content": "Implement a C++ class representing a simple stack data structure with push, pop, and peek operations. The stack should have a fixed size specified at instantiation and throw an exception when trying to push onto a full stack or pop from an empty stack. Include unit tests demonstrating correct functionality.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Alright, I'm going to implement a simple stack in C++ as per your request. I'll make sure it has a fixed size determined at creation and handles exceptions for pushing to a full stack or popping from an empty one. Also, I'll include some unit tests to ensure everything works correctly.\n\nFirst, I need to define the stack class. It should have the following operations:\n\n1. **Push**: Adds an element to the top of the stack. If the stack is full, it should throw an exception.\n\n2. **Pop**: Removes the top element from the stack. If the stack is empty, it should throw an exception.\n\n3. **Peek**: Returns the top element without removing it. If the stack is empty, it should throw an exception.\n\nAdditionally, the stack should have a fixed size specified when it's created.\n\nI'll start by planning the class structure.\n\n## Final Solution\nTo implement a simple stack in C++ with fixed size and exception handling, we can create a class that manages an array of a specified size and tracks the current top of the stack. We will throw exceptions when attempting to push onto a full stack or pop from an empty stack.\n\n### Approach\n1. **Stack Class Definition**:\n   - Use an array to store stack elements.\n   - Maintain a variable to track the top of the stack.\n   - Provide methods to push, pop, and peek with appropriate exception handling.\n\n2. **Exception Handling**:\n   - Throw a `std::runtime_error` with appropriate messages for invalid operations.\n\n3. **Unit Tests**:\n   - Use `std::cout` to demonstrate the stack operations and verify correctness.\n\n### Solution Code\n\n```cpp\n#include <iostream>\n#include <exception>\n\nclass StackFullException : public std::runtime_error {\npublic:\n    StackFullException() : std::runtime_error(\"Stack is full\") {}\n};\n\nclass StackEmptyException : public std::runtime_error {\npublic:\n    StackEmptyException() : std::runtime_error(\"Stack is empty\") {}\n};\n\ntemplate<typename T>\nclass FixedSizeStack {\nprivate:\n    T* arr;\n    int top;\n    int capacity;\n\npublic:\n    FixedSizeStack(int size) {\n        if (size <= 0) {\n            throw std::invalid_argument(\"Size must be positive\");\n        }\n        arr = new T[size];\n        capacity = size;\n        top = -1;\n    }\n\n    ~FixedSizeStack() {\n        delete[] arr;\n    }\n\n    void push(const T& value) {\n        if (top >= capacity - 1) {\n            throw StackFullException();\n        }\n        arr[++top] = value;\n    }\n\n    T pop() {\n        if (top < 0) {\n            throw StackEmptyException();\n        }\n        return arr[top--];\n    }\n\n    T peek() const {\n        if (top < 0) {\n            throw StackEmptyException();\n        }\n        return arr[top];\n    }\n\n    bool isEmpty() const {\n        return top == -1;\n    }\n\n    bool isFull() const {\n        return top == capacity - 1;\n    }\n};\n\nint main() {\n    try {\n        FixedSizeStack<int> stack(3);\n\n        stack.push(1);\n        stack.push(2);\n        stack.push(3);\n\n        if (stack.peek() != 3) {\n            std::cerr << \"Top element should be 3\" << std::endl;\n            return 1;\n        }\n\n        stack.push(4); // Should throw StackFullException\n    } catch (const StackFullException& e) {\n        std::cout << \"Caught exception: \" << e.what() << std::endl;\n    } catch (const std::exception& e) {\n        std::cerr << \"Unexpected exception: \" << e.what() << std::endl;\n        return 1;\n    }\n\n    try {\n        FixedSizeStack<int> stack(1);\n        stack.pop(); // Should throw StackEmptyException\n    } catch (const StackEmptyException& e) {\n        std::cout << \"Caught exception: \" << e.what() << std::endl;\n    } catch (const std::exception& e) {\n        std::cerr << \"Unexpected exception: \" << e.what() << std::endl;\n        return 1;\n    }\n\n    std::cout << \"All tests passed successfully.\" << std::endl;\n    return 0;\n}\n```\n\n### Explanation\n1. **Stack Class**:\n   - **Constructor**: Initializes the stack with a given size, allocating an array of that size.\n   - **Destructor**: Frees the allocated array memory.\n   - **push**: Adds an element to the top of the stack. Throws `StackFullException` if the stack is full.\n   - **pop**: Removes and returns the top element. Throws `StackEmptyException` if the stack is empty.\n   - **peek**: Returns the top element without removing it. Throws `StackEmptyException` if the stack is empty.\n   - **isEmpty** and **isFull**: Helper methods to check the state of the stack.\n\n2. **Exception Classes**:\n   - **StackFullException** and **StackEmptyException**: Custom exceptions derived from `std::runtime_error` for better error handling.\n\n3. **Unit Tests**:\n   - Test pushing elements until the stack is full and verify that further pushes throw an exception.\n   - Test popping from an empty stack and verify that it throws an exception.\n   - Output messages to confirm the correctness of operations and exception handling.\n\nThis implementation ensures that the stack operates within its bounds and provides clear feedback through exceptions when operations are invalid."
    }
]