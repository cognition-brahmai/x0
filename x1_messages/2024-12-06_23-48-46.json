[
    {
        "role": "user",
        "content": "Write a Java program that reads a CSV file containing user information (first name, last name, email, and age) and stores the data in an SQLite database. The program should also provide methods to query the database for all users, users with specific ages, and users with specific email domains.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Alright, I've got this task to create a Java program that reads a CSV file with user information and stores it in an SQLite database. Then, I need to provide some methods to query the database in different ways. Let's break this down step by step.\n\nFirst, I need to set up the environment. Since I'm using Java, I'll need to make sure I have the JDBC driver for SQLite. I can include it via Maven or download it manually. For simplicity, I'll assume Maven is being used.\n\nSo, in the `pom.xml` file, I need to add the SQLite JDBC dependency:\n\n```xml\n<dependency>\n    <groupId>org.xerial</groupId>\n    <artifactId>sqlite-jdbc</artifactId>\n    <version>3.36.0.3</version>\n</dependency>\n```\n\nNext, I need to design the CSV file format. It should contain first name, last name, email, and age. Let's assume the CSV looks like this:\n\n```\nfirst_name,last_name,email,age\nJohn,Doe,john.doe@example.com,30\nJane,Smith,jane.smith@example.com,25\n...\n```\n\nI need to read this CSV file and insert the data into an SQLite database. I should create a table to store this information. The table might look like this:\n\n```sql\nCREATE TABLE users (\n    id INTEGER PRIMARY KEY AUTOINCREMENT,\n    first_name TEXT NOT NULL,\n    last_name TEXT NOT NULL,\n    email TEXT UNIQUE NOT NULL,\n    age INTEGER NOT NULL\n);\n```\n\nNow, for reading the CSV file, I can use Java's built-in classes like `BufferedReader` and `FileReader`, or I can use a library like OpenCSV, which makes handling CSV files easier. I'll go with OpenCSV for simplicity.\n\nAdd the OpenCSV dependency to `pom.xml`:\n\n```xml\n<dependency>\n    <groupId>com.opencsv</groupId>\n    <artifactId>opencsv</artifactId>\n    <version>5.5.2</version>\n</dependency>\n```\n\nNow, I can write a method to read the CSV file and insert the data into the SQLite database.\n\nHere's a rough outline of the method:\n\n1. Connect to the SQLite database (create it if it doesn't exist).\n2. Create the users table if it doesn't exist.\n3. Read the CSV file using OpenCSV.\n4. Insert each row into the users table.\n\nFor connecting to SQLite, I can use the `java.sql.DriverManager` to get a connection.\n\nHere's some sample code for connecting to SQLite:\n\n```java\nConnection conn = DriverManager.getConnection(\"jdbc:sqlite:user_database.db\");\n```\n\nTo create the table:\n\n```java\nString createTableSql = \"CREATE TABLE IF NOT EXISTS users (\" +\n                        \"id INTEGER PRIMARY KEY AUTOINCREMENT,\" +\n                        \"first_name TEXT NOT NULL,\" +\n                        \"last_name TEXT NOT NULL,\" +\n                        \"email TEXT UNIQUE NOT NULL,\" +\n                        \"age INTEGER NOT NULL\" +\n                        \");\";\nStatement stmt = conn.createStatement();\nstmt.execute(createTableSql);\n```\n\nReading the CSV file:\n\n```java\nCSVReader csvReader = new CSVReader(new FileReader(\"users.csv\"));\nList<String[]> records = csvReader.readAll();\nfor (String[] record : records) {\n    // Skip header\n    if (record[0].equals(\"first_name\")) continue;\n    // Insert into database\n    String insertSql = \"INSERT INTO users (first_name, last_name, email, age) VALUES (?, ?, ?, ?);\";\n    PreparedStatement pstmt = conn.prepareStatement(insertSql);\n    pstmt.setString(1, record[0]);\n    pstmt.setString(2, record[1]);\n    pstmt.setString(3, record[2]);\n    pstmt.setInt(4, Integer.parseInt(record[3]));\n    pstmt.executeUpdate();\n}\n```\n\nNow, for the querying part:\n\n1. Method to get all users.\n\n```java\npublic List<User> getAllUsers() {\n    List<User> users = new ArrayList<>();\n    String sql = \"SELECT * FROM users;\";\n    try (Statement stmt = conn.createStatement();\n         ResultSet rs = stmt.executeQuery(sql)) {\n        while (rs.next()) {\n            User user = new User(\n                rs.getInt(\"id\"),\n                rs.getString(\"first_name\"),\n                rs.getString(\"last_name\"),\n                rs.getString(\"email\"),\n                rs.getInt(\"age\")\n            );\n            users.add(user);\n        }\n    } catch (SQLException e) {\n        e.printStackTrace();\n    }\n    return users;\n}\n```\n\n2. Method to get users with a specific age.\n\n```java\npublic List<User> getUsersByAge(int age) {\n    List<User> users = new ArrayList<>();\n    String sql = \"SELECT * FROM users WHERE age = ?;\";\n    try (PreparedStatement pstmt = conn.prepareStatement(sql)) {\n        pstmt.setInt(1, age);\n        ResultSet rs = pstmt.executeQuery();\n        while (rs.next()) {\n            User user = new User(\n                rs.getInt(\"id\"),\n                rs.getString(\"first_name\"),\n                rs.getString(\"last_name\"),\n                rs.getString(\"email\"),\n                rs.getInt(\"age\")\n            );\n            users.add(user);\n        }\n    } catch (SQLException e) {\n        e.printStackTrace();\n    }\n    return users;\n}\n```\n\n3. Method to get users with a specific email domain.\n\n```java\npublic List<User> getUsersByEmailDomain(String domain) {\n    List<User> users = new ArrayList<>();\n    String sql = \"SELECT * FROM users WHERE email LIKE ?;\";\n    try (PreparedStatement pstmt = conn.prepareStatement(sql)) {\n        pstmt.setString(1, \"%\" + domain);\n        ResultSet rs = pstmt.executeQuery();\n        while (rs.next()) {\n            User user = new User(\n                rs.getInt(\"id\"),\n                rs.getString(\"first_name\"),\n                rs.getString(\"last_name\"),\n                rs.getString(\"email\"),\n                rs.getInt(\"age\")\n            );\n            users.add(user);\n        }\n    } catch (SQLException e) {\n        e.printStackTrace();\n    }\n    return users;\n}\n```\n\nI should also create a `User` class to hold the user data.\n\n```java\npublic class User {\n    int id;\n    String firstName;\n    String lastName;\n    String email;\n    int age;\n\n    // Constructor, getters, setters, toString, etc.\n}\n```\n\nError handling is important here. I need to handle cases where the CSV file is missing or has incorrect formats, and handle SQL exceptions properly.\n\nAlso, I should make sure to close resources like connections, statements, and result sets to avoid leaks. Using try-with-resources can help with that.\n\nAdditionally, to prevent SQL injection, I should use prepared statements with parameters, which I've already done in the insert and query methods.\n\nFinally, I need to think about the program's structure. Maybe have a `UserDAO` class that handles all database operations, and a `CSVLoader` class that reads the CSV and uses the `UserDAO` to insert data.\n\nHere's a rough outline of the classes:\n\n- `User.java`: POJO for user data.\n- `UserDAO.java`: Data Access Object for users, containing methods to insert and query users.\n- `CSVLoader.java`: Handles reading the CSV file and inserting data into the database.\n- `Main.java`: Entry point of the program, where I can test the functionality.\n\nLet me sketch out the `UserDAO` class:\n\n```java\npublic class UserDAO {\n    private Connection conn;\n\n    public UserDAO(Connection conn) {\n        this.conn = conn;\n    }\n\n    public void createTable() {\n        // Create users table\n    }\n\n    public void insertUser(String firstName, String lastName, String email, int age) {\n        // Insert user into database\n    }\n\n    public List<User> getAllUsers() {\n        // Return all users\n    }\n\n    public List<User> getUsersByAge(int age) {\n        // Return users with specified age\n    }\n\n    public List<User> getUsersByEmailDomain(String domain) {\n        // Return users with email containing the domain\n    }\n}\n```\n\nAnd the `CSVLoader` class:\n\n```java\npublic class CSVLoader {\n    private UserDAO userDAO;\n\n    public CSVLoader(UserDAO userDAO) {\n        this.userDAO = userDAO;\n    }\n\n    public void loadCSV(String csvFilePath) {\n        // Read CSV and insert into database\n    }\n}\n```\n\nIn the `Main` class, I can set up the database connection, create the UserDAO, create the CSVLoader, and load the data.\n\n```java\npublic class Main {\n    public static void main(String[] args) {\n        try (Connection conn = DriverManager.getConnection(\"jdbc:sqlite:user_database.db\")) {\n            UserDAO userDAO = new UserDAO(conn);\n            userDAO.createTable();\n\n            CSVLoader csvLoader = new CSVLoader(userDAO);\n            csvLoader.loadCSV(\"users.csv\");\n\n            // Query examples\n            List<User> allUsers = userDAO.getAllUsers();\n            List<User> usersAge30 = userDAO.getUsersByAge(30);\n            List<User> usersExampleCom = userDAO.getUsersByEmailDomain(\"example.com\");\n\n            // Print results\n            for (User user : allUsers) {\n                System.out.println(user);\n            }\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\nI need to make sure that the database connection is properly closed after use, which is handled by the try-with-resources statement in the `Main` class.\n\nAlso, I should consider whether to overwrite the database each time the program runs or to preserve existing data. For now, I'll assume that the database is created if it doesn't exist and data is appended.\n\nEdge cases to consider:\n\n- Empty CSV file.\n- CSV file with missing columns.\n- Duplicate emails (since email is UNIQUE in the database).\n- Invalid age values (non-numeric or negative).\n\nI should add checks in the CSV reading process to handle these cases gracefully, perhaps by skipping invalid rows or logging errors.\n\nFor example, when inserting users, if a duplicate email is found, a unique constraint violation exception will be thrown. I can catch that specific exception and handle it accordingly.\n\nSimilarly, for invalid age values, I can add checks in the CSV reading process to ensure that age is a valid integer.\n\nLet me add some validation in the `CSVLoader` class:\n\n```java\npublic void loadCSV(String csvFilePath) {\n    try (CSVReader csvReader = new CSVReader(new FileReader(csvFilePath))) {\n        List<String[]> records = csvReader.readAll();\n        for (String[] record : records) {\n            if (record.length != 4) {\n                System.out.println(\"Skipping invalid row: \" + Arrays.toString(record));\n                continue;\n            }\n            String firstName = record[0];\n            String lastName = record[1];\n            String email = record[2];\n            String ageStr = record[3];\n            try {\n                int age = Integer.parseInt(ageStr);\n                if (age < 0) {\n                    System.out.println(\"Invalid age: \" + ageStr);\n                    continue;\n                }\n                userDAO.insertUser(firstName, lastName, email, age);\n            } catch (NumberFormatException e) {\n                System.out.println(\"Invalid age value: \" + ageStr);\n            }\n        }\n    } catch (IOException e) {\n        e.printStackTrace();\n    } catch (SQLException e) {\n        e.printStackTrace();\n    }\n}\n```\n\nThis way, any rows with incorrect formats or invalid data are skipped, and an error message is printed.\n\nI should also consider internationalization and potential special characters in the CSV file. Make sure that the CSV reader handles encoding correctly, perhaps by specifying UTF-8 encoding.\n\nTo do that, I can use the `CSVReaderBuilder` to set the encoding:\n\n```java\nCSVReader csvReader = new CSVReaderBuilder(new FileReader(csvFilePath))\n                           .withSkipLines(1) // Skip header\n                           .withCharsetStandardCharsets.UTF_8)\n                           .build();\n```\n\nWait, actually, `FileReader` uses the platform's default encoding. To specify UTF-8, I should use `InputStreamReader` with `FileInputStream`:\n\n```java\nCSVReader csvReader = new CSVReader(new InputStreamReader(new FileInputStream(csvFilePath), StandardCharsets.UTF_8));\n```\n\nThat's better.\n\nMoreover, I should ensure that the database connection is thread-safe if the program is multi-threaded, but for simplicity, I'll assume single-threaded execution.\n\nAnother consideration is performance. If the CSV file is large, reading it all into memory at once might not be efficient. OpenCSV's `CSVReader` has methods to read records one by one, which is more memory-efficient.\n\nSo, I can read and process records one by one instead of reading all records into a list at once.\n\nHere's an improved version of `loadCSV`:\n\n```java\npublic void loadCSV(String csvFilePath) {\n    try (CSVReader csvReader = new CSVReader(new InputStreamReader(new FileInputStream(csvFilePath), StandardCharsets.UTF_8))) {\n        String[] header = csvReader.readNext(); // Read header\n        if (header == null || header.length != 4) {\n            System.out.println(\"Invalid CSV header\");\n            return;\n        }\n        String[] line;\n        while ((line = csvReader.readNext()) != null) {\n            if (line.length != 4) {\n                System.out.println(\"Skipping invalid row: \" + Arrays.toString(line));\n                continue;\n            }\n            String firstName = line[0];\n            String lastName = line[1];\n            String email = line[2];\n            String ageStr = line[3];\n            try {\n                int age = Integer.parseInt(ageStr);\n                if (age < 0) {\n                    System.out.println(\"Invalid age: \" + ageStr);\n                    continue;\n                }\n                userDAO.insertUser(firstName, lastName, email, age);\n            } catch (NumberFormatException e) {\n                System.out.println(\"Invalid age value: \" + ageStr);\n            }\n        }\n    } catch (IOException e) {\n        e.printStackTrace();\n    } catch (SQLException e) {\n        e.printStackTrace();\n    }\n}\n```\n\nThis approach is more memory-efficient, especially for large CSV files.\n\nNow, regarding the querying methods, I need to make sure that they handle empty result sets gracefully and return empty lists instead of null.\n\nAlso, for the email domain query, I'm using `LIKE` with a wildcard at the beginning. In SQLite, `LIKE` is case-sensitive by default, but it depends on the collation. To make it case-insensitive, I can use `COLLATE NOCASE`.\n\nSo, the email domain query should be:\n\n```sql\nSELECT * FROM users WHERE email LIKE ? ESCAPE '\\\\' COLLATE NOCASE;\n```\n\nAnd when setting the parameter, I need to escape any special characters in the domain, like percent signs or underscores.\n\nWait, actually, to search for emails containing a specific domain, I can set the parameter as \"%@domain.com\".\n\nBut to make it more precise, perhaps I should require that the email ends with the domain.\n\nFor example, to find emails ending with \"@example.com\", I can set the parameter as \"%@example.com\".\n\nHere's an updated version of the `getUsersByEmailDomain` method:\n\n```java\npublic List<User> getUsersByEmailDomain(String domain) {\n    List<User> users = new ArrayList<>();\n    String sql = \"SELECT * FROM users WHERE email LIKE ? ESCAPE '\\\\' COLLATE NOCASE;\";\n    try (PreparedStatement pstmt = conn.prepareStatement(sql)) {\n        String likePattern = \"%\" + domain.replace(\"%\", \"\\\\%\").replace(\"_\", \"\\\\_\");\n        pstmt.setString(1, likePattern);\n        ResultSet rs = pstmt.executeQuery();\n        while (rs.next()) {\n            User user = new User(\n                rs.getInt(\"id\"),\n                rs.getString(\"first_name\"),\n                rs.getString(\"last_name\"),\n                rs.getString(\"email\"),\n                rs.getInt(\"age\")\n            );\n            users.add(user);\n        }\n    } catch (SQLException e) {\n        e.printStackTrace();\n    }\n    return users;\n}\n```\n\nThis way, I escape any percent signs or underscores in the domain to prevent them from being interpreted as wildcards in the `LIKE` clause.\n\nAdditionally, I can add more sophisticated error handling, such as logging errors instead of printing stack traces, and throwing custom exceptions.\n\nI should also consider adding transaction management, especially when inserting multiple records to improve performance and ensure data consistency.\n\nIn SQLite, by default, each SQL statement is its own transaction. To group multiple inserts into a single transaction, I can set the connection to manual commit mode.\n\nHere's how I can modify the `loadCSV` method to use a single transaction for all inserts:\n\n```java\npublic void loadCSV(String csvFilePath) {\n    try (CSVReader csvReader = new CSVReader(new InputStreamReader(new FileInputStream(csvFilePath), StandardCharsets.UTF_8))) {\n        conn.setAutoCommit(false); // Start transaction\n        String[] header = csvReader.readNext(); // Read header\n        if (header == null || header.length != 4) {\n            System.out.println(\"Invalid CSV header\");\n            conn.rollback();\n            return;\n        }\n        String[] line;\n        while ((line = csvReader.readNext()) != null) {\n            if (line.length != 4) {\n                System.out.println(\"Skipping invalid row: \" + Arrays.toString(line));\n                continue;\n            }\n            String firstName = line[0];\n            String lastName = line[1];\n            String email = line[2];\n            String ageStr = line[3];\n            try {\n                int age = Integer.parseInt(ageStr);\n                if (age < 0) {\n                    System.out.println(\"Invalid age: \" + ageStr);\n                    continue;\n                }\n                userDAO.insertUser(firstName, lastName, email, age);\n            } catch (NumberFormatException e) {\n                System.out.println(\"Invalid age value: \" + ageStr);\n            }\n        }\n        conn.commit(); // Commit transaction\n        conn.setAutoCommit(true); // Restore auto-commit\n    } catch (IOException | SQLException e) {\n        try {\n            conn.rollback();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n        }\n        e.printStackTrace();\n    }\n}\n```\n\nBy setting `autoCommit` to `false`, all subsequent SQL statements become part of a single transaction until `commit` is called. If an error occurs, I can roll back the transaction to maintain data integrity.\n\nThis should cover the main requirements. I might need to add more features or handle more edge cases based on specific requirements, but this should serve as a solid foundation.\n\n## Final Solution\nTo accomplish the task of reading a CSV file containing user information and storing it in an SQLite database, along with providing methods to query the database, follow these steps:\n\n### Solution Code Structure\n\n1. **User.java**: Represents the user data.\n2. **UserDAO.java**: Handles database operations for users.\n3. **CSVLoader.java**: Reads the CSV file and loads data into the database.\n4. **Main.java**: Entry point to run the program and test the functionality.\n\n### Solution Code\n\n#### User.java\n```java\npublic class User {\n    int id;\n    String firstName;\n    String lastName;\n    String email;\n    int age;\n\n    // Constructor, getters, setters, toString, etc.\n    public User(int id, String firstName, String lastName, String email, int age) {\n        this.id = id;\n        this.firstName = firstName;\n        this.lastName = lastName;\n        this.email = email;\n        this.age = age;\n    }\n\n    @Override\n    public String toString() {\n        return \"User{\" +\n                \"id=\" + id +\n                \", firstName='\" + firstName + '\\'' +\n                \", lastName='\" + lastName + '\\'' +\n                \", email='\" + email + '\\'' +\n                \", age=\" + age +\n                '}';\n    }\n}\n```\n\n#### UserDAO.java\n```java\nimport java.sql.*;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class UserDAO {\n    private Connection conn;\n\n    public UserDAO(Connection conn) {\n        this.conn = conn;\n    }\n\n    public void createTable() {\n        String createTableSql = \"CREATE TABLE IF NOT EXISTS users (\" +\n                \"id INTEGER PRIMARY KEY AUTOINCREMENT,\" +\n                \"first_name TEXT NOT NULL,\" +\n                \"last_name TEXT NOT NULL,\" +\n                \"email TEXT UNIQUE NOT NULL,\" +\n                \"age INTEGER NOT NULL\" +\n                \");\";\n        try (Statement stmt = conn.createStatement()) {\n            stmt.execute(createTableSql);\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void insertUser(String firstName, String lastName, String email, int age) {\n        String insertSql = \"INSERT INTO users (first_name, last_name, email, age) VALUES (?, ?, ?, ?);\";\n        try (PreparedStatement pstmt = conn.prepareStatement(insertSql)) {\n            pstmt.setString(1, firstName);\n            pstmt.setString(2, lastName);\n            pstmt.setString(3, email);\n            pstmt.setInt(4, age);\n            pstmt.executeUpdate();\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public List<User> getAllUsers() {\n        List<User> users = new ArrayList<>();\n        String sql = \"SELECT * FROM users;\";\n        try (Statement stmt = conn.createStatement();\n             ResultSet rs = stmt.executeQuery(sql)) {\n            while (rs.next()) {\n                User user = new User(\n                        rs.getInt(\"id\"),\n                        rs.getString(\"first_name\"),\n                        rs.getString(\"last_name\"),\n                        rs.getString(\"email\"),\n                        rs.getInt(\"age\")\n                );\n                users.add(user);\n            }\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n        return users;\n    }\n\n    public List<User> getUsersByAge(int age) {\n        List<User> users = new ArrayList<>();\n        String sql = \"SELECT * FROM users WHERE age = ?;\";\n        try (PreparedStatement pstmt = conn.prepareStatement(sql)) {\n            pstmt.setInt(1, age);\n            ResultSet rs = pstmt.executeQuery();\n            while (rs.next()) {\n                User user = new User(\n                        rs.getInt(\"id\"),\n                        rs.getString(\"first_name\"),\n                        rs.getString(\"last_name\"),\n                        rs.getString(\"email\"),\n                        rs.getInt(\"age\")\n                );\n                users.add(user);\n            }\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n        return users;\n    }\n\n    public List<User> getUsersByEmailDomain(String domain) {\n        List<User> users = new ArrayList<>();\n        String sql = \"SELECT * FROM users WHERE email LIKE ? ESCAPE '\\\\' COLLATE NOCASE;\";\n        try (PreparedStatement pstmt = conn.prepareStatement(sql)) {\n            String likePattern = \"%\" + domain.replace(\"%\", \"\\\\%\").replace(\"_\", \"\\\\_\");\n            pstmt.setString(1, likePattern);\n            ResultSet rs = pstmt.executeQuery();\n            while (rs.next()) {\n                User user = new User(\n                        rs.getInt(\"id\"),\n                        rs.getString(\"first_name\"),\n                        rs.getString(\"last_name\"),\n                        rs.getString(\"email\"),\n                        rs.getInt(\"age\")\n                );\n                users.add(user);\n            }\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n        return users;\n    }\n}\n```\n\n#### CSVLoader.java\n```java\nimport com.opencsv.CSVReader;\n\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.FileInputStream;\nimport java.nio.charset.StandardCharsets;\n\npublic class CSVLoader {\n    private UserDAO userDAO;\n\n    public CSVLoader(UserDAO userDAO) {\n        this.userDAO = userDAO;\n    }\n\n    public void loadCSV(String csvFilePath) {\n        try (CSVReader csvReader = new CSVReader(new InputStreamReader(new FileInputStream(csvFilePath), StandardCharsets.UTF_8))) {\n            conn.setAutoCommit(false); // Start transaction\n            String[] header = csvReader.readNext(); // Read header\n            if (header == null || header.length != 4) {\n                System.out.println(\"Invalid CSV header\");\n                conn.rollback();\n                return;\n            }\n            String[] line;\n            while ((line = csvReader.readNext()) != null) {\n                if (line.length != 4) {\n                    System.out.println(\"Skipping invalid row: \" + Arrays.toString(line));\n                    continue;\n                }\n                String firstName = line[0];\n                String lastName = line[1];\n                String email = line[2];\n                String ageStr = line[3];\n                try {\n                    int age = Integer.parseInt(ageStr);\n                    if (age < 0) {\n                        System.out.println(\"Invalid age: \" + ageStr);\n                        continue;\n                    }\n                    userDAO.insertUser(firstName, lastName, email, age);\n                } catch (NumberFormatException e) {\n                    System.out.println(\"Invalid age value: \" + ageStr);\n                }\n            }\n            conn.commit(); // Commit transaction\n            conn.setAutoCommit(true); // Restore auto-commit\n        } catch (IOException | SQLException e) {\n            try {\n                conn.rollback();\n            } catch (SQLException ex) {\n                ex.printStackTrace();\n            }\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n#### Main.java\n```java\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.SQLException;\n\npublic class Main {\n    public static void main(String[] args) {\n        try (Connection conn = DriverManager.getConnection(\"jdbc:sqlite:user_database.db\")) {\n            UserDAO userDAO = new UserDAO(conn);\n            userDAO.createTable();\n\n            CSVLoader csvLoader = new CSVLoader(userDAO);\n            csvLoader.loadCSV(\"users.csv\");\n\n            // Query examples\n            List<User> allUsers = userDAO.getAllUsers();\n            List<User> usersAge30 = userDAO.getUsersByAge(30);\n            List<User> usersExampleCom = userDAO.getUsersByEmailDomain(\"example.com\");\n\n            // Print results\n            for (User user : allUsers) {\n                System.out.println(user);\n            }\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n### Explanation\n\n1. **User.java**: A simple POJO to represent user data.\n2. **UserDAO.java**: Manages database operations including creating the table, inserting users, and querying users based on different criteria.\n3. **CSVLoader.java**: Reads the CSV file and loads the data into the SQLite database, handling potential errors and invalid data.\n4. **Main.java**: Sets up the database connection, creates necessary tables, loads data from the CSV file, and provides examples of querying the database.\n\nThis setup ensures that the CSV data is correctly read and stored in the SQLite database, and that the database can be queried efficiently for different user scenarios."
    }
]