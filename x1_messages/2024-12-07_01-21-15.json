[
    {
        "role": "user",
        "content": "Create a Python-based command-line tool that interacts with the GitHub API to perform operations such as creating repositories, listing issues, and managing pull requests. Use argparse for handling command line arguments and ensure proper error handling. PLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Alright, I've got this task to create a Python-based command-line tool that interacts with the GitHub API. I need to make sure it can do things like create repositories, list issues, and manage pull requests. And I have to use argparse for handling command line arguments, plus proper error handling. Okay, let's break this down.\n\nFirst things first, I need to understand what the GitHub API offers and how to interact with it using Python. I know GitHub has a comprehensive API that allows you to perform nearly all the actions you can do on the website itself. For this tool, I'll need to focus on specific parts of the API related to repositories, issues, and pull requests.\n\nI should start by setting up a new Python project. I'll need to decide on the structure of the tool. Since it's a command-line tool, it's common to have subcommands for different operations. For example, one command for creating repositories, another for listing issues, and so on. Argparse is great for this because it supports subcommands.\n\nLet me think about the overall structure. Maybe something like this:\n\n- `gh-tool repo create` to create a new repository\n\n- `gh-tool issues list` to list issues in a repository\n\n- `gh-tool pr manage` to manage pull requests\n\nEach of these commands will require different arguments and possibly different levels of authentication, depending on the action.\n\nNow, interacting with the GitHub API will require making HTTP requests. Python's requests library is perfect for this. I should check if it's installed, and if not, include it in the project's requirements.\n\nAuthentication is a crucial part of interacting with GitHub's API. GitHub supports several authentication methods, but the most straightforward for a command-line tool might be using a personal access token. Users can generate a token in their GitHub account settings, and I'll need to figure out how to securely handle this token in the tool.\n\nSecurity is important here. I don't want to store the token in plain text or expose it in the command line. Maybe I can have the tool read the token from an environment variable or a configuration file that's not checked into version control.\n\nLet me consider using environment variables. The user can set a\u73af\u5883 variable like `GITHUB_TOKEN` and the tool can read from that. This way, the token isn't hard-coded into the script.\n\nAlright, moving on to creating repositories. According to the GitHub API documentation, creating a repository requires a POST request to `https://api.github.com/user/repos` with a JSON payload containing repository details like name, description, etc.\n\nI need to define the arguments for the `repo create` command. Probably, the repository name will be mandatory, and other details like description, visibility, etc., can be optional.\n\nSimilarly, listing issues would require a GET request to the issues endpoint of a specific repository. I'll need to specify the owner and repository name.\n\nManaging pull requests could involve various actions like creating, updating, closing, etc. Maybe I need to further break this down into subcommands under `pr`, like `pr create`, `pr close`, etc.\n\nThis is getting a bit complex. Maybe I should start by sketching out the basic structure of the tool using argparse, and then fill in the functions for each command.\n\nLet me try to write a simple outline of the code.\n\nFirst, import necessary modules:\n\n```python\nimport argparse\nimport requests\nimport os\n```\n\nThen, set up the main parser:\n\n```python\nparser = argparse.ArgumentParser(description=\"GitHub CLI tool\")\nsubparsers = parser.add_subparsers(dest=\"command\")\n```\n\nNow, create subparsers for each command.\n\nFor creating a repository:\n\n```python\nrepo_parser = subparsers.add_parser('repo', description=\"Repository operations\")\nrepo_subparsers = repo_parser.add_subparsers(dest=\"subcommand\")\n\ncreate_parser = repo_subparsers.add_parser('create', help=\"Create a new repository\")\ncreate_parser.add_argument(\"name\", help=\"Name of the repository\")\ncreate_parser.add_argument(\"--description\", help=\"Description of the repository\")\ncreate_parser.add_argument(\"--private\", action=\"store_true\", help=\"Create a private repository\")\n```\n\nSimilarly, for listing issues:\n\n```python\nissues_parser = subparsers.add_parser('issues', description=\"Issue operations\")\nissues_subparsers = issues_parser.add_subparsers(dest=\"subcommand\")\n\nlist_issues_parser = issues_subparsers.add_parser('list', help=\"List issues in a repository\")\nlist_issues_parser.add_argument(\"owner\", help=\"Owner of the repository\")\nlist_issues_parser.add_argument(\"repo\", help=\"Name of the repository\")\n```\n\nAnd for managing pull requests:\n\n```python\npr_parser = subparsers.add_parser('pr', description=\"Pull request operations\")\npr_subparsers = pr_parser.add_subparsers(dest=\"subcommand\")\n\n# For example, creating a pull request\ncreate_pr_parser = pr_subparsers.add_parser('create', help=\"Create a new pull request\")\ncreate_pr_parser.add_argument(\"owner\", help=\"Owner of the repository\")\ncreate_pr_parser.add_argument(\"repo\", help=\"Name of the repository\")\ncreate_pr_parser.add_argument(\"title\", help=\"Title of the pull request\")\ncreate_pr_parser.add_argument(\"head\", help=\"Head branch\")\ncreate_pr_parser.add_argument(\"base\", help=\"Base branch\")\n```\n\nThis looks like a good start. Now, I need to define functions that will be called for each subcommand.\n\nBut first, I need to handle authentication. As I thought earlier, I'll use a personal access token from an environment variable.\n\nI can define a function to get the token:\n\n```python\ndef get_github_token():\n    token = os.getenv(\"GITHUB_TOKEN\")\n    if not token:\n        raise ValueError(\"GITHUB_TOKEN environment variable is not set\")\n    return token\n```\n\nThen, I can create a session with the token for authenticated requests.\n\n```python\ndef create_session():\n    token = get_github_token()\n    session = requests.Session()\n    session.headers.update({\n        \"Authorization\": f\"token {token}\",\n        \"Accept\": \"application/vnd.github.v3+json\"\n    })\n    return session\n```\n\nNow, for each subcommand, I'll define a function that uses this session to make API calls.\n\nLet's start with creating a repository.\n\nAccording to the GitHub API, to create a repository, I need to make a POST request to `https://api.github.com/user/repos` with a JSON payload containing repository details.\n\nSo, the function might look like this:\n\n```python\ndef create_repository(name, description, private):\n    session = create_session()\n    payload = {\n        \"name\": name,\n        \"description\": description,\n        \"private\": private\n    }\n    response = session.post(\"https://api.github.com/user/repos\", json=payload)\n    if response.status_code == 201:\n        print(\"Repository created successfully\")\n        print(response.json())\n    else:\n        print(\"Failed to create repository\")\n        print(response.json())\n```\n\nSimilarly, for listing issues, I need to make a GET request to `https://api.github.com/repos/{owner}/{repo}/issues`.\n\n```python\ndef list_issues(owner, repo):\n    session = create_session()\n    url = f\"https://api.github.com/repos/{owner}/{repo}/issues\"\n    response = session.get(url)\n    if response.status_code == 200:\n        issues = response.json()\n        for issue in issues:\n            print(issue[\"number\"], issue[\"title\"])\n    else:\n        print(\"Failed to list issues\")\n        print(response.json())\n```\n\nAnd for creating a pull request, I need to make a POST request to `https://api.github.com/repos/{owner}/{repo}/pulls`.\n\n```python\ndef create_pull_request(owner, repo, title, head, base):\n    session = create_session()\n    url = f\"https://api.github.com/repos/{owner}/{repo}/pulls\"\n    payload = {\n        \"title\": title,\n        \"head\": head,\n        \"base\": base\n    }\n    response = session.post(url, json=payload)\n    if response.status_code == 201:\n        print(\"Pull request created successfully\")\n        print(response.json())\n    else:\n        print(\"Failed to create pull request\")\n        print(response.json())\n```\n\nNow, I need to link these functions to the respective subparsers using the `set_defaults` method.\n\nFor example:\n\n```python\ncreate_parser.set_defaults(func=create_repository)\nlist_issues_parser.set_defaults(func=list_issues)\ncreate_pr_parser.set_defaults(func=create_pull_request)\n```\n\nThen, in the main part of the script, I can parse the arguments and call the appropriate function.\n\n```python\nargs = parser.parse_args()\nif hasattr(args, 'func'):\n    args.func(args)\nelse:\n    parser.print_help()\n```\n\nWait, but I need to make sure that for each subcommand, the required arguments are provided.\n\nAlso, I should add more error handling. For example, checking if the repository exists before trying to list issues or create pull requests.\n\nMoreover, I should handle cases where the API returns errors, like invalid tokens, rate limits, etc.\n\nLet me think about error handling.\n\nFirst, when getting the GitHub token, I already have a check to see if the environment variable is set. If not, I raise a ValueError.\n\nIn the API calls, I should check the response status codes and print meaningful error messages.\n\nGitHub API uses standard HTTP status codes, so I can handle errors like this:\n\n- 401 Unauthorized: invalid token\n\n- 403 Forbidden: possibly rate limited or insufficient permissions\n\n- 404 Not Found: repository doesn't exist\n\n- 422 Unprocessable Entity: invalid request parameters\n\n- 500+ Server Errors: something went wrong on GitHub's end\n\nI can add general error handling in each function to cover these cases.\n\nAlso, I should consider adding options for more details or options in each command. For example, in listing issues, I might want to filter by state (open, closed), labels, etc.\n\nSimilarly, in managing pull requests, I might want to add options to update or close pull requests.\n\nBut to keep it simple, I'll start with the basic operations and expand from there.\n\nAnother thing to consider is pagination. Some endpoints, like listing issues, might return a large number of results, and GitHub API paginates them.\n\nI need to handle pagination if I want to fetch all issues, not just the first page.\n\nFor now, I'll assume that the API returns all the data in one page, but I should keep in mind that for larger datasets, I need to handle pagination.\n\nOkay, let's think about testing this tool.\n\nSince it interacts with a live API, testing might be a bit tricky. I need to make sure that the tool works correctly with different inputs and handles errors properly.\n\nI can set up a test GitHub repository and use it to test the tool's functionality.\n\nFor example, I can create a new repository using the tool and verify that it appears in my GitHub account.\n\nI can list issues in an existing repository and check if the output matches the actual issues.\n\nI can create a pull request and see if it shows up in the repository's pull requests.\n\nAdditionally, I should test error scenarios, like providing an invalid token, trying to access a non-existent repository, etc.\n\nNow, about the code structure. Having all the functions in one file might work for a simple tool, but if I plan to expand it, it's better to organize the code into separate modules.\n\nFor example, I can have a `repo.py` for repository-related functions, `issues.py` for issue-related functions, and `pr.py` for pull request functions.\n\nThis way, the code is more modular and easier to maintain.\n\nBut for now, I'll keep it in one file to simplify things.\n\nLet me try to write a draft of the complete code.\n\n## Final Solution\nTo create a Python-based command-line tool that interacts with the GitHub API, perform operations such as creating repositories, listing issues, and managing pull requests, you can follow the steps below. This solution uses the `argparse` library for handling command-line arguments and the `requests` library for making API calls.\n\nEnsure you have the required libraries installed:\n\n```sh\npip install requests\n```\n\n### Solution Code\n\n```python\nimport argparse\nimport requests\nimport os\n\ndef get_github_token():\n    token = os.getenv(\"GITHUB_TOKEN\")\n    if not token:\n        raise ValueError(\"GITHUB_TOKEN environment variable is not set\")\n    return token\n\ndef create_session():\n    token = get_github_token()\n    session = requests.Session()\n    session.headers.update({\n        \"Authorization\": f\"token {token}\",\n        \"Accept\": \"application/vnd.github.v3+json\"\n    })\n    return session\n\ndef create_repository(args):\n    session = create_session()\n    payload = {\n        \"name\": args.name,\n        \"description\": args.description,\n        \"private\": args.private\n    }\n    response = session.post(\"https://api.github.com/user/repos\", json=payload)\n    if response.status_code == 201:\n        print(\"Repository created successfully\")\n        print(response.json())\n    else:\n        print(\"Failed to create repository\")\n        print(response.json())\n\ndef list_issues(args):\n    session = create_session()\n    url = f\"https://api.github.com/repos/{args.owner}/{args.repo}/issues\"\n    response = session.get(url)\n    if response.status_code == 200:\n        issues = response.json()\n        for issue in issues:\n            print(issue[\"number\"], issue[\"title\"])\n    else:\n        print(\"Failed to list issues\")\n        print(response.json())\n\ndef create_pull_request(args):\n    session = create_session()\n    url = f\"https://api.github.com/repos/{args.owner}/{args.repo}/pulls\"\n    payload = {\n        \"title\": args.title,\n        \"head\": args.head,\n        \"base\": args.base\n    }\n    response = session.post(url, json=payload)\n    if response.status_code == 201:\n        print(\"Pull request created successfully\")\n        print(response.json())\n    else:\n        print(\"Failed to create pull request\")\n        print(response.json())\n\ndef main():\n    parser = argparse.ArgumentParser(description=\"GitHub CLI tool\")\n    subparsers = parser.add_subparsers(dest=\"command\")\n    \n    # Repository subcommands\n    repo_parser = subparsers.add_parser('repo', description=\"Repository operations\")\n    repo_subparsers = repo_parser.add_subparsers(dest=\"subcommand\")\n    \n    create_parser = repo_subparsers.add_parser('create', help=\"Create a new repository\")\n    create_parser.add_argument(\"name\", help=\"Name of the repository\")\n    create_parser.add_argument(\"--description\", help=\"Description of the repository\")\n    create_parser.add_argument(\"--private\", action=\"store_true\", help=\"Create a private repository\")\n    create_parser.set_defaults(func=create_repository)\n    \n    # Issues subcommands\n    issues_parser = subparsers.add_parser('issues', description=\"Issue operations\")\n    issues_subparsers = issues_parser.add_subparsers(dest=\"subcommand\")\n    \n    list_issues_parser = issues_subparsers.add_parser('list', help=\"List issues in a repository\")\n    list_issues_parser.add_argument(\"owner\", help=\"Owner of the repository\")\n    list_issues_parser.add_argument(\"repo\", help=\"Name of the repository\")\n    list_issues_parser.set_defaults(func=list_issues)\n    \n    # Pull Request subcommands\n    pr_parser = subparsers.add_parser('pr', description=\"Pull request operations\")\n    pr_subparsers = pr_parser.add_subparsers(dest=\"subcommand\")\n    \n    create_pr_parser = pr_subparsers.add_parser('create', help=\"Create a new pull request\")\n    create_pr_parser.add_argument(\"owner\", help=\"Owner of the repository\")\n    create_pr_parser.add_argument(\"repo\", help=\"Name of the repository\")\n    create_pr_parser.add_argument(\"title\", help=\"Title of the pull request\")\n    create_pr_parser.add_argument(\"head\", help=\"Head branch\")\n    create_pr_parser.add_argument(\"base\", help=\"Base branch\")\n    create_pr_parser.set_defaults(func=create_pull_request)\n    \n    args = parser.parse_args()\n    if hasattr(args, 'func'):\n        args.func(args)\n    else:\n        parser.print_help()\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Instructions\n\n1. **Set up your GitHub token**:\n   - Generate a personal access token in your [GitHub settings](https://github.com/settings/tokens).\n   - Export the token as an environment variable: `export GITHUB_TOKEN='your_token_here'`.\n\n2. **Install dependencies**:\n   - Ensure you have `requests` installed: `pip install requests`.\n\n3. **Run the tool**:\n   - Create a new repository: `python gh-tool.py repo create --name my-new-repo --description \"My new repository\" --private`.\n   - List issues in a repository: `python gh-tool.py issues list --owner username --repo repositoryname`.\n   - Create a pull request: `python gh-tool.py pr create --owner username --repo repositoryname --title \"My PR\" --head feature-branch --base main`.\n\nThis tool provides a basic structure for interacting with the GitHub API via the command line. You can extend it by adding more subcommands and options as needed."
    }
]