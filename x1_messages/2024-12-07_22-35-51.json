[
    {
        "role": "user",
        "content": "Develop a Python script that generates random math problems (addition, subtraction, multiplication, division) based on user-specified difficulty levels and keeps track of the user's score."
    },
    {
        "role": "assistant",
        "content": "Sure, I can help you with that! Creating a Python script that generates random math problems and tracks the user's score sounds like a fun project. Let's break it down into smaller steps to make it easier.\n\nFirst, we need to decide on the structure of our script. We'll need to:\n\n1. **Get user input for difficulty level.**\n\n2. **Generate random math problems based on the difficulty level.**\n\n3. **Present the problems to the user and get their answers.**\n\n4. **Check if the user's answers are correct and keep track of the score.**\n\n5. **Display the final score after a set number of questions.**\n\nLet's think about how to implement each of these steps.\n\n**Step 1: Get user input for difficulty level.**\n\nWe'll ask the user to select a difficulty level, perhaps easy, medium, or hard. Each difficulty level will correspond to a range of numbers used in the problems. For example:\n\n- Easy: numbers between 1 and 10\n\n- Medium: numbers between 11 and 50\n\n- Hard: numbers between 51 and 100\n\nWe can use if-elif-else statements to handle the difficulty levels.\n\n**Step 2: Generate random math problems.**\n\nWe'll need to generate random numbers within the selected range and choose random operators (addition, subtraction, multiplication, division). Python's random module will be helpful here.\n\nFor division problems, we need to ensure that the denominator is not zero and that the result is an integer to keep it simple.\n\n**Step 3: Present the problems and get user answers.**\n\nWe'll display each problem to the user and ask for their answer. We can use a loop to handle multiple questions.\n\n**Step 4: Check answers and track score.**\n\nFor each problem, we'll compare the user's answer with the correct answer and update the score accordingly.\n\n**Step 5: Display the final score.**\n\nAfter all questions are answered, we'll show the user how many they got right.\n\nNow, let's think about how to structure the code. We can use functions to organize different parts of the script, making it cleaner and more manageable.\n\nHere's a rough outline of the functions we might need:\n\n- `get_difficulty()`: to get the difficulty level from the user.\n\n- `generate_problem(difficulty)`: to generate a random math problem based on the difficulty.\n\n- `check_answer(user_answer, correct_answer)`: to check if the user's answer is correct.\n\n- `main()`: to handle the flow of the script, including getting user input, generating problems, checking answers, and displaying the score.\n\nLet me start by writing the `get_difficulty()` function. This function will prompt the user to select a difficulty level and validate the input.\n\n```python\ndef get_difficulty():\n    difficulty = input(\"Select difficulty level (easy, medium, hard): \").lower()\n    while difficulty not in ['easy', 'medium', 'hard']:\n        print(\"Invalid input. Please choose easy, medium, or hard.\")\n        difficulty = input(\"Select difficulty level (easy, medium, hard): \").lower()\n    return difficulty\n```\n\nNext, I'll work on the `generate_problem(difficulty)` function. This function will generate two random numbers based on the difficulty level and select a random operator.\n\nLet's define the number ranges for each difficulty:\n\n- Easy: 1 to 10\n\n- Medium: 11 to 50\n\n- Hard: 51 to 100\n\nWe'll use the random module to generate the numbers and choose the operator.\n\nHere's a draft of the `generate_problem` function:\n\n```python\nimport random\n\ndef generate_problem(difficulty):\n    if difficulty == 'easy':\n        num1 = random.randint(1, 10)\n        num2 = random.randint(1, 10)\n    elif difficulty == 'medium':\n        num1 = random.randint(11, 50)\n        num2 = random.randint(11, 50)\n    else:  # hard\n        num1 = random.randint(51, 100)\n        num2 = random.randint(51, 100)\n    \n    operator = random.choice(['+', '-', '*', '/'])\n    \n    # Handle division to ensure integer result\n    if operator == '/':\n        # Adjust num1 to be a multiple of num2\n        if num2 == 0:\n            num2 = random.randint(1, 100)\n        num1 = num2 * random.randint(1, 10)\n    \n    return num1, num2, operator\n```\n\nIn this function, for division problems, I'm adjusting num1 to be a multiple of num2 so that the result is always an integer. This avoids dealing with fractions or decimals, which can complicate things for now.\n\nNow, let's think about how to present the problem to the user and get their answer. We'll need to format the problem as a string and handle the user's input.\n\nWe can create a function called `present_problem(num1, num2, operator)` that prints the problem and returns the user's answer.\n\nHere's a possible implementation:\n\n```python\ndef present_problem(num1, num2, operator):\n    problem = f\"What is {num1} {operator} {num2}? \"\n    user_answer = input(problem)\n    return user_answer\n```\n\nHowever, we need to make sure that the user enters a valid number. We should add some input validation here.\n\nLet's enhance the function to handle invalid inputs:\n\n```python\ndef present_problem(num1, num2, operator):\n    problem = f\"What is {num1} {operator} {num2}? \"\n    while True:\n        user_answer = input(problem)\n        try:\n            answer = float(user_answer)\n            return answer\n        except ValueError:\n            print(\"Please enter a valid number.\")\n```\n\nThis way, if the user enters something that's not a number, we'll prompt them to enter a valid number.\n\nNext, we need to calculate the correct answer based on the operator and the numbers generated.\n\nLet's create a function called `get_correct_answer(num1, num2, operator)` that returns the correct answer.\n\nHere's how it can be done:\n\n```python\ndef get_correct_answer(num1, num2, operator):\n    if operator == '+':\n        return num1 + num2\n    elif operator == '-':\n        return num1 - num2\n    elif operator == '*':\n        return num1 * num2\n    elif operator == '/':\n        return num1 / num2\n```\n\nNow, we can compare the user's answer with the correct answer in another function, say `check_answer(user_answer, correct_answer)`.\n\nWe need to consider that for division, the user might enter a floating-point number, so we should allow some tolerance in the answer.\n\nLet's define the `check_answer` function:\n\n```python\ndef check_answer(user_answer, correct_answer):\n    # Allow some tolerance for floating point answers\n    if abs(user_answer - correct_answer) < 0.01:\n        return True\n    else:\n        return False\n```\n\nThis function checks if the user's answer is within 0.01 of the correct answer, which should be sufficient for our purposes.\n\nNow, let's think about the main function that will orchestrate everything.\n\nWe'll need to:\n\n1. Get the difficulty level from the user.\n\n2. Decide how many questions to ask. Maybe allow the user to specify this or set a fixed number.\n\n3. Generate a set of problems based on the difficulty.\n\n4. Present each problem to the user, get their answer, and check if it's correct.\n\n5. Keep track of the score.\n\n6. After all questions are answered, display the final score.\n\nLet's start by assuming we'll ask 10 questions per session.\n\nHere's a draft of the `main` function:\n\n```python\ndef main():\n    print(\"Welcome to the Math Quiz!\")\n    difficulty = get_difficulty()\n    score = 0\n    num_questions = 10\n    \n    for _ in range(num_questions):\n        num1, num2, operator = generate_problem(difficulty)\n        user_answer = present_problem(num1, num2, operator)\n        correct_answer = get_correct_answer(num1, num2, operator)\n        if check_answer(user_answer, correct_answer):\n            print(\"Correct!\")\n            score += 1\n        else:\n            print(f\"Wrong! The correct answer is {correct_answer}\")\n    \n    print(f\"You scored {score} out of {num_questions}\")\n```\n\nThis seems straightforward. Now, let's consider if there are any edge cases or improvements we can make.\n\nFirst, for division problems, we're ensuring that num1 is a multiple of num2 to avoid non-integer results. However, we might still have issues if num2 is 1, which could lead to problems like \"What is 5 / 1?\" which might be too easy. To make it more challenging, maybe we can adjust the range for num2 in division problems.\n\nAlternatively, we could restrict division problems to have num2 between 2 and 10, for example.\n\nLet me adjust the `generate_problem` function for division:\n\n```python\nif operator == '/':\n    # For division, num2 should be between 2 and 10 to make it more challenging\n    num2 = random.randint(2, 10)\n    # num1 should be a multiple of num2\n    multiplier = random.randint(1, 10)\n    num1 = num2 * multiplier\n```\n\nThis way, division problems will be a bit more varied and challenging.\n\nAnother consideration is to handle the case where num1 is smaller than num2 in subtraction problems to avoid negative numbers, unless we want to include negative numbers in the easy difficulty.\n\nFor now, let's assume we want to avoid negative numbers in easy mode.\n\nWe can adjust the `generate_problem` function accordingly:\n\n```python\nif difficulty == 'easy' and operator == '-':\n    # Ensure num1 >= num2 to avoid negative numbers\n    num1 = random.randint(num2, 10)\n```\n\nBut this might not always work as intended because num2 can be up to 10, and num1 is also up to 10. So, to ensure num1 >= num2, we can generate num1 first and then generate num2 such that num2 <= num1.\n\nHere's a better way:\n\n```python\nif difficulty == 'easy' and operator == '-':\n    num1 = random.randint(1, 10)\n    num2 = random.randint(1, num1)\n```\n\nThis ensures that num2 is less than or equal to num1, preventing negative answers in easy subtraction problems.\n\nLet's incorporate this into the `generate_problem` function.\n\nAlso, for multiplication problems, especially in hard difficulty, the results might be very large. We might want to consider limiting the range or accepting approximate answers, but for simplicity, let's keep it as is.\n\nNow, let's think about how to handle the user's score. In the `main` function, we're keeping a score variable and incrementing it each time the user answers correctly.\n\nAt the end, we're printing the final score. It might be helpful to also display the percentage score.\n\nWe can modify the final print statement to include the percentage:\n\n```python\nprint(f\"You scored {score} out of {num_questions}, which is {score/num_questions*100}%\")\n```\n\nAdditionally, we might want to give the user the option to quit or see their score at any time, but for now, let's keep it simple with a fixed number of questions.\n\nAnother enhancement could be to allow the user to choose how many questions they want to answer. We can modify the `main` function to ask for the number of questions.\n\nHere's an updated `main` function:\n\n```python\ndef main():\n    print(\"Welcome to the Math Quiz!\")\n    difficulty = get_difficulty()\n    num_questions = int(input(\"How many questions would you like to answer? \"))\n    score = 0\n    \n    for _ in range(num_questions):\n        num1, num2, operator = generate_problem(difficulty)\n        user_answer = present_problem(num1, num2, operator)\n        correct_answer = get_correct_answer(num1, num2, operator)\n        if check_answer(user_answer, correct_answer):\n            print(\"Correct!\")\n            score += 1\n        else:\n            print(f\"Wrong! The correct answer is {correct_answer}\")\n    \n    print(f\"You scored {score} out of {num_questions}, which is {score/num_questions*100}%\")\n```\n\nThis way, the user can decide how many questions they want to answer, making the quiz more flexible.\n\nNow, let's consider adding a feature to log the user's score or save it for future reference. This could be done by writing the score to a file along with the date and time.\n\nWe can create a function called `log_score(score, num_questions)` that handles this.\n\nHere's how it might look:\n\n```python\nfrom datetime import datetime\n\ndef log_score(score, num_questions):\n    with open(\"scores.txt\", \"a\") as file:\n        timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        file.write(f\"{timestamp}: {score} out of {num_questions}\\n\")\n```\n\nWe can call this function at the end of the `main` function.\n\nAdditionally, we can read previous scores from the file and display a history of the user's performance.\n\nTo do this, we can create a function called `show_history()` that reads and prints the scores from the file.\n\nHere's a possible implementation:\n\n```python\ndef show_history():\n    try:\n        with open(\"scores.txt\", \"r\") as file:\n            print(\"Score History:\")\n            for line in file:\n                print(line.strip())\n    except FileNotFoundError:\n        print(\"No score history found.\")\n```\n\nWe can add an option for the user to view their score history after the quiz.\n\nLet's update the `main` function to include this feature.\n\nAlso, to make the script more user-friendly, we can wrap the entire quiz in a loop that allows the user to take the quiz multiple times or exit.\n\nHere's an enhanced version of the `main` function:\n\n```python\ndef main():\n    print(\"Welcome to the Math Quiz!\")\n    \n    while True:\n        print(\"\\nOptions:\")\n        print(\"1. Take the quiz\")\n        print(\"2. View score history\")\n        print(\"3. Exit\")\n        choice = input(\"Enter your choice (1/2/3): \")\n        \n        if choice == '1':\n            difficulty = get_difficulty()\n            num_questions = int(input(\"How many questions would you like to answer? \"))\n            score = 0\n            \n            for _ in range(num_questions):\n                num1, num2, operator = generate_problem(difficulty)\n                user_answer = present_problem(num1, num2, operator)\n                correct_answer = get_correct_answer(num1, num2, operator)\n                if check_answer(user_answer, correct_answer):\n                    print(\"Correct!\")\n                    score += 1\n                else:\n                    print(f\"Wrong! The correct answer is {correct_answer}\")\n            \n            print(f\"You scored {score} out of {num_questions}, which is {score/num_questions*100}%\")\n            log_score(score, num_questions)\n        \n        elif choice == '2':\n            show_history()\n        \n        elif choice == '3':\n            print(\"Goodbye!\")\n            break\n        \n        else:\n            print(\"Invalid choice. Please select 1, 2, or 3.\")\n```\n\nThis way, the user can choose to take the quiz, view their history, or exit the program.\n\nNow, let's think about testing the script to ensure it works as expected.\n\nWe should test each part separately:\n\n1. **Difficulty selection:** Ensure that the correct difficulty levels are selected and that invalid inputs are handled.\n\n2. **Problem generation:** Verify that problems are generated within the specified ranges and that division problems have integer answers.\n\n3. **User input handling:** Make sure that the script handles invalid user answers gracefully and only accepts valid numbers.\n\n4. **Score tracking:** Check that the score is correctly incremented and displayed at the end.\n\n5. **Score logging and history:** Ensure that scores are logged to the file and that the history is displayed correctly.\n\nLet's write some test cases for each of these.\n\n**Test Case 1: Difficulty selection**\n\n- Input: 'easy'\n\n- Expected: Problems with numbers between 1 and 10\n\n- Input: 'medium'\n\n- Expected: Problems with numbers between 11 and 50\n\n- Input: 'hard'\n\n- Expected: Problems with numbers between 51 and 100\n\n- Input: 'invalid'\n\n- Expected: Prompt to enter a valid difficulty level\n\n**Test Case 2: Problem generation**\n\n- For 'easy' difficulty:\n\n- num1 and num2 should be between 1 and 10\n\n- For 'medium' difficulty:\n\n- num1 and num2 should be between 11 and 50\n\n- For 'hard' difficulty:\n\n- num1 and num2 should be between 51 and 100\n\n- For division problems:\n\n- num1 should be a multiple of num2\n\n- num2 should not be zero\n\n**Test Case 3: User input handling**\n\n- Valid number input:\n\n- Answer is accepted and checked\n\n- Invalid input (non-numeric):\n\n- Prompt to enter a valid number\n\n**Test Case 4: Score tracking**\n\n- Correct answers increment the score\n\n- Incorrect answers do not increment the score\n\n- Final score is displayed correctly\n\n**Test Case 5: Score logging and history**\n\n- Scores are written to \"scores.txt\" with timestamp\n\n- History is displayed correctly from the file\n\nBy testing each component individually, we can ensure that the entire script functions as intended.\n\nNow, let's think about potential errors and exceptions that might occur during the execution of the script.\n\n1. **Division by zero:** We've already handled this by ensuring num2 is not zero in division problems.\n\n2. **Invalid user input for difficulty level:** Handled by looping until a valid input is received.\n\n3. **Invalid user input for number of questions:** Need to handle cases where the user enters a non-integer or a negative number.\n\n4. **File I/O errors:** Need to handle cases where the scores file cannot be written to or read from.\n\nLet's add input validation for the number of questions.\n\nIn the `main` function, when asking for the number of questions, we can use a loop to ensure the user enters a valid positive integer.\n\nHere's how we can modify the code:\n\n```python\ndef main():\n    print(\"Welcome to the Math Quiz!\")\n    \n    while True:\n        print(\"\\nOptions:\")\n        print(\"1. Take the quiz\")\n        print(\"2. View score history\")\n        print(\"3. Exit\")\n        choice = input(\"Enter your choice (1/2/3): \")\n        \n        if choice == '1':\n            difficulty = get_difficulty()\n            \n            while True:\n                try:\n                    num_questions = int(input(\"How many questions would you like to answer? \"))\n                    if num_questions > 0:\n                        break\n                    else:\n                        print(\"Please enter a positive integer.\")\n                except ValueError:\n                    print(\"Please enter a valid integer.\")\n            \n            score = 0\n            \n            for _ in range(num_questions):\n                num1, num2, operator = generate_problem(difficulty)\n                user_answer = present_problem(num1, num2, operator)\n                correct_answer = get_correct_answer(num1, num2, operator)\n                if check_answer(user_answer, correct_answer):\n                    print(\"Correct!\")\n                    score += 1\n                else:\n                    print(f\"Wrong! The correct answer is {correct_answer}\")\n            \n            print(f\"You scored {score} out of {num_questions}, which is {score/num_questions*100}%\")\n            log_score(score, num_questions)\n        \n        elif choice == '2':\n            show_history()\n        \n        elif choice == '3':\n            print(\"Goodbye!\")\n            break\n        \n        else:\n            print(\"Invalid choice. Please select 1, 2, or 3.\")\n```\n\nThis addition ensures that the user enters a valid positive integer for the number of questions.\n\nNext, let's consider file I/O errors in the `log_score` and `show_history` functions.\n\nWe can add error handling to these functions to manage cases where the file cannot be accessed.\n\nHere's an updated version of `log_score`:\n\n```python\ndef log_score(score, num_questions):\n    try:\n        with open(\"scores.txt\", \"a\") as file:\n            timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n            file.write(f\"{timestamp}: {score} out of {num_questions}\\n\")\n    except IOError:\n        print(\"Error writing to score file.\")\n```\n\nAnd for `show_history`:\n\n```python\ndef show_history():\n    try:\n        with open(\"scores.txt\", \"r\") as file:\n            print(\"Score History:\")\n            for line in file:\n                print(line.strip())\n    except FileNotFoundError:\n        print(\"No score history found.\")\n    except IOError:\n        print(\"Error reading score file.\")\n```\n\nThis way, if there are any issues with file operations, the user is informed accordingly.\n\nNow, let's consider enhancing the user interface to make it more user-friendly.\n\nWe can provide clear instructions and feedback to the user at each step.\n\nAdditionally, we can add color to the output to make it more visually appealing. For example, display correct answers in green and wrong answers in red.\n\nTo use colors in the terminal, we can use the `colorama` library, which works across different platforms.\n\nFirst, we need to install the `colorama` package:\n\n```sh\npip install colorama\n```\n\nThen, we can import it in our script and use it to color the output.\n\nHere's how we can modify the `present_problem` function to include colored feedback:\n\n```python\nfrom colorama import Fore, Style, init\n\ninit(autoreset=True)\n\ndef present_problem(num1, num2, operator):\n    problem = f\"What is {num1} {operator} {num2}? \"\n    while True:\n        user_answer = input(problem)\n        try:\n            answer = float(user_answer)\n            return answer\n        except ValueError:\n            print(f\"{Fore.RED}Please enter a valid number.{Style.RESET_ALL}\")\n```\n\nAnd in the `main` function:\n\n```python\nif check_answer(user_answer, correct_answer):\n    print(f\"{Fore.GREEN}Correct!{Style.RESET_ALL}\")\n    score += 1\nelse:\n    print(f\"{Fore.RED}Wrong! The correct answer is {correct_answer}{Style.RESET_ALL}\")\n```\n\nThis will display \"Correct!\" in green and \"Wrong! The correct answer is X\" in red, making it clearer for the user.\n\nNow, let's think about how to handle floating-point precision in the `check_answer` function.\n\nCurrently, we're allowing a tolerance of 0.01, which should be sufficient for most cases. However, for multiplication and addition problems with large numbers, the tolerance might need to be adjusted.\n\nTo make it more accurate, we can calculate the tolerance based on the magnitude of the correct answer.\n\nFor example, we can allow a tolerance of 0.01% of the correct answer.\n\nHere's an updated `check_answer` function:\n\n```python\ndef check_answer(user_answer, correct_answer):\n    tolerance = 0.0001 * correct_answer  # 0.01% tolerance\n    if abs(user_answer - correct_answer) < tolerance:\n        return True\n    else:\n        return False\n```\n\nThis way, the tolerance adjusts based on the size of the correct answer, which should handle larger numbers more accurately.\n\nAnother enhancement could be to include a timer for each question, to make the quiz more challenging.\n\nWe can use the `time` module to measure the time taken for each answer and perhaps deduct points for slower responses.\n\nHowever, this might complicate the script, so for now, let's keep it without a timer.\n\nLastly, we can add a feature to shuffle the order of operations, so that not all addition problems come first, followed by subtraction, etc.\n\nBut since we're generating random operators for each problem, the order should already be shuffled.\n\nTo further ensure randomness, we can use `random.choice` to select the operator for each problem.\n\nLooking back at the `generate_problem` function, it already selects a random operator for each problem.\n\nTherefore, the problems should be presented in a random order regarding the operators.\n\nNow, let's consider packaging all these functions into a complete script.\n\nHere's a draft of the entire script:\n\n```python\nimport random\nfrom datetime import datetime\nfrom colorama import Fore, Style, init\n\n# Initialize colorama\ninit(autoreset=True)\n\ndef get_difficulty():\n    difficulty = input(\"Select difficulty level (easy, medium, hard): \").lower()\n    while difficulty not in ['easy', 'medium', 'hard']:\n        print(\"Invalid input. Please choose easy, medium, or hard.\")\n        difficulty = input(\"Select difficulty level (easy, medium, hard): \").lower()\n    return difficulty\n\ndef generate_problem(difficulty):\n    if difficulty == 'easy':\n        num1 = random.randint(1, 10)\n        num2 = random.randint(1, 10)\n    elif difficulty == 'medium':\n        num1 = random.randint(11, 50)\n        num2 = random.randint(11, 50)\n    else:  # hard\n        num1 = random.randint(51, 100)\n        num2 = random.randint(51, 100)\n    \n    operator = random.choice(['+', '-', '*', '/'])\n    \n    # Handle division to ensure integer result\n    if operator == '/':\n        # For division, num2 should be between 2 and 10\n        num2 = random.randint(2, 10)\n        # num1 should be a multiple of num2\n        multiplier = random.randint(1, 10)\n        num1 = num2 * multiplier\n    elif difficulty == 'easy' and operator == '-':\n        # Ensure num1 >= num2 to avoid negative numbers\n        num1 = random.randint(num2, 10)\n    \n    return num1, num2, operator\n\ndef present_problem(num1, num2, operator):\n    problem = f\"What is {num1} {operator} {num2}? \"\n    while True:\n        user_answer = input(problem)\n        try:\n            answer = float(user_answer)\n            return answer\n        except ValueError:\n            print(f\"{Fore.RED}Please enter a valid number.{Style.RESET_ALL}\")\n\ndef get_correct_answer(num1, num2, operator):\n    if operator == '+':\n        return num1 + num2\n    elif operator == '-':\n        return num1 - num2\n    elif operator == '*':\n        return num1 * num2\n    elif operator == '/':\n        return num1 / num2\n\ndef check_answer(user_answer, correct_answer):\n    tolerance = 0.0001 * correct_answer  # 0.01% tolerance\n    if abs(user_answer - correct_answer) < tolerance:\n        return True\n    else:\n        return False\n\ndef log_score(score, num_questions):\n    try:\n        with open(\"scores.txt\", \"a\") as file:\n            timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n            file.write(f\"{timestamp}: {score} out of {num_questions}\\n\")\n    except IOError:\n        print(\"Error writing to score file.\")\n\ndef show_history():\n    try:\n        with open(\"scores.txt\", \"r\") as file:\n            print(\"Score History:\")\n            for line in file:\n                print(line.strip())\n    except FileNotFoundError:\n        print(\"No score history found.\")\n    except IOError:\n        print(\"Error reading score file.\")\n\ndef main():\n    print(\"Welcome to the Math Quiz!\")\n    \n    while True:\n        print(\"\\nOptions:\")\n        print(\"1. Take the quiz\")\n        print(\"2. View score history\")\n        print(\"3. Exit\")\n        choice = input(\"Enter your choice (1/2/3): \")\n        \n        if choice == '1':\n            difficulty = get_difficulty()\n            \n            while True:\n                try:\n                    num_questions = int(input(\"How many questions would you like to answer? \"))\n                    if num_questions > 0:\n                        break\n                    else:\n                        print(\"Please enter a positive integer.\")\n                except ValueError:\n                    print(\"Please enter a valid integer.\")\n            \n            score = 0\n            \n            for _ in range(num_questions):\n                num1, num2, operator = generate_problem(difficulty)\n                user_answer = present_problem(num1, num2, operator)\n                correct_answer = get_correct_answer(num1, num2, operator)\n                if check_answer(user_answer, correct_answer):\n                    print(f\"{Fore.GREEN}Correct!{Style.RESET_ALL}\")\n                    score += 1\n                else:\n                    print(f\"{Fore.RED}Wrong! The correct answer is {correct_answer}{Style.RESET_ALL}\")\n            \n            print(f\"You scored {score} out of {num_questions}, which is {score/num_questions*100}%\")\n            log_score(score, num_questions)\n        \n        elif choice == '2':\n            show_history()\n        \n        elif choice == '3':\n            print(\"Goodbye!\")\n            break\n        \n        else:\n            print(\"Invalid choice. Please select 1, 2, or 3.\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis script includes all the features we've discussed, such as difficulty selection, random problem generation, user input validation, score tracking, and score logging with history.\n\nI've also included color-coded feedback for correct and wrong answers to make the user interface more engaging.\n\nMake sure to install the `colorama` library if you haven't already, as it's used for colored output in the terminal.\n\nYou can run this script in your Python environment, and it should provide an interactive math quiz experience with the options to choose difficulty, view history, and exit.\n\nIf you have any specific requirements or want to add more features, feel free to ask!"
    }
]