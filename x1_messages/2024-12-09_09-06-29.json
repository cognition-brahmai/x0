[
    {
        "role": "user",
        "content": "Implement a C++ class representing a simple stack data structure using templates. The class should provide methods for pushing, popping, checking if the stack is empty, and retrieving the size of the stack. Include exception handling for cases when attempting to pop from an empty stack.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "I've got this task to implement a simple stack data structure in C++ using templates. I need to create a class that can handle different data types, so templates are perfect for that. The stack should have methods to push elements onto the stack, pop elements off, check if it's empty, and get the size of the stack. Also, I need to handle exceptions properly, especially when someone tries to pop from an empty stack.\n\nFirst, I need to think about how to structure this class. Since it's a stack, it should follow the Last In, First Out (LIFO) principle. I'll probably use a dynamic array or a linked list to store the elements. Dynamic arrays are efficient in terms of memory, but linked lists provide constant time operations for push and pop. I think I'll go with a linked list for simplicity and efficiency.\n\nSo, I'll define a template class called Stack. Inside this class, I'll have a nested template class for the nodes of the linked list. Each node will hold an element of the stack and a pointer to the next node.\n\nHere's a rough sketch:\n\n```cpp\ntemplate<typename T>\nclass Stack {\nprivate:\n    struct Node {\n        T data;\n        Node* next;\n        Node(T value) : data(value), next(nullptr) {}\n    };\n    Node* top;\n    int size;\n\npublic:\n    Stack() : top(nullptr), size(0) {}\n    ~Stack();\n    void push(const T& value);\n    T pop();\n    bool isEmpty() const;\n    int getSize() const;\n};\n```\n\nI need to implement the destructor to free the memory allocated for the nodes, otherwise, there will be a memory leak.\n\nFor the push method, I'll create a new node with the given value and make it the new top of the stack, updating the next pointer to the previous top.\n\nThe pop method needs to remove the top node, return its value, and update the top to be the next node. If the stack is empty, I need to handle that case by throwing an exception.\n\nThe isEmpty method will just check if the top is nullptr, and getSize will return the current size.\n\nLet me think about exception handling. In C++, I can throw and catch exceptions. So, in the pop method, if the stack is empty, I'll throw an exception, say, a std::runtime_error with a message like \"Pop from empty stack\".\n\nHere's how the push and pop methods might look:\n\n```cpp\ntemplate<typename T>\nvoid Stack<T>::push(const T& value) {\n    Node* newNode = new Node(value);\n    newNode->next = top;\n    top = newNode;\n    size++;\n}\n\ntemplate<typename T>\nT Stack<T>::pop() {\n    if (isEmpty()) {\n        throw std::runtime_error(\"Pop from empty stack\");\n    }\n    T value = top->data;\n    Node* temp = top;\n    top = top->next;\n    delete temp;\n    size--;\n    return value;\n}\n```\n\nI also need to implement the destructor to delete all the nodes:\n\n```cpp\ntemplate<typename T>\nStack<T>::~Stack() {\n    while (top != nullptr) {\n        Node* temp = top;\n        top = top->next;\n        delete temp;\n    }\n}\n```\n\nAnd the other methods:\n\n```cpp\ntemplate<typename T>\nbool Stack<T>::isEmpty() const {\n    return top == nullptr;\n}\n\ntemplate<typename T>\nint Stack<T>::getSize() const {\n    return size;\n}\n```\n\nI should also consider copy constructors and assignment operators, but for simplicity, I'll omit them for now.\n\nLet me think about potential issues. One thing is making sure that the size is correctly updated with push and pop operations. Another is ensuring that there are no memory leaks, which the destructor should handle.\n\nAlso, I might want to consider using smart pointers instead of raw pointers for better memory management, but since this is a simple implementation, raw pointers should suffice.\n\nAnother consideration is the time complexity. Push and pop operations should be O(1), which they are with a linked list implementation.\n\nI should also think about how to test this stack class. I can write a main function that creates a stack, pushes some elements, pops them, checks if it's empty, and gets the size at different stages.\n\nHere's a simple test:\n\n```cpp\nint main() {\n    Stack<int> stack;\n    std::cout << \"Is empty: \" << stack.isEmpty() << std::endl;\n    std::cout << \"Size: \" << stack.getSize() << std::endl;\n\n    stack.push(1);\n    stack.push(2);\n    stack.push(3);\n\n    std::cout << \"Is empty: \" << stack.isEmpty() << std::endl;\n    std::cout << \"Size: \" << stack.getSize() << std::endl;\n\n    try {\n        std::cout << \"Pop: \" << stack.pop() << std::endl;\n        std::cout << \"Pop: \" << stack.pop() << std::endl;\n        std::cout << \"Pop: \" << stack.pop() << std::endl;\n        std::cout << \"Pop: \" << stack.pop() << std::endl; // Should throw exception\n    } catch (const std::exception& e) {\n        std::cerr << \"Exception: \" << e.what() << std::endl;\n    }\n\n    return 0;\n}\n```\n\nThis should demonstrate that the stack works as expected and that the exception is thrown when trying to pop from an empty stack.\n\nI think this covers the basic requirements. If I had more time, I might consider adding more features like a peek method to look at the top element without popping it, or making the stack iterable.\n\nBut for now, this should be a good starting point.\n\n**Final Solution**\n\nTo implement a simple stack data structure in C++ using templates, we can create a `Stack` class that uses a linked list to store elements. This approach ensures efficient operations for pushing and popping elements.\n\n## Approach\n\n1. **Template Class**: We use a template to make the stack capable of handling any data type.\n2. **Linked List Structure**: Each node in the linked list contains an element and a pointer to the next node.\n3. **Methods**:\n   - `push`: Adds an element to the top of the stack.\n   - `pop`: Removes the top element from the stack and returns its value.\n   - `isEmpty`: Checks if the stack is empty.\n   - `getSize`: Returns the number of elements in the stack.\n4. **Exception Handling**: Throws a `std::runtime_error` if an attempt is made to pop from an empty stack.\n\n## Solution Code\n\n```cpp\n#include <iostream>\n#include <stdexcept>\n\ntemplate<typename T>\nclass Stack {\nprivate:\n    struct Node {\n        T data;\n        Node* next;\n        Node(T value) : data(value), next(nullptr) {}\n    };\n    Node* top;\n    int size;\n\npublic:\n    Stack() : top(nullptr), size(0) {}\n    ~Stack();\n    void push(const T& value);\n    T pop();\n    bool isEmpty() const;\n    int getSize() const;\n};\n\ntemplate<typename T>\nStack<T>::~Stack() {\n    while (top != nullptr) {\n        Node* temp = top;\n        top = top->next;\n        delete temp;\n    }\n}\n\ntemplate<typename T>\nvoid Stack<T>::push(const T& value) {\n    Node* newNode = new Node(value);\n    newNode->next = top;\n    top = newNode;\n    size++;\n}\n\ntemplate<typename T>\nT Stack<T>::pop() {\n    if (isEmpty()) {\n        throw std::runtime_error(\"Pop from empty stack\");\n    }\n    T value = top->data;\n    Node* temp = top;\n    top = top->next;\n    delete temp;\n    size--;\n    return value;\n}\n\ntemplate<typename T>\nbool Stack<T>::isEmpty() const {\n    return top == nullptr;\n}\n\ntemplate<typename T>\nint Stack<T>::getSize() const {\n    return size;\n}\n\nint main() {\n    Stack<int> stack;\n    std::cout << \"Is empty: \" << stack.isEmpty() << std::endl;\n    std::cout << \"Size: \" << stack.getSize() << std::endl;\n\n    stack.push(1);\n    stack.push(2);\n    stack.push(3);\n\n    std::cout << \"Is empty: \" << stack.isEmpty() << std::endl;\n    std::cout << \"Size: \" << stack.getSize() << std::endl;\n\n    try {\n        std::cout << \"Pop: \" << stack.pop() << std::endl;\n        std::cout << \"Pop: \" << stack.pop() << std::endl;\n        std::cout << \"Pop: \" << stack.pop() << std::endl;\n        std::cout << \"Pop: \" << stack.pop() << std::endl; // Should throw exception\n    } catch (const std::exception& e) {\n        std::cerr << \"Exception: \" << e.what() << std::endl;\n    }\n\n    return 0;\n}\n```\n\n## Explanation\n\n- **Node Structure**: Inner structure of the `Stack` class to represent each element in the linked list.\n- **push Operation**: Adds a new node containing the element to the top of the stack.\n- **pop Operation**: Removes the node from the top of the stack and returns its value. Throws an exception if the stack is empty.\n- **isEmpty Operation**: Returns `true` if the stack is empty, otherwise `false`.\n- **getSize Operation**: Returns the number of elements in the stack.\n- **Destructor**: Ensures all nodes are deleted to prevent memory leaks.\n\nThis implementation provides a solid foundation for a stack data structure in C++, with necessary operations and exception handling for robustness."
    }
]