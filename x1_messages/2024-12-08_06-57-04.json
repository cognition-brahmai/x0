[
    {
        "role": "user",
        "content": "Write a C++ program that implements a Least Recently Used (LRU) cache using a doubly-linked list and a hash map. The cache should support get(key), put(key, value), and delete(key) operations with O(1) time complexity. Additionally, it should have a configurable maximum size, and when the cache is full, the least recently used item should be evicted."
    },
    {
        "role": "assistant",
        "content": "I'd be happy to help you with that! Implementing an LRU cache in C++ using a doubly-linked list and a hash map is a great way to achieve O(1) time complexity for get, put, and delete operations. I'll walk you through the steps and provide you with a sample code to achieve this.\n\n### Approach\n\n1. **Doubly-Linked List**: This will store the order of elements based on their usage. The most recently used element will be at the front, and the least recently used at the end.\n2. **Hash Map**: This will store the keys and their corresponding pointers to nodes in the doubly-linked list for O(1) access.\n\n### Solution Code\n\n```cpp\n#include <iostream>\n#include <unordered_map>\n\nclass LRUCache {\nprivate:\n    struct Node {\n        int key;\n        int value;\n        Node* prev;\n        Node* next;\n        Node(int k, int v) : key(k), value(v), prev(nullptr), next(nullptr) {}\n    };\n\n    std::unordered_map<int, Node*> map;\n    Node* head;\n    Node* tail;\n    int capacity;\n    int currentSize;\n\n    void moveToFront(Node* node) {\n        if (node == head) return;\n        if (node == tail) {\n            tail = tail->prev;\n            tail->next = nullptr;\n        } else {\n            node->prev->next = node->next;\n            node->next->prev = node->prev;\n        }\n        node->next = head;\n        node->prev = nullptr;\n        head->prev = node;\n        head = node;\n    }\n\n    void evictLeastRecent() {\n        Node* toEvict = tail;\n        tail = tail->prev;\n        if (tail != nullptr) {\n            tail->next = nullptr;\n        }\n        map.erase(toEvict->key);\n        delete toEvict;\n        currentSize--;\n    }\n\npublic:\n    LRUCache(int cap) : capacity(cap), currentSize(0) {\n        head = nullptr;\n        tail = nullptr;\n    }\n\n    int get(int key) {\n        if (map.find(key) == map.end()) {\n            return -1; // Key not found\n        }\n        Node* node = map[key];\n        moveToFront(node);\n        return node->value;\n    }\n\n    void put(int key, int value) {\n        if (map.find(key) != map.end()) {\n            Node* existing = map[key];\n            existing->value = value;\n            moveToFront(existing);\n        } else {\n            Node* newNode = new Node(key, value);\n            map[key] = newNode;\n            if (head == nullptr) {\n                head = newNode;\n                tail = newNode;\n            } else {\n                newNode->next = head;\n                head->prev = newNode;\n                head = newNode;\n            }\n            currentSize++;\n            if (currentSize > capacity) {\n                evictLeastRecent();\n            }\n        }\n    }\n\n    void deleteKey(int key) {\n        if (map.find(key) == map.end()) {\n            return; // Key not found\n        }\n        Node* node = map[key];\n        if (node == head && node == tail) {\n            head = nullptr;\n            tail = nullptr;\n        } else if (node == head) {\n            head = head->next;\n            head->prev = nullptr;\n        } else if (node == tail) {\n            tail = tail->prev;\n            tail->next = nullptr;\n        } else {\n            node->prev->next = node->next;\n            node->next->prev = node->prev;\n        }\n        map.erase(key);\n        delete node;\n        currentSize--;\n    }\n};\n\nint main() {\n    LRUCache cache(2);\n    cache.put(1, 1);\n    cache.put(2, 2);\n    std::cout << cache.get(1) << std::endl; // returns 1\n    cache.put(3, 3);                         // evicts key 2\n    std::cout << cache.get(2) << std::endl; // returns -1 (not found)\n    cache.put(4, 4);                         // evicts key 1\n    std::cout << cache.get(1) << std::endl; // returns -1 (not found)\n    std::cout << cache.get(3) << std::endl; // returns 3\n    std::cout << cache.get(4) << std::endl; // returns 4\n    cache.deleteKey(3);\n    std::cout << cache.get(3) << std::endl; // returns -1 (not found)\n    return 0;\n}\n```\n\n### Explanation\n\n1. **Node Structure**: Each node in the doubly-linked list holds a key-value pair and pointers to the previous and next nodes.\n2. **HashMap**: Maps keys to their corresponding nodes in the list for O(1) access.\n3. **MoveToFront Function**: Moves a node to the front of the list, marking it as most recently used.\n4. **EvictLeastRecent Function**: Removes the least recently used node (tail of the list) and updates the hash map.\n5. **Get Operation**: Retrieves the value for a key and moves the corresponding node to the front.\n6. **Put Operation**: Inserts or updates a key-value pair and moves the node to the front, evicting the least recently used item if the cache is full.\n7. **Delete Operation**: Removes a key and its corresponding node from the cache.\n\nThis implementation ensures all operations are performed in O(1) time complexity, making it efficient for scenarios where cache operations need to be fast."
    }
]