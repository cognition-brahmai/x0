[
    {
        "role": "user",
        "content": "Create a Python script that implements a stack data structure using a dynamic array, supporting push, pop, peek, and is_empty operations."
    },
    {
        "role": "assistant",
        "content": "Sure! I can help you with that. Let's create a Python script that implements a stack data structure using a dynamic array. We'll make sure to include the operations you mentioned: push, pop, peek, and is_empty.\n\nFirst, it's important to understand what a stack is. A stack is a linear data structure that follows the Last In, First Out (LIFO) principle. This means that the last element added to the stack is the first one to be removed.\n\nIn Python, we can use a list to implement a stack because lists in Python are dynamic arrays, which means they can resize themselves as needed. This is perfect for our purposes.\n\nHere's a step-by-step plan for our implementation:\n\n1. **Initialization**: We'll create a class called `Stack` and initialize it with an empty list to hold the stack's elements.\n\n2. **Push Operation**: This method will add an element to the top of the stack.\n\n3. **Pop Operation**: This method will remove and return the top element of the stack. We need to handle the case where the stack is empty.\n\n4. **Peek Operation**: This method will return the top element of the stack without removing it. Again, handle the empty stack case.\n\n5. **Is Empty Operation**: This method will return True if the stack is empty, otherwise False.\n\nLet's write the code accordingly.\n\n## Final Solution\nTo implement a stack data structure in Python using a dynamic array, we can use the built-in list type, which is ideal for this purpose due to its dynamic nature. Below is the code that provides a `Stack` class with the required operations: `push`, `pop`, `peek`, and `is_empty`.\n\n```python\nclass Stack:\n    def __init__(self):\n        self.items = []\n\n    def push(self, item):\n        self.items.append(item)\n\n    def pop(self):\n        if not self.is_empty():\n            return self.items.pop()\n        else:\n            raise IndexError(\"pop from empty stack\")\n\n    def peek(self):\n        if not self.is_empty():\n            return self.items[-1]\n        else:\n            raise IndexError(\"peek from empty stack\")\n\n    def is_empty(self):\n        return len(self.items) == 0\n\n# Example usage:\nif __name__ == \"__main__\":\n    stack = Stack()\n    print(\"Is the stack empty? \", stack.is_empty())  # Should print True\n\n    stack.push(1)\n    stack.push(2)\n    stack.push(3)\n\n    print(\"Stack after pushing 1, 2, 3:\")\n    print(stack.items)  # Should print [1, 2, 3]\n\n    print(\"Peek at top element:\", stack.peek())  # Should print 3\n\n    popped = stack.pop()\n    print(\"Popped:\", popped)  # Should print 3\n    print(\"Stack after popping:\")\n    print(stack.items)  # Should print [1, 2]\n\n    print(\"Is the stack empty? \", stack.is_empty())  # Should print False\n```\n\n### Explanation\n\n1. **Initialization**: \n   - We define a class `Stack` with a constructor that initializes an empty list `items`.\n\n2. **Push Operation**:\n   - The `push` method appends an item to the end of the list, which represents the top of the stack.\n\n3. **Pop Operation**:\n   - The `pop` method removes and returns the last item from the list (i.e., the top of the stack).\n   - If the stack is empty, it raises an `IndexError`.\n\n4. **Peek Operation**:\n   - The `peek` method returns the last item in the list without removing it.\n   - If the stack is empty, it raises an `IndexError`.\n\n5. **Is Empty Operation**:\n   - The `is_empty` method returns `True` if the stack (list) is empty, otherwise `False`.\n\nThis implementation ensures that the stack operations behave as expected, adhering to the LIFO principle, and handles cases where the stack is empty to prevent errors."
    }
]