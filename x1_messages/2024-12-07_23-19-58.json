[
    {
        "role": "user",
        "content": "Write a Python program that generates random mazes using Prim's algorithm and displays them as ASCII art.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Alright, I've got this task to create a Python program that generates random mazes using Prim's algorithm and then displays them as ASCII art. I'm excited about this because I've always been fascinated by mazes and algorithms that can create them. I've heard of Prim's algorithm before, but I'm not entirely sure how it works in the context of maze generation. So, I guess I need to do a bit of research on that.\n\nFirst things first, I need to understand what Prim's algorithm is and how it can be applied to generate mazes. I know that Prim's algorithm is primarily used to find the minimum spanning tree in a weighted graph, but I'm not sure how that translates to maze generation. Maybe there's a way to interpret a maze as a graph where the walls are edges and the paths are vertices, or something like that.\n\nI think I should look up some resources on maze generation algorithms, specifically focusing on Prim's algorithm. There must be tutorials or articles that explain this process step by step. Once I have a clear understanding of the algorithm, I can start thinking about how to implement it in Python.\n\nAlso, I need to figure out how to represent the maze in Python. Should I use a 2D list? Maybe a NumPy array would be more efficient, but I don't want to complicate things by introducing additional libraries if I can help it. Simplicity is key here, so a 2D list should suffice.\n\nThen, there's the matter of displaying the maze as ASCII art. I need to decide on a set of characters to represent walls and paths. Maybe use '#' for walls and spaces for paths. That's a common convention, and it should be easy to read.\n\nI should also consider the size of the maze. It would be good to allow the user to specify the dimensions, but to also set some default values in case they don't provide any. Maybe a 20x20 grid by default.\n\nAnother thing to think about is how to start the maze generation process. In Prim's algorithm, you usually start with an arbitrary vertex and build the MST from there. In the case of a maze, perhaps I can start from a random cell and expand from there, adding walls and paths according to the algorithm.\n\nI need to make sure that the maze is solvable, meaning that there's a path from any point in the maze to any other point. That's an important characteristic of mazes, and Prim's algorithm should ensure that, since it produces a spanning tree.\n\nLet me try to outline the steps for implementing Prim's algorithm for maze generation:\n\n1. Represent the maze as a grid of cells, where each cell can be either a wall or a path.\n\n2. Initialize all cells as walls, except for a starting cell which is set as a path.\n\n3. Create a list of walls, which are the edges between path cells and wall cells.\n\n4. Randomly select a wall from the list and consider removing it (i.e., turning it into a path) if it connects two different regions.\n\n5. Repeat step 4 until all walls have been considered, and the maze is fully generated.\n\nWait, that seems a bit vague. I need a more concrete plan. Maybe I should look for pseudocode or an example implementation to guide me.\n\nI recall that in maze generation, each cell can be thought of as a node in a graph, and the walls between cells are the edges. Prim's algorithm can be used to select a subset of these edges to form a minimum spanning tree, which in this case would represent the paths in the maze.\n\nBut since we're dealing with a grid, there might be a more grid-specific way to implement this algorithm.\n\nLet me try to find some pseudocode for Prim's algorithm in maze generation.\n\nAfter a quick search, I found this general outline for using Prim's algorithm to generate a maze:\n\n1. Choose a cell at random and add it to the maze.\n\n2. Add all the walls of this cell to a list of walls.\n\n3. While there are walls in the list:\n\na. Pick a random wall from the list.\n\nb. If the cell on the other side of this wall is not yet in the maze:\n\ni. Remove the wall.\n\nii. Add the new cell to the maze.\n\niii. Add the walls of the new cell to the list.\n\nc. Remove the wall from the list, regardless of whether it was removed or not.\n\n4. End when there are no more walls in the list.\n\nThis makes sense. So, in this context, \"adding a cell to the maze\" means marking it as a path, and \"removing a wall\" means connecting two cells by removing the wall between them.\n\nNow, I need to think about how to implement this in Python.\n\nFirst, I'll need a way to represent the grid. As I thought earlier, a 2D list should work. Each element in the list can represent a cell, and I can use, say, 0 for walls and 1 for paths.\n\nNext, I need to keep track of the walls. Each cell has four walls: north, south, east, and west. But walls are shared between adjacent cells, so I need to make sure that when I remove a wall between two cells, both cells reflect this change.\n\nMaybe instead of each cell having its own set of walls, I can have a separate data structure to represent the walls. But that might complicate things.\n\nAlternatively, I can use a grid where each cell contains information about which walls are present. For example, each cell can have a set of booleans indicating whether the north, south, east, and west walls are present.\n\nWait, but in the simplified version, if I just have a grid of cells that are either walls or paths, and I consider the paths to have no walls between them, that might be sufficient.\n\nLet me think differently. Perhaps I can represent the maze as a grid of cells, where each cell knows which of its walls have been removed.\n\nFor instance, each cell can have a dictionary with keys 'n', 's', 'e', 'w', indicating whether the north, south, east, or west wall is present.\n\nBut that might be too complicated for what I need.\n\nMaybe I can simplify it by just having a grid of cells, where each cell is either a wall or a path, and I keep track of the walls separately.\n\nWait, this is getting confusing. Maybe I should look for an existing implementation to see how others have done it.\n\nI found a few examples online, but I want to try to implement it myself as much as possible.\n\nLet me try to think of the grid as a list of lists, where each element is a cell, and each cell knows which of its walls have been removed.\n\nSo, I can define a Cell class with attributes for whether the north, south, east, and west walls are present.\n\nThat might be a good approach.\n\nHere's a rough outline of the Cell class:\n\nclass Cell:\n\ndef __init__(self):\n\nself.walls = {'n': True, 's': True, 'e': True, 'w': True}\n\nThen, I can create a grid of these cells.\n\nNext, I need to implement the maze generation using Prim's algorithm.\n\nI'll need to keep track of the walls between cells that are potential candidates for removal.\n\nI can maintain a list of walls, where each wall is a tuple containing the cells it separates.\n\nWait, but in the simplified version, maybe I can just pick a random cell to start, mark it as a path, and then add its neighboring walls to a list.\n\nThen, in each iteration, I pick a random wall from the list, and if the cell on the other side is a wall, I remove the wall and add the new cell's walls to the list.\n\nI need to be careful not to add walls that have already been considered.\n\nMaybe I need a way to track which walls have already been considered.\n\nThis is getting a bit tricky. Maybe I should consider using coordinates to represent cells and walls.\n\nLet's say I have a grid with rows and columns.\n\nEach cell can be identified by its row and column indices.\n\nThen, walls can be represented by the boundaries between cells.\n\nFor example, the wall to the east of cell (r, c) is shared with cell (r, c+1), assuming c+1 is within bounds.\n\nSimilarly, the wall to the south of cell (r, c) is shared with cell (r+1, c).\n\nThis seems promising.\n\nSo, I can represent the maze as a grid of cells, each with coordinates (r, c), and keep track of the walls between them.\n\nTo implement Prim's algorithm:\n\n1. Pick a random starting cell and mark it as part of the maze.\n\n2. Add all of its surrounding walls to a list of walls.\n\n3. While there are walls in the list:\n\na. Pick a random wall from the list.\n\nb. Let's call the cells on either side of the wall cell_A and cell_B.\n\nc. If cell_A is in the maze and cell_B is not, or vice versa:\n\ni. Remove the wall.\n\nii. Add cell_B to the maze.\n\niii. Add the walls of cell_B to the list of walls.\n\nd. Remove the wall from the list.\n\n4. Repeat until there are no more walls in the list.\n\nThis seems workable.\n\nNow, I need to think about how to implement this in code.\n\nFirst, I need a way to represent the grid.\n\nI can use a list of lists, where each element is a cell object.\n\nEach cell object can keep track of whether it's part of the maze or not, and which of its walls are still present.\n\nWait, but in this approach, I might not need to track individual walls for each cell, as long as I can track which walls separate maze cells from non-maze cells.\n\nActually, maybe it's simpler to just have a grid where each cell is either part of the maze or not, and maintain a separate list of candidate walls.\n\nLet me try to define the Cell class:\n\nclass Cell:\n\ndef __init__(self):\n\nself.in_maze = False\n\nself.walls = {'n': True, 's': True, 'e': True, 'w': True}\n\nThen, I can create a grid of cells:\n\nnum_rows = 10\n\nnum_cols = 10\n\ngrid = [[Cell() for _ in range(num_cols)] for _ in range(num_rows)]\n\nNext, I need to pick a random starting cell and mark it as part of the maze.\n\nimport random\n\nstart_row = random.randint(0, num_rows-1)\n\nstart_col = random.randint(0, num_cols-1)\n\ngrid[start_row][start_col].in_maze = True\n\nNow, I need to collect all the walls around the starting cell.\n\nI need to define what a \"wall\" is in this context.\n\nA wall is a boundary between two cells.\n\nSo, for each cell, it has four potential walls: north, south, east, and west.\n\nBut not all cells have all four walls; for example, cells on the edges of the grid have fewer walls.\n\nI need to make sure that when I consider a wall, I'm not going outside the grid.\n\nMaybe I can define a list of walls, where each wall is a tuple containing the coordinates of the two cells it separates.\n\nWait, but that might be inefficient for large grids.\n\nAlternatively, I can represent walls independently, but that could get complicated.\n\nPerhaps a better way is to iterate through all cells that are part of the maze and add their surrounding walls to the list of candidate walls.\n\nBut I need to make sure that each wall is only considered once.\n\nWait, maybe I can keep a separate list of walls and mark them as considered or not.\n\nThis is getting a bit messy.\n\nLet me look for a more straightforward way.\n\nI found a different approach that might be easier to implement.\n\nIn this approach, the grid is represented as a list of cells, where each cell contains its own walls.\n\nWhen a wall between two cells is removed, both cells update their wall information accordingly.\n\nHere's a rough outline:\n\n1. Initialize the grid with all cells having all their walls intact.\n\n2. Choose a starting cell and mark it as part of the maze.\n\n3. Create a list of walls from the starting cell.\n\n4. While there are walls in the list:\n\na. Pick a random wall from the list.\n\nb. Let cell_A be the cell on one side of the wall, and cell_B be the cell on the other side.\n\nc. If cell_B is not part of the maze:\n\ni. Remove the wall.\n\nii. Add cell_B to the maze.\n\niii. Add cell_B's walls to the list.\n\nd. Remove the wall from the list.\n\n5. Repeat until no walls are left in the list.\n\nThis seems similar to what I thought earlier.\n\nNow, I need to implement this in code.\n\nFirst, define the Cell class:\n\nclass Cell:\n\ndef __init__(self):\n\nself.walls = {'n': True, 's': True, 'e': True, 'w': True}\n\nself.in_maze = False\n\nThen, create the grid:\n\nnum_rows = 10\n\nnum_cols = 10\n\ngrid = [[Cell() for _ in range(num_cols)] for _ in range(num_rows)]\n\nChoose a random starting cell:\n\nstart_row = random.randint(0, num_rows-1)\n\nstart_col = random.randint(0, num_cols-1)\n\ngrid[start_row][start_col].in_maze = True\n\nNow, collect the initial list of walls.\n\nI need a way to get the walls of a cell.\n\nEach wall corresponds to a direction: north, south, east, west.\n\nFor example, the north wall of cell (r, c) is the wall above it, which is shared with cell (r-1, c), provided r-1 is within bounds.\n\nSimilarly, the south wall is shared with cell (r+1, c), and so on.\n\nSo, for each cell, I can define functions to get the neighboring cells in each direction.\n\ndef get_neighbor(row, col, direction):\n\nif direction == 'n' and row > 0:\n\nreturn grid[row-1][col]\n\nelif direction == 's' and row < num_rows-1:\n\nreturn grid[row+1][col]\n\nelif direction == 'e' and col < num_cols-1:\n\nreturn grid[row][col+1]\n\nelif direction == 'w' and col > 0:\n\nreturn grid[row][col-1]\n\nreturn None\n\nThen, for a given cell, I can get its walls by checking which neighboring cells exist and whether the wall in that direction is present.\n\nBut in Prim's algorithm, I need to consider walls that separate maze cells from non-maze cells.\n\nSo, for each cell that is part of the maze, I need to look at its surrounding walls and see if the neighboring cell is not part of the maze.\n\nIf so, add that wall to the list of candidate walls.\n\nThen, when I pick a random wall from the list, if the neighboring cell is not part of the maze, I remove the wall and add the neighboring cell to the maze.\n\nThis seems manageable.\n\nLet's try to implement this step by step.\n\nFirst, initialize the starting cell and its walls.\n\nwalls = []\n\nstart_cell = grid[start_row][start_col]\n\nfor direction in ['n', 's', 'e', 'w']:\n\nneighbor = get_neighbor(start_row, start_col, direction)\n\nif neighbor and not neighbor.in_maze:\n\nwalls.append((start_cell, direction))\n\nWait, but in this case, since the starting cell is the only one in the maze initially, all its walls should be candidate walls.\n\nNow, enter the main loop:\n\nwhile walls:\n\n# Pick a random wall\n\nrandom_index = random.randrange(len(walls))\n\nwall = walls[random_index]\n\ncell_A = wall[0]\n\ndirection = wall[1]\n\n# Get the neighboring cell\n\ncell_B = get_neighbor(cell_A.row, cell_A.col, direction)\n\nif cell_B and not cell_B.in_maze:\n\n# Remove the wall\n\ncell_A.walls[direction] = False\n\nif direction == 'n':\n\nopposite_direction = 's'\n\nelif direction == 's':\n\nopposite_direction = 'n'\n\nelif direction == 'e':\n\nopposite_direction = 'w'\n\nelif direction == 'w':\n\nopposite_direction = 'e'\n\ncell_B.walls[opposite_direction] = False\n\n# Add cell_B to the maze\n\ncell_B.in_maze = True\n\n# Add cell_B's walls to the list\n\nfor dir in ['n', 's', 'e', 'w']:\n\nneighbor = get_neighbor(cell_B.row, cell_B.col, dir)\n\nif neighbor and not neighbor.in_maze:\n\nwalls.append((cell_B, dir))\n\n# Remove the wall from the list\n\nwalls.pop(random_index)\n\nThis seems like it could work.\n\nBut I need to make sure that I'm handling the coordinates correctly.\n\nWait, in the Cell class, I don't have row and column attributes.\n\nI think I need to include the row and column indices in the Cell class so that I can easily get the neighbor's coordinates.\n\nLet me update the Cell class:\n\nclass Cell:\n\ndef __init__(self, row, col):\n\nself.row = row\n\nself.col = col\n\nself.walls = {'n': True, 's': True, 'e': True, 'w': True}\n\nself.in_maze = False\n\nThen, when creating the grid:\n\ngrid = [[Cell(row, col) for col in range(num_cols)] for row in range(num_rows)]\n\nNow, the get_neighbor function can be defined as:\n\ndef get_neighbor(cell, direction):\n\nrow = cell.row\n\ncol = cell.col\n\nif direction == 'n' and row > 0:\n\nreturn grid[row-1][col]\n\nelif direction == 's' and row < num_rows-1:\n\nreturn grid[row+1][col]\n\nelif direction == 'e' and col < num_cols-1:\n\nreturn grid[row][col+1]\n\nelif direction == 'w' and col > 0:\n\nreturn grid[row][col-1]\n\nreturn None\n\nThis should work.\n\nNow, back to the main loop.\n\nI think the earlier steps are correct.\n\nAfter the maze is generated, I need to convert the grid into ASCII art.\n\nFor that, I need to decide how to represent walls and paths.\n\nI'll use '#' for walls and ' ' (space) for paths.\n\nBut I need to consider that walls can be present or absent between cells.\n\nWait, in my current implementation, each cell knows which of its walls are present.\n\nSo, to draw the maze, I need to iterate through the grid and print the walls accordingly.\n\nThis might be a bit tricky.\n\nLet me think about how to print the maze.\n\nI need to print the north walls of each cell, then the west walls, and the paths in between.\n\nWait, maybe it's easier to think in terms of ASCII characters representing the walls and paths.\n\nEach cell can be represented by a set of wall characters around it.\n\nFor example, for each cell, I can have characters for the north, south, west, and east walls.\n\nThen, by combining these characters for all cells, I can form the entire maze as ASCII art.\n\nI found a helpful approach online where the maze is printed by iterating through each row and column and printing the appropriate wall or path characters.\n\nHere's a simplified version:\n\n- For each row, print the north walls of the cells.\n\n- Then, for each column in that row, print the west wall and the cell itself (as a space if it's a path).\n\n- Repeat for all rows and columns.\n\nThis seems manageable.\n\nLet me try to write a function to print the maze.\n\ndef print_maze(grid, num_rows, num_cols):\n\nfor row in range(num_rows):\n\n# Print the north walls\n\nprint('+', end='')\n\nfor col in range(num_cols):\n\nif grid[row][col].walls['n']:\n\nprint('---+', end='')\n\nelse:\n\nprint('   +', end='')\n\nprint()\n\n# Print the west walls and the cells\n\nprint('|', end='')\n\nfor col in range(num_cols):\n\nif grid[row][col].walls['w']:\n\nprint(' ', end='')\n\nelse:\n\nprint('  ', end='')\n\nif grid[row][col].in_maze:\n\nprint(' ', end='')\n\nelse:\n\nprint(' ', end='')\n\nprint('|', end='')\n\nprint()\n\n# Print the south walls of the last row\n\nprint('+', end='')\n\nfor col in range(num_cols):\n\nif grid[num_rows-1][col].walls['s']:\n\nprint('---+', end='')\n\nelse:\n\nprint('   +', end='')\n\nprint()\n\nThis should give a nice ASCII representation of the maze.\n\nNow, I need to put all these pieces together into a complete program.\n\nI should also consider adding some parameters for the user to specify the size of the maze.\n\nMaybe allow the user to input the number of rows and columns.\n\nI can set default values in case no inputs are provided.\n\nAdditionally, I can add some error checking to make sure that the inputs are positive integers.\n\nLet me outline the complete program structure:\n\n- Import necessary modules (random).\n\n- Define the Cell class with row and column attributes, walls, and in_maze status.\n\n- Define the get_neighbor function to get neighboring cells.\n\n- Define the print_maze function to display the maze as ASCII art.\n\n- Implement the maze generation using Prim's algorithm.\n\n- Allow user input for the number of rows and columns, with defaults.\n\n- Generate and print the maze.\n\nI should also consider the starting point for the maze.\n\nIn the earlier steps, I picked a random starting cell.\n\nThat should be fine.\n\nNow, let me think about how to handle user input.\n\nI can use the input function to ask for the number of rows and columns.\n\nI need to convert the input strings to integers and handle any potential errors.\n\nFor example, if the user enters a non-integer value or a negative number, I should prompt them to enter valid positive integers.\n\nI can use a while loop to keep asking until valid inputs are provided.\n\nAlternatively, for simplicity, I can just set default values and not prompt for input.\n\nSince the task is to write a Python program, I'll assume that the program can take command-line arguments for the maze dimensions.\n\nBut since the task is to write a program that generates random mazes and displays them as ASCII art, I'll make it simple and use default dimensions, say 10x10.\n\nIf I want to make it more interactive, I can add input prompts.\n\nBut to keep it straightforward, I'll use default values.\n\nNow, I need to make sure that the maze is fully connected, meaning there are no isolated sections.\n\nPrim's algorithm should ensure that, since it builds a minimal spanning tree covering all cells.\n\nBut I should test the generated mazes to confirm that they are indeed fully connected.\n\nAnother consideration is the complexity of the maze.\n\nI want the maze to look natural, with a good balance of paths and dead ends.\n\nPrim's algorithm should produce mazes with these characteristics.\n\nOnce the maze is generated, I need to display it correctly as ASCII art.\n\nI need to make sure that the walls are properly connected and that there are no gaps or overlaps.\n\nThis might require careful handling of the wall characters.\n\nLet me try to write some sample code to see if this approach works.\n\nI'll start by defining the Cell class and the get_neighbor function.\n\nThen, I'll create a grid with default dimensions and generate the maze using Prim's algorithm.\n\nFinally, I'll print the maze using the print_maze function.\n\nI should also consider the performance, especially for larger mazes.\n\nPrim's algorithm should be efficient enough for maze generation, but I need to make sure that the program doesn't take too long for large grids.\n\nPython might not be the fastest language, but for reasonable maze sizes, it should be fine.\n\nI can also think about optimizing the algorithm if needed, but for now, I'll stick with the basic implementation.\n\nAnother enhancement could be to allow the user to specify the starting point, but that's optional.\n\nFor now, I'll randomize the starting cell.\n\nAlright, I think I have a plan.\n\nLet me start implementing the code step by step.\n\nFirst, define the Cell class:\n\nclass Cell:\n\ndef __init__(self, row, col):\n\nself.row = row\n\nself.col = col\n\nself.walls = {'n': True, 's': True, 'e': True, 'w': True}\n\nself.in_maze = False\n\nNext, define the get_neighbor function:\n\ndef get_neighbor(grid, cell, direction):\n\nrow = cell.row\n\ncol = cell.col\n\nnum_rows = len(grid)\n\nnum_cols = len(grid[0])\n\nif direction == 'n' and row > 0:\n\nreturn grid[row-1][col]\n\nelif direction == 's' and row < num_rows-1:\n\nreturn grid[row+1][col]\n\nelif direction == 'e' and col < num_cols-1:\n\nreturn grid[row][col+1]\n\nelif direction == 'w' and col > 0:\n\nreturn grid[row][col-1]\n\nreturn None\n\nThen, create the grid with default dimensions:\n\nimport random\n\nnum_rows = 10\n\nnum_cols = 10\n\ngrid = [[Cell(row, col) for col in range(num_cols)] for row in range(num_rows)]\n\nChoose a random starting cell and mark it as part of the maze:\n\nstart_row = random.randint(0, num_rows-1)\n\nstart_col = random.randint(0, num_cols-1)\n\nstart_cell = grid[start_row][start_col]\n\nstart_cell.in_maze = True\n\nInitialize the list of walls with the starting cell's walls:\n\nwalls = []\n\nfor direction in ['n', 's', 'e', 'w']:\n\nneighbor = get_neighbor(grid, start_cell, direction)\n\nif neighbor and not neighbor.in_maze:\n\nwalls.append((start_cell, direction))\n\nNow, enter the main loop:\n\nwhile walls:\n\n# Pick a random wall\n\nrandom_index = random.randrange(len(walls))\n\nwall = walls[random_index]\n\ncell_A = wall[0]\n\ndirection = wall[1]\n\n# Get the neighboring cell\n\ncell_B = get_neighbor(grid, cell_A, direction)\n\nif cell_B and not cell_B.in_maze:\n\n# Remove the wall\n\ncell_A.walls[direction] = False\n\n# Remove the opposite wall in cell_B\n\nif direction == 'n':\n\nopposite_direction = 's'\n\nelif direction == 's':\n\nopposite_direction = 'n'\n\nelif direction == 'e':\n\nopposite_direction = 'w'\n\nelif direction == 'w':\n\nopposite_direction = 'e'\n\ncell_B.walls[opposite_direction] = False\n\n# Add cell_B to the maze\n\ncell_B.in_maze = True\n\n# Add cell_B's walls to the list\n\nfor dir in ['n', 's', 'e', 'w']:\n\nneighbor = get_neighbor(grid, cell_B, dir)\n\nif neighbor and not neighbor.in_maze:\n\nwalls.append((cell_B, dir))\n\n# Remove the wall from the list\n\nwalls.pop(random_index)\n\nFinally, print the maze:\n\ndef print_maze(grid, num_rows, num_cols):\n\nfor row in range(num_rows):\n\n# Print the north walls\n\nprint('+', end='')\n\nfor col in range(num_cols):\n\nif grid[row][col].walls['n']:\n\nprint('---+', end='')\n\nelse:\n\nprint('   +', end='')\n\nprint()\n\n# Print the west walls and the cells\n\nprint('|', end='')\n\nfor col in range(num_cols):\n\nif grid[row][col].walls['w']:\n\nprint(' ', end='')\n\nelse:\n\nprint('  ', end='')\n\nif grid[row][col].in_maze:\n\nprint(' ', end='')\n\nelse:\n\nprint(' ', end='')\n\nprint('|', end='')\n\nprint()\n\n# Print the south walls of the last row\n\nprint('+', end='')\n\nfor col in range(num_cols):\n\nif grid[num_rows-1][col].walls['s']:\n\nprint('---+', end='')\n\nelse:\n\nprint('   +', end='')\n\nprint()\n\nprint_maze(grid, num_rows, num_cols)\n\nThis should generate and display a random maze using Prim's algorithm.\n\nI need to test this code to make sure it works as expected.\n\nI can run it multiple times to see different mazes being generated.\n\nAlso, I should check if the maze is fully connected and if there are any errors in the wall configurations.\n\nIf everything looks good, I can consider adding more features, like allowing user input for maze dimensions or specifying the starting point.\n\nBut for now, this should suffice.\n\nI think this meets the requirements of the task.\n\n**Final Solution**\n\nTo create a Python program that generates random mazes using Prim's algorithm and displays them as ASCII art, follow these steps:\n\n### Approach\n\n1. **Representation**:\n   - Use a 2D grid of `Cell` objects, where each `Cell` tracks its walls and whether it's part of the maze.\n\n2. **Prim's Algorithm**:\n   - Start from a random cell, mark it as part of the maze, and add its walls to a list.\n   - Randomly select a wall from the list:\n     - If the adjacent cell is not part of the maze, remove the wall, add the new cell to the maze, and add the new cell's walls to the list.\n   - Repeat until no walls are left in the list.\n\n3. **ASCII Art**:\n   - Print the grid by combining wall and path characters to form the maze visually.\n\n### Solution Code\n\n```python\nimport random\n\nclass Cell:\n    def __init__(self, row, col):\n        self.row = row\n        self.col = col\n        self.walls = {'n': True, 's': True, 'e': True, 'w': True}\n        self.in_maze = False\n\ndef get_neighbor(grid, cell, direction):\n    row = cell.row\n    col = cell.col\n    num_rows = len(grid)\n    num_cols = len(grid[0])\n    if direction == 'n' and row > 0:\n        return grid[row-1][col]\n    elif direction == 's' and row < num_rows-1:\n        return grid[row+1][col]\n    elif direction == 'e' and col < num_cols-1:\n        return grid[row][col+1]\n    elif direction == 'w' and col > 0:\n        return grid[row][col-1]\n    return None\n\ndef print_maze(grid, num_rows, num_cols):\n    for row in range(num_rows):\n        # Print the north walls\n        print('+', end='')\n        for col in range(num_cols):\n            if grid[row][col].walls['n']:\n                print('---+', end='')\n            else:\n                print('   +', end='')\n        print()\n        # Print the west walls and the cells\n        print('|', end='')\n        for col in range(num_cols):\n            if grid[row][col].walls['w']:\n                print(' ', end='')\n            else:\n                print('  ', end='')\n            if grid[row][col].in_maze:\n                print(' ', end='')\n            else:\n                print(' ', end='')\n            print('|', end='')\n        print()\n    # Print the south walls of the last row\n    print('+', end='')\n    for col in range(num_cols):\n        if grid[num_rows-1][col].walls['s']:\n            print('---+', end='')\n        else:\n            print('   +', end='')\n    print()\n\ndef generate_maze(num_rows, num_cols):\n    grid = [[Cell(row, col) for col in range(num_cols)] for row in range(num_rows)]\n    start_row = random.randint(0, num_rows-1)\n    start_col = random.randint(0, num_cols-1)\n    start_cell = grid[start_row][start_col]\n    start_cell.in_maze = True\n\n    walls = []\n    for direction in ['n', 's', 'e', 'w']:\n        neighbor = get_neighbor(grid, start_cell, direction)\n        if neighbor and not neighbor.in_maze:\n            walls.append((start_cell, direction))\n\n    while walls:\n        random_index = random.randrange(len(walls))\n        wall = walls[random_index]\n        cell_A = wall[0]\n        direction = wall[1]\n        cell_B = get_neighbor(grid, cell_A, direction)\n        if cell_B and not cell_B.in_maze:\n            cell_A.walls[direction] = False\n            if direction == 'n':\n                opposite_direction = 's'\n            elif direction == 's':\n                opposite_direction = 'n'\n            elif direction == 'e':\n                opposite_direction = 'w'\n            elif direction == 'w':\n                opposite_direction = 'e'\n            cell_B.walls[opposite_direction] = False\n            cell_B.in_maze = True\n            for dir in ['n', 's', 'e', 'w']:\n                neighbor = get_neighbor(grid, cell_B, dir)\n                if neighbor and not neighbor.in_maze:\n                    walls.append((cell_B, dir))\n        walls.pop(random_index)\n    return grid\n\nif __name__ == \"__main__\":\n    num_rows = 10\n    num_cols = 10\n    grid = generate_maze(num_rows, num_cols)\n    print_maze(grid, num_rows, num_cols)\n```\n\n### Explanation\n\n1. **Cell Class**:\n   - Each `Cell` object holds its position (row and column), a dictionary of wall statuses, and a flag indicating if it's part of the maze.\n\n2. **get_neighbor Function**:\n   - Determines the neighboring cell in a given direction, ensuring the position is within grid bounds.\n\n3. **print_maze Function**:\n   - Iterates through the grid to print walls and paths, forming the maze in ASCII art format.\n\n4. **generate_maze Function**:\n   - Initializes the grid and starts from a random cell.\n   - Uses Prim's algorithm to build the maze by randomly removing walls between cells.\n\n5. **Main Block**:\n   - Sets default maze dimensions and generates the maze.\n   - Prints the generated maze using ASCII characters."
    }
]