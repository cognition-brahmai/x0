[
    {
        "role": "user",
        "content": "Create a Python script that uses the FastAPI framework to build a weather forecasting API, which fetches data from OpenWeatherMap API and caches it for a certain period before making another request."
    },
    {
        "role": "assistant",
        "content": "Alright, I have this task to create a Python script using FastAPI to build a weather forecasting API. This API should fetch data from OpenWeatherMap and cache it for a certain period before making another request. Okay, let's break this down.\n\nFirst, I need to set up a FastAPI project. I'm familiar with FastAPI, but just to make sure, I'll recall the basics. FastAPI is a modern, fast (high-performance), web framework for building APIs with Python. It's based on Starlette and Pydantic.\n\nSo, to start, I need to create a new directory for my project, say, \"weather_api\". Inside this directory, I'll set up a virtual environment to manage dependencies properly. I can use venv for this:\n\n```bash\npython -m venv venv\nsource venv/bin/activate  # On Windows use `venv\\Scripts\\activate`\n```\n\nNext, I need to install FastAPI and Uvicorn. Uvicorn is an ASGI server that we'll use to run our application.\n\n```bash\npip install fastapi uvicorn\n```\n\nNow, I'll create a main Python file, let's call it `main.py`, which will contain all the FastAPI application code.\n\nIn `main.py`, I'll start by importing FastAPI and creating an instance of it:\n\n```python\nfrom fastapi import FastAPI\n\napp = FastAPI()\n```\n\nNow, I need to integrate OpenWeatherMap API. To do that, I first need to sign up for an API key from OpenWeatherMap. I can do that by visiting their website and creating an account.\n\nOnce I have the API key, I need to make requests to their API to get weather data. For that, I'll use the `requests` library, which I need to install:\n\n```bash\npip install requests\n```\n\nI'll create an endpoint in my FastAPI app that users can hit to get weather forecasts for a specific location. Let's say the endpoint will be `/weather` and it will accept a query parameter `city` to specify the city for which the weather is required.\n\nSo, in `main.py`, I'll define a path operation for `/weather`:\n\n```python\nfrom fastapi import FastAPI, Query\nimport requests\n\napp = FastAPI()\n\n@app.get(\"/weather\")\nasync def get_weather(city: str = Query(..., description=\"Name of the city\")):\n    # Make a request to OpenWeatherMap API\n    api_key = \"YOUR_OPENWEATHERMAP_API_KEY\"\n    url = f\"http://api.openweathermap.org/data/2.5/weather?q={city}&appid={api_key}\"\n    response = requests.get(url)\n    data = response.json()\n    return data\n```\n\nHere, I'm using the `Query` parameter to make the `city` parameter required and provide a description for it. The `requests.get` makes a synchronous HTTP request, which is fine for this example, but in a production setting, I might want to use an asynchronous HTTP client like `httpx` to keep the application non-blocking.\n\nHowever, this doesn't include caching. I need to add caching\u673a\u5236 to avoid hitting the OpenWeatherMap API too frequently for the same city. There are several ways to implement caching in Python. One simple way is to use the `cachetools` library, which provides various caching primitives.\n\nI'll install `cachetools`:\n\n```bash\npip install cachetools\n```\n\nThen, I can use a TTLCache, which is a cache that removes entries after a certain time to live.\n\nFirst, import the necessary modules:\n\n```python\nfrom cachetools import TTLCache\nfrom typing import Optional\n```\n\nThen, create a cache instance with a specified max size and TTL (time to live in seconds):\n\n```python\ncache = TTLCache(maxsize=100, ttl=3600)  # Cache up to 100 items, each expires after 1 hour\n```\n\nNow, modify the `get_weather` function to check the cache before making a new request:\n\n```python\n@app.get(\"/weather\")\nasync def get_weather(city: str = Query(..., description=\"Name of the city\")):\n    # Check if city is in cache\n    if city in cache:\n        return cache[city]\n    \n    # If not in cache, make a request to OpenWeatherMap API\n    api_key = \"YOUR_OPENWEATHERMAP_API_KEY\"\n    url = f\"http://api.openweathermap.org/data/2.5/weather?q={city}&appid={api_key}\"\n    response = requests.get(url)\n    data = response.json()\n    \n    # Store the data in cache\n    cache[city] = data\n    \n    return data\n```\n\nThis way, if the city's weather data is already in the cache and hasn't expired, it's returned directly. Otherwise, a new request is made, and the result is stored in the cache for future requests.\n\nBut wait, there's a potential issue here. What if the city is not found or the API returns an error? In that case, I don't want to cache the error response indefinitely. I should maybe cache it for a shorter period or handle it differently.\n\nLet's add some error handling:\n\n```python\n@app.get(\"/weather\")\nasync def get_weather(city: str = Query(..., description=\"Name of the city\")):\n    # Check if city is in cache\n    if city in cache:\n        return cache[city]\n    \n    # If not in cache, make a request to OpenWeatherMap API\n    api_key = \"YOUR_OPENWEATHERMAP_API_KEY\"\n    url = f\"http://api.openweathermap.org/data/2.5/weather?q={city}&appid={api_key}\"\n    response = requests.get(url)\n    data = response.json()\n    \n    # Check if the request was successful\n    if response.status_code == 200:\n        # Store the data in cache\n        cache[city] = data\n    else:\n        # Maybe cache the error for a shorter time, say 10 minutes\n        cache[city] = data\n        cache.expire(city, 600)  # Expire in 10 minutes\n    \n    return data\n```\n\nHere, if the request is successful (status code 200), I cache the data with the default TTL of 1 hour. If there's an error, I cache the error response but set a shorter expiration time, say 10 minutes.\n\nThis should handle both successful and unsuccessful responses appropriately.\n\nAnother consideration is that multiple requests for the same city might be happening almost simultaneously, and with caching, only one request should actually hit the OpenWeatherMap API, while others wait for the result and then cache it.\n\nHowever, in the current implementation, if two requests for the same city come in at the same time, both will check the cache, not find the city, and both will make a request to OpenWeatherMap API. To prevent this, I can implement a locking mechanism to ensure that only one request is made to the API while others wait for the result.\n\nFor this, I can use the `cachetools` library's `TLRCache` or implement my own locking mechanism using `asyncio.Lock`.\n\nSince FastAPI is asynchronous, I should consider using asynchronous programming features to handle concurrency properly.\n\nFirst, I need to make the `get_weather` function asynchronous. I'll use `httpx` instead of `requests` for asynchronous HTTP requests.\n\nInstall `httpx`:\n\n```bash\npip install httpx\n```\n\nThen, modify the code to use `httpx`:\n\n```python\nfrom fastapi import FastAPI, Query\nimport httpx\nfrom cachetools import TTLCache\nfrom typing import Optional\nimport asyncio\n\napp = FastAPI()\n\ncache = TTLCache(maxsize=100, ttl=3600)  # Cache up to 100 items, each expires after 1 hour\nlocks = {}\n\n@app.get(\"/weather\")\nasync def get_weather(city: str = Query(..., description=\"Name of the city\")):\n    # Check if city is in cache\n    if city in cache:\n        return cache[city]\n    \n    # If not in cache, check if a request is already in progress\n    if city not in locks:\n        locks[city] = asyncio.Lock()\n    \n    async with locks[city]:\n        # Double-check if city is in cache while waiting for the lock\n        if city in cache:\n            return cache[city]\n        \n        # Make an asynchronous request to OpenWeatherMap API\n        api_key = \"YOUR_OPENWEATHERMAP_API_KEY\"\n        url = f\"http://api.openweathermap.org/data/2.5/weather?q={city}&appid={api_key}\"\n        async with httpx.AsyncClient() as client:\n            response = await client.get(url)\n            data = response.json()\n        \n        # Check if the request was successful\n        if response.status_code == 200:\n            # Store the data in cache\n            cache[city] = data\n        else:\n            # Cache the error for a shorter time, say 10 minutes\n            cache[city] = data\n            cache.expire(city, 600)  # Expire in 10 minutes\n        \n        return data\n```\n\nHere, I'm using a dictionary of `asyncio.Lock` objects to ensure that only one request is made to the API for a particular city at a time. Other requests for the same city will wait for the lock to be released and then use the cached result.\n\nThis should handle concurrency better and reduce the load on the OpenWeatherMap API.\n\nAnother improvement could be to make the cache size and TTL configurable, perhaps through environment variables. This way, I can adjust them without changing the code.\n\nI can use the `python-dotenv` library to load environment variables from a `.env` file.\n\nFirst, install `python-dotenv`:\n\n```bash\npip install python-dotenv\n```\n\nThen, create a `.env` file in the project root with the following content:\n\n```\nOPENWEATHERMAP_API_KEY=your_api_key_here\nCACHE_MAXSIZE=100\nCACHE_TTL=3600\n```\n\nNow, modify `main.py` to read these variables:\n\n```python\nfrom fastapi import FastAPI, Query\nimport httpx\nfrom cachetools import TTLCache\nfrom typing import Optional\nimport asyncio\nfrom dotenv import load_dotenv\nimport os\n\nload_dotenv()\n\napp = FastAPI()\n\nCACHE_MAXSIZE = int(os.getenv(\"CACHE_MAXSIZE\", \"100\"))\nCACHE_TTL = int(os.getenv(\"CACHE_TTL\", \"3600\"))\ncache = TTLCache(maxsize=CACHE_MAXSIZE, ttl=CACHE_TTL)  # Cache up to 100 items, each expires after 1 hour\nlocks = {}\n\n@app.get(\"/weather\")\nasync def get_weather(city: str = Query(..., description=\"Name of the city\")):\n    # Check if city is in cache\n    if city in cache:\n        return cache[city]\n    \n    # If not in cache, check if a request is already in progress\n    if city not in locks:\n        locks[city] = asyncio.Lock()\n    \n    async with locks[city]:\n        # Double-check if city is in cache while waiting for the lock\n        if city in cache:\n            return cache[city]\n        \n        # Make an asynchronous request to OpenWeatherMap API\n        api_key = os.getenv(\"OPENWEATHERMAP_API_KEY\")\n        url = f\"http://api.openweathermap.org/data/2.5/weather?q={city}&appid={api_key}\"\n        async with httpx.AsyncClient() as client:\n            response = await client.get(url)\n            data = response.json()\n        \n        # Check if the request was successful\n        if response.status_code == 200:\n            # Store the data in cache\n            cache[city] = data\n        else:\n            # Cache the error for a shorter time, say 10 minutes\n            cache[city] = data\n            cache.expire(city, 600)  # Expire in 10 minutes\n        \n        return data\n```\n\nThis makes the cache configuration more flexible and keeps sensitive information like API keys out of the code.\n\nAdditionally, I should handle cases where the city name is invalid or not found. OpenWeatherMap API might return a specific error code for such cases, and I should propagate that back to the user.\n\nAlso, I might want to add more detailed error responses. For example, if the city is not found, I can return a 404 status code, or if there's an error with the OpenWeatherMap API, I can return a 500 internal server error.\n\nLet's enhance the error handling:\n\n```python\nfrom fastapi import FastAPI, Query, HTTPException\n\n# ... other imports ...\n\n@app.get(\"/weather\")\nasync def get_weather(city: str = Query(..., description=\"Name of the city\")):\n    # Check if city is in cache\n    if city in cache:\n        return cache[city]\n    \n    # If not in cache, check if a request is already in progress\n    if city not in locks:\n        locks[city] = asyncio.Lock()\n    \n    async with locks[city]:\n        # Double-check if city is in cache while waiting for the lock\n        if city in cache:\n            return cache[city]\n        \n        # Make an asynchronous request to OpenWeatherMap API\n        api_key = os.getenv(\"OPENWEATHERMAP_API_KEY\")\n        url = f\"http://api.openweathermap.org/data/2.5/weather?q={city}&appid={api_key}\"\n        async with httpx.AsyncClient() as client:\n            response = await client.get(url)\n            data = response.json()\n        \n        # Check if the request was successful\n        if response.status_code == 200:\n            # Store the data in cache\n            cache[city] = data\n        elif response.status_code == 404:\n            # City not found\n            raise HTTPException(status_code=404, detail=\"City not found\")\n        else:\n            # Other errors, cache the error for a shorter time, say 10 minutes\n            cache[city] = data\n            cache.expire(city, 600)  # Expire in 10 minutes\n            raise HTTPException(status_code=500, detail=\"Failed to fetch weather data\")\n        \n        return data\n```\n\nHere, I'm raising FastAPI's `HTTPException` for specific error cases, which will return the appropriate HTTP status codes and messages to the client.\n\nFurthermore, I can add more features like caching by latitude and longitude instead of just city name, or supporting multiple units (Celsius, Fahrenheit), but for the scope of this task, this should suffice.\n\nTo run the application, I can use Uvicorn by running:\n\n```bash\nuvicorn main:app --reload\n```\n\nThis will start the server, and I can access the API at `http://127.0.0.1:8000/weather?city=London`, for example.\n\nI should also consider adding API documentation, which FastAPI provides automatically via Swagger UI and ReDoc. I can access them at `http://127.0.0.1:8000/docs` and `http://127.0.0.1:8000/redoc`, respectively.\n\nIn summary, I've created a FastAPI application that fetches weather data from OpenWeatherMap API and caches it using `cachetools` to reduce the load and improve response times. I've also handled concurrency and errors appropriately.\n\n**Final `main.py` code:**\n\n```python\nfrom fastapi import FastAPI, Query, HTTPException\nimport httpx\nfrom cachetools import TTLCache\nfrom typing import Optional\nimport asyncio\nfrom dotenv import load_dotenv\nimport os\n\nload_dotenv()\n\napp = FastAPI()\n\nCACHE_MAXSIZE = int(os.getenv(\"CACHE_MAXSIZE\", \"100\"))\nCACHE_TTL = int(os.getenv(\"CACHE_TTL\", \"3600\"))\ncache = TTLCache(maxsize=CACHE_MAXSIZE, ttl=CACHE_TTL)  # Cache up to 100 items, each expires after 1 hour\nlocks = {}\n\n@app.get(\"/weather\")\nasync def get_weather(city: str = Query(..., description=\"Name of the city\")):\n    # Check if city is in cache\n    if city in cache:\n        return cache[city]\n    \n    # If not in cache, check if a request is already in progress\n    if city not in locks:\n        locks[city] = asyncio.Lock()\n    \n    async with locks[city]:\n        # Double-check if city is in cache while waiting for the lock\n        if city in cache:\n            return cache[city]\n        \n        # Make an asynchronous request to OpenWeatherMap API\n        api_key = os.getenv(\"OPENWEATHERMAP_API_KEY\")\n        url = f\"http://api.openweathermap.org/data/2.5/weather?q={city}&appid={api_key}\"\n        async with httpx.AsyncClient() as client:\n            response = await client.get(url)\n            data = response.json()\n        \n        # Check if the request was successful\n        if response.status_code == 200:\n            # Store the data in cache\n            cache[city] = data\n        elif response.status_code == 404:\n            # City not found\n            raise HTTPException(status_code=404, detail=\"City not found\")\n        else:\n            # Other errors, cache the error for a shorter time, say 10 minutes\n            cache[city] = data\n            cache.expire(city, 600)  # Expire in 10 minutes\n            raise HTTPException(status_code=500, detail=\"Failed to fetch weather data\")\n        \n        return data\n```\n\n**`.env` file:**\n\n```\nOPENWEATHERMAP_API_KEY=your_api_key_here\nCACHE_MAXSIZE=100\nCACHE_TTL=3600\n```\n\n**To run the application:**\n\n```bash\nuvicorn main:app --reload\n```\n\n**Access the API:**\n\n- Docs: `http://127.0.0.1:8000/docs`\n- ReDoc: `http://127.0.0.1:8000/redoc`\n- Weather data: `http://127.0.0.1:8000/weather?city=London`"
    }
]