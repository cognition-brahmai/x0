[
    {
        "role": "user",
        "content": "Implement a simple LRU (Least Recently Used) cache in Python with the following features:\n   - Set and get methods for adding and retrieving items from the cache.\n   - A maximum size for the cache, after which the least recently used item is evicted when a new item is added.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Sure! I can help you implement a simple LRU cache in Python with the specified features. We'll create a class that handles setting and getting items, and manages a maximum size, evicting the least recently used item when necessary.\n\nTo achieve this, we'll use a combination of a dictionary for quick access and a doubly linked list to keep track of the order in which items are used. The doubly linked list will help us efficiently move recently used items to the front and remove the least recently used items from the end.\n\nHere's a step-by-step implementation:\n\n1. **Doubly Linked List Node**: We'll create a node class for the doubly linked list, which will hold the key and value, as well as pointers to the next and previous nodes.\n\n2. **Doubly Linked List**: We'll manage a doubly linked list to maintain the order of item usage. The front of the list will hold the most recently used item, and the end will hold the least recently used item.\n\n3. **LRUCache Class**: This class will use a dictionary to store references to the nodes, allowing O(1) access time. It will also maintain a count of the number of items to handle the maximum size.\n\n4. **Set Method**: This method will add a new item or update an existing item's value and move it to the front of the list. If the cache is full, it will evict the least recently used item.\n\n5. **Get Method**: This method will retrieve an item's value, move it to the front of the list to mark it as recently used, and return the value.\n\nLet's write the code accordingly:\n\n```python\nclass Node:\n    def __init__(self, key, value):\n        self.key = key\n        self.value = value\n        self.prev = None\n        self.next = None\n\nclass DoublyLinkedList:\n    def __init__(self):\n        self.head = None\n        self.tail = None\n\n    def append_front(self, node):\n        if self.head is None:\n            self.head = node\n            self.tail = node\n        else:\n            node.next = self.head\n            self.head.prev = node\n            self.head = node\n\n    def remove(self, node):\n        if node.prev:\n            node.prev.next = node.next\n        else:\n            self.head = node.next\n        if node.next:\n            node.next.prev = node.prev\n        else:\n            self.tail = node.prev\n        node.prev = None\n        node.next = None\n\nclass LRUCache:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.cache = {}\n        self.list = DoublyLinkedList()\n        self.count = 0\n\n    def get(self, key):\n        if key in self.cache:\n            node = self.cache[key]\n            self.list.remove(node)\n            self.list.append_front(node)\n            return node.value\n        else:\n            return -1  # or None, depending on your preference\n\n    def set(self, key, value):\n        if key in self.cache:\n            node = self.cache[key]\n            node.value = value\n            self.list.remove(node)\n            self.list.append_front(node)\n        else:\n            new_node = Node(key, value)\n            self.cache[key] = new_node\n            self.list.append_front(new_node)\n            self.count += 1\n            if self.count > self.capacity:\n                del self.cache[self.list.tail.key]\n                self.list.remove(self.list.tail)\n                self.count -= 1\n```\n\n### Explanation:\n\n- **Node Class**: Represents an element in the doubly linked list, with pointers to previous and next nodes.\n- **DoublyLinkedList Class**: Manages the linked list operations like appending to the front and removing a node.\n- **LRUCache Class**: Manages the cache operations:\n  - **Get**: Retrieves the value for a key if it exists, moves the accessed node to the front.\n  - **Set**: Adds a new key-value pair or updates an existing one, ensuring the cache doesn't exceed its capacity by evicting the least recently used item.\n\nThis implementation ensures that both get and set operations are efficient, typically O(1) time complexity, making it suitable for scenarios where fast access and limited memory are crucial."
    }
]