[
    {
        "role": "user",
        "content": "Develop a Python script that takes a directory path as a command-line argument and compresses all files within the specified directory into a single ZIP archive. The script should also display the total size of the compressed files and the compression ratio achieved."
    },
    {
        "role": "assistant",
        "content": "To create a Python script that compresses all files within a specified directory into a single ZIP archive and provides the total size of the compressed files along with the compression ratio, you can follow these steps:\n\n1. **Parse Command-Line Arguments:** Use the `sys` module to handle command-line arguments.\n2. **List Files in Directory:** Use the `os` module to list all files in the specified directory.\n3. **Create ZIP Archive:** Use the `zipfile` module to create a ZIP archive and add files to it.\n4. **Calculate Sizes and Compression Ratio:** Calculate the total size of the original files and the compressed archive to determine the compression ratio.\n\nHere's a sample script that accomplishes this:\n\n```python\nimport sys\nimport os\nimport zipfile\n\ndef get_directory_size(directory):\n    total_size = 0\n    for dirpath, dirnames, filenames in os.walk(directory):\n        for f in filenames:\n            fp = os.path.join(dirpath, f)\n            # Skip symbolic links\n            if not os.path.islink(fp):\n                total_size += os.path.getsize(fp)\n    return total_size\n\ndef main():\n    if len(sys.argv) != 2:\n        print(\"Usage: python compress_directory.py <directory_path>\")\n        sys.exit(1)\n    \n    directory = sys.argv[1]\n    if not os.path.isdir(directory):\n        print(f\"Error: {directory} is not a valid directory.\")\n        sys.exit(1)\n    \n    zip_filename = os.path.basename(directory) + '.zip'\n    with zipfile.ZipFile(zip_filename, 'w', zipfile.ZIP_DEFLATED) as zipf:\n        for root, dirs, files in os.walk(directory):\n            for file in files:\n                file_path = os.path.join(root, file)\n                arcname = os.path.relpath(file_path, directory)\n                zipf.write(file_path, arcname)\n    \n    original_size = get_directory_size(directory)\n    compressed_size = os.path.getsize(zip_filename)\n    compression_ratio = (original_size - compressed_size) / original_size * 100\n    \n    print(f\"Compression complete. Original size: {original_size} bytes, Compressed size: {compressed_size} bytes\")\n    print(f\"Compression ratio: {compression_ratio:.2f}%\")\n    \nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation:\n\n1. **Command-Line Argument Parsing:**\n   - The script checks if exactly one command-line argument (the directory path) is provided. If not, it prints usage information and exits.\n\n2. **Directory Validation:**\n   - It verifies if the provided path is a valid directory. If not, it outputs an error message and exits.\n\n3. **Creating ZIP Archive:**\n   - It constructs the ZIP file name based on the directory name.\n   - It walks through the directory tree, adding each file to the ZIP archive while maintaining the relative file paths.\n\n4. **Calculating Sizes and Compression Ratio:**\n   - `get_directory_size` function recursively calculates the total size of all files in the directory.\n   - After creating the ZIP archive, it calculates the size of the archive and then computes the compression ratio based on the original and compressed sizes.\n\nThis script provides a straightforward way to compress a directory and evaluate the effectiveness of the compression."
    }
]