[
    {
        "role": "user",
        "content": "Implement a basic calculator using C++ that supports addition, subtraction, multiplication, and division operations on integers. The calculator should be able to parse input expressions in infix notation (e.g., \"5 + 3 * 2\") and return the correct result. Use object-oriented programming principles to design the calculator.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Alright, I've got this task to create a basic calculator in C++ that can handle addition, subtraction, multiplication, and division of integers. It should take infix notation expressions like \"5 + 3 * 2\" and compute the right answer. Also, I need to use object-oriented programming principles for this. Okay, let's break this down.\n\nFirst, I need to understand what infix notation is. Infix notation is where operators are placed between operands, like \"5 + 3\". But expressions can get complicated with multiple operators and parentheses, so I need a way to parse and evaluate these expressions correctly, considering the operator precedence and associativity.\n\nI remember that to evaluate infix expressions, one common approach is to convert them to postfix (also known as Reverse Polish Notation, RPN) and then evaluate the postfix expression, which is straightforward. There's a well-known algorithm for infix to postfix conversion using a stack.\n\nSo, maybe I can design my calculator in two main stages:\n\n1. Convert the infix expression to postfix.\n\n2. Evaluate the postfix expression.\n\nLet me think about how to structure this in C++ using OOP principles. I should probably have a Calculator class that can take an infix expression as input, convert it to postfix, and then evaluate it.\n\nI'll need some helper classes or functions for tokenizing the input expression, handling operators, and managing the stacks for conversion and evaluation.\n\nLet's consider the components:\n\n- **Tokenization**: Break the input string into tokens (operands and operators).\n\n- **Operator Precedence**: Define the precedence of operators to correctly convert infix to postfix.\n\n- **Stacks**: Implement stacks for operator stacking during conversion.\n\n- **Postfix Evaluation**: Evaluate the postfix expression using a stack.\n\nI should also handle potential errors, like division by zero or invalid inputs.\n\nLet me sketch a rough outline of the Calculator class:\n\n```cpp\nclass Calculator {\nprivate:\n    // Methods for infix to postfix conversion\n    std::string infixToPostfix(const std::string& infix);\n\n    // Methods for postfix evaluation\n    int evaluatePostfix(const std::string& postfix);\n\n    // Helper methods for token handling, precedence, etc.\n    // ...\n\npublic:\n    // Constructor\n    Calculator();\n\n    // Main method to calculate the expression\n    int calculate(const std::string& expression);\n};\n```\n\nI need to handle tokens, which can be numbers or operators. I should define what constitutes each type.\n\nOperators: +, -, *, /\n\nParentheses: (, )\n\nNumbers: sequences of digits (integers in this case)\n\nI need to tokenize the input expression by separating these tokens. For example, \"5 + 3 * 2\" should be split into [\"5\", \"+\", \"3\", \"*\", \"2\"].\n\nNext, I need to convert this infix list of tokens into postfix notation. For that, I'll use a stack to hold operators and output tokens to a vector or string.\n\nThe algorithm for infix to postfix conversion is something like:\n\n1. Initialize an empty stack and an empty output list.\n\n2. Read the infix expression from left to right.\n\n- If the token is an operand, add it to the output list.\n\n- If the token is an operator, pop operators from the stack to the output list if they have higher or equal precedence than the current operator (and if the stack isn't empty). Then push the current operator onto the stack.\n\n- If the token is a left parenthesis, push it onto the stack.\n\n- If the token is a right parenthesis, pop operators from the stack to the output list until a left parenthesis is encountered. Remove the left parenthesis from the stack.\n\n3. After reading all tokens, pop any remaining operators from the stack to the output list.\n\nFinally, evaluate the postfix expression by:\n\n1. Initialize an empty stack.\n\n2. Read the postfix expression from left to right.\n\n- If the token is an operand, push it onto the stack.\n\n- If the token is an operator, pop the top two operands from the stack, apply the operator, and push the result back onto the stack.\n\n3. After reading all tokens, the result should be on the top of the stack.\n\nI need to implement these steps in C++. I should also consider how to handle negative numbers and the unary minus operator.\n\nWait, the task specifies integers and operations like addition, subtraction, multiplication, and division. It doesn't mention negative numbers or unary operators, but to make the calculator more robust, maybe I should consider them.\n\nIf I decide to handle negative numbers, I need to recognize them as single tokens, like \"-5\", rather than treating '-' as a unary operator initially.\n\nAlternatively, I can treat '-' as a unary operator if it appears at the beginning of the expression or after an operator.\n\nBut to keep it simple, perhaps I can assume that all operands are non-negative integers and handle only binary operators.\n\nLet me check the task again: \"Implement a basic calculator using C++ that supports addition, subtraction, multiplication, and division operations on integers. The calculator should be able to parse input expressions in infix notation (e.g., \"5 + 3 * 2\") and return the correct result.\"\n\nIt doesn't specify handling negative numbers or unary operators, so I'll assume that all operands are non-negative integers and that '-' is only used as a subtraction operator.\n\nBut to make the calculator more versatile, I might consider handling negative numbers as separate tokens.\n\nOkay, I'll proceed with that assumption.\n\nNow, about error handling: I need to handle cases like division by zero, invalid tokens, mismatched parentheses, etc.\n\nI should throw exceptions or return error codes in such cases.\n\nAlso, I need to make sure that the input expression is well-formed, with matching parentheses and correct operator usage.\n\nFor now, I'll assume that the input expressions are well-formed and handle only the specified operations.\n\nLet me think about the implementation in steps:\n\n1. **Tokenization**:\n\n- Read the input string and split it into tokens.\n\n- Ignore whitespace.\n\n- Identify numbers, operators, and parentheses.\n\n2. **Infix to Postfix Conversion**:\n\n- Use a stack to hold operators.\n\n- Output tokens to a string or vector.\n\n- Handle operator precedence and associativity.\n\n3. **Postfix Evaluation**:\n\n- Use a stack to hold operands.\n\n- Apply operators to the top operands and push the result back.\n\n4. **Error Handling**:\n\n- Check for division by zero.\n\n- Ensure all tokens are valid.\n\n- Balance parentheses.\n\nI need to define the precedence of operators:\n\n- Multiplication and division have higher precedence than addition and subtraction.\n\n- Operators of the same precedence are evaluated from left to right (associativity).\n\nIn the conversion algorithm, I need to pop operators from the stack if they have higher or equal precedence than the incoming operator.\n\nWait, actually, for left-associative operators, I should pop operators with higher or equal precedence, but for right-associative operators, it's different. But since all our operators are left-associative, I'll stick with popping operators with higher or equal precedence.\n\nLet me define a function to get the precedence of operators:\n\n```cpp\nint precedence(char op) {\n    switch (op) {\n        case '+':\n        case '-': return 1;\n        case '*':\n        case '/': return 2;\n        default: return -1;\n    }\n}\n```\n\nI need to implement the infixToPostfix method.\n\nHere's a rough sketch:\n\n```cpp\nstd::string infixToPostfix(const std::string& infix) {\n    std::stack<char> stack;\n    std::string postfix;\n    for (char c : infix) {\n        if (isspace(c)) continue;\n        if (isdigit(c)) {\n            // Read the entire number\n            std::string num = readNumber(infix, &i);\n            postfix += num + ' ';\n        } else if (c == '(') {\n            stack.push(c);\n        } else if (c == ')') {\n            while (!stack.empty() && stack.top() != '(') {\n                postfix += stack.top();\n                stack.pop();\n            }\n            if (!stack.empty() && stack.top() == '(') {\n                stack.pop();\n            } else {\n                throw std::runtime_error(\"Mismatched parentheses\");\n            }\n        } else if (isOperator(c)) {\n            while (!stack.empty() && precedence(stack.top()) >= precedence(c)) {\n                postfix += stack.top();\n                stack.pop();\n            }\n            stack.push(c);\n        } else {\n            throw std::runtime_error(\"Invalid token\");\n        }\n    }\n    while (!stack.empty()) {\n        if (stack.top() == '(') {\n            throw std::runtime_error(\"Mismatched parentheses\");\n        }\n        postfix += stack.top();\n        stack.pop();\n    }\n    return postfix;\n}\n```\n\nI need to implement the readNumber function to read the entire number if it's more than one digit.\n\nSimilarly, I need to implement isOperator function.\n\nThen, the evaluatePostfix method:\n\n```cpp\nint evaluatePostfix(const std::string& postfix) {\n    std::stack<int> stack;\n    std::istringstream iss(postfix);\n    std::string token;\n    while (iss >> token) {\n        if (isdigit(token[0]) || (token.length() > 1 && isdigit(token[1]))) {\n            int num = std::stoi(token);\n            stack.push(num);\n        } else if (isOperator(token[0])) {\n            if (stack.size() < 2) {\n                throw std::runtime_error(\"Invalid expression\");\n            }\n            int b = stack.top();\n            stack.pop();\n            int a = stack.top();\n            stack.pop();\n            char op = token[0];\n            int result;\n            switch (op) {\n                case '+': result = a + b; break;\n                case '-': result = a - b; break;\n                case '*': result = a * b; break;\n                case '/':\n                    if (b == 0) {\n                        throw std::runtime_error(\"Division by zero\");\n                    }\n                    result = a / b;\n                    break;\n                default:\n                    throw std::runtime_error(\"Invalid operator\");\n            }\n            stack.push(result);\n        } else {\n            throw std::runtime_error(\"Invalid token in postfix expression\");\n        }\n    }\n    if (stack.size() != 1) {\n        throw std::runtime_error(\"Invalid expression\");\n    }\n    return stack.top();\n}\n```\n\nI need to make sure that the postfix expression is correctly evaluated.\n\nNow, in the calculate method, I can call infixToPostfix and then evaluatePostfix:\n\n```cpp\nint calculate(const std::string& expression) {\n    std::string postfix = infixToPostfix(expression);\n    return evaluatePostfix(postfix);\n}\n```\n\nI should also consider optimizing the code, maybe by avoiding multiple string concatenations in infixToPostfix. Instead of using string concatenation, I can use a vector to store tokens and then join them at the end.\n\nAlso, I need to handle multi-digit numbers correctly.\n\nLet me think about how to read numbers from the infix expression.\n\nI can iterate through the string, and when I encounter a digit, I read all consecutive digits to form the complete number.\n\nI need to make sure that numbers are properly separated by operators or parentheses.\n\nSimilarly, I need to handle operators that can be negative, but since I'm assuming all operands are non-negative for now, I can simplify this.\n\nWait, if I assume all operands are non-negative, then '-' is only used as a subtraction operator.\n\nBut perhaps I should still handle negative numbers for completeness.\n\nLet me consider how to handle negative numbers.\n\nIf a '-' sign appears at the beginning of the expression or after an operator, it could be a negative operand.\n\nFor example, \"-5 + 3\" should be interpreted as negative five plus three.\n\nTo handle this, I can keep track of whether a '-' sign is a unary operator or a binary operator.\n\nThis complicates things a bit, but perhaps it's manageable.\n\nAlternatively, I can pre-process the expression to convert unary minus into something else.\n\nFor example, replace \"-5\" with \"0-5\", but that might not be the best approach.\n\nAnother approach is to treat '-' as a unary operator if it appears at the beginning or after an operator.\n\nI need to modify the tokenization and conversion steps to handle this.\n\nPerhaps I can introduce a flag to indicate whether the next token can be a unary operator.\n\nLet me try to outline this:\n\n- Initialize a flag 'unary' to true if the next token can be unary (e.g., start of expression or after an operator).\n\n- When reading tokens:\n\n- If 'unary' is true and the next token is '-', it's a unary minus.\n\n- Otherwise, it's a binary subtraction operator.\n\n- After encountering an operator or '(', set 'unary' to true for the next token.\n\n- After encountering a number or ')', set 'unary' to false.\n\nThis way, I can distinguish between unary and binary minus operators.\n\nSimilarly, I can assign higher precedence to unary operators.\n\nIn the infixToPostfix method, I can treat unary minus as a higher-precedence operator.\n\nFor example, define precedence for unary minus as higher than multiplication and division.\n\nThen, in the conversion algorithm, I can handle it accordingly.\n\nThis would allow expressions like \"-5 * 3 + 2\" to be correctly interpreted.\n\nLet me adjust the precedence function:\n\n```cpp\nint precedence(char op) {\n    switch (op) {\n        case '+':\n        case '-': return 1;\n        case '*':\n        case '/': return 2;\n        case 'u-': return 3; // unary minus\n        default: return -1;\n    }\n}\n```\n\nWait, but 'u-' is not a single character. I need a way to differentiate unary minus from binary minus.\n\nPerhaps I can use a different character or a modified operator for unary minus.\n\nAlternatively, I can represent unary minus as a separate token, say '#', and then handle it accordingly.\n\nThis might get messy. Maybe I should look for a standard approach to handle unary operators in infix to postfix conversion.\n\nUpon researching, I find that one common approach is to insert a dummy '(' at the beginning of the expression and a ')' at the end, and treat unary operators by inserting another operator of higher precedence before them.\n\nBut perhaps this is getting too complicated for the current task.\n\nSince the task doesn't explicitly require handling negative numbers or unary operators, maybe I can proceed with the assumption that all operands are non-negative integers and '-' is only a binary operator.\n\nThis will simplify the implementation.\n\nIf time permits, I can extend it to handle unary operators later.\n\nSo, for now, I'll proceed with handling only non-negative integers and binary operators.\n\nLet me proceed with implementing the tokenization.\n\nI need a function to tokenize the input expression.\n\nHere's a possible implementation:\n\n```cpp\nstd::vector<std::string> tokenize(const std::string& infix) {\n    std::vector<std::string> tokens;\n    size_t i = 0;\n    while (i < infix.length()) {\n        char c = infix[i];\n        if (isspace(c)) {\n            i++;\n            continue;\n        }\n        if (isdigit(c)) {\n            std::string num;\n            while (i < infix.length() && isdigit(infix[i])) {\n                num += infix[i];\n                i++;\n            }\n            tokens.push_back(num);\n        } else if (c == '(' || c == ')' || isOperator(c)) {\n            tokens.push_back(std::string(1, c));\n            i++;\n        } else {\n            throw std::runtime_error(\"Invalid character in expression\");\n        }\n    }\n    return tokens;\n}\n```\n\nI need to define isOperator:\n\n```cpp\nbool isOperator(char c) {\n    return c == '+' || c == '-' || c == '*' || c == '/';\n}\n```\n\nNow, in infixToPostfix, I can use these tokens.\n\nLet me adjust the infixToPostfix method to use the tokens:\n\n```cpp\nstd::string infixToPostfix(const std::string& infix) {\n    std::vector<std::string> tokens = tokenize(infix);\n    std::stack<std::string> stack;\n    std::string postfix;\n    for (const std::string& token : tokens) {\n        if (isdigit(token[0])) {\n            postfix += token + ' ';\n        } else if (token == \"(\") {\n            stack.push(token);\n        } else if (token == \")\") {\n            while (!stack.empty() && stack.top() != \"(\") {\n                postfix += stack.top() + ' ';\n                stack.pop();\n            }\n            if (!stack.empty() && stack.top() == \"(\") {\n                stack.pop();\n            } else {\n                throw std::runtime_error(\"Mismatched parentheses\");\n            }\n        } else if (isOperator(token[0])) {\n            while (!stack.empty() && precedence(stack.top()[0]) >= precedence(token[0])) {\n                postfix += stack.top() + ' ';\n                stack.pop();\n            }\n            stack.push(token);\n        } else {\n            throw std::runtime_error(\"Invalid token\");\n        }\n    }\n    while (!stack.empty()) {\n        if (stack.top() == \"(\") {\n            throw std::runtime_error(\"Mismatched parentheses\");\n        }\n        postfix += stack.top() + ' ';\n        stack.pop();\n    }\n    return postfix;\n}\n```\n\nI need to make sure that the precedence function handles all operators correctly.\n\nNow, for evaluatePostfix, I can use a stack of integers.\n\nHere's a possible implementation:\n\n```cpp\nint evaluatePostfix(const std::string& postfix) {\n    std::stack<int> stack;\n    std::istringstream iss(postfix);\n    std::string token;\n    while (iss >> token) {\n        if (isdigit(token[0]) || (token.length() > 1 && isdigit(token[1]))) {\n            int num = std::stoi(token);\n            stack.push(num);\n        } else if (isOperator(token[0])) {\n            if (stack.size() < 2) {\n                throw std::runtime_error(\"Invalid expression\");\n            }\n            int b = stack.top();\n            stack.pop();\n            int a = stack.top();\n            stack.pop();\n            int result;\n            switch (token[0]) {\n                case '+': result = a + b; break;\n                case '-': result = a - b; break;\n                case '*': result = a * b; break;\n                case '/':\n                    if (b == 0) {\n                        throw std::runtime_error(\"Division by zero\");\n                    }\n                    result = a / b;\n                    break;\n                default:\n                    throw std::runtime_error(\"Invalid operator\");\n            }\n            stack.push(result);\n        } else {\n            throw std::runtime_error(\"Invalid token in postfix expression\");\n        }\n    }\n    if (stack.size() != 1) {\n        throw std::runtime_error(\"Invalid expression\");\n    }\n    return stack.top();\n}\n```\n\nI think this covers the basic functionality.\n\nNow, I need to write a main function to test this calculator.\n\nFor example:\n\n```cpp\nint main() {\n    Calculator calc;\n    try {\n        int result = calc.calculate(\"5 + 3 * 2\");\n        std::cout << \"Result: \" << result << std::endl; // Should output 11\n    } catch (const std::exception& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n    }\n    return 0;\n}\n```\n\nI should also write more test cases to ensure correctness.\n\nPotential test cases:\n\n- \"5 + 3 * 2\" -> 11\n\n- \"5 * 3 + 2\" -> 17\n\n- \"(5 + 3) * 2\" -> 16\n\n- \"10 / 2 - 3\" -> 2\n\n- \"8 / (2 + 2)\" -> 2\n\n- \"2 * (3 - (2 / 2))\" -> 4\n\n- \"5\" -> 5 (single operand)\n\n- \"1 + 2 + 3 + 4\" -> 10\n\n- \"1 * 2 * 3 * 4\" -> 24\n\n- \"10 - 5 * 2\" -> 0\n\n- \"3 + 4 * 2 / (1 - 5)^2^\" -> This one has exponentiation, which is not supported, so it should throw an error.\n\nWait, but exponentiation is not specified in the task, so I don't need to handle it.\n\nIf I assume that only +, -, *, / are supported, then the last expression should throw an error due to the '^' operator.\n\nI need to make sure that any invalid operators cause an error.\n\nAlso, I need to handle cases where there are consecutive operators, like \"5++3\", which is invalid.\n\nSimilarly, \"5 + -3\" should be invalid in our current implementation since we're not handling unary operators.\n\nBut if I decide to handle unary operators later, I need to adjust the tokenization and conversion accordingly.\n\nFor now, I'll proceed with the current implementation.\n\nI should also consider edge cases, such as:\n\n- Empty expression -> error\n\n- Expression with only one operand -> return that operand\n\n- Expression with mismatched parentheses -> error\n\n- Division by zero -> error\n\nI need to implement error handling for these cases.\n\nLet me think about how to structure the Calculator class.\n\nI can have private helper methods for tokenization, precedence, and the main methods for conversion and evaluation.\n\nHere's a possible class definition:\n\n```cpp\nclass Calculator {\nprivate:\n    std::vector<std::string> tokenize(const std::string& infix);\n    std::string infixToPostfix(const std::string& infix);\n    int evaluatePostfix(const std::string& postfix);\n    int precedence(char op);\n    bool isOperator(char c);\n\npublic:\n    Calculator();\n    int calculate(const std::string& expression);\n};\n```\n\nI need to implement all these methods.\n\nI should also consider using standard C++ libraries where appropriate, like using `<stack>`, `<string>`, `<vector>`, and `<cctype>` for character handling.\n\nI need to make sure that the code is clean, well-commented, and handles all edge cases properly.\n\nAlso, I should avoid memory leaks and ensure that all resources are properly managed.\n\nSince I'm using C++11 or later, I can use smart pointers if necessary, but for this simple calculator, it might not be needed.\n\nI should also consider writing unit tests for the calculator to verify its correctness.\n\nNow, let me start coding this step by step.\n\nFirst, I'll implement the tokenization method.\n\nThen, the infix to postfix conversion.\n\nAfter that, the postfix evaluation.\n\nFinally, the main calculate method that ties everything together.\n\nI'll also write a main function with test cases to verify the functionality.\n\nLet me start by writing the tokenize method.\n\n## Final Solution\nTo implement a basic calculator in C++ that supports addition, subtraction, multiplication, and division operations on integers using infix notation, we can use the following approach:\n\n1. **Tokenization**: Break the input string into tokens (operands and operators).\n2. **Infix to Postfix Conversion**: Convert the infix expression to postfix notation using the Shunting Yard algorithm.\n3. **Postfix Evaluation**: Evaluate the postfix expression using a stack.\n\n### Approach\n\n1. **Tokenization**:\n   - Read the input string and split it into tokens (numbers, operators, and parentheses).\n   - Ignore whitespace.\n   \n2. **Infix to Postfix Conversion**:\n   - Use a stack to hold operators.\n   - Output tokens to a string.\n   - Handle operator precedence and associativity.\n   \n3. **Postfix Evaluation**:\n   - Use a stack to hold operands.\n   - Apply operators to the top operands and push the result back.\n\n4. **Error Handling**:\n   - Check for division by zero.\n   - Ensure all tokens are valid.\n   - Balance parentheses.\n\n### Solution Code\n\n```cpp\n#include <iostream>\n#include <stack>\n#include <vector>\n#include <cctype>\n#include <sstream>\n#include <string>\n\nclass Calculator {\nprivate:\n    std::vector<std::string> tokenize(const std::string& infix) {\n        std::vector<std::string> tokens;\n        size_t i = 0;\n        while (i < infix.length()) {\n            char c = infix[i];\n            if (isspace(c)) {\n                i++;\n                continue;\n            }\n            if (isdigit(c)) {\n                std::string num;\n                while (i < infix.length() && isdigit(infix[i])) {\n                    num += infix[i];\n                    i++;\n                }\n                tokens.push_back(num);\n            } else if (c == '(' || c == ')' || isOperator(c)) {\n                tokens.push_back(std::string(1, c));\n                i++;\n            } else {\n                throw std::runtime_error(\"Invalid character in expression\");\n            }\n        }\n        return tokens;\n    }\n\n    std::string infixToPostfix(const std::string& infix) {\n        std::vector<std::string> tokens = tokenize(infix);\n        std::stack<std::string> stack;\n        std::string postfix;\n        for (const std::string& token : tokens) {\n            if (isdigit(token[0])) {\n                postfix += token + ' ';\n            } else if (token == \"(\") {\n                stack.push(token);\n            } else if (token == \")\") {\n                while (!stack.empty() && stack.top() != \"(\") {\n                    postfix += stack.top() + ' ';\n                    stack.pop();\n                }\n                if (!stack.empty() && stack.top() == \"(\") {\n                    stack.pop();\n                } else {\n                    throw std::runtime_error(\"Mismatched parentheses\");\n                }\n            } else if (isOperator(token[0])) {\n                while (!stack.empty() && precedence(stack.top()[0]) >= precedence(token[0])) {\n                    postfix += stack.top() + ' ';\n                    stack.pop();\n                }\n                stack.push(token);\n            } else {\n                throw std::runtime_error(\"Invalid token\");\n            }\n        }\n        while (!stack.empty()) {\n            if (stack.top() == \"(\") {\n                throw std::runtime_error(\"Mismatched parentheses\");\n            }\n            postfix += stack.top() + ' ';\n            stack.pop();\n        }\n        return postfix;\n    }\n\n    int evaluatePostfix(const std::string& postfix) {\n        std::stack<int> stack;\n        std::istringstream iss(postfix);\n        std::string token;\n        while (iss >> token) {\n            if (isdigit(token[0]) || (token.length() > 1 && isdigit(token[1]))) {\n                int num = std::stoi(token);\n                stack.push(num);\n            } else if (isOperator(token[0])) {\n                if (stack.size() < 2) {\n                    throw std::runtime_error(\"Invalid expression\");\n                }\n                int b = stack.top();\n                stack.pop();\n                int a = stack.top();\n                stack.pop();\n                int result;\n                switch (token[0]) {\n                    case '+': result = a + b; break;\n                    case '-': result = a - b; break;\n                    case '*': result = a * b; break;\n                    case '/':\n                        if (b == 0) {\n                            throw std::runtime_error(\"Division by zero\");\n                        }\n                        result = a / b;\n                        break;\n                    default:\n                        throw std::runtime_error(\"Invalid operator\");\n                }\n                stack.push(result);\n            } else {\n                throw std::runtime_error(\"Invalid token in postfix expression\");\n            }\n        }\n        if (stack.size() != 1) {\n            throw std::runtime_error(\"Invalid expression\");\n        }\n        return stack.top();\n    }\n\n    int precedence(char op) {\n        switch (op) {\n            case '+':\n            case '-': return 1;\n            case '*':\n            case '/': return 2;\n            default: return -1;\n        }\n    }\n\n    bool isOperator(char c) {\n        return c == '+' || c == '-' || c == '*' || c == '/';\n    }\n\npublic:\n    Calculator() {}\n\n    int calculate(const std::string& expression) {\n        std::string postfix = infixToPostfix(expression);\n        return evaluatePostfix(postfix);\n    }\n};\n\nint main() {\n    Calculator calc;\n    try {\n        int result = calc.calculate(\"5 + 3 * 2\");\n        std::cout << \"Result: \" << result << std::endl; // Should output 11\n    } catch (const std::exception& e) {\n        std::cerr << \"Error: \" << e.what() << std::endl;\n    }\n    return 0;\n}\n```\n\n### Explanation\n\n1. **Tokenization**:\n   - The `tokenize` method splits the input string into tokens, considering numbers, operators, and parentheses.\n\n2. **Infix to Postfix Conversion**:\n   - The `infixToPostfix` method uses the Shunting Yard algorithm to convert infix expressions to postfix.\n   - It uses a stack to handle operators and ensures that precedence and associativity rules are followed.\n\n3. **Postfix Evaluation**:\n   - The `evaluatePostfix` method evaluates the postfix expression using a stack.\n   - It performs operations based on operators and maintains operands on the stack.\n\n4. **Error Handling**:\n   - The code throws exceptions for invalid expressions, mismatched parentheses, and division by zero.\n\nThis approach ensures that the calculator handles basic arithmetic operations correctly and efficiently."
    }
]