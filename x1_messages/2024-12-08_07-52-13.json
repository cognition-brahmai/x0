[
    {
        "role": "user",
        "content": "Write a Python script to implement a stack data structure using a linked list. The stack should support push, pop, and peek operations.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Sure! Implementing a stack using a linked list in Python is straightforward. A stack typically follows the Last In, First Out (LIFO) principle, meaning the last element added is the first one to be removed. We'll create a simple linked list where each node contains data and a reference to the next node.\n\nHere's how you can do it:\n\n1. **Define a Node class**: This will represent each element in the linked list.\n2. **Define a Stack class**: This will manage the nodes and implement the stack operations.\n\n### Step-by-Step Implementation\n\n#### 1. Node Class\n\nEach node will have two main parts:\n- `data`: The value stored in the node.\n- `next`: A reference to the next node in the stack.\n\n```python\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n```\n\n#### 2. Stack Class\n\nThe stack will have the following components:\n- `top`: A reference to the top node in the stack.\n- `push(data)`: Add a new node with the given data to the top of the stack.\n- `pop()`: Remove and return the data from the top node.\n- `peek()`: Return the data from the top node without removing it.\n- `is_empty()`: Check if the stack is empty.\n\n```python\nclass Stack:\n    def __init__(self):\n        self.top = None\n\n    def is_empty(self):\n        return self.top is None\n\n    def push(self, data):\n        new_node = Node(data)\n        new_node.next = self.top\n        self.top = new_node\n\n    def pop(self):\n        if self.is_empty():\n            raise IndexError(\"pop from empty stack\")\n        data = self.top.data\n        self.top = self.top.next\n        return data\n\n    def peek(self):\n        if self.is_empty():\n            raise IndexError(\"peek from empty stack\")\n        return self.top.data\n```\n\n#### 3. Example Usage\n\nHere's how you can use this stack:\n\n```python\nif __name__ == \"__main__\":\n    stack = Stack()\n    \n    stack.push(10)\n    stack.push(20)\n    stack.push(30)\n    \n    print(stack.peek())  # Output: 30\n    \n    print(stack.pop())   # Output: 30\n    print(stack.pop())   # Output: 20\n    \n    print(stack.is_empty())  # Output: False\n    \n    print(stack.pop())   # Output: 10\n    print(stack.is_empty())  # Output: True\n```\n\n### Explanation\n\n- **Node Class**: Each node holds data and a reference to the next node.\n- **Stack Class**:\n  - `is_empty()`: Checks if the top is `None`.\n  - `push(data)`: Creates a new node and sets it as the new top.\n  - `pop()`: Removes the top node, returns its data, and updates the top reference.\n  - `peek()`: Returns the data of the top node without removing it.\n\nThis implementation ensures that stack operations are efficient, with O(1) time complexity for push, pop, and peek operations."
    }
]