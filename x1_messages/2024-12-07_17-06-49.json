[
    {
        "role": "user",
        "content": "Write a Golang program that reads a directory path from the command line, recursively scans all files and folders within that directory, and outputs a JSON object containing file paths and their respective MD5 checksums.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Okay, I need to write a Go program that does a few things:\n\n1. Reads a directory path from the command line.\n\n2. Recursively scans all files and folders within that directory.\n\n3. Computes the MD5 checksum for each file.\n\n4. Outputs a JSON object with file paths and their MD5 checksums.\n\nAlright, let's break this down step by step.\n\nFirst, I need to handle command-line arguments to get the directory path. In Go, I can use the \"os\" package to access command-line arguments via \"os.Args\". The first element, os.Args[0], is the executable name, so the directory path would be os.Args[1].\n\nNext, I need to recursively scan all files and folders within the specified directory. For this, I can use the \"filepath\" package's Walk function. Walk takes a function that's called for every file and directory in the tree.\n\nInside the walk function, I need to check if the item is a file or a directory. I can use \"os.Stat\" to get the file information and check if it's a directory or not.\n\nFor each file, I need to compute the MD5 checksum. I can use the \"crypto/md5\" package for this purpose. I'll open each file, read its content, and compute the MD5 hash.\n\nI need to store the file paths and their corresponding MD5 checksums in a data structure that can be easily marshaled to JSON. A map where the key is the file path and the value is the MD5 checksum should work fine.\n\nFinally, I'll use the \"encoding/json\" package to marshal the map into a JSON object and print it to the standard output.\n\nLet me think about error handling. I need to make sure that the directory path provided exists and is a directory. Also, handle cases where files cannot be read.\n\nI should also consider that the program might be run with a directory path that doesn't exist or is not readable. I need to check for these conditions and provide appropriate error messages.\n\nAdditionally, since computing MD5 hashes for large files can be resource-intensive, I should think about reading files in chunks rather than loading the entire file into memory at once. But for simplicity, I'll assume that the files are not too large.\n\nLet me outline the steps in code:\n\n1. Check if the correct number of command-line arguments is provided.\n\n2. Verify that the provided path is a directory.\n\n3. Use filepath.Walk to traverse the directory tree.\n\n4. For each file, compute the MD5 checksum.\n\n5. Store the file path and checksum in a map.\n\n6. Marshal the map into JSON and print it.\n\nAlright, now let's think about how to compute the MD5 checksum. I need to open each file, read its content, and compute the hash.\n\nHere's a rough idea:\n\n- Open the file using os.Open.\n\n- Read the file content into a byte slice using ioutil.ReadFile.\n\n- Compute the MD5 hash using md5.Sum.\n\n- Convert the hash to a hexadecimal string using hex.EncodeToString.\n\nBut, to handle larger files without loading the entire file into memory, I can read the file in chunks and pipe it to the hash function.\n\nWait, the md5 hash can be updated incrementally. So, I can read the file in chunks and feed each chunk to the hash function.\n\nThat would be more efficient for large files.\n\nSo, I'll create an md5.Hash instance, read the file in chunks, and write each chunk to the hash object.\n\nOnce the entire file is read, I can get the final hash.\n\nOkay, let's consider writing a function to compute the MD5 checksum of a file.\n\nSomething like:\n\nfunc md5Sum(filePath string) (string, error) {\n\n    file, err := os.Open(filePath)\n\n    if err != nil {\n\n        return \"\", err\n\n    }\n\n    defer file.Close()\n\n    hash := md5.New()\n\n    if _, err := io.Copy(hash, file); err != nil {\n\n        return \"\", err\n\n    }\n\n    return hex.EncodeToString(hash.Sum(nil)), nil\n\n}\n\nThat should work.\n\nNow, for the main function:\n\n- Check if the correct number of arguments is provided.\n\n- Check if the provided path is a directory.\n\n- Initialize a map to store file paths and their checksums.\n\n- Use filepath.Walk to traverse the directory.\n\n- For each file, compute the MD5 sum and store it in the map.\n\n- Marshal the map into JSON and print it.\n\nI need to skip directories while walking, so I'll check if the item is a regular file before computing the checksum.\n\nAlso, I should handle any errors that occur during file reading or hash computation.\n\nLet me think about the output JSON format. It should be a JSON object where keys are file paths and values are their MD5 sums.\n\nFor example:\n\n{\n\n    \"/path/to/file1\": \"hash1\",\n\n    \"/path/to/file2\": \"hash2\",\n\n    ...\n\n}\n\nI need to make sure that the file paths are represented as strings in the JSON.\n\nAlso, I should consider that file paths might contain special characters that need to be properly escaped in JSON.\n\nThe encoding/json package should handle that automatically.\n\nNow, about the file paths, should I use absolute or relative paths?\n\nProbably, it's better to use absolute paths to avoid any confusion, especially if the directory contains symbolic links.\n\nBut, to be consistent, I can use the paths as they are, relative to the provided directory.\n\nWait, no. To make it more useful, I should use absolute paths.\n\nAlternatively, I can make it an option to choose between absolute and relative paths.\n\nBut to keep it simple, I'll use absolute paths.\n\nI need to get the absolute path of the provided directory and then prepend it to the relative paths obtained from filepath.Walk.\n\nWait, filepath.Walk provides paths relative to the root directory.\n\nActually, filepath.Walk provides paths relative to the starting directory.\n\nWait, no. It provides the full path for each file.\n\nLet me check the documentation.\n\nAh, filepath.Walk passes the full path of each file to the walk function.\n\nSo, I can directly use those paths.\n\nBut, to make it more user-friendly, I might want to make the paths relative to the provided directory.\n\nFor example, if the provided directory is \"/home/user/project\" and there's a file \"/home/user/project/src/main.go\", the JSON key should be \"src/main.go\".\n\nThat way, if the JSON is used in a different context, the paths are relative and more portable.\n\nSo, I'll make the paths relative to the provided directory.\n\nTo do that, I can use the \"path relativize\" approach.\n\nBut Go doesn't have a built-in relativize function, so I need to handle it manually.\n\nI can use strings.TrimPrefix to remove the prefix of the provided directory from the file paths.\n\nBut, I need to ensure that the paths are properly trimmed and that I handle any leading slashes correctly.\n\nAlternatively, I can use the \"path relativize\" approach from the \"path\" package.\n\nWait, the \"path\" package doesn't have a relativize function.\n\nMaybe I can use \"path.Rel\" but I'm not sure.\n\nLet me look it up.\n\nAh, Go doesn't have a standard relativize function. I need to implement it myself.\n\nHere's a way to do it:\n\n- Get the absolute path of the provided directory.\n\n- For each file path, get its absolute path.\n\n- Remove the directory path from the file path to get the relative path.\n\nSomething like:\n\ndirAbs, _ := filepath.EvalSymlinks(directoryPath)\n\nfileAbs, _ := filepath.EvalSymlinks(filePath)\n\nrelativePath := strings.TrimPrefix(fileAbs, dirAbs)\n\nBut, this might leave a leading slash, so I need to handle that.\n\nAlternatively, I can use strings.TrimPrefix and then remove the leading slash if present.\n\nWait, strings.TrimPrefix will remove the exact prefix, so if dirAbs is \"/home/user/project\" and fileAbs is \"/home/user/project/src/main.go\", TrimPrefix will return \"/src/main.go\".\n\nSo, I need to remove the leading slash to get \"src/main.go\".\n\nYes, that should work.\n\nI can use strings.TrimPrefix and then strings.TrimPrefix again to remove a single leading slash.\n\nLike this:\n\nrelativePath := strings.TrimPrefix(fileAbs, dirAbs)\n\nrelativePath = strings.TrimPrefix(relativePath, \"/\")\n\nThat should give me the relative path without the leading slash.\n\nGood.\n\nNow, let's think about the JSON output.\n\nI need to ensure that the JSON is properly formatted and printed to stdout.\n\nAlso, I should handle any errors that occur during the process and print meaningful error messages.\n\nI can collect all the errors in a slice and print them at the end.\n\nAlternatively, I can print errors as they occur.\n\nBut, to keep the program simpler, I'll print errors as they occur and continue processing the other files.\n\nHowever, in the end, I need to ensure that the JSON is still output even if there were some errors.\n\nWait, but if there are errors, I might want to indicate which files had errors.\n\nMaybe I can have a separate section in the JSON for errors.\n\nBut, to keep it simple, I'll just output the successfully processed files' paths and checksums.\n\nAnd print the errors to stderr.\n\nIn Go, I can use log.Println to print to stderr.\n\nSo, I'll print any errors using log.Println and continue processing.\n\nNow, let's think about the code structure.\n\nI'll have the main function that:\n\n- Checks command-line arguments.\n\n- Verifies that the provided path is a directory.\n\n- Gets the absolute path of the directory.\n\n- Initializes a map to store file paths and checksums.\n\n- Calls filepath.Walk with a walk function.\n\n- In the walk function, checks if the item is a regular file.\n\n- If it is, computes the MD5 sum and stores it in the map.\n\n- After walking, marshals the map into JSON and prints it.\n\nNow, for the walk function:\n\n- It receives the full file path and file info.\n\n- Checks if it's a regular file.\n\n- If it is, computes the MD5 sum.\n\n- Computes the relative path.\n\n- Stores the relative path and checksum in the map.\n\nI need to make sure that the walk function has access to the map and the directory's absolute path.\n\nIn Go, I can pass these as arguments to the walk function.\n\nWait, but filepath.Walk requires a function of type filepath.WalkFunc, which has the signature func(path string, info os.FileInfo, err error) error.\n\nSo, I need to define a closure that captures the map and the directory's absolute path.\n\nYes, that's a good approach.\n\nI'll define the walk function as an anonymous function inside main that captures the necessary variables.\n\nSomething like:\n\nwalkFunc := func(path string, info os.FileInfo, err error) error {\n\n    if err != nil {\n\n        log.Println(\"Error accessing\", path, \":\", err)\n\n        return nil\n\n    }\n\n    if !info.IsDir() {\n\n        relativePath := makeRelative(path, dirAbs)\n\n        checksum, err := md5Sum(path)\n\n        if err != nil {\n\n            log.Println(\"Error computing MD5 for\", path, \":\", err)\n\n        } else {\n\n            checksums[relativePath] = checksum\n\n        }\n\n    }\n\n    return nil\n\n}\n\nWhere makeRelative is a function that computes the relative path as discussed earlier.\n\nThen, call filepath.Walk with this walkFunc.\n\nAlright, now, for the JSON marshaling.\n\nI need to use json.Marshal to convert the map into a JSON byte slice, and then print it using fmt.Println.\n\nBut, json.Marshal returns a byte slice, so I need to convert it to a string using string(jsonBytes).\n\nWait, no, fmt.Println can handle byte slices.\n\nBut, to ensure proper formatting, I can use json.Indent to get pretty-printed JSON.\n\nThat would make it more readable.\n\nSo, I'll use json.Indent to format the JSON with indentation.\n\nThen, print it to stdout.\n\nAlso, I need to handle any errors that occur during marshaling.\n\nBut, if there are errors in marshaling, it's probably a problem with the data, which shouldn't happen with a map of strings to strings.\n\nStill, it's good to handle it.\n\nNow, let's think about potential edge cases:\n\n- The provided directory path doesn't exist.\n\n- The provided directory path is not a directory.\n\n- The directory is empty.\n\n- The directory contains symbolic links.\n\n- The directory contains files that cannot be read.\n\nFor each of these cases, I need to handle them appropriately.\n\n- If the directory doesn't exist or is not a directory, print an error and exit.\n\n- If the directory is empty, the JSON should be an empty object.\n\n- If there are files that cannot be read, print an error and skip them.\n\n- If there are symbolic links, filepath.Walk follows them by default, but I need to ensure that I handle them correctly, especially if they are links to directories.\n\nWait, by default, filepath.Walk follows symbolic links for directories, which might lead to infinite recursion if there are circular links.\n\nTo prevent that, I can set the walk option to SkipCycles.\n\nWait, in Go 1.16 and later, filepath.Walk has been deprecated in favor of filepath.WalkDir, which has better support for handling errors and cycles.\n\nI should use filepath.WalkDir instead.\n\nLet me check the documentation.\n\nYes, filepath.WalkDir is the recommended way in Go 1.16 and later.\n\nSo, I'll use filepath.WalkDir.\n\nThe walk function for WalkDir has a different signature: func(path string, d fs.DirEntry, err error) error.\n\nI need to adjust the walk function accordingly.\n\nIn this case, I can use d.IsDir() to check if it's a directory.\n\nAnd, to get the file info, I can use d.Info().\n\nSo, I'll update the walk function accordingly.\n\nAlso, I need to import \"go/fs\" for fs.DirEntry.\n\nWait, no, in Go 1.16, filepath.WalkDir returns fs.DirEntry.\n\nSo, I need to use d.Type().IsRegular() to check if it's a regular file.\n\nWait, let's check the documentation.\n\nYes, fs.DirEntry has a Type() fs.FileType method, which has methods like IsRegular(), IsDir(), etc.\n\nSo, I can use d.Type().IsRegular() to check if it's a regular file.\n\nAlright, I'll update the walk function to use WalkDir and fs.DirEntry.\n\nNow, about symbolic links.\n\nBy default, WalkDir follows symbolic links for directories, but it skips them if they are files.\n\nWait, no, WalkDir follows symbolic links for directories, but it doesn't follow them if they are files.\n\nWait, I need to check the documentation.\n\nAccording to the Go docs, WalkDir follows symbolic links if they are directories, but it skips them if they are files.\n\nTo prevent infinite recursion, WalkDir skips over cycles.\n\nBut, to be safe, I can set the walk option to filepath.SkipCycles to handle cycles properly.\n\nAlso, I need to handle the case where a symbolic link points to a file outside the directory tree.\n\nIn that case, the relative path might not make sense, so I need to handle that appropriately.\n\nBut, for simplicity, I'll assume that symbolic links are handled correctly by WalkDir.\n\nNow, let's think about the makeRelative function.\n\nI need to compute the relative path of each file with respect to the provided directory.\n\nGiven the absolute path of the directory and the absolute path of the file, I can remove the directory path from the file path.\n\nAs I thought earlier, using strings.TrimPrefix(fileAbs, dirAbs) and then removing the leading slash if present.\n\nBut, I need to ensure that the paths are properly normalized.\n\nFor example, if dirAbs is \"/home/user/project/\" and fileAbs is \"/home/user/project/src/main.go\", TrimPrefix should work fine.\n\nBut, if dirAbs doesn't have a trailing slash, like \"/home/user/project\", TrimPrefix might not work correctly.\n\nSo, I need to ensure that dirAbs has a trailing slash.\n\nAlternatively, I can use path relativization logic.\n\nBut, since Go doesn't have a built-in relativize function, I need to handle it carefully.\n\nHere's an approach:\n\n- Get the absolute path of the directory with a trailing slash.\n\n- Get the absolute path of the file.\n\n- Use strings.TrimPrefix(fileAbs, dirAbs) to get the relative path.\n\n- If the relative path starts with a slash, remove it.\n\nThis should work.\n\nI need to make sure that dirAbs has a trailing slash.\n\nSo, after getting the absolute path of the directory, I can check if it ends with a slash, and if not, append one.\n\nSomething like:\n\nif !strings.HasSuffix(dirAbs, string(filepath.Separator)) {\n\n    dirAbs += string(filepath.Separator)\n\n}\n\nThen, relativePath := strings.TrimPrefix(fileAbs, dirAbs)\n\nThat should give me the relative path without a leading slash.\n\nPerfect.\n\nNow, let's consider the case where the file is outside the directory.\n\nBut, since we're using WalkDir starting from the directory, it should only visit files within the directory tree.\n\nUnless there are symbolic links pointing outside, but even then, WalkDir should handle them appropriately.\n\nBut, to be safe, I can check if the fileAbs starts with dirAbs, and if not, skip it or handle it as an error.\n\nBut, since WalkDir is supposed to only visit files within the directory tree, this shouldn't be necessary.\n\nNow, let's think about the JSON output.\n\nI need to marshal the map into JSON.\n\nIn Go, maps are marshaled into JSON objects with keys and values.\n\nI need to ensure that the map is of type map[string]string.\n\nYes, that should work.\n\nAlso, I can sort the map keys if I want the JSON to be deterministic, but it's not strictly necessary.\n\nNow, about the command-line arguments.\n\nI need to check if exactly one argument is provided.\n\nIf not, print usage instructions.\n\nSomething like:\n\nif len(os.Args) != 2 {\n\n    fmt.Println(\"Usage: myprogram /path/to/directory\")\n\n    os.Exit(1)\n\n}\n\nAlso, I should verify that the provided path exists and is a directory.\n\nI can use os.Stat to get the file info and check if it's a directory.\n\nIf not, print an error and exit.\n\nNow, putting it all together, here's a rough sketch of the code:\n\npackage main\n\nimport (\n\n    \"crypto/md5\"\n\n    \"encoding/hex\"\n\n    \"encoding/json\"\n\n    \"flag\"\n\n    \"fmt\"\n\n    \"io\"\n\n    \"log\"\n\n    \"os\"\n\n    \"path/filepath\"\n\n    \"strings\"\n\n)\n\nfunc main() {\n\n    if len(os.Args) != 2 {\n\n        fmt.Println(\"Usage:\", os.Args[0], \"/path/to/directory\")\n\n        os.Exit(1)\n\n    }\n\n    directoryPath := os.Args[1]\n\n    info, err := os.Stat(directoryPath)\n\n    if err != nil {\n\n        log.Fatal(\"Error accessing directory:\", err)\n\n    }\n\n    if !info.IsDir() {\n\n        log.Fatal(\"Provided path is not a directory.\")\n\n    }\n\n    dirAbs, err := filepath.EvalSymlinks(directoryPath)\n\n    if err != nil {\n\n        log.Fatal(\"Error evaluating symlinks for directory path:\", err)\n\n    }\n\n    if !strings.HasSuffix(dirAbs, string(filepath.Separator)) {\n\n        dirAbs += string(filepath.Separator)\n\n    }\n\n    checksums := make(map[string]string)\n\n    walkFunc := func(path string, d fs.DirEntry, err error) error {\n\n        if err != nil {\n\n            log.Println(\"Error accessing\", path, \":\", err)\n\n            return nil\n\n        }\n\n        if d.Type().IsRegular() {\n\n            relativePath := makeRelative(path, dirAbs)\n\n            checksum, err := md5Sum(path)\n\n            if err != nil {\n\n                log.Println(\"Error computing MD5 for\", path, \":\", err)\n\n            } else {\n\n                checksums[relativePath] = checksum\n\n            }\n\n        }\n\n        return nil\n\n    }\n\n    err = filepath.WalkDir(directoryPath, walkFunc)\n\n    if err != nil {\n\n        log.Fatal(\"Error walking directory:\", err)\n\n    }\n\n    jsonBytes, err := json.MarshalIndent(checksums, \"\", \"    \")\n\n    if err != nil {\n\n        log.Fatal(\"Error marshaling JSON:\", err)\n\n    }\n\n    fmt.Println(string(jsonBytes))\n\n}\n\nfunc makeRelative(fileAbs, dirAbs string) string {\n\n    relativePath := strings.TrimPrefix(fileAbs, dirAbs)\n\n    return relativePath\n\n}\n\nfunc md5Sum(filePath string) (string, error) {\n\n    file, err := os.Open(filePath)\n\n    if err != nil {\n\n        return \"\", err\n\n    }\n\n    defer file.Close()\n\n    hash := md5.New()\n\n    _, err = io.Copy(hash, file)\n\n    if err != nil {\n\n        return \"\", err\n\n    }\n\n    return hex.EncodeToString(hash.Sum(nil)), nil\n\n}\n\nWait, but I need to import \"go/fs\" for fs.DirEntry.\n\nActually, in Go 1.16, filepath.WalkDir returns fs.DirEntry, so I need to import \"go/fs\".\n\nBut, I think it's \"path/filepath\" and \"io/fs\".\n\nWait, no, in Go 1.16, filepath.WalkDir uses \"io/fs\", but I need to check.\n\nWait, perhaps I need to import \"io/fs\".\n\nLet me check the documentation.\n\nYes, in Go 1.16, filepath.WalkDir uses \"io/fs\", so I need to import \"io/fs\".\n\nSo, I need to import \"io/fs\" for fs.DirEntry.\n\nAlso, I need to make sure that I'm using Go 1.16 or later.\n\nAlternatively, if the code needs to be compatible with earlier Go versions, I should use filepath.Walk instead.\n\nBut, since WalkDir is recommended, I'll proceed with it.\n\nSo, I need to import \"io/fs\".\n\nNow, regarding the makeRelative function, I think it's simple enough.\n\nBut, to handle any edge cases, I can add some checks.\n\nFor example, ensure that fileAbs starts with dirAbs.\n\nBut, since we're using filepath.WalkDir starting from dirAbs, it should always be the case.\n\nStill, to be safe, I can add an assertion or a check.\n\nIf strings.HasPrefix(fileAbs, dirAbs), then proceed, else log an error.\n\nBut, for now, I'll assume it's always the case.\n\nNow, about computing the MD5 sum.\n\nI have the md5Sum function that opens the file, reads it, and computes the hash.\n\nBut, to handle large files efficiently, I'm using io.Copy to stream the file content into the hash object.\n\nThis should work well for large files.\n\nI need to ensure that the file is read completely without errors.\n\nIf there are read errors, they should be handled appropriately.\n\nIn the walk function, I'm already handling errors by logging them and continuing.\n\nNow, let's think about testing the program.\n\nI need to create a test directory with some files and subdirectories, compute the MD5 sums manually, and compare them with the program's output.\n\nAlso, test with symbolic links, empty directories, and files that cannot be read.\n\nBut, for now, I'll focus on writing the code.\n\nI think this covers the main requirements.\n\nLet me summarize:\n\n- Read directory path from command line.\n\n- Verify it's a directory.\n\n- Get its absolute path with a trailing slash.\n\n- Recursively walk the directory using filepath.WalkDir.\n\n- For each regular file, compute MD5 sum.\n\n- Make the file path relative to the directory path.\n\n- Store in a map.\n\n- Marshal the map to JSON and print it.\n\nSeems straightforward.\n\nI need to ensure that all edge cases are handled, but for now, this should work.\n\n## Final Solution\nTo solve this problem, we need a Go program that reads a directory path from the command line, recursively scans all files and folders within that directory, and outputs a JSON object containing file paths and their respective MD5 checksums.\n\n### Approach\n\n1. **Command-line Arguments**: Retrieve the directory path from the command-line arguments.\n2. **Directory Validation**: Ensure the provided path is a valid directory.\n3. **Recursive File Scan**: Use `filepath.WalkDir` to traverse the directory tree recursively.\n4. **MD5 Checksum Calculation**: For each file, compute its MD5 checksum.\n5. **Relative Path Calculation**: Calculate the relative path of each file with respect to the provided directory.\n6. **JSON Output**: Store the file paths and checksums in a map and output them as a JSON object.\n\n### Solution Code\n\n```go\npackage main\n\nimport (\n    \"crypto/md5\"\n    \"encoding/hex\"\n    \"encoding/json\"\n    \"flag\"\n    \"fmt\"\n    \"io\"\n    \"log\"\n    \"os\"\n    \"path/filepath\"\n    \"strings\"\n)\n\nfunc main() {\n    if len(os.Args) != 2 {\n        fmt.Println(\"Usage:\", os.Args[0], \"/path/to/directory\")\n        os.Exit(1)\n    }\n\n    directoryPath := os.Args[1]\n    info, err := os.Stat(directoryPath)\n    if err != nil {\n        log.Fatal(\"Error accessing directory:\", err)\n    }\n\n    if !info.IsDir() {\n        log.Fatal(\"Provided path is not a directory.\")\n    }\n\n    dirAbs, err := filepath.EvalSymlinks(directoryPath)\n    if err != nil {\n        log.Fatal(\"Error evaluating symlinks for directory path:\", err)\n    }\n\n    if !strings.HasSuffix(dirAbs, string(filepath.Separator)) {\n        dirAbs += string(filepath.Separator)\n    }\n\n    checksums := make(map[string]string)\n\n    walkFunc := func(path string, d os.DirEntry, err error) error {\n        if err != nil {\n            log.Println(\"Error accessing\", path, \":\", err)\n            return nil\n        }\n\n        if !d.IsDir() {\n            relativePath := makeRelative(path, dirAbs)\n            checksum, err := md5Sum(path)\n            if err != nil {\n                log.Println(\"Error computing MD5 for\", path, \":\", err)\n            } else {\n                checksums[relativePath] = checksum\n            }\n        }\n        return nil\n    }\n\n    err = filepath.WalkDir(directoryPath, walkFunc)\n    if err != nil {\n        log.Fatal(\"Error walking directory:\", err)\n    }\n\n    jsonBytes, err := json.MarshalIndent(checksums, \"\", \"    \")\n    if err != nil {\n        log.Fatal(\"Error marshaling JSON:\", err)\n    }\n\n    fmt.Println(string(jsonBytes))\n}\n\nfunc makeRelative(fileAbs, dirAbs string) string {\n    relativePath := strings.TrimPrefix(fileAbs, dirAbs)\n    return relativePath\n}\n\nfunc md5Sum(filePath string) (string, error) {\n    file, err := os.Open(filePath)\n    if err != nil {\n        return \"\", err\n    }\n    defer file.Close()\n\n    hash := md5.New()\n    _, err = io.Copy(hash, file)\n    if err != nil {\n        return \"\", err\n    }\n\n    return hex.EncodeToString(hash.Sum(nil)), nil\n}\n```\n\n### Explanation\n\n1. **Command-line Arguments**: The directory path is retrieved from `os.Args`.\n2. **Directory Validation**: `os.Stat` checks if the provided path is a directory.\n3. **Recursive File Scan**: `filepath.WalkDir` traverses the directory tree, and for each file, the `walkFunc` is called.\n4. **MD5 Checksum Calculation**: `md5Sum` function reads the file and computes its MD5 checksum using `md5.New()` and `io.Copy`.\n5. **Relative Path Calculation**: `makeRelative` function computes the relative path by trimming the directory path prefix.\n6. **JSON Output**: The map of relative paths and their checksums is marshaled into a JSON object using `json.MarshalIndent` and printed.\n\nThis solution ensures that all files within the specified directory are processed recursively, and their paths and checksums are output in a readable JSON format."
    }
]