[
    {
        "role": "user",
        "content": "Create a Golang program that implements a singly linked list data structure with methods for adding elements at the beginning, end, and a specified position, as well as removing elements by value or position."
    },
    {
        "role": "assistant",
        "content": "Here is a simple implementation of a singly linked list in Go with the specified methods:\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\ntype Node struct {\n\tdata int\n\tnext *Node\n}\n\ntype LinkedList struct {\n\thead *Node\n\tsize int\n}\n\n// AddAtBeginning adds a new node with the given data at the beginning of the list.\nfunc (list *LinkedList) AddAtBeginning(data int) {\n\tnewNode := &Node{data, list.head}\n\tlist.head = newNode\n\tlist.size++\n}\n\n// AddAtEnd adds a new node with the given data at the end of the list.\nfunc (list *LinkedList) AddAtEnd(data int) {\n\tnewNode := &Node{data, nil}\n\tif list.head == nil {\n\t\tlist.head = newNode\n\t} else {\n\t\tcurrent := list.head\n\t\tfor current.next != nil {\n\t\t\tcurrent = current.next\n\t\t}\n\t\tcurrent.next = newNode\n\t}\n\tlist.size++\n}\n\n// AddAtPosition adds a new node with the given data at the specified position.\nfunc (list *LinkedList) AddAtPosition(data int, position int) {\n\tif position < 0 || position > list.size {\n\t\tfmt.Println(\"Invalid position\")\n\t\treturn\n\t}\n\tif position == 0 {\n\t\tlist.AddAtBeginning(data)\n\t\treturn\n\t}\n\tnewNode := &Node{data, nil}\n\tcurrent := list.head\n\tfor i := 1; i < position; i++ {\n\t\tcurrent = current.next\n\t}\n\tnewNode.next = current.next\n\tcurrent.next = newNode\n\tlist.size++\n}\n\n// RemoveByValue removes the first occurrence of a node with the given data.\nfunc (list *LinkedList) RemoveByValue(data int) {\n\tvar current = list.head\n\tvar previous *Node\n\tfor current != nil {\n\t\tif current.data == data {\n\t\t\tif previous != nil {\n\t\t\t\tprevious.next = current.next\n\t\t\t} else {\n\t\t\t\tlist.head = current.next\n\t\t\t}\n\t\t\tlist.size--\n\t\t\treturn\n\t\t}\n\t\tprevious = current\n\t\tcurrent = current.next\n\t}\n\tfmt.Println(\"Data not found\")\n}\n\n// RemoveByPosition removes the node at the specified position.\nfunc (list *LinkedList) RemoveByPosition(position int) {\n\tif position < 0 || position >= list.size {\n\t\tfmt.Println(\"Invalid position\")\n\t\treturn\n\t}\n\tif position == 0 {\n\t\tlist.head = list.head.next\n\t\tlist.size--\n\t\treturn\n\t}\n\tcurrent := list.head\n\tfor i := 1; i < position; i++ {\n\t\tcurrent = current.next\n\t}\n\tcurrent.next = current.next.next\n\tlist.size--\n}\n\n// Display prints the elements of the list.\nfunc (list *LinkedList) Display() {\n\tcurrent := list.head\n\tfor current != nil {\n\t\tfmt.Printf(\"%d -> \", current.data)\n\t\tcurrent = current.next\n\t}\n\tfmt.Println(\"nil\")\n}\n\nfunc main() {\n\tlist := &LinkedList{}\n\tlist.AddAtBeginning(1)\n\tlist.AddAtEnd(2)\n\tlist.AddAtEnd(3)\n\tlist.AddAtPosition(4, 2)\n\tlist.Display() // Output: 1 -> 4 -> 2 -> 3 -> nil\n\tlist.RemoveByValue(4)\n\tlist.Display() // Output: 1 -> 2 -> 3 -> nil\n\tlist.RemoveByPosition(1)\n\tlist.Display() // Output: 1 -> 3 -> nil\n}\n```\n\nThis code defines a `Node` struct to represent each element in the linked list and a `LinkedList` struct to manage the list. The `LinkedList` struct has methods to add elements at the beginning, end, or a specific position, and to remove elements by value or position. The `Display` method is used to print the list for verification.\n\n## Final Solution\nTo implement a singly linked list in Go with methods for adding and removing elements at various positions, follow the steps below.\n\n### Approach\n\n1. **Define the Node Structure:**\n   - Each node contains an integer data field and a pointer to the next node.\n\n2. **Define the LinkedList Structure:**\n   - Contains a pointer to the head node and an integer to keep track of the list's size.\n\n3. **Implement Methods:**\n   - `AddAtBeginning(data int)`: Adds a new node with the given data at the beginning of the list.\n   - `AddAtEnd(data int)`: Adds a new node with the given data at the end of the list.\n   - `AddAtPosition(data int, position int)`: Adds a new node with the given data at the specified position.\n   - `RemoveByValue(data int)`: Removes the first occurrence of a node with the given data.\n   - `RemoveByPosition(position int)`: Removes the node at the specified position.\n   - `Display()`: Prints the elements of the list.\n\n### Solution Code\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\ntype Node struct {\n\tdata int\n\tnext *Node\n}\n\ntype LinkedList struct {\n\thead *Node\n\tsize int\n}\n\n// AddAtBeginning adds a new node with the given data at the beginning of the list.\nfunc (list *LinkedList) AddAtBeginning(data int) {\n\tnewNode := &Node{data, list.head}\n\tlist.head = newNode\n\tlist.size++\n}\n\n// AddAtEnd adds a new node with the given data at the end of the list.\nfunc (list *LinkedList) AddAtEnd(data int) {\n\tnewNode := &Node{data, nil}\n\tif list.head == nil {\n\t\tlist.head = newNode\n\t} else {\n\t\tcurrent := list.head\n\t\tfor current.next != nil {\n\t\t\tcurrent = current.next\n\t\t}\n\t\tcurrent.next = newNode\n\t}\n\tlist.size++\n}\n\n// AddAtPosition adds a new node with the given data at the specified position.\nfunc (list *LinkedList) AddAtPosition(data int, position int) {\n\tif position < 0 || position > list.size {\n\t\tfmt.Println(\"Invalid position\")\n\t\treturn\n\t}\n\tif position == 0 {\n\t\tlist.AddAtBeginning(data)\n\t\treturn\n\t}\n\tnewNode := &Node{data, nil}\n\tcurrent := list.head\n\tfor i := 1; i < position; i++ {\n\t\tcurrent = current.next\n\t}\n\tnewNode.next = current.next\n\tcurrent.next = newNode\n\tlist.size++\n}\n\n// RemoveByValue removes the first occurrence of a node with the given data.\nfunc (list *LinkedList) RemoveByValue(data int) {\n\tvar current = list.head\n\tvar previous *Node\n\tfor current != nil {\n\t\tif current.data == data {\n\t\t\tif previous != nil {\n\t\t\t\tprevious.next = current.next\n\t\t\t} else {\n\t\t\t\tlist.head = current.next\n\t\t\t}\n\t\t\tlist.size--\n\t\t\treturn\n\t\t}\n\t\tprevious = current\n\t\tcurrent = current.next\n\t}\n\tfmt.Println(\"Data not found\")\n}\n\n// RemoveByPosition removes the node at the specified position.\nfunc (list *LinkedList) RemoveByPosition(position int) {\n\tif position < 0 || position >= list.size {\n\t\tfmt.Println(\"Invalid position\")\n\t\treturn\n\t}\n\tif position == 0 {\n\t\tlist.head = list.head.next\n\t\tlist.size--\n\t\treturn\n\t}\n\tcurrent := list.head\n\tfor i := 1; i < position; i++ {\n\t\tcurrent = current.next\n\t}\n\tcurrent.next = current.next.next\n\tlist.size--\n}\n\n// Display prints the elements of the list.\nfunc (list *LinkedList) Display() {\n\tcurrent := list.head\n\tfor current != nil {\n\t\tfmt.Printf(\"%d -> \", current.data)\n\t\tcurrent = current.next\n\t}\n\tfmt.Println(\"nil\")\n}\n\nfunc main() {\n\tlist := &LinkedList{}\n\tlist.AddAtBeginning(1)\n\tlist.AddAtEnd(2)\n\tlist.AddAtEnd(3)\n\tlist.AddAtPosition(4, 2)\n\tlist.Display() // Output: 1 -> 4 -> 2 -> 3 -> nil\n\tlist.RemoveByValue(4)\n\tlist.Display() // Output: 1 -> 2 -> 3 -> nil\n\tlist.RemoveByPosition(1)\n\tlist.Display() // Output: 1 -> 3 -> nil\n}\n```\n\n### Explanation\n\n1. **Node Structure:**\n   - `data`: Stores the integer value of the node.\n   - `next`: Pointer to the next node in the list.\n\n2. **LinkedList Structure:**\n   - `head`: Pointer to the first node in the list.\n   - `size`: Keeps track of the number of nodes in the list.\n\n3. **Methods:**\n   - `AddAtBeginning(data int)`: Creates a new node and sets it as the new head.\n   - `AddAtEnd(data int)`: Traverses to the end of the list and appends a new node.\n   - `AddAtPosition(data int, position int)`: Inserts a new node at the specified position.\n   - `RemoveByValue(data int)`: Removes the first node that matches the given data.\n   - `RemoveByPosition(position int)`: Removes the node at the specified position.\n   - `Display()`: Prints the list from head to tail.\n\nThis implementation ensures that all operations are performed efficiently, with time complexities appropriate for linked list operations."
    }
]