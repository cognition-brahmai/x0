[
    {
        "role": "user",
        "content": "Create a Python script that implements the Dijkstra's shortest path algorithm for a given graph represented as an adjacency matrix."
    },
    {
        "role": "assistant",
        "content": "Sure, I can help you with that! Dijkstra's algorithm is a popular method for finding the shortest path between nodes in a graph. It's widely used in various applications, such as network routing and map navigation.\n\nTo implement Dijkstra's algorithm in Python, we'll need to follow these steps:\n\n1. **Initialize the graph**: Represent the graph using an adjacency matrix. An adjacency matrix is a square matrix used to represent a finite graph. The elements of the matrix indicate whether pairs of vertices are adjacent or not in the graph.\n\n2. **Set up distance and visited arrays**: \n   - **Distance array**: This will keep track of the shortest distance from the source node to each node.\n   - **Visited array**: This will keep track of the nodes that have already been visited to avoid processing them multiple times.\n\n3. **Select the source node**: Choose the starting node from which we want to find the shortest paths to all other nodes.\n\n4. **Iterate through the nodes**:\n   - Select the node with the smallest distance that has not been visited yet.\n   - Update the distances of its neighboring nodes.\n   - Mark the selected node as visited.\n\n5. **Repeat until all nodes are visited**: Continue the process until all nodes have been visited.\n\nLet's dive into the code step by step.\n\n## Final Solution\nTo implement Dijkstra's shortest path algorithm in Python for a graph represented by an adjacency matrix, follow the steps below:\n\n### Approach\n1. **Initialization**:\n   - Take the number of vertices and the source vertex as input.\n   - Create an adjacency matrix representing the graph.\n   - Initialize a list to keep track of the minimum distance from the source to each vertex.\n   - Initialize a list to keep track of visited vertices.\n\n2. **Algorithm**:\n   - Set the distance to the source vertex as 0 and to all other vertices as infinity.\n   - While there are unvisited vertices:\n     - Select the vertex with the smallest distance that has not been visited yet.\n     - For the current vertex, consider all its unvisited neighbors and calculate their tentative distances through the current vertex.\n     - If the new distance is smaller than the previously recorded distance, update the distance.\n     - Mark the current vertex as visited.\n\n3. **Output**:\n   - Print the shortest distances from the source to all other vertices.\n\n### Solution Code\n\n```python\ndef dijkstra(adj_matrix, source):\n    num_vertices = len(adj_matrix)\n    distance = [float('inf')] * num_vertices\n    visited = [False] * num_vertices\n    distance[source] = 0\n\n    for _ in range(num_vertices):\n        # Select the vertex with the minimum distance value from the set of vertices not yet visited\n        min_distance = float('inf')\n        min_index = -1\n        for v in range(num_vertices):\n            if not visited[v] and distance[v] < min_distance:\n                min_distance = distance[v]\n                min_index = v\n\n        # Mark the selected vertex as visited\n        visited[min_index] = True\n\n        # Update the distance values of the adjacent vertices of the selected vertex\n        for v in range(num_vertices):\n            if adj_matrix[min_index][v] != 0 and not visited[v]:\n                new_distance = distance[min_index] + adj_matrix[min_index][v]\n                if new_distance < distance[v]:\n                    distance[v] = new_distance\n\n    # Print the shortest distances\n    print(\"Vertex\\t Distance from Source\")\n    for v in range(num_vertices):\n        print(f\"{v}\\t {distance[v]}\")\n\n# Example usage\nif __name__ == \"__main__\":\n    n = int(input(\"Enter the number of vertices: \"))\n    source = int(input(\"Enter the source vertex: \"))\n    print(\"Enter the adjacency matrix row by row, with space-separated values:\")\n    adj_matrix = []\n    for _ in range(n):\n        row = list(map(int, input().split()))\n        adj_matrix.append(row)\n    \n    dijkstra(adj_matrix, source)\n```\n\n### Explanation\n- **Initialization**:\n  - `distance` list is initialized to infinity for all vertices except the source vertex, which is set to 0.\n  - `visited` list keeps track of vertices already processed.\n\n- **Algorithm**:\n  - In each iteration, the vertex with the smallest distance that has not been visited is selected.\n  - For this vertex, its unvisited neighbors' distances are checked and updated if a shorter path is found.\n\n- **Output**:\n  - The shortest distances from the source vertex to all other vertices are printed in a formatted manner.\n\nThis implementation ensures that the shortest paths are correctly calculated using Dijkstra's algorithm for graphs without negative weights."
    }
]