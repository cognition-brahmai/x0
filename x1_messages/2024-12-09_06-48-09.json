[
    {
        "role": "user",
        "content": "Create a C++ program that implements a binary search tree data structure with insert, delete, and search operations.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Sure, I can help you with that! Implementing a binary search tree (BST) in C++ involves creating a structure for the nodes and defining functions for insertion, deletion, and search operations. Below is a simple implementation of a BST with these operations.\n\nFirst, let's define the structure for the nodes:\n\n```cpp\nstruct Node {\n    int key;\n    Node* left;\n    Node* right;\n    Node(int k) {\n        key = k;\n        left = right = nullptr;\n    }\n};\n```\n\nNow, we'll create a class for the BST that includes methods for insertion, deletion, and search.\n\n```cpp\nclass BST {\nprivate:\n    Node* root;\n\n    Node* insert(Node* node, int key) {\n        if (node == nullptr) {\n            return new Node(key);\n        }\n        if (key < node->key) {\n            node->left = insert(node->left, key);\n        } else if (key > node->key) {\n            node->right = insert(node->right, key);\n        }\n        return node;\n    }\n\n    Node* minValueNode(Node* node) {\n        Node* current = node;\n        while (current && current->left != nullptr)\n            current = current->left;\n        return current;\n    }\n\n    Node* deleteNode(Node* root, int key) {\n        if (root == nullptr) return root;\n\n        if (key < root->key)\n            root->left = deleteNode(root->left, key);\n        else if (key > root->key)\n            root->right = deleteNode(root->right, key);\n        else {\n            if (root->left == nullptr) {\n                Node* temp = root->right;\n                delete root;\n                return temp;\n            } else if (root->right == nullptr) {\n                Node* temp = root->left;\n                delete root;\n                return temp;\n            }\n\n            Node* temp = minValueNode(root->right);\n            root->key = temp->key;\n            root->right = deleteNode(root->right, temp->key);\n        }\n        return root;\n    }\n\n    Node* search(Node* node, int key) {\n        if (node == nullptr || node->key == key)\n            return node;\n        if (key < node->key)\n            return search(node->left, key);\n        return search(node->right, key);\n    }\n\npublic:\n    BST() { root = nullptr; }\n\n    void insert(int key) {\n        root = insert(root, key);\n    }\n\n    void deleteNode(int key) {\n        root = deleteNode(root, key);\n    }\n\n    Node* search(int key) {\n        return search(root, key);\n    }\n};\n```\n\nFinally, you can use this BST class in your main function to test the operations:\n\n```cpp\nint main() {\n    BST tree;\n    tree.insert(50);\n    tree.insert(30);\n    tree.insert(20);\n    tree.insert(40);\n    tree.insert(70);\n    tree.insert(60);\n    tree.insert(80);\n\n    // Search for a node\n    if (tree.search(40)) {\n        std::cout << \"40 is found\\n\";\n    } else {\n        std::cout << \"40 is not found\\n\";\n    }\n\n    // Delete a node\n    tree.deleteNode(20);\n    if (tree.search(20)) {\n        std::cout << \"20 is found\\n\";\n    } else {\n        std::cout << \"20 is not found\\n\";\n    }\n\n    tree.deleteNode(30);\n    if (tree.search(30)) {\n        std::cout << \"30 is found\\n\";\n    } else {\n        std::cout << \"30 is not found\\n\";\n    }\n\n    tree.deleteNode(50);\n    if (tree.search(50)) {\n        std::cout << \"50 is found\\n\";\n    } else {\n        std::cout << \"50 is not found\\n\";\n    }\n\n    return 0;\n}\n```\n\nThis code defines a simple BST with insertion, deletion, and search operations. The deletion function handles all three cases: deleting a node with no children, one child, or two children. The search function returns the node if the key is found, otherwise, it returns nullptr."
    }
]