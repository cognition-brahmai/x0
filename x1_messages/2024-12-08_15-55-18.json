[
    {
        "role": "user",
        "content": "Implement a binary search tree in Golang, with methods for insertion, deletion, and searching of nodes."
    },
    {
        "role": "assistant",
        "content": "Implementing a Binary Search Tree (BST) in Golang involves creating a tree data structure where each node has at most two children, referred to as the left child and the right child. For a BST, the key in each node must be greater than all keys stored in its left subtree and less than all keys in its right subtree. This property allows for efficient insertion, deletion, and search operations.\n\n## Final Solution\nTo implement a Binary Search Tree (BST) in Golang, we need to define a structure for the tree nodes and implement methods for insertion, deletion, and searching of nodes.\n\n### Approach\n\n1. **Node Structure**: Each node will have an integer key and pointers to its left and right children.\n2. **Insertion**: We will recursively find the correct position for the new key based on BST properties.\n3. **Search**: We will recursively search for a key in the tree based on BST properties.\n4. **Deletion**: This is the most complex operation. We need to handle three cases:\n   - Deleting a leaf node (no children).\n   - Deleting a node with one child.\n   - Deleting a node with two children, which involves finding the in-order successor or predecessor.\n\n### Solution Code\n\n```go\npackage main\n\ntype Node struct {\n    Key   int\n    Left  *Node\n    Right *Node\n}\n\ntype BinarySearchTree struct {\n    Root *Node\n}\n\n// Insert a new key into the BST\nfunc (bst *BinarySearchTree) Insert(key int) {\n    if bst.Root == nil {\n        bst.Root = &Node{Key: key}\n        return\n    }\n    bst.insertRecursive(bst.Root, key)\n}\n\nfunc (bst *BinarySearchTree) insertRecursive(current *Node, key int) {\n    if key < current.Key {\n        if current.Left == nil {\n            current.Left = &Node{Key: key}\n        } else {\n            bst.insertRecursive(current.Left, key)\n        }\n    } else {\n        if current.Right == nil {\n            current.Right = &Node{Key: key}\n        } else {\n            bst.insertRecursive(current.Right, key)\n        }\n    }\n}\n\n// Search for a key in the BST\nfunc (bst *BinarySearchTree) Search(key int) bool {\n    return bst.searchRecursive(bst.Root, key)\n}\n\nfunc (bst *BinarySearchTree) searchRecursive(current *Node, key int) bool {\n    if current == nil {\n        return false\n    }\n    if key == current.Key {\n        return true\n    } else if key < current.Key {\n        return bst.searchRecursive(current.Left, key)\n    } else {\n        return bst.searchRecursive(current.Right, key)\n    }\n}\n\n// Delete a key from the BST\nfunc (bst *BinarySearchTree) Delete(key int) {\n    bst.Root = bst.deleteRecursive(bst.Root, key)\n}\n\nfunc (bst *BinarySearchTree) deleteRecursive(current *Node, key int) *Node {\n    if current == nil {\n        return nil\n    }\n    if key < current.Key {\n        current.Left = bst.deleteRecursive(current.Left, key)\n        return current\n    } else if key > current.Key {\n        current.Right = bst.deleteRecursive(current.Right, key)\n        return current\n    }\n    // Node with only one child or no child\n    if current.Left == nil {\n        return current.Right\n    } else if current.Right == nil {\n        return current.Left\n    }\n    // Node with two children: get the in-order successor (smallest in the right subtree)\n    minNode := current.Right\n    for minNode.Left != nil {\n        minNode = minNode.Left\n    }\n    current.Key = minNode.Key\n    current.Right = bst.deleteRecursive(current.Right, minNode.Key)\n    return current\n}\n\nfunc main() {\n    bst := &BinarySearchTree{}\n    bst.Insert(50)\n    bst.Insert(30)\n    bst.Insert(20)\n    bst.Insert(40)\n    bst.Insert(70)\n    bst.Insert(60)\n    bst.Insert(80)\n\n    println(bst.Search(20)) // true\n    println(bst.Search(15)) // false\n\n    bst.Delete(20)\n    println(bst.Search(20)) // false\n\n    bst.Delete(30)\n    println(bst.Search(30)) // false\n\n    bst.Delete(50)\n    println(bst.Search(50)) // false\n}\n```\n\n### Explanation\n\n1. **Node Structure**: \n   - Each node contains an integer key and pointers to left and right children.\n\n2. **Insertion**:\n   - If the tree is empty, the new key becomes the root.\n   - Otherwise, we recursively find the correct position based on the key value and insert the new node.\n\n3. **Search**:\n   - Start from the root and recursively search for the key based on comparisons with node keys.\n\n4. **Deletion**:\n   - If the node is a leaf, simply remove it.\n   - If the node has one child, replace the node with its child.\n   - If the node has two children, find the in-order successor (smallest in the right subtree), replace the node's key with the successor's key, and then delete the successor node.\n\nThis implementation ensures that the BST properties are maintained after each operation."
    }
]