[
    {
        "role": "user",
        "content": "Write a Java program that implements a simple LRU (Least Recently Used) cache with a fixed size. The cache should support insertion, deletion, and retrieval operations in O(1) time complexity.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Sure! Implementing an LRU (Least Recently Used) cache in Java with O(1) time complexity for insertion, deletion, and retrieval operations requires the use of a combination of a HashMap and a Doubly Linked List. The HashMap provides quick access to the cache entries, while the Doubly Linked List helps maintain the order of usage.\n\nBelow is a simple implementation of an LRU cache in Java:\n\n```java\nimport java.util.HashMap;\n\nclass LRUCache {\n\n    class DLinkedNode {\n        int key;\n        int value;\n        DLinkedNode prev;\n        DLinkedNode next;\n    }\n\n    private void addNode(DLinkedNode node) {\n        node.prev = head;\n        node.next = head.next;\n\n        head.next.prev = node;\n        head.next = node;\n    }\n\n    private void removeNode(DLinkedNode node){\n        DLinkedNode prev = node.prev;\n        DLinkedNode next = node.next;\n\n        prev.next = next;\n        next.prev = prev;\n    }\n\n    private void moveToHead(DLinkedNode node){\n        removeNode(node);\n        addNode(node);\n    }\n\n    private DLinkedNode popTail(){\n        DLinkedNode res = tail.prev;\n        removeNode(res);\n        return res;\n    }\n\n    private DLinkedNode head;\n    private DLinkedNode tail;\n    private HashMap<Integer, DLinkedNode> cache = new HashMap<Integer, DLinkedNode>();\n    private int size;\n    private int capacity;\n\n    public LRUCache(int capacity) {\n        this.size = 0;\n        this.capacity = capacity;\n\n        head = new DLinkedNode();\n        head.prev = null;\n\n        tail = new DLinkedNode();\n        tail.next = null;\n\n        head.next = tail;\n        tail.prev = head;\n    }\n\n    public int get(int key) {\n        DLinkedNode node = cache.get(key);\n        if (node == null) {\n            return -1;\n        }\n\n        // Move the accessed node to the head\n        moveToHead(node);\n\n        return node.value;\n    }\n\n    public void put(int key, int value) {\n        DLinkedNode node = cache.get(key);\n\n        if (node != null) {\n            // Update the value\n            node.value = value;\n            // Move the accessed node to the head\n            moveToHead(node);\n        } else {\n            DLinkedNode newNode = new DLinkedNode();\n            newNode.key = key;\n            newNode.value = value;\n\n            cache.put(key, newNode);\n            addNode(newNode);\n            ++size;\n\n            if (size > capacity) {\n                // Pop the tail\n                DLinkedNode tail = popTail();\n                cache.remove(tail.key);\n                --size;\n            }\n        }\n    }\n}\n```\n\n### Explanation\n\n1. **Doubly Linked List Node (`DLinkedNode`)**:\n   - Each node contains `key`, `value`, and references to the previous and next nodes.\n\n2. **Helper Methods**:\n   - `addNode(DLinkedNode node)`: Adds a new node right after the head.\n   - `removeNode(DLinkedNode node)`: Removes a node from the list.\n   - `moveToHead(DLinkedNode node)`: Moves a node to the head by first removing it and then adding it back.\n   - `popTail()`: Removes the node before the tail (the least recently used node).\n\n3. **LRUCache Class**:\n   - Initializes a doubly linked list with a dummy head and tail.\n   - Uses a `HashMap` to store keys and their corresponding nodes for O(1) access.\n   - `get(int key)`: Retrieves a value by key and moves the accessed node to the head.\n   - `put(int key, int value)`: Inserts or updates a key-value pair and moves the node to the head. If the cache exceeds capacity, removes the least recently used item.\n\nThis implementation ensures that all operations are performed in constant time, O(1), making it efficient for scenarios where cache operations need to be fast."
    }
]