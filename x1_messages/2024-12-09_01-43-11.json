[
    {
        "role": "user",
        "content": "Implement a simple LRU (Least Recently Used) cache in Golang that supports get and put operations with O(1) time complexity."
    },
    {
        "role": "assistant",
        "content": "Implementing a Least Recently Used (LRU) cache in Golang with O(1) time complexity for both get and put operations involves using a combination of a hash map and a doubly linked list. The hash map provides quick access to the cache elements, while the doubly linked list helps maintain the order of elements based on their usage.\n\nHere's a step-by-step guide to implementing such a cache:\n\n### Step 1: Define the Cache Structure\n\nWe need to define a structure that holds the cache data, including a hash map for quick access and a doubly linked list to maintain the order of elements.\n\n```go\ntype LRUCache struct {\n    capacity int\n    cache    map[int]*DoublyLinkedListNode\n    head     *DoublyLinkedListNode\n    tail     *DoublyLinkedListNode\n}\n```\n\n### Step 2: Define the Doubly Linked List Node\n\nEach node in the doubly linked list will hold the key and value of the cache item, along with pointers to the next and previous nodes.\n\n```go\ntype DoublyLinkedListNode struct {\n    key  int\n    value int\n    prev *DoublyLinkedListNode\n    next *DoublyLinkedListNode\n}\n```\n\n### Step 3: Initialize the Cache\n\nWhen creating a new LRUCache instance, initialize the hash map and set up the head and tail pointers of the doubly linked list.\n\n```go\nfunc NewLRUCache(capacity int) *LRUCache {\n    if capacity <= 0 {\n        panic(\"Capacity must be positive\")\n    }\n    cache := make(map[int]*DoublyLinkedListNode)\n    head := &DoublyLinkedListNode{}\n    tail := &DoublyLinkedListNode{}\n    head.next = tail\n    tail.prev = head\n    return &LRUCache{\n        capacity: capacity,\n        cache:    cache,\n        head:     head,\n        tail:     tail,\n    }\n}\n```\n\n### Step 4: Implement the Get Operation\n\nThe get operation should retrieve the value associated with a given key and update the recency of the item.\n\n- If the key is not found, return -1.\n- If the key is found, move the corresponding node to the front of the list (most recently used) and return its value.\n\n```go\nfunc (c *LRUCache) Get(key int) int {\n    node, found := c.cache[key]\n    if !found {\n        return -1\n    }\n    c.moveToFront(node)\n    return node.value\n}\n```\n\n### Step 5: Implement the Put Operation\n\nThe put operation should insert a new key-value pair into the cache.\n\n- If the key already exists, update its value and move it to the front.\n- If the key is new and the cache is at capacity, remove the least recently used item (the one at the end of the list).\n- Add the new key-value pair to the front of the list and update the hash map.\n\n```go\nfunc (c *LRUCache) Put(key int, value int) {\n    if node, found := c.cache[key]; found {\n        node.value = value\n        c.moveToFront(node)\n        return\n    }\n    if len(c.cache) >= c.capacity {\n        c.removeLeastRecentlyUsed()\n    }\n    newNode := &DoublyLinkedListNode{key: key, value: value}\n    c.cache[key] = newNode\n    c.addToFront(newNode)\n}\n```\n\n### Step 6: Helper Functions\n\nImplement helper functions to manage the doubly linked list operations.\n\n- `moveToFront(node *DoublyLinkedListNode)`: Moves a node to the front of the list.\n- `removeNode(node *DoublyLinkedListNode)`: Removes a node from its current position in the list.\n- `addToFront(node *DoublyLinkedListNode)`: Adds a node to the front of the list.\n- `removeLeastRecentlyUsed()`: Removes the least recently used item from the cache.\n\n```go\nfunc (c *LRUCache) moveToFront(node *DoublyLinkedListNode) {\n    c.removeNode(node)\n    c.addToFront(node)\n}\n\nfunc (c *LRUCache) removeNode(node *DoublyLinkedListNode) {\n    node.prev.next = node.next\n    node.next.prev = node.prev\n}\n\nfunc (c *LRUCache) addToFront(node *DoublyLinkedListNode) {\n    node.prev = c.head\n    node.next = c.head.next\n    c.head.next.prev = node\n    c.head.next = node\n}\n\nfunc (c *LRUCache) removeLeastRecentlyUsed() {\n    delete(c.cache, c.tail.prev.key)\n    c.removeNode(c.tail.prev)\n}\n```\n\n### Step 7: Testing the Cache\n\nTo verify the correctness of the implementation, you can write some test cases.\n\n```go\nfunc main() {\n    cache := NewLRUCache(2)\n    cache.Put(1, 1)\n    cache.Put(2, 2)\n    fmt.Println(cache.Get(1)) // returns 1\n    cache.Put(3, 3)           // evicts key 2\n    fmt.Println(cache.Get(2)) // returns -1 (not found)\n    cache.Put(4, 4)           // evicts key 1\n    fmt.Println(cache.Get(1)) // returns -1 (not found)\n    fmt.Println(cache.Get(3)) // returns 3\n    fmt.Println(cache.Get(4)) // returns 4\n}\n```\n\nThis implementation ensures that both get and put operations are performed in O(1) time complexity, meeting the requirements for an efficient LRU cache."
    }
]