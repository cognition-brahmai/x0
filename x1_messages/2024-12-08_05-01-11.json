[
    {
        "role": "user",
        "content": "Implement a binary search tree in C++ with the following features:\n   - Insertion of elements\n   - Deletion of elements\n   - In-order traversal\n   - Pre-order traversal\n   - Post-order traversal\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Implementing a Binary Search Tree (BST) in C++ with insertion, deletion, and traversal operations involves several steps. Below is a comprehensive implementation that includes all the requested features.\n\n### Binary Search Tree Implementation in C++\n\n```cpp\n#include <iostream>\n\nclass Node {\npublic:\n    int data;\n    Node* left;\n    Node* right;\n\n    Node(int val) {\n        data = val;\n        left = nullptr;\n        right = nullptr;\n    }\n};\n\nclass BinarySearchTree {\npublic:\n    Node* root;\n\n    BinarySearchTree() {\n        root = nullptr;\n    }\n\n    // Insertion\n    void insert(int val) {\n        root = insertRec(root, val);\n    }\n\n    // In-order traversal\n    void inorder() {\n        inorderRec(root);\n        std::cout << std::endl;\n    }\n\n    // Pre-order traversal\n    void preorder() {\n        preorderRec(root);\n        std::cout << std::endl;\n    }\n\n    // Post-order traversal\n    void postorder() {\n        postorderRec(root);\n        std::cout << std::endl;\n    }\n\n    // Deletion\n    void deleteNode(int key) {\n        root = deleteNodeRec(root, key);\n    }\n\nprivate:\n    // Recursive insertion\n    Node* insertRec(Node* node, int val) {\n        if (node == nullptr) {\n            return new Node(val);\n        }\n\n        if (val < node->data) {\n            node->left = insertRec(node->left, val);\n        } else if (val > node->data) {\n            node->right = insertRec(node->right, val);\n        } else {\n            // Duplicate values are not allowed in BST\n            return node;\n        }\n\n        return node;\n    }\n\n    // In-order traversal\n    void inorderRec(Node* node) {\n        if (node != nullptr) {\n            inorderRec(node->left);\n            std::cout << node->data << \" \";\n            inorderRec(node->right);\n        }\n    }\n\n    // Pre-order traversal\n    void preorderRec(Node* node) {\n        if (node != nullptr) {\n            std::cout << node->data << \" \";\n            preorderRec(node->left);\n            preorderRec(node->right);\n        }\n    }\n\n    // Post-order traversal\n    void postorderRec(Node* node) {\n        if (node != nullptr) {\n            postorderRec(node->left);\n            postorderRec(node->right);\n            std::cout << node->data << \" \";\n        }\n    }\n\n    // Function to find the node with the minimum value in a subtree\n    Node* minValueNode(Node* node) {\n        Node* current = node;\n        while (current && current->left != nullptr) {\n            current = current->left;\n        }\n        return current;\n    }\n\n    // Recursive deletion\n    Node* deleteNodeRec(Node* root, int key) {\n        if (root == nullptr) {\n            return root;\n        }\n\n        if (key < root->data) {\n            root->left = deleteNodeRec(root->left, key);\n        } else if (key > root->data) {\n            root->right = deleteNodeRec(root->right, key);\n        } else {\n            // Node with only one child or no child\n            if (root->left == nullptr) {\n                Node* temp = root->right;\n                delete root;\n                return temp;\n            } else if (root->right == nullptr) {\n                Node* temp = root->left;\n                delete root;\n                return temp;\n            }\n\n            // Node with two children: Get the inorder successor (smallest in the right subtree)\n            Node* temp = minValueNode(root->right);\n\n            // Copy the inorder successor's content to this node\n            root->data = temp->data;\n\n            // Delete the inorder successor\n            root->right = deleteNodeRec(root->right, temp->data);\n        }\n        return root;\n    }\n};\n\nint main() {\n    BinarySearchTree tree;\n\n    // Insert elements\n    tree.insert(50);\n    tree.insert(30);\n    tree.insert(20);\n    tree.insert(40);\n    tree.insert(70);\n    tree.insert(60);\n    tree.insert(80);\n\n    // In-order traversal\n    std::cout << \"In-order traversal: \";\n    tree.inorder();\n\n    // Pre-order traversal\n    std::cout << \"Pre-order traversal: \";\n    tree.preorder();\n\n    // Post-order traversal\n    std::cout << \"Post-order traversal: \";\n    tree.postorder();\n\n    // Delete elements\n    tree.deleteNode(20);\n    std::cout << \"After deleting 20:\\n\";\n    tree.inorder();\n\n    tree.deleteNode(30);\n    std::cout << \"After deleting 30:\\n\";\n    tree.inorder();\n\n    tree.deleteNode(50);\n    std::cout << \"After deleting 50:\\n\";\n    tree.inorder();\n\n    return 0;\n}\n```\n\n### Explanation\n\n1. **Node Class**:\n   - Represents each node in the BST with `data`, `left`, and `right` pointers.\n\n2. **BinarySearchTree Class**:\n   - Contains the `root` pointer.\n   - **Insertion**:\n     - `insert(int val)`: Public method to insert a value.\n     - `insertRec(Node* node, int val)`: Recursive helper function to insert a value.\n   - **Deletion**:\n     - `deleteNode(int key)`: Public method to delete a node with the given key.\n     - `deleteNodeRec(Node* root, int key)`: Recursive helper function to delete a node.\n     - `minValueNode(Node* node)`: Helper function to find the node with the smallest value in a subtree.\n   - **Traversal**:\n     - `inorder()`, `preorder()`, `postorder()`: Public methods for in-order, pre-order, and post-order traversals.\n     - Corresponding recursive helper functions: `inorderRec`, `preorderRec`, `postorderRec`.\n\n3. **Main Function**:\n   - Demonstrates insertion, traversal, and deletion operations.\n\nThis implementation ensures that the BST properties are maintained during insertions and deletions and provides the required traversals to visualize the tree structure."
    }
]