[
    {
        "role": "user",
        "content": "Create a Golang web server that serves static files from a specified directory and provides an API endpoint to search for files by their filename. The server should also support pagination, allowing clients to request a specific number of results per page.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Alright, I'm going to create a Go web server that serves static files from a specified directory and has an API endpoint to search for files by their filename. Additionally, this server should support pagination, so clients can request a specific number of results per page.\n\nFirst, I need to set up a basic Go web server using the `net/http` package. I'll also need to serve static files, which can be done using `http.FileServer` and `http.Handle`.\n\nLet's start by setting up the file server:\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n)\n\nfunc main() {\n\tfs := http.FileServer(http.Dir(\"./static\"))\n\thttp.Handle(\"/static/\", http.StripPrefix(\"/static/\", fs))\n\thttp.ListenAndServe(\":8080\", nil)\n}\n```\n\nThis code sets up a server that serves files from the `./static` directory when URLs start with `/static/`.\n\nNext, I need to add an API endpoint for searching files by filename. I'll create a handler function for this purpose.\n\nFirst, I need to list all files in the static directory and allow searching based on the filename. I'll use the `filepath` package to list all files in the directory.\n\nI'll also need to handle query parameters for the search term and pagination.\n\nLet's define the API endpoint at `/api/search`.\n\nHere's how I can structure the handler:\n\n1. Read the search query parameter.\n2. Read pagination parameters: `page` and `results_per_page`.\n3. List all files in the static directory.\n4. Filter files based on the search term.\n5. Paginate the results based on the provided parameters.\n6. Return the paginated results as JSON.\n\nI need to make sure that the pagination works correctly, meaning that the correct slice of results is returned based on the page number and results per page.\n\nLet's start by implementing the handler function.\n\nFirst, I need to import necessary packages:\n\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"path/filepath\"\n\t\"strconv\"\n\t\"strings\"\n)\n```\n\nNow, I'll write the handler function:\n\n```go\nfunc searchHandler(w http.ResponseWriter, r *http.Request) {\n\tquery := r.URL.Query()\n\tsearchTerm := query.Get(\"q\")\n\tpageStr := query.Get(\"page\")\n\tresultsPerPageStr := query.Get(\"results_per_page\")\n\n\tpage, err := strconv.Atoi(pageStr)\n\tif err != nil || page < 1 {\n\t\tpage = 1\n\t}\n\n\tresultsPerPage, err := strconv.Atoi(resultsPerPageStr)\n\tif err != nil || resultsPerPage < 1 {\n\t\tresultsPerPage = 10\n\t}\n\n\t// List all files in the static directory\n\tdir := \"./static\"\n\tfiles, err := ioutil.ReadDir(dir)\n\tif err != nil {\n\t\thttp.Error(w, \"Error reading directory\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\t// Filter files based on the search term\n\tvar matchingFiles []string\n\tfor _, file := range files {\n\t\tif file.IsDir() {\n\t\t\tcontinue\n\t\t}\n\t\tfilename := file.Name()\n\t\tif strings.Contains(filename, searchTerm) {\n\t\t\tmatchingFiles = append(matchingFiles, filename)\n\t\t}\n\t}\n\n\t// Paginate the results\n\tstartIndex := (page - 1) * resultsPerPage\n\tendIndex := startIndex + resultsPerPage\n\tif startIndex >= len(matchingFiles) {\n\t\tmatchingFiles = []string{}\n\t} else {\n\t\tif endIndex > len(matchingFiles) {\n\t\t\tendIndex = len(matchingFiles)\n\t\t}\n\t\tmatchingFiles = matchingFiles[startIndex:endIndex]\n\t}\n\n\t// Return the results as JSON\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(w).Encode(matchingFiles)\n}\n```\n\nNow, I need to register this handler with the `/api/search` endpoint.\n\nUpdating the `main` function:\n\n```go\nfunc main() {\n\tfs := http.FileServer(http.Dir(\"./static\"))\n\thttp.Handle(\"/static/\", http.StripPrefix(\"/static/\", fs))\n\n\thttp.HandleFunc(\"/api/search\", searchHandler)\n\n\tfmt.Println(\"Server starting on :8080\")\n\thttp.ListenAndServe(\":8080\", nil)\n}\n```\n\nThis sets up the file server and the search API endpoint.\n\nLet's test this setup.\n\nFirst, create a `static` directory and add some files to it.\n\n```\nmkdir static\ntouch static/file1.txt\ntouch static/file2.txt\ntouch static/example.txt\n```\n\nNow, run the server:\n\n```\ngo run main.go\n```\n\nOpen a web browser and go to `http://localhost:8080/static/file1.txt` to verify that static files are served correctly.\n\nNext, test the search API using a tool like curl or Postman.\n\nFor example:\n\n```\ncurl \"http://localhost:8080/api/search?q=file&page=1&results_per_page=2\"\n```\n\nThis should return a JSON array with filenames containing \"file\", paginated with 2 results per page.\n\nPotential improvements:\n\n- Handle subdirectories if needed.\n- Add error handling for invalid pagination parameters.\n- Optimize file listing for large directories.\n- Use a more efficient way to handle file listings if performance is an issue.\n\nFor now, this should satisfy the requirements.\n\n## Final Solution\nTo create a Golang web server that serves static files and provides an API endpoint to search for files by their filename with pagination, follow these steps:\n\n1. **Set up the file server:**\n   - Use `http.FileServer` to serve static files from a specified directory.\n   - Map the file server to a specific URL path.\n\n2. **Create an API endpoint for searching files:**\n   - Handle HTTP requests to the `/api/search` endpoint.\n   - Read query parameters for the search term, page number, and results per page.\n   - List and filter files based on the search term.\n   - Paginate the results based on the provided parameters.\n   - Return the paginated results as JSON.\n\n### Solution Code\n\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"path/filepath\"\n\t\"strconv\"\n\t\"strings\"\n)\n\nfunc searchHandler(w http.ResponseWriter, r *http.Request) {\n\tquery := r.URL.Query()\n\tsearchTerm := query.Get(\"q\")\n\tpageStr := query.Get(\"page\")\n\tresultsPerPageStr := query.Get(\"results_per_page\")\n\n\tpage, err := strconv.Atoi(pageStr)\n\tif err != nil || page < 1 {\n\t\tpage = 1\n\t}\n\n\tresultsPerPage, err := strconv.Atoi(resultsPerPageStr)\n\tif err != nil || resultsPerPage < 1 {\n\t\tresultsPerPage = 10\n\t}\n\n\tdir := \"./static\"\n\tfiles, err := ioutil.ReadDir(dir)\n\tif err != nil {\n\t\thttp.Error(w, \"Error reading directory\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tvar matchingFiles []string\n\tfor _, file := range files {\n\t\tif file.IsDir() {\n\t\t\tcontinue\n\t\t}\n\t\tfilename := file.Name()\n\t\tif strings.Contains(filename, searchTerm) {\n\t\t\tmatchingFiles = append(matchingFiles, filename)\n\t\t}\n\t}\n\n\tstartIndex := (page - 1) * resultsPerPage\n\tendIndex := startIndex + resultsPerPage\n\tif startIndex >= len(matchingFiles) {\n\t\tmatchingFiles = []string{}\n\t} else {\n\t\tif endIndex > len(matchingFiles) {\n\t\t\tendIndex = len(matchingFiles)\n\t\t}\n\t\tmatchingFiles = matchingFiles[startIndex:endIndex]\n\t}\n\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(w).Encode(matchingFiles)\n}\n\nfunc main() {\n\tfs := http.FileServer(http.Dir(\"./static\"))\n\thttp.Handle(\"/static/\", http.StripPrefix(\"/static/\", fs))\n\n\thttp.HandleFunc(\"/api/search\", searchHandler)\n\n\tfmt.Println(\"Server starting on :8080\")\n\thttp.ListenAndServe(\":8080\", nil)\n}\n```\n\n### Explanation\n\n1. **File Server Setup:**\n   - The `http.FileServer` serves files from the `./static` directory.\n   - The `http.Handle` function maps the file server to URLs starting with `/static/`.\n\n2. **Search API Endpoint:**\n   - The `searchHandler` function handles requests to `/api/search`.\n   - It reads the search query parameters: `q` (search term), `page`, and `results_per_page`.\n   - Lists all files in the `./static` directory and filters them based on the search term.\n   - Paginates the results based on the provided page number and results per page.\n   - Returns the paginated filenames as a JSON array.\n\nThis setup ensures that static files are served correctly and that clients can search for files by filename with pagination support."
    }
]