[
    {
        "role": "user",
        "content": "Implement a simple version of the Huffman Coding algorithm in Java. This task involves creating a priority queue, building the Huffman tree, generating the codes, and encoding/decoding messages."
    },
    {
        "role": "assistant",
        "content": "Alright, I'm going to try to implement a simple version of the Huffman Coding algorithm in Java. I've got some ideas, but I might need to look up a few things to make sure I get it right. Let's start by understanding what Huffman Coding is all about.\n\nHuffman Coding is a lossless data compression algorithm. The idea is to assign variable-length codes to input characters, with shorter codes for more frequent characters. This way, the overall size of the encoded data is reduced.\n\nFirst things first, I need to understand the steps involved in Huffman Coding:\n\n1. **Frequency Count:** Calculate the frequency of each character in the input data.\n\n2. **Build a Priority Queue:** Create a priority queue (min-heap) of nodes, where each node represents a character and its frequency.\n\n3. **Build the Huffman Tree:**\n\n- Create a leaf node for each character and add it to the priority queue.\n\n- While there is more than one node in the queue:\n\n- Remove the two nodes of the lowest frequency.\n\n- Create a new internal node with these two nodes as children and with frequency equal to the sum of the two nodes' frequencies.\n\n- Add the new node back to the priority queue.\n\n- The remaining node is the root node and the tree is complete.\n\n4. **Generate Codes:** Traverse the Huffman Tree to generate binary codes for each character. The path from the root to each leaf node represents the code for the character at that leaf, with left edges being '0' and right edges being '1'.\n\n5. **Encode the Message:** Replace each character in the original message with its corresponding Huffman code.\n\n6. **Decode the Message:** Traverse the Huffman tree for each bit in the encoded message. When a leaf node is reached, append the character to the result and restart from the root for the next bit.\n\nAlright, now let's think about how to implement this in Java.\n\n### Step 1: Define the Node Structure\n\nEach node in the Huffman Tree will have:\n\n- A character (for leaf nodes)\n\n- Frequency of the character\n\n- Pointers to left and right children\n\n- A flag to indicate if it's a leaf node\n\nI can define a class for the nodes:\n\n```java\nclass HuffmanNode implements Comparable<HuffmanNode> {\n    char character;\n    int frequency;\n    HuffmanNode left, right;\n    boolean isLeaf;\n\n    public HuffmanNode(char character, int frequency, HuffmanNode left, HuffmanNode right, boolean isLeaf) {\n        this.character = character;\n        this.frequency = frequency;\n        this.left = left;\n        this.right = right;\n        this.isLeaf = isLeaf;\n    }\n\n    @Override\n    public int compareTo(HuffmanNode other) {\n        return this.frequency - other.frequency;\n    }\n}\n```\n\n### Step 2: Build the Frequency Table\n\nI need to calculate the frequency of each character in the input string.\n\n```java\nimport java.util.HashMap;\n\npublic HashMap<Character, Integer> buildFrequencyTable(String data) {\n    HashMap<Character, Integer> frequencyMap = new HashMap<>();\n    for (char c : data.toCharArray()) {\n        frequencyMap.put(c, frequencyMap.getOrDefault(c, 0) + 1);\n    }\n    return frequencyMap;\n}\n```\n\n### Step 3: Build the Huffman Tree\n\nI'll use a priority queue (min-heap) to build the Huffman Tree.\n\n```java\nimport java.util.PriorityQueue;\n\npublic HuffmanNode buildHuffmanTree(HashMap<Character, Integer> frequencyMap) {\n    PriorityQueue<HuffmanNode> priorityQueue = new PriorityQueue<>();\n\n    // Step 1: Create a leaf node for each character and frequency\n    for (Map.Entry<Character, Integer> entry : frequencyMap.entrySet()) {\n        HuffmanNode node = new HuffmanNode(entry.getKey(), entry.getValue(), null, null, true);\n        priorityQueue.add(node);\n    }\n\n    // Step 2: Build the Huffman Tree\n    while (priorityQueue.size() > 1) {\n        HuffmanNode left = priorityQueue.poll();\n        HuffmanNode right = priorityQueue.poll();\n\n        int sum = left.frequency + right.frequency;\n        HuffmanNode parent = new HuffmanNode('\\0', sum, left, right, false);\n        priorityQueue.add(parent);\n    }\n\n    return priorityQueue.peek();\n}\n```\n\n### Step 4: Generate Huffman Codes\n\nI need to traverse the tree to generate codes for each character.\n\n```java\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic Map<Character, String> generateCodes(HuffmanNode root) {\n    Map<Character, String> codes = new HashMap<>();\n    generateCodesHelper(root, \"\", codes);\n    return codes;\n}\n\nprivate void generateCodesHelper(HuffmanNode node, String code, Map<Character, String> codes) {\n    if (node.isLeaf) {\n        codes.put(node.character, code);\n        return;\n    }\n    generateCodesHelper(node.left, code + \"0\", codes);\n    generateCodesHelper(node.right, code + \"1\", codes);\n}\n```\n\n### Step 5: Encode the Message\n\nReplace each character with its Huffman code.\n\n```java\npublic String encode(String data, Map<Character, String> codes) {\n    StringBuilder encoded = new StringBuilder();\n    for (char c : data.toCharArray()) {\n        encoded.append(codes.get(c));\n    }\n    return encoded.toString();\n}\n```\n\n### Step 6: Decode the Message\n\nTraverse the Huffman tree for each bit in the encoded message.\n\n```java\npublic String decode(String encoded, HuffmanNode root) {\n    StringBuilder decoded = new StringBuilder();\n    HuffmanNode current = root;\n    for (char bit : encoded.toCharArray()) {\n        if (bit == '0') {\n            current = current.left;\n        } else {\n            current = current.right;\n        }\n        if (current.isLeaf) {\n            decoded.append(current.character);\n            current = root;\n        }\n    }\n    return decoded.toString();\n}\n```\n\n### Putting It All Together\n\nNow, let's create a main method to test the Huffman Coding implementation.\n\n```java\npublic class HuffmanCoding {\n    public static void main(String[] args) {\n        String data = \"Huffman coding is a data compression algorithm.\";\n\n        HuffmanCoding huffman = new HuffmanCoding();\n\n        // Step 1: Build frequency table\n        HashMap<Character, Integer> frequencyMap = huffman.buildFrequencyTable(data);\n\n        // Step 2: Build Huffman Tree\n        HuffmanNode root = huffman.buildHuffmanTree(frequencyMap);\n\n        // Step 3: Generate codes\n        Map<Character, String> codes = huffman.generateCodes(root);\n\n        // Step 4: Encode the message\n        String encoded = huffman.encode(data, codes);\n        System.out.println(\"Encoded: \" + encoded);\n\n        // Step 5: Decode the message\n        String decoded = huffman.decode(encoded, root);\n        System.out.println(\"Decoded: \" + decoded);\n    }\n}\n```\n\n### Explanation\n\n1. **Frequency Table:** Counts the occurrence of each character in the input string.\n\n2. **Huffman Tree:** Built using a min-heap to ensure the nodes with the lowest frequencies are combined first.\n\n3. **Codes Generation:** Traverses the tree to assign binary codes to each character, with '0' for left edges and '1' for right edges.\n\n4. **Encoding:** Replaces each character in the original message with its corresponding Huffman code.\n\n5. **Decoding:** Traverses the Huffman tree for each bit in the encoded message, appending the character when a leaf node is reached.\n\nThis should give a basic implementation of Huffman Coding in Java. I might need to handle some edge cases, like when there's only one unique character in the input, but this should be a good starting point."
    }
]