[
    {
        "role": "user",
        "content": "Implement a Python program that simulates the behavior of a Least Recently Used (LRU) Cache using a dictionary and a doubly-linked list. The cache should have methods for adding items, retrieving items by key, and removing the least recently used item when the cache reaches its capacity."
    },
    {
        "role": "assistant",
        "content": "Certainly! Implementing an LRU (Least Recently Used) cache in Python using a dictionary and a doubly-linked list is a great way to understand both data structures and how they can be combined for efficient operations. Below is a step-by-step explanation followed by the complete code.\n\n### Explanation\n\n1. **Doubly-Linked List**:\n   - We'll create a doubly-linked list where each node represents a cache entry.\n   - The list will maintain the order of usage, with the most recently used item at the head and the least recently used item at the tail.\n\n2. **Dictionary**:\n   - A dictionary will be used to store keys and their corresponding list nodes for O(1) access time.\n\n3. **Operations**:\n   - **Add Item**: If the key already exists, update its value and move it to the head. If the cache is full, remove the least recently used item (tail).\n   - **Retrieve Item**: Given a key, return the value and move the accessed item to the head.\n   - **Remove Least Recently Used Item**: Remove the item at the tail of the list.\n\n### Solution Code\n\n```python\nclass ListNode:\n    def __init__(self, key, value):\n        self.key = key\n        self.value = value\n        self.prev = None\n        self.next = None\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = {}\n        self.head = ListNode(0, 0)  # Dummy head\n        self.tail = ListNode(0, 0)  # Dummy tail\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    def _remove(self, node):\n        prev_node = node.prev\n        next_node = node.next\n        prev_node.next = next_node\n        next_node.prev = prev_node\n\n    def _add_to_head(self, node):\n        node.prev = self.head\n        node.next = self.head.next\n        self.head.next.prev = node\n        self.head.next = node\n\n    def get(self, key: int) -> int:\n        if key in self.cache:\n            node = self.cache[key]\n            self._remove(node)\n            self._add_to_head(node)\n            return node.value\n        return -1\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            node = self.cache[key]\n            self._remove(node)\n            del self.cache[key]\n        if len(self.cache) >= self.capacity:\n            tail_node = self.tail.prev\n            self._remove(tail_node)\n            del self.cache[tail_node.key]\n        new_node = ListNode(key, value)\n        self._add_to_head(new_node)\n        self.cache[key] = new_node\n\n# Example usage:\n# cache = LRUCache(2)\n# cache.put(1, 1)\n# cache.put(2, 2)\n# print(cache.get(1))       # returns 1\n# cache.put(3, 3)           # evicts key 2\n# print(cache.get(2))       # returns -1 (not found)\n# cache.put(4, 4)           # evicts key 1\n# print(cache.get(1))       # returns -1 (not found)\n# print(cache.get(3))       # returns 3\n# print(cache.get(4))       # returns 4\n```\n\n### Explanation of Methods\n\n1. **`__init__(self, capacity: int)`**:\n   - Initializes the LRU cache with the given capacity.\n   - Sets up a dummy head and tail to simplify addition and removal operations.\n\n2. **`_remove(self, node)`**:\n   - Helper method to remove a node from the list.\n\n3. **`_add_to_head(self, node)`**:\n   - Helper method to add a node to the head of the list.\n\n4. **`get(self, key: int) -> int`**:\n   - Retrieves the value for the given key if it exists.\n   - Moves the accessed node to the head to mark it as recently used.\n   - Returns -1 if the key is not found.\n\n5. **`put(self, key: int, value: int) -> None`**:\n   - Adds or updates the value for the given key.\n   - If the key already exists, removes the old entry before adding the new one.\n   - If the cache is at capacity, removes the least recently used item (tail).\n   - Adds the new entry to the head of the list and updates the dictionary.\n\nThis implementation ensures that both `get` and `put` operations have an average time complexity of O(1), making it efficient for caching purposes."
    }
]