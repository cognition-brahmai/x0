[
    {
        "role": "user",
        "content": "Implement a Python program that simulates the behavior of a doubly linked list, including methods for insertion, deletion, and traversal."
    },
    {
        "role": "assistant",
        "content": "Alright, I'm going to try to create a Python program that simulates a doubly linked list. I need to make sure that it includes methods for insertion, deletion, and traversal. Let's start by understanding what a doubly linked list is.\n\nA doubly linked list is a type of linked list in which each node has pointers to both the next and previous nodes. This allows traversal in both directions, which can be useful in certain scenarios.\n\nFirst, I need to define the structure of a node in the doubly linked list. Each node should contain data and two pointers: one pointing to the next node and another pointing to the previous node.\n\nLet me think about how to implement this in Python. In Python, we can define a class for the node, say `Node`, which will have attributes for data, next, and prev.\n\nHere's a rough idea:\n\n```python\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n        self.prev = None\n```\n\nOkay, that seems straightforward. Now, I need to create another class for the doubly linked list itself, say `DoublyLinkedList`, which will have methods for insertion, deletion, and traversal.\n\nLet's think about the insertion method. There are different ways to insert a node into a doubly linked list: at the beginning, at the end, or at a specific position.\n\nI should probably have methods for inserting at the beginning, inserting at the end, and inserting after a specific node.\n\nSimilarly, for deletion, I need methods to delete a node based on its data or its position.\n\nAnd for traversal, I need methods to traverse the list in both forward and backward directions.\n\nLet me start by defining the `DoublyLinkedList` class and initializing it with a head and tail pointer.\n\n```python\nclass DoublyLinkedList:\n    def __init__(self):\n        self.head = None\n        self.tail = None\n```\n\nNow, let's implement the insertion methods.\n\nFirst, inserting at the beginning of the list.\n\nTo insert a node at the beginning, I need to set the new node's next pointer to the current head and the current head's prev pointer to the new node. Also, update the head pointer to point to the new node.\n\nIf the list is empty, both head and tail should point to the new node.\n\nHere's how I can implement it:\n\n```python\ndef insert_beginning(self, data):\n    new_node = Node(data)\n    if self.head is None:\n        self.head = new_node\n        self.tail = new_node\n    else:\n        new_node.next = self.head\n        self.head.prev = new_node\n        self.head = new_node\n```\n\nNext, inserting at the end of the list.\n\nTo insert a node at the end, I need to set the new node's prev pointer to the current tail and the current tail's next pointer to the new node. Then, update the tail pointer to point to the new node.\n\nIf the list is empty, both head and tail should point to the new node.\n\nHere's the code:\n\n```python\ndef insert_end(self, data):\n    new_node = Node(data)\n    if self.tail is None:\n        self.head = new_node\n        self.tail = new_node\n    else:\n        new_node.prev = self.tail\n        self.tail.next = new_node\n        self.tail = new_node\n```\n\nNow, inserting after a specific node.\n\nFor this, I need to have a method that takes a node and inserts a new node after it.\n\nI need to make sure that the node exists in the list before inserting after it.\n\nHere's how I can do it:\n\n```python\ndef insert_after_node(self, prev_node, data):\n    if prev_node is None:\n        print(\"The given previous node must be in the linked list.\")\n        return\n    new_node = Node(data)\n    new_node.next = prev_node.next\n    new_node.prev = prev_node\n    if prev_node.next is not None:\n        prev_node.next.prev = new_node\n    prev_node.next = new_node\n```\n\nOkay, now let's think about deletion methods.\n\nFirst, deleting a node based on its data.\n\nI need to traverse the list and find the node with the given data, then remove it by adjusting the pointers of the previous and next nodes.\n\nIf the node to be deleted is the head or the tail, I need to update the head or tail pointer accordingly.\n\nHere's a rough implementation:\n\n```python\ndef delete_node(self, data):\n    current = self.head\n    while current:\n        if current.data == data:\n            if current.prev is not None:\n                current.prev.next = current.next\n            else:\n                self.head = current.next\n            if current.next is not None:\n                current.next.prev = current.prev\n            else:\n                self.tail = current.prev\n            return\n        current = current.next\n    print(\"Node with data {} not found.\".format(data))\n```\n\nNext, traversing the list in both forward and backward directions.\n\nFor forward traversal, I can start from the head and move to the next nodes until I reach the tail.\n\nFor backward traversal, I can start from the tail and move to the previous nodes until I reach the head.\n\nI should implement methods to print the list in both directions.\n\nHere's how I can do it:\n\n```python\ndef traverse_forward(self):\n    current = self.head\n    while current:\n        print(current.data, end=\" \")\n        current = current.next\n    print()\n\ndef traverse_backward(self):\n    current = self.tail\n    while current:\n        print(current.data, end=\" \")\n        current = current.prev\n    print()\n```\n\nAlright, I think I have the basic methods covered. Now, I need to put everything together and test it.\n\nLet me write the complete code with all the methods.\n\n## Final Solution\nTo simulate a doubly linked list in Python, we need to implement a structure where each node contains data and pointers to both the next and previous nodes. This allows for traversal in both directions, which can be beneficial in various scenarios.\n\n### Approach\n\n1. **Node Structure**: Each node contains data, a pointer to the next node, and a pointer to the previous node.\n2. **Doubly Linked List Operations**:\n   - **Insertion**:\n     - At the beginning of the list.\n     - At the end of the list.\n     - After a specific node.\n   - **Deletion**:\n     - Delete a node based on its data.\n   - **Traversal**:\n     - Traverse and print the list from head to tail.\n     - Traverse and print the list from tail to head.\n\n### Solution Code\n\n```python\nclass Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n        self.prev = None\n\nclass DoublyLinkedList:\n    def __init__(self):\n        self.head = None\n        self.tail = None\n\n    def insert_beginning(self, data):\n        new_node = Node(data)\n        if self.head is None:\n            self.head = new_node\n            self.tail = new_node\n        else:\n            new_node.next = self.head\n            self.head.prev = new_node\n            self.head = new_node\n\n    def insert_end(self, data):\n        new_node = Node(data)\n        if self.tail is None:\n            self.head = new_node\n            self.tail = new_node\n        else:\n            new_node.prev = self.tail\n            self.tail.next = new_node\n            self.tail = new_node\n\n    def insert_after_node(self, prev_node, data):\n        if prev_node is None:\n            print(\"The given previous node must be in the linked list.\")\n            return\n        new_node = Node(data)\n        new_node.next = prev_node.next\n        new_node.prev = prev_node\n        if prev_node.next is not None:\n            prev_node.next.prev = new_node\n        prev_node.next = new_node\n\n    def delete_node(self, data):\n        current = self.head\n        while current:\n            if current.data == data:\n                if current.prev is not None:\n                    current.prev.next = current.next\n                else:\n                    self.head = current.next\n                if current.next is not None:\n                    current.next.prev = current.prev\n                else:\n                    self.tail = current.prev\n                return\n            current = current.next\n        print(\"Node with data {} not found.\".format(data))\n\n    def traverse_forward(self):\n        current = self.head\n        while current:\n            print(current.data, end=\" \")\n            current = current.next\n        print()\n\n    def traverse_backward(self):\n        current = self.tail\n        while current:\n            print(current.data, end=\" \")\n            current = current.prev\n        print()\n\n# Example usage\nif __name__ == \"__main__\":\n    dll = DoublyLinkedList()\n    dll.insert_end(1)\n    dll.insert_end(2)\n    dll.insert_end(3)\n    dll.insert_end(4)\n    dll.insert_end(5)\n    dll.insert_beginning(0)\n    dll.insert_after_node(dll.head.next, 1.5)\n    print(\"Forward traversal:\")\n    dll.traverse_forward()  # Output: 0 1 1.5 2 3 4 5\n    print(\"Backward traversal:\")\n    dll.traverse_backward()  # Output: 5 4 3 2 1.5 1 0\n    dll.delete_node(1.5)\n    print(\"After deleting 1.5:\")\n    dll.traverse_forward()  # Output: 0 1 2 3 4 5\n```\n\n### Explanation\n\n1. **Node Structure**: \n   - Each `Node` has `data`, `next`, and `prev` attributes.\n   \n2. **Doubly Linked List Operations**:\n   - **insert_beginning(data)**: Inserts a new node at the start of the list.\n   - **insert_end(data)**: Inserts a new node at the end of the list.\n   - **insert_after_node(prev_node, data)**: Inserts a new node after the specified node.\n   - **delete_node(data)**: Deletes the node with the specified data.\n   - **traverse_forward()**: Prints the list from head to tail.\n   - **traverse_backward()**: Prints the list from tail to head.\n\nThis implementation ensures that all basic operations of a doubly linked list are covered, providing a solid foundation for more complex operations and use cases."
    }
]