[
    {
        "role": "user",
        "content": "Develop a Golang command-line tool that monitors a specified directory for changes in real-time. When a change is detected (file creation, modification, or deletion), log the event type, file name, and timestamp to a text file.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "I've got this task to create a Go command-line tool that watches a directory for changes and logs those changes to a text file. Sounds straightforward, but I need to make sure I cover all the bases. Let's break it down step by step.\n\nFirst, I need to understand what it means to monitor a directory for changes in real-time. In Go, there's a package called `fsnotify` that's perfect for this job. It allows you to watch files and directories for changes efficiently.\n\nSo, I'll need to import `fsnotify` and set up a watcher for the specified directory. The user should be able to specify which directory to watch, probably via a command-line argument.\n\nNext, I need to detect different types of changes: file creation, modification, and deletion. Fsnotify provides events for these actions: `Create`, `Write`, and `Remove`. I'll need to handle each of these events and log the appropriate information.\n\nLogging the event type, file name, and timestamp to a text file is straightforward. I can use Go's `log` package to write to a file. I should make sure that the log file is appended to, so history is preserved.\n\nLet me think about the command-line interface. The user should be able to specify the directory to watch and maybe the log file name. I can use the `flag` package to handle command-line arguments.\n\nEdge cases to consider:\n\n- The specified directory doesn't exist.\n\n- The program doesn't have permission to read the directory.\n\n- The log file can't be opened or written to.\n\n- Multiple events happening at the same time.\n\nI need to handle these gracefully, perhaps by logging an error message and continuing.\n\nAlso, I should think about how to stop the watcher. Maybe the user can press Ctrl+C to stop the program.\n\nLet me sketch a rough structure of the program:\n\n1. Parse command-line arguments: directory to watch and log file name.\n\n2. Set up a log file and configure the logger to write to it.\n\n3. Create an fsnotify watcher and start watching the directory.\n\n4. In a loop, wait for events from the watcher and log them.\n\n5. Handle errors appropriately.\n\n6. Clean up when the program is interrupted or ends.\n\nI should also consider if I need to watch subdirectories recursively. Fsnotify can handle this with the `Watch` method for each subdirectory, but it might be overkill for a simple tool. Maybe I'll make it optional via a command-line flag.\n\nAnother thing: timestamps. I need to make sure that the timestamps are accurate and in a human-readable format. Go's `time` package can handle this.\n\nLet me think about the log entry format. Something like:\n\n[timestamp] [event type] [file name]\n\nFor example:\n\n[2023-04-01 12:34:56] Create /path/to/file.txt\n\n[2023-04-01 12:35:01] Modify /path/to/file.txt\n\n[2023-04-01 12:35:05] Remove /path/to/file.txt\n\nThat seems clear and concise.\n\nNow, implementing this in Go. I'll need to:\n\n- Import the necessary packages: `flag`, `log`, `time`, `github.com/fsnotify/fsnotify`.\n\n- Define command-line flags for the directory and log file.\n\n- Open the log file and set up the logger to write to it.\n\n- Create a watcher and start watching the directory.\n\n- In a loop, receive events from the watcher and log them with the appropriate format.\n\n- Handle errors, like permission issues or full disk.\n\n- Make sure the program can be interrupted gracefully, perhaps by catching SIGINT to stop the watcher.\n\nLet me consider writing a small example to test fsnotify first.\n\nHere's a simple example from the fsnotify README:\n\n```go\n\npackage main\n\nimport (\n\n \"fmt\"\n\n \"github.com/fsnotify/fsnotify\"\n\n)\n\nfunc main() {\n\n watcher, err := fsnotify.NewWatcher()\n\n if err != nil {\n\n panic(err)\n\n }\n\n defer watcher.Close()\n\n done := make(chan bool)\n\n go func() {\n\n for {\n\n select {\n\n case event := <-watcher.Events:\n\n fmt.Println(\"event:\", event)\n\n case err := <-watcher.Errors:\n\n fmt.Println(\"error:\", err)\n\n }\n\n }\n\n }()\n\n err = watcher.Add(\"/tmp\")\n\n if err != nil {\n\n panic(err)\n\n }\n\n <-done\n\n}\n\n```\n\nThis shows how to set up a watcher and listen for events and errors.\n\nI need to adapt this to my use case: logging events to a file with specific formatting.\n\nI should also handle the directory path from a command-line argument.\n\nLet me start by defining the command-line flags.\n\nI'll have:\n\n- `-dir`: the directory to watch.\n\n- `-log`: the log file name.\n\nI can set default values if not provided.\n\nWait, it's better to require the directory to be specified, but have a default log file name, say \"directory_watch.log\".\n\nNow, for error handling, if the directory doesn't exist, I should inform the user and exit.\n\nSimilarly, if there's an error opening the log file, I need to handle that gracefully.\n\nI should also think about concurrent access. Fsnotify events might come in quickly, and I need to make sure that logging is thread-safe.\n\nGo's log package is safe for concurrent use, so that should be okay.\n\nLet me outline the code structure:\n\n- Parse command-line flags.\n\n- Check if the directory exists and is a directory.\n\n- Open the log file, creating it if it doesn't exist.\n\n- Configure the logger to write to the log file.\n\n- Create a fsnotify watcher.\n\n- Add the directory to the watcher.\n\n- Start a goroutine to listen for events and log them.\n\n- In the main goroutine, wait for interrupt signal to stop the watcher.\n\nI need to make sure that the program doesn't exit immediately but stays running to watch for changes.\n\nUsing a channel to block the main goroutine and wait for SIGINT seems appropriate.\n\nI can use `os.Interrupt` to catch Ctrl+C.\n\nLet me look up how to catch SIGINT in Go.\n\nI can use a signal trap:\n\n```go\n\nc := make(chan os.Signal, 1)\n\nsignal.Notify(c, os.Interrupt)\n\ngo func() {\n\n for sig := range c {\n\n // Handle the signal, e.g., stop the watcher.\n\n }\n\n}()\n\n```\n\nI can use this to stop the watcher when the user interrupts the program.\n\nNow, for logging, I need to format the log entries as specified.\n\nI can create a custom logging function that takes the event type and file name, gets the current time, and writes the formatted string to the log.\n\nSomething like:\n\n```go\n\nfunc logEvent(eventType string, fileName string) {\n\n timestamp := time.Now().Format(time.RFC3339)\n\n logEntry := fmt.Sprintf(\"[%s] %s %s\\n\", timestamp, eventType, fileName)\n\n log.Print(logEntry)\n\n}\n\n```\n\nI need to make sure that the file names are absolute or relative as needed.\n\nWait, fsnotify events contain the file name relative to the watched directory.\n\nI might want to log the full path for clarity.\n\nSo, I should construct the full path by joining the watched directory path and the file name.\n\nLet me check the fsnotify.Event struct.\n\nLooking at the documentation:\n\nType Event describes a file system event.\n\ntype Event struct {\n\n Name string // file or directory name\n\n Op Op // operations\n\n}\n\nSo, Name is the file or directory name, and Op is the operation.\n\nI need to get the absolute path by joining the watched directory path and the Name.\n\nWait, actually, Name seems to be the full path.\n\nLooking closer:\n\n\"Name is the file or directory name that caused the event.\"\n\nBut in the example, it's just \"/tmp\" for the directory.\n\nI need to confirm this.\n\nI think Name is the full path of the file or directory that triggered the event.\n\nSo, I can use it directly.\n\nBut to make it more user-friendly, I might want to log the path relative to the watched directory.\n\nFor example, if watching \"/home/user/docs\" and a file \"/home/user/docs/report.txt\" is created, log \"report.txt\" instead of the full path.\n\nThat might be better, but I need to decide.\n\nLet me think about it.\n\nIf the user is watching a directory, they probably know the path, so logging the relative path would be sufficient and cleaner.\n\nBut to be safe, I'll log the full path.\n\nIn case the same tool is used to watch multiple directories with similar file names, full paths will avoid confusion.\n\nSo, I'll log the full path.\n\nNow, for the event types, fsnotify.Op describes the operation.\n\nIt's a bitmask that can have multiple operations combined, like Create, Write, Remove, Rename, etc.\n\nI need to map these operations to human-readable strings.\n\nFsnotify provides constants for these operations:\n\n- OpCreate\n\n- OpWrite\n\n- OpRemove\n\n- OpRename\n\n- OpChmod\n\nI need to handle these and possibly others.\n\nI can create a function to convert Op to a string.\n\nSomething like:\n\n```go\n\nfunc opToString(op fsnotify.Op) string {\n\n switch op {\n\n case fsnotify.OpCreate:\n\n return \"Create\"\n\n case fsnotify.OpWrite:\n\n return \"Modify\" // Assuming write means modify\n\n case fsnotify.OpRemove:\n\n return \"Remove\"\n\n case fsnotify.OpRename:\n\n return \"Rename\"\n\n case fsnotify.OpChmod:\n\n return \"Chmod\"\n\n default:\n\n return \"Unknown\"\n\n }\n\n}\n\n```\n\nI'll use this function to get the event type string for logging.\n\nNow, about logging the full path.\n\nIn the event handler, I'll construct the full path by combining the watched directory path and the event Name.\n\nWait, no, according to fsnotify documentation, Name is the full path of the file or directory that triggered the event.\n\nSo, I can use event.Name directly.\n\nBut to make it relative to the watched directory, I can use filepath.Rel.\n\nFor example:\n\nrelativePath, err := filepath.Rel(watchedDir, event.Name)\n\nif err != nil {\n\n // Handle error, use event.Name as is\n\n relativePath = event.Name\n\n}\n\nThen, log the relativePath.\n\nThis way, the log will show paths relative to the watched directory, which is cleaner.\n\nI need to handle the case where filepath.Rel returns an error, perhaps if the paths are on different file systems.\n\nIn such cases, I'll just log the full path.\n\nNow, for the log file, I need to open it in append mode so that logs are added to the end without overwriting previous logs.\n\nIn Go, when opening a file with `os.Create`, it truncates the file if it exists or creates a new one.\n\nTo append, I should use `os.OpenFile` with `os.O_APPEND|os.O_CREATE|os.O_WRONLY`.\n\nThen, set the logger to output to that file.\n\nSomething like:\n\n```go\n\nfile, err := os.OpenFile*logFilePath, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)\n\nif err != nil {\n\n log.Fatalf(\"Failed to open log file: %v\", err)\n\n}\n\ndefer file.Close()\n\nlog.SetOutput(file)\n\n```\n\nThis way, logs will be appended to the specified file.\n\nI should also set the log prefix and flags if needed.\n\nFor example:\n\n```go\n\nlog.SetFlags(log.LstdFlags)\n\n```\n\nThis will include the date and time in the log entries.\n\nBut since I'm already including the timestamp in my custom log format, I might not need the default prefix.\n\nWait, actually, in my custom log format, I'm including the timestamp, event type, and file name.\n\nSo, I can use log.Print to write the formatted string.\n\nI think that's fine.\n\nNow, about watching subdirectories recursively.\n\nFsnotify can watch directories recursively, but it requires setting up watchers for each subdirectory.\n\nTo keep it simple, I'll start by watching the specified directory only.\n\nIf I have time, I can add an option to watch recursively.\n\nFor now, let's stick to a single directory.\n\nAlright, time to start writing some code.\n\nFirst, I'll set up the command-line flags.\n\nUsing the `flag` package:\n\n```go\n\nvar dir = flag.String(\"dir\", \"\", \"Directory to watch\")\n\nvar logFile = flag.String(\"log\", \"directory_watch.log\", \"Log file name\")\n\n```\n\nI need to make sure that the directory flag is required.\n\nWait, the `flag` package doesn't support required flags directly, but I can check if it's provided.\n\nI'll add a check after parsing the flags:\n\n```go\n\nflag.Parse()\n\nif *dir == \"\" {\n\n log.Fatal(\"Directory to watch is required.\")\n\n}\n\n```\n\nNext, check if the directory exists and is actually a directory.\n\nI can use `os.Stat` and check the file type.\n\n```go\n\ninfo, err := os.Stat(*dir)\n\nif err != nil {\n\n log.Fatalf(\"Error accessing directory: %v\", err)\n\n}\n\nif !info.IsDir() {\n\n log.Fatalf(\"Specified path is not a directory.\")\n\n}\n\n```\n\nThen, open the log file in append mode.\n\n```go\n\nfile, err := os.OpenFile(*logFile, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)\n\nif err != nil {\n\n log.Fatalf(\"Failed to open log file: %v\", err)\n\n}\n\ndefer file.Close()\n\nlog.SetOutput(file)\n\n```\n\nNow, set up the fsnotify watcher.\n\n```go\n\nwatcher, err := fsnotify.NewWatcher()\n\nif err != nil {\n\n log.Fatal(\"Error creating watcher:\", err)\n\n}\n\ndefer watcher.Close()\n\n```\n\nAdd the directory to the watcher.\n\n```go\n\nerr = watcher.Add(*dir)\n\nif err != nil {\n\n log.Fatalf(\"Error adding directory to watcher: %v\", err)\n\n}\n\n```\n\nStart a goroutine to handle events and errors.\n\n```go\n\ngo func() {\n\n for {\n\n select {\n\n case event := <-watcher.Events:\n\n handleEvent(event)\n\n case err := <-watcher.Errors:\n\n log.Println(\"Watch error:\", err)\n\n }\n\n }\n\n}()\n\n```\n\nDefine the handleEvent function to log the events.\n\n```go\n\nfunc handleEvent(event fsnotify.Event) {\n\n eventType := opToString(event.Op)\n\n // Get relative path if possible\n\n relativePath, err := filepath.Rel(*dir, event.Name)\n\n if err != nil {\n\n relativePath = event.Name\n\n }\n\n logEvent(eventType, relativePath)\n\n}\n\n```\n\nImplement opToString as previously discussed.\n\nImplement logEvent to format and log the entry.\n\n```go\n\nfunc logEvent(eventType string, fileName string) {\n\n timestamp := time.Now().Format(time.RFC3339)\n\n logEntry := fmt.Sprintf(\"[%s] %s %s\\n\", timestamp, eventType, fileName)\n\n log.Print(logEntry)\n\n}\n\n```\n\nFinally, set up a signal trap to catch Ctrl+C and stop the watcher gracefully.\n\n```go\n\nc := make(chan os.Signal, 1)\n\nsignal.Notify(c, os.Interrupt)\n\ngo func() {\n\n for sig := range c {\n\n watcher.Close()\n\n os.Exit(0)\n\n }\n\n}()\n\n// Block forever\n\nselect {}\n\n```\n\nThis should keep the program running until interrupted.\n\nPutting it all together, here's a rough draft of the code:\n\n```go\n\npackage main\n\nimport (\n\n \"flag\"\n\n \"fmt\"\n\n \"log\"\n\n \"os\"\n\n \"path/filepath\"\n\n \"time\"\n\n \"github.com/fsnotify/fsnotify\"\n\n)\n\nvar dir = flag.String(\"dir\", \"\", \"Directory to watch\")\n\nvar logFile = flag.String(\"log\", \"directory_watch.log\", \"Log file name\")\n\nfunc main() {\n\n flag.Parse()\n\n if *dir == \"\" {\n\n log.Fatal(\"Directory to watch is required.\")\n\n }\n\n info, err := os.Stat(*dir)\n\n if err != nil {\n\n log.Fatalf(\"Error accessing directory: %v\", err)\n\n }\n\n if !info.IsDir() {\n\n log.Fatalf(\"Specified path is not a directory.\")\n\n }\n\n file, err := os.OpenFile(*logFile, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)\n\n if err != nil {\n\n log.Fatalf(\"Failed to open log file: %v\", err)\n\n }\n\n defer file.Close()\n\n log.SetOutput(file)\n\n watcher, err := fsnotify.NewWatcher()\n\n if err != nil {\n\n log.Fatal(\"Error creating watcher:\", err)\n\n }\n\n defer watcher.Close()\n\n err = watcher.Add(*dir)\n\n if err != nil {\n\n log.Fatalf(\"Error adding directory to watcher: %v\", err)\n\n }\n\n go func() {\n\n for {\n\n select {\n\n case event := <-watcher.Events:\n\n handleEvent(event)\n\n case err := <-watcher.Errors:\n\n log.Println(\"Watch error:\", err)\n\n }\n\n }\n\n }()\n\n c := make(chan os.Signal, 1)\n\n signal.Notify(c, os.Interrupt)\n\n go func() {\n\n for sig := range c {\n\n watcher.Close()\n\n os.Exit(0)\n\n }\n\n }()\n\n // Block forever\n\n select {}\n\n}\n\nfunc handleEvent(event fsnotify.Event) {\n\n eventType := opToString(event.Op)\n\n relativePath, err := filepath.Rel(*dir, event.Name)\n\n if err != nil {\n\n relativePath = event.Name\n\n }\n\n logEvent(eventType, relativePath)\n\n}\n\nfunc opToString(op fsnotify.Op) string {\n\n switch op {\n\n case fsnotify.OpCreate:\n\n return \"Create\"\n\n case fsnotify.OpWrite:\n\n return \"Modify\"\n\n case fsnotify.OpRemove:\n\n return \"Remove\"\n\n case fsnotify.OpRename:\n\n return \"Rename\"\n\n case fsnotify.OpChmod:\n\n return \"Chmod\"\n\n default:\n\n return \"Unknown\"\n\n }\n\n}\n\nfunc logEvent(eventType string, fileName string) {\n\n timestamp := time.Now().Format(time.RFC3339)\n\n logEntry := fmt.Sprintf(\"[%s] %s %s\\n\", timestamp, eventType, fileName)\n\n log.Print(logEntry)\n\n}\n\n```\n\nThis should be a good starting point.\n\nI need to test this code to make sure it works as expected.\n\nI'll create a directory, specify it with the -dir flag, and perform some operations like creating, modifying, and deleting files within it.\n\nI should check if the log file is created and updated correctly with the events.\n\nAlso, I need to ensure that the program handles errors gracefully, such as permission issues or if the log file becomes unreadable.\n\nAdditionally, I should consider if fsnotify supports watching files within subdirectories recursively.\n\nIf needed, I can enhance the tool to watch subdirectories recursively, but for now, this should suffice.\n\nI think this covers the basic requirements of the task.\n\n## Final Solution\nTo create a Go command-line tool that monitors a specified directory for changes in real-time and logs these changes to a text file, you can follow the steps and use the code provided below.\n\n### Approach\n\n1. **Monitoring Directory Changes:** Use the `fsnotify` package to watch for file system changes.\n2. **Logging Events:** Log details about each change (create, modify, delete) including the event type, file name, and timestamp to a text file.\n3. **Command-Line Interface:** Allow users to specify the directory to watch and the log file name via command-line arguments.\n4. **Error Handling:** Gracefully handle errors such as invalid directories or permission issues.\n\n### Solution Code\n\n```go\npackage main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"time\"\n\n\t\"github.com/fsnotify/fsnotify\"\n)\n\nvar dir = flag.String(\"dir\", \"\", \"Directory to watch\")\nvar logFile = flag.String(\"log\", \"directory_watch.log\", \"Log file name\")\n\nfunc main() {\n\tflag.Parse()\n\tif *dir == \"\" {\n\t\tlog.Fatal(\"Directory to watch is required.\")\n\t}\n\n\tinfo, err := os.Stat(*dir)\n\tif err != nil {\n\t\tlog.Fatalf(\"Error accessing directory: %v\", err)\n\t}\n\tif !info.IsDir() {\n\t\tlog.Fatalf(\"Specified path is not a directory.\")\n\t}\n\n\tfile, err := os.OpenFile(*logFile, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to open log file: %v\", err)\n\t}\n\tdefer file.Close()\n\tlog.SetOutput(file)\n\n\twatcher, err := fsnotify.NewWatcher()\n\tif err != nil {\n\t\tlog.Fatal(\"Error creating watcher:\", err)\n\t}\n\tdefer watcher.Close()\n\n\terr = watcher.Add(*dir)\n\tif err != nil {\n\t\tlog.Fatalf(\"Error adding directory to watcher: %v\", err)\n\t}\n\n\tgo func() {\n\t\tfor {\n\t\t\tselect {\n\t\t\tcase event := <-watcher.Events:\n\t\t\t\thandleEvent(event)\n\t\t\tcase err := <-watcher.Errors:\n\t\t\t\tlog.Println(\"Watch error:\", err)\n\t\t\t}\n\t\t}\n\t}()\n\n\tc := make(chan os.Signal, 1)\n\tsignal.Notify(c, os.Interrupt)\n\tgo func() {\n\t\tfor sig := range c {\n\t\t\twatcher.Close()\n\t\t\tos.Exit(0)\n\t\t}\n\t}()\n\n\t// Block forever\n\tselect {}\n}\n\nfunc handleEvent(event fsnotify.Event) {\n\teventType := opToString(event.Op)\n\trelativePath, err := filepath.Rel(*dir, event.Name)\n\tif err != nil {\n\t\trelativePath = event.Name\n\t}\n\tlogEvent(eventType, relativePath)\n}\n\nfunc opToString(op fsnotify.Op) string {\n\tswitch op {\n\tcase fsnotify.OpCreate:\n\t\treturn \"Create\"\n\tcase fsnotify.OpWrite:\n\t\treturn \"Modify\"\n\tcase fsnotify.OpRemove:\n\t\treturn \"Remove\"\n\tcase fsnotify.OpRename:\n\t\treturn \"Rename\"\n\tcase fsnotify.OpChmod:\n\t\treturn \"Chmod\"\n\tdefault:\n\t\treturn \"Unknown\"\n\t}\n}\n\nfunc logEvent(eventType string, fileName string) {\n\ttimestamp := time.Now().Format(time.RFC3339)\n\tlogEntry := fmt.Sprintf(\"[%s] %s %s\\n\", timestamp, eventType, fileName)\n\tlog.Print(logEntry)\n}\n```\n\n### Explanation\n\n1. **Flags and Parsing:**\n   - Use `flag` package to parse command-line arguments for the directory to watch and the log file name.\n\n2. **Directory Validation:**\n   - Check if the specified path exists and is a directory.\n\n3. **Logging Setup:**\n   - Open the log file in append mode and set up the logger to write to this file.\n\n4. **Watcher Setup:**\n   - Create a new `fsnotify.Watcher` and add the directory to be watched.\n\n5. **Event Handling:**\n   - Run a goroutine to handle file system events and log them with the appropriate details.\n\n6. **Signal Handling:**\n   - Trap the interrupt signal to close the watcher gracefully when the program is interrupted.\n\nThis tool provides real-time monitoring of a specified directory and logs all changes to a specified log file, making it easy to track modifications, creations, and deletions of files within the directory."
    }
]