[
    {
        "role": "user",
        "content": "Create a C++ program that implements a singly linked list with methods to add nodes at the beginning, end, and middle of the list, as well as to delete nodes by value.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Sure! Below is a simple implementation of a singly linked list in C++ with methods to add nodes at the beginning, end, and middle of the list, as well as to delete nodes by value.\n\n```cpp\n#include <iostream>\nusing namespace std;\n\nclass Node {\npublic:\n    int data;\n    Node* next;\n};\n\nclass SinglyLinkedList {\nprivate:\n    Node* head;\n\npublic:\n    SinglyLinkedList() : head(nullptr) {}\n\n    // Add node at the beginning\n    void addAtBeginning(int value) {\n        Node* newNode = new Node();\n        newNode->data = value;\n        newNode->next = head;\n        head = newNode;\n    }\n\n    // Add node at the end\n    void addAtEnd(int value) {\n        Node* newNode = new Node();\n        newNode->data = value;\n        newNode->next = nullptr;\n\n        if (head == nullptr) {\n            head = newNode;\n            return;\n        }\n\n        Node* temp = head;\n        while (temp->next != nullptr) {\n            temp = temp->next;\n        }\n        temp->next = newNode;\n    }\n\n    // Add node after a specific node\n    void addAtMiddle(int after, int value) {\n        Node* temp = head;\n        while (temp != nullptr && temp->data != after) {\n            temp = temp->next;\n        }\n\n        if (temp == nullptr) {\n            cout << \"Node with value \" << after << \" not found.\" << endl;\n            return;\n        }\n\n        Node* newNode = new Node();\n        newNode->data = value;\n        newNode->next = temp->next;\n        temp->next = newNode;\n    }\n\n    // Delete node by value\n    void deleteNode(int value) {\n        if (head == nullptr) {\n            cout << \"List is empty.\" << endl;\n            return;\n        }\n\n        if (head->data == value) {\n            Node* temp = head;\n            head = head->next;\n            delete temp;\n            return;\n        }\n\n        Node* temp = head;\n        while (temp->next != nullptr && temp->next->data != value) {\n            temp = temp->next;\n        }\n\n        if (temp->next == nullptr) {\n            cout << \"Node with value \" << value << \" not found.\" << endl;\n            return;\n        }\n\n        Node* toDelete = temp->next;\n        temp->next = temp->next->next;\n        delete toDelete;\n    }\n\n    // Display the list\n    void display() {\n        Node* temp = head;\n        while (temp != nullptr) {\n            cout << temp->data << \" -> \";\n            temp = temp->next;\n        }\n        cout << \"NULL\" << endl;\n    }\n\n    // Destructor to free memory\n    ~SinglyLinkedList() {\n        Node* temp;\n        while (head != nullptr) {\n            temp = head;\n            head = head->next;\n            delete temp;\n        }\n    }\n};\n\nint main() {\n    SinglyLinkedList list;\n\n    list.addAtBeginning(3);\n    list.addAtEnd(5);\n    list.addAtMiddle(3, 4);\n    list.display();  // Output: 3 -> 4 -> 5 -> NULL\n\n    list.deleteNode(4);\n    list.display();  // Output: 3 -> 5 -> NULL\n\n    list.deleteNode(5);\n    list.display();  // Output: 3 -> NULL\n\n    list.deleteNode(3);\n    list.display();  // Output: NULL\n\n    list.deleteNode(1);  // Output: List is empty.\n\n    return 0;\n}\n```\n\n### Explanation:\n\n1. **Node Class**: Represents each element in the linked list with `data` and `next` pointer.\n2. **SinglyLinkedList Class**: Manages the linked list operations.\n   - **addAtBeginning(int value)**: Adds a new node with the given value at the start of the list.\n   - **addAtEnd(int value)**: Adds a new node with the given value at the end of the list.\n   - **addAtMiddle(int after, int value)**: Adds a new node with the given value after the node that contains 'after'.\n   - **deleteNode(int value)**: Deletes the first node that contains the given value.\n   - **display()**: Prints the current state of the list.\n   - **Destructor**: Frees the memory allocated for each node when the list is destroyed.\n\nThis code provides a basic implementation and can be expanded with additional features as needed."
    }
]