[
    {
        "role": "user",
        "content": "Develop a Node.js script that periodically fetches cryptocurrency price data from a public API and saves it to a MongoDB database. The script should run every 15 minutes and store the latest prices for Bitcoin, Ethereum, and Litecoin. Implement error handling and ensure that duplicate entries are not added to the database.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Alright, I'm going to tackle this task of creating a Node.js script that fetches cryptocurrency prices periodically and stores them in a MongoDB database. Let's break this down step by step.\n\nFirst, I need to set up a Node.js project. I'll start by creating a new directory for this project and initializing it with npm.\n\n```bash\nmkdir crypto-price-tracker\ncd crypto-price-tracker\nnpm init -y\n```\n\nNext, I need to install the necessary dependencies. I'll need `node-fetch` for making HTTP requests to the API, `mongodb` for interacting with MongoDB, and `cron` for scheduling the script to run every 15 minutes.\n\n```bash\nnpm install node-fetch mongodb cron\n```\n\nNow, I need to choose a public API that provides cryptocurrency price data. A popular choice is CoinGecko or CoinMarketCap. For this example, I'll use the CoinGecko API because it's free and doesn't require an API key for basic data.\n\nFirst, I need to find out how to get the latest prices for Bitcoin, Ethereum, and Litecoin from CoinGecko. Looking at their documentation, I can see that I can make a GET request to `https://api.coingecko.com/api/v3/simple/price` with parameters for the ids and the vs_currency.\n\nFor example:\n\n```bash\nhttps://api.coingecko.com/api/v3/simple/price?ids=bitcoin%2Cethereum%2Clitecoin&vs_currencies=usd\n```\n\nThis should return the current price of Bitcoin, Ethereum, and Litecoin in USD.\n\nNow, I need to set up a MongoDB database to store this data. I'll assume that I have a MongoDB instance running locally, but in a real-world scenario, I might want to use a cloud-based MongoDB service like MongoDB Atlas.\n\nI need to create a schema for the price data. Each entry should include the cryptocurrency name, its price, and a timestamp for when the price was fetched.\n\nIn MongoDB, I can use a collection like `crypto_prices` with documents structured like this:\n\n```json\n{\n  \"crypto\": \"bitcoin\",\n  \"price\": 40000,\n  \"timestamp\": ISODate(\"2023-04-01T12:00:00Z\")\n}\n```\n\nSimilarly for Ethereum and Litecoin.\n\nNow, I need to set up the MongoDB connection in my Node.js script. I'll use the `mongodb` package to connect to the database and insert documents.\n\nFirst, I need to import the required modules:\n\n```javascript\nconst fetch = require('node-fetch');\nconst { MongoClient } = require('mongodb');\nconst cron = require('cron');\n```\n\nI need to set up the MongoDB connection URL. Assuming a local MongoDB instance, the URL would be `'mongodb://localhost:27017'`. I'll also specify the database name, say `'crypto_db'`, and the collection name `'crypto_prices'`.\n\nNext, I need to create a function that fetches the price data from the CoinGecko API and inserts it into the MongoDB collection.\n\nI need to handle errors appropriately. If there's an error fetching the data or inserting it into the database, I should log the error and possibly send an alert or notify someone.\n\nAlso, I need to ensure that duplicate entries are not added to the database. Since I'm fetching data every 15 minutes, I need to make sure that I don't insert the same price data multiple times. One way to do this is to check if a document with the same `crypto` and `timestamp` already exists before inserting a new document.\n\nAlternatively, I could design the schema to have a compound unique index on `crypto` and `timestamp` fields to prevent duplicates.\n\nIn MongoDB, I can create a unique index like this:\n\n```javascript\ncollection.createIndex( { \"crypto\": 1, \"timestamp\": 1 }, { unique: true } );\n```\n\nThis way, if I try to insert a document with a duplicate `crypto` and `timestamp`, MongoDB will throw an error, which I can catch and handle.\n\nNow, let's outline the steps in code:\n\n1. Connect to the MongoDB database.\n\n2. Select the `crypto_prices` collection.\n\n3. Create a unique index on `crypto` and `timestamp`.\n\n4. Define a function to fetch and save the price data.\n\n5. Use the `cron` package to schedule this function to run every 15 minutes.\n\nLet's start by setting up the MongoDB connection:\n\n```javascript\nconst url = 'mongodb://localhost:27017';\nconst client = new MongoClient(url);\n\nasync function main() {\n  await client.connect();\n  const db = client.db('crypto_db');\n  const collection = db.collection('crypto_prices');\n  \n  // Create unique index\n  await collection.createIndex( { \"crypto\": 1, \"timestamp\": 1 }, { unique: true } );\n  \n  // Fetch and save prices\n  await fetchAndSavePrices(collection);\n  \n  // Schedule the job\n  const job = new cron.CronJob('0 */15 * * * *', () => {\n    fetchAndSavePrices(collection);\n  });\n  \n  job.start();\n}\n\nmain().catch(console.error);\n```\n\nNote that I'm using a cron expression `'0 */15 * * * *'` which means every 15 minutes.\n\nNow, I need to implement the `fetchAndSavePrices` function.\n\nFirst, I'll make a GET request to the CoinGecko API to fetch the latest prices.\n\nThen, for each cryptocurrency, I'll create a document with `crypto`, `price`, and `timestamp`, and insert it into the MongoDB collection.\n\nI need to handle cases where the API request fails or the response is not as expected.\n\nHere's a rough implementation:\n\n```javascript\nasync function fetchAndSavePrices(collection) {\n  const apiURL = 'https://api.coingecko.com/api/v3/simple/price?ids=bitcoin%2Cethereum%2Clitecoin&vs_currencies=usd';\n  \n  try {\n    const response = await fetch(apiURL);\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    const data = await response.json();\n    \n    const cryptoList = ['bitcoin', 'ethereum', 'litecoin'];\n    const timestamp = new Date();\n    \n    for (const crypto of cryptoList) {\n      const price = data[crypto].usd;\n      const document = {\n        crypto: crypto,\n        price: price,\n        timestamp: timestamp\n      };\n      \n      try {\n        await collection.insertOne(document);\n        console.log(`Inserted ${crypto} price: ${price} at ${timestamp}`);\n      } catch (err) {\n        if (err.code === 11000) {\n          console.log(`Duplicate entry for ${crypto} at ${timestamp}`);\n        } else {\n          console.error(`Error inserting ${crypto} price:`, err);\n        }\n      }\n    }\n  } catch (err) {\n    console.error('Error fetching or saving prices:', err);\n  }\n}\n```\n\nIn this function:\n\n- I make a GET request to the API.\n\n- Check if the response is OK.\n\n- Parse the JSON response.\n\n- Loop through the list of cryptocurrencies.\n\n- Create a document with `crypto`, `price`, and `timestamp`.\n\n- Insert the document into the collection, handling duplicates gracefully.\n\nI'm using `insertOne` method and catching the duplicate key error (error code 11000) to handle duplicates.\n\nThis should cover the basic functionality.\n\nHowever, there are a few improvements and considerations:\n\n1. **Error Handling:** Currently, I'm logging errors to the console. In a production environment, I might want to set up proper error logging, maybe using a logging service like Winston or sending alerts via email or a messaging service.\n\n2. **API Rate Limits:** Public APIs often have rate limits. CoinGecko's API has certain rate limits for unauthenticated requests. I need to make sure that fetching every 15 minutes is within those limits.\n\n3. **Configuration Management:** Hardcoding values like API URLs, database names, and collection names is not ideal. I should consider using environment variables or a configuration file to manage these settings.\n\n4. **Timestamp Precision:** Using JavaScript's `Date` object for timestamps is fine, but I need to ensure that the timestamp is accurate and consistent across different environments.\n\n5. **Cryptocurrency List:** If I need to add more cryptocurrencies in the future, I can make the cryptocurrency list configurable.\n\n6. **MongoDB Connection Management:** In the current implementation, the MongoDB connection is established once when the script starts. I need to make sure that the connection is properly closed when the script exits and handle any connection errors.\n\n7. **Cron Job Time Zone:** The cron job runs based on the system's time zone. If I need it to run based on a specific time zone, I might need to configure that.\n\n8. **Testing:** I should test the script to ensure that it fetches data correctly, handles errors, and doesn't insert duplicates.\n\nLet me address some of these points.\n\nFirst, for configuration management, I'll create a `config.js` file to store settings like API URL, database URL, database name, collection name, and cryptocurrency list.\n\n```javascript\n// config.js\nmodule.exports = {\n  apiURL: 'https://api.coingecko.com/api/v3/simple/price?ids=bitcoin%2Cethereum%2Clitecoin&vs_currencies=usd',\n  mongoURL: 'mongodb://localhost:27017',\n  dbName: 'crypto_db',\n  collectionName: 'crypto_prices',\n  cryptoList: ['bitcoin', 'ethereum', 'litecoin']\n};\n```\n\nThen, in my main script, I'll require this config.\n\nNext, for error logging, I can use the `winston` library, which provides a flexible logging system.\n\nFirst, install it:\n\n```bash\nnpm install winston\n```\n\nThen, set it up in the script:\n\n```javascript\nconst winston = require('winston');\n\nconst logger = winston.createLogger({\n  level: 'info',\n  format: winston.format.json(),\n  defaultMeta: { service: 'crypto-price-tracker' },\n  transports: [\n    new winston.transports.File({ filename: 'error.log', level: 'error' }),\n    new winston.transports.File({ filename: 'combined.log' })\n  ]\n});\n\nif (process.env.NODE_ENV !== 'production') {\n  logger.add(new winston.transports.Console({\n    format: winston.format.simple()\n  }));\n}\n```\n\nNow, instead of console.log, I can use logger.info, logger.error, etc.\n\nThis will log errors to a file and also to the console in development mode.\n\nNext, I need to handle the MongoDB connection more gracefully. I can create a function to connect to the database and handle disconnections.\n\nAlso, I should close the connection when the script exits.\n\nI can use the `once` event of the `process` object to handle script termination.\n\nHere's an updated version of the main function:\n\n```javascript\nasync function main() {\n  const config = require('./config');\n  \n  try {\n    await client.connect();\n    console.log(\"Connected correctly to server\");\n    const db = client.db(config.dbName);\n    const collection = db.collection(config.collectionName);\n    \n    // Create unique index\n    await collection.createIndex( { \"crypto\": 1, \"timestamp\": 1 }, { unique: true } );\n    \n    // Fetch and save prices initially\n    await fetchAndSavePrices(collection, config);\n    \n    // Schedule the job\n    const job = new cron.CronJob(config.cronExpression, () => {\n      fetchAndSavePrices(collection, config);\n    });\n    \n    job.start();\n    \n    // Close the connection on exit\n    process.once('SIGUSR2', async () => {\n      await client.close();\n      process.kill(process.pid, 'SIGUSR2');\n    });\n  } catch (err) {\n    logger.error('Error connecting to database:', err);\n    process.exit(1);\n  }\n}\n\nmain();\n```\n\nI've also added a `config.cronExpression` to make it configurable.\n\nIn `config.js`, I can add:\n\n```javascript\nmodule.exports = {\n  // other configs\n  cronExpression: '0 */15 * * * *' // every 15 minutes\n};\n```\n\nAdditionally, I should handle cases where the API response doesn't contain the expected data. For example, if a cryptocurrency is not found in the response, or if the price is not available.\n\nIn the `fetchAndSavePrices` function, I can add checks for these scenarios.\n\nHere's an updated version:\n\n```javascript\nasync function fetchAndSavePrices(collection, config) {\n  try {\n    const response = await fetch(config.apiURL);\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    const data = await response.json();\n    \n    const timestamp = new Date();\n    \n    for (const crypto of config.cryptoList) {\n      if (!data[crypto] || typeof data[crypto].usd !== 'number') {\n        logger.warn(`Invalid data for ${crypto}:`, data[crypto]);\n        continue;\n      }\n      const price = data[crypto].usd;\n      const document = {\n        crypto: crypto,\n        price: price,\n        timestamp: timestamp\n      };\n      \n      try {\n        await collection.insertOne(document);\n        logger.info(`Inserted ${crypto} price: ${price} at ${timestamp}`);\n      } catch (err) {\n        if (err.code === 11000) {\n          logger.info(`Duplicate entry for ${crypto} at ${timestamp}`);\n        } else {\n          logger.error(`Error inserting ${crypto} price:`, err);\n        }\n      }\n    }\n  } catch (err) {\n    logger.error('Error fetching or saving prices:', err);\n  }\n}\n```\n\nI've added a warning log for invalid data.\n\nFinally, I should consider adding more detailed logging and possibly sending notifications for critical errors.\n\nAlso, for production, I might want to run this script as a service, ensuring it restarts on failure and handles system restarts.\n\nI can use process managers like PM2 to achieve this.\n\nFirst, install PM2:\n\n```bash\nnpm install pm2 -g\n```\n\nThen, start the script with PM2:\n\n```bash\npm2 start app.js --name \"crypto-price-tracker\"\n```\n\nThis will keep the script running in the background and restart it if it crashes.\n\nI can also configure PM2 to start the script on system reboot.\n\nThat should cover the requirements for this task.\n\n## Final Solution\nTo create a Node.js script that periodically fetches cryptocurrency price data from the CoinGecko API and saves it to a MongoDB database, follow these steps:\n\n### Prerequisites\n1. **Node.js** installed on your system.\n2. **MongoDB** instance running locally or access to a cloud MongoDB service.\n3. **CoinGecko API** to fetch cryptocurrency prices.\n\n### Project Setup\n1. **Initialize the project:**\n   ```bash\n   mkdir crypto-price-tracker\n   cd crypto-price-tracker\n   npm init -y\n   ```\n\n2. **Install dependencies:**\n   ```bash\n   npm install node-fetch mongodb cron winston\n   ```\n\n3. **Create configuration file (`config.js`):**\n   ```javascript\n   module.exports = {\n     apiURL: 'https://api.coingecko.com/api/v3/simple/price?ids=bitcoin%2Cethereum%2Clitecoin&vs_currencies=usd',\n     mongoURL: 'mongodb://localhost:27017',\n     dbName: 'crypto_db',\n     collectionName: 'crypto_prices',\n     cryptoList: ['bitcoin', 'ethereum', 'litecoin'],\n     cronExpression: '0 */15 * * * *' // every 15 minutes\n   };\n   ```\n\n4. **Set up logging using Winston:**\n   ```javascript\n   const winston = require('winston');\n\n   const logger = winston.createLogger({\n     level: 'info',\n     format: winston.format.json(),\n     defaultMeta: { service: 'crypto-price-tracker' },\n     transports: [\n       new winston.transports.File({ filename: 'error.log', level: 'error' }),\n       new winston.transports.File({ filename: 'combined.log' })\n     ]\n   });\n\n   if (process.env.NODE_ENV !== 'production') {\n     logger.add(new winston.transports.Console({\n       format: winston.format.simple()\n     }));\n   }\n   ```\n\n5. **Main script (`app.js`):**\n   ```javascript\n   const fetch = require('node-fetch');\n   const { MongoClient } = require('mongodb');\n   const cron = require('cron');\n   const logger = require('./winstonLogger');\n\n   const url = 'mongodb://localhost:27017';\n   const client = new MongoClient(url);\n\n   async function main() {\n     try {\n       await client.connect();\n       logger.info(\"Connected correctly to server\");\n       const config = require('./config');\n       const db = client.db(config.dbName);\n       const collection = db.collection(config.collectionName);\n       \n       // Create unique index\n       await collection.createIndex( { \"crypto\": 1, \"timestamp\": 1 }, { unique: true } );\n       \n       // Fetch and save prices initially\n       await fetchAndSavePrices(collection, config);\n       \n       // Schedule the job\n       const job = new cron.CronJob(config.cronExpression, () => {\n         fetchAndSavePrices(collection, config);\n       });\n       \n       job.start();\n       \n       // Close the connection on exit\n       process.once('SIGUSR2', async () => {\n         await client.close();\n         process.kill(process.pid, 'SIGUSR2');\n       });\n     } catch (err) {\n       logger.error('Error connecting to database:', err);\n       process.exit(1);\n     }\n   }\n\n   async function fetchAndSavePrices(collection, config) {\n     try {\n       const response = await fetch(config.apiURL);\n       if (!response.ok) {\n         throw new Error(`HTTP error! status: ${response.status}`);\n       }\n       const data = await response.json();\n       \n       const timestamp = new Date();\n       \n       for (const crypto of config.cryptoList) {\n         if (!data[crypto] || typeof data[crypto].usd !== 'number') {\n           logger.warn(`Invalid data for ${crypto}:`, data[crypto]);\n           continue;\n         }\n         const price = data[crypto].usd;\n         const document = {\n           crypto: crypto,\n           price: price,\n           timestamp: timestamp\n         };\n         \n         try {\n           await collection.insertOne(document);\n           logger.info(`Inserted ${crypto} price: ${price} at ${timestamp}`);\n         } catch (err) {\n           if (err.code === 11000) {\n             logger.info(`Duplicate entry for ${crypto} at ${timestamp}`);\n           } else {\n             logger.error(`Error inserting ${crypto} price:`, err);\n           }\n         }\n       }\n     } catch (err) {\n       logger.error('Error fetching or saving prices:', err);\n     }\n   }\n\n   main();\n   ```\n\n### Running the Script\n1. **Start the script:**\n   ```bash\n   node app.js\n   ```\n\n2. **For production, use PM2 to manage the process:**\n   - Install PM2 globally:\n     ```bash\n     npm install pm2 -g\n     ```\n   - Start the script with PM2:\n     ```bash\n     pm2 start app.js --name \"crypto-price-tracker\"\n     ```\n\nThis setup ensures that the script runs every 15 minutes, fetches the latest prices for Bitcoin, Ethereum, and Litecoin from the CoinGecko API, and saves them to a MongoDB database, handling duplicates and errors gracefully."
    }
]