[
    {
        "role": "user",
        "content": "Develop a JavaScript Node.js script that listens to incoming HTTP requests on port 8080 and serves static files from a specified directory. The script should support command line arguments for the listening IP address, port number, and the directory to serve files from. Additionally, implement an endpoint that accepts POST requests containing JSON data and saves them as individual files in a separate subdirectory, using the current timestamp as the filename.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Alright, I'm going to tackle this task of creating a Node.js script that serves static files and handles POST requests to save JSON data. Let's break it down step by step.\n\nFirst, I need to set up a basic HTTP server in Node.js that listens on a specified port and IP address. I should also make sure that it can serve static files from a given directory. For handling static files, I can use the built-in 'http' module along with 'fs' (file system) and 'path' modules to serve the files.\n\nNext, I need to accept command line arguments for the IP address, port number, and the directory to serve files from. In Node.js, I can access command line arguments using the 'process.argv' array.\n\nThen, I need to create a specific endpoint that accepts POST requests containing JSON data. When a POST request is received at this endpoint, I should extract the JSON data and save it as a separate file in a subdirectory, using the current timestamp as the filename.\n\nLet me think about the structure of the script:\n\n1. Parse command line arguments to get IP, port, and directory path.\n\n2. Set up an HTTP server that listens on the specified IP and port.\n\n3. Configure the server to serve static files from the specified directory.\n\n4. Create a specific endpoint (e.g., '/save') that handles POST requests.\n\n5. In the POST endpoint handler, read the JSON data from the request, generate a filename using the current timestamp, and save the JSON data to a file in a subdirectory.\n\nI should also make sure to handle any errors that might occur, such as invalid JSON data or issues with writing to the file system.\n\nLet me start by setting up the basic HTTP server and serving static files.\n\nFirst, I need to install any necessary packages. Since I'm using built-in modules, I don't need to install anything via npm.\n\nI'll start by writing code to parse the command line arguments. The process.argv array contains the command line arguments. The first element is 'node', the second is the script name, and the subsequent elements are the arguments passed.\n\nI need to expect three arguments: IP address, port number, and directory path.\n\nFor example:\n\nnode myscript.js 127.0.0.1 8080 /path/to/static/files\n\nSo, process.argv[2] will be IP, process.argv[3] will be port, and process.argv[4] will be the directory.\n\nI should add some validation to ensure that all three arguments are provided.\n\nNext, I'll set up the HTTP server using the http module. I'll create a server that listens on the specified IP and port.\n\nTo serve static files, I'll need to handle GET requests and serve files from the specified directory based on the requested path.\n\nI'll use the fs module to read the files and the path module to handle file paths.\n\nI need to make sure to handle different types of files appropriately, such as sending the correct Content-Type headers.\n\nFor the POST endpoint, I'll need to handle POST requests to a specific URL, say '/save'. In this endpoint, I'll read the JSON data from the request body, parse it, and save it to a file in a subdirectory, using the current timestamp as the filename.\n\nI need to make sure to handle the request body correctly, as HTTP requests in Node.js require reading the request stream.\n\nI should also ensure that the subdirectory exists before trying to write the file; if not, create it.\n\nLet me think about the code structure.\n\nI can have a main function that parses the arguments, sets up the server, and starts listening.\n\nI'll have a function to serve static files, which will handle GET requests.\n\nI'll have another function to handle the POST requests to the '/save' endpoint.\n\nI should also handle errors gracefully, such as file not found or permission issues.\n\nLet me start writing some pseudocode to outline the steps.\n\nPseudocode:\n\n- Parse command line arguments for IP, port, and directory.\n\n- If any argument is missing, display usage and exit.\n\n- Set up HTTP server to listen on specified IP and port.\n\n- For GET requests:\n\n- Determine the file path based on the requested URL.\n\n- Check if the file exists in the specified directory.\n\n- If it exists, read the file and send it as the response with the appropriate Content-Type.\n\n- If it doesn't exist, send a 404 response.\n\n- For POST requests to '/save':\n\n- Read the request body.\n\n- Parse the JSON data.\n\n- Generate a filename using the current timestamp.\n\n- Save the JSON data to a file in a subdirectory.\n\n- Send a success response.\n\n- Handle any errors that occur during these operations.\n\nNow, let's think about implementing this.\n\nFirst, parsing command line arguments.\n\nI can use process.argv to get the arguments.\n\nI need to check if exactly three arguments are provided beyond 'node' and the script name.\n\nIf not, print usage instructions and exit.\n\nThen, set up the HTTP server using http.createServer().\n\nIn the request event handler, check the method and URL.\n\nFor GET requests, handle serving static files.\n\nFor POST requests to '/save', handle saving the JSON data.\n\nLet's consider serving static files.\n\nI need to map the requested URL path to a file in the specified directory.\n\nI should avoid serving files outside the specified directory to prevent security issues.\n\nI can use path.join() to safely concatenate the directory path and the requested path.\n\nI should also set the appropriate Content-Type based on the file extension.\n\nFor that, I can use the 'mime' module, but since it's not built-in, I might need to install it, or implement a simple mapping myself.\n\nAlternatively, I can use the 'http-server' module for serving static files, but since the task is to implement it ourselves, I'll stick with built-in modules.\n\nNow, handling POST requests to '/save'.\n\nI need to read the request body, which is a stream.\n\nI can listen to 'data' events on the request object to collect the data chunks.\n\nThen, once the 'end' event is emitted, I can parse the collected data as JSON.\n\nThen, generate a filename using the current timestamp, maybe in the format yyyy-mm-dd hh-mm-ss.json.\n\nI need to make sure to handle any errors that occur during JSON parsing or file writing.\n\nAlso, I need to ensure that the subdirectory for saving files exists. If not, create it.\n\nI can use fs.existsSync() to check if the directory exists, and fs.mkdirSync() to create it if necessary.\n\nOnce the file is saved, send a success response back to the client.\n\nI should also consider handling errors properly, such as sending appropriate HTTP status codes and error messages.\n\nLet me think about error handling.\n\nFor file not found, send a 404 response.\n\nFor server errors, send a 500 response.\n\nFor invalid JSON in POST requests, send a 400 bad request response.\n\nI should also log errors for debugging purposes.\n\nNow, let's think about the code organization.\n\nI can have a main function that sets up the server and starts listening.\n\nI can have a serveStaticFile function that handles serving static files.\n\nI can have a saveJsonData function that handles saving JSON data from POST requests.\n\nI can have a utility function to get the MIME type based on file extension.\n\nLet me sketch a rough code structure.\n\nCode structure:\n\nconst http = require('http');\n\nconst fs = require('fs');\n\nconst path = require('path');\n\n// Function to serve static files\n\nfunction serveStaticFile(res, filePath, contentType) {\n\n fs.readFile(filePath, (err, data) => {\n\n if (err) {\n\n res.writeHead(404);\n\n res.end('File not found');\n\n } else {\n\n res.writeHead(200, { 'Content-Type': contentType });\n\n res.end(data);\n\n }\n\n });\n\n}\n\n// Function to handle POST requests to /save\n\nfunction saveJsonData(req, res) {\n\n let body = '';\n\n req.on('data', chunk => {\n\n body += chunk;\n\n });\n\n req.on('end', () => {\n\n try {\n\n const data = JSON.parse(body);\n\n const timestamp = new Date().toISOString().replace(/:/g, '-');\n\n const filename = `${timestamp}.json`;\n\n const subdir = path.join(process.argv[4], 'saved_data');\n\n if (!fs.existsSync(subdir)) {\n\n fs.mkdirSync(subdir);\n\n }\n\n const filePath = path.join(subdir, filename);\n\n fs.writeFile(filePath, JSON.stringify(data, null, 2), err => {\n\n if (err) {\n\n console.error(err);\n\n res.writeHead(500);\n\n res.end('Error saving file');\n\n } else {\n\n res.writeHead(200);\n\n res.end('File saved successfully');\n\n }\n\n });\n\n } catch (e) {\n\n res.writeHead(400);\n\n res.end('Invalid JSON data');\n\n }\n\n });\n\n}\n\n// Main function to set up the server\n\nfunction main() {\n\n if (process.argv.length < 6) {\n\n console.log('Usage: node script.js <ip> <port> <directory>');\n\n process.exit(1);\n\n }\n\n const ip = process.argv[2];\n\n const port = parseInt(process.argv[3], 10);\n\n const directory = process.argv[4];\n\n const server = http.createServer((req, res) => {\n\n if (req.method === 'GET') {\n\n // Handle static file serving\n\n const filePath = path.join(directory, req.url);\n\n const extname = path.extname(filePath);\n\n let contentType = 'text/html';\n\n if (extname === '.js') {\n\n contentType = 'text/javascript';\n\n } else if (extname === '.css') {\n\n contentType = 'text/css';\n\n }\n\n serveStaticFile(res, filePath, contentType);\n\n } else if (req.method === 'POST' && req.url === '/save') {\n\n // Handle saving JSON data\n\n saveJsonData(req, res);\n\n } else {\n\n res.writeHead(404);\n\n res.end('Not found');\n\n }\n\n });\n\n server.listen(port, ip, () => {\n\n console.log(`Server listening on http://${ip}:${port}`);\n\n });\n\n}\n\nmain();\n\nThis is a rough outline. I need to refine it and add more error handling and edge cases.\n\nFor example, I should handle cases where the directory does not exist.\n\nI should also ensure that the server can handle large files without running out of memory.\n\nAdditionally, I should consider using streams for serving files to be more efficient.\n\nAlso, for the POST endpoint, I should consider limiting the request body size to prevent abuse.\n\nMoreover, using the built-in 'http' module is fine, but for a more robust solution, I might consider using Express.js, which simplifies many of these tasks.\n\nHowever, since the task is to use plain Node.js, I'll stick with the 'http' module.\n\nLet me think about how to improve the code.\n\nFirst, for serving static files, using fs.createReadStream() would be better for performance, especially for large files.\n\nSo, instead of fs.readFile(), I can use fs.createReadStream() and pipe it to the response.\n\nThis way, the file is streamed directly to the client without loading the entire file into memory.\n\nSecond, for determining the Content-Type, I can create a more comprehensive mapping of file extensions to MIME types.\n\nThird, I should handle cases where the directory does not exist or is not accessible.\n\nI can check if the directory exists and is readable before starting the server.\n\nFourth, for the POST endpoint, I should ensure that only JSON data is accepted, and handle cases where the request content type is not application/json.\n\nFifth, I should consider adding a limit to the request body size to prevent denial of service attacks.\n\nSixth, I should log requests or errors for debugging purposes.\n\nSeventh, I should consider making the subdirectory name configurable or part of the command line arguments.\n\nBut for now, hardcoding it as 'saved_data' is fine.\n\nLet me think about implementing these improvements.\n\nFirst, using streams for serving static files.\n\nI can modify the serveStaticFile function to use fs.createReadStream() and pipe it to the response.\n\nThis will be more efficient for large files.\n\nSecond, enhancing the Content-Type mapping.\n\nI can create an object that maps file extensions to MIME types.\n\nI can include common types like html, css, js, jpg, png, etc.\n\nIf the extension is not recognized, I can default to 'application/octet-stream'.\n\nThird, checking if the directory exists and is accessible.\n\nI can use fs.existsSync() and fs.accessSync() to check if the directory exists and is readable.\n\nIf not, log an error and exit.\n\nFourth, for the POST endpoint, checking the Content-Type header.\n\nI can check if the 'Content-Type' header is 'application/json'. If not, respond with 400 bad request.\n\nFifth, limiting the request body size.\n\nI can set a maximum allowed size and accumulate the 'data' chunks, checking if the total size exceeds the limit.\n\nIf it does, respond with 413 Request Entity Too Large.\n\nSixth, logging requests or errors.\n\nI can add console.log statements to log incoming requests and any errors that occur.\n\nThis will help in debugging and monitoring the server's behavior.\n\nNow, let's think about implementing these improvements.\n\nFirst, modifying serveStaticFile to use streams.\n\nconst serveStaticFile = (res, filePath, contentType) => {\n\n const fileStream = fs.createReadStream(filePath);\n\n res.writeHead(200, { 'Content-Type': contentType });\n\n fileStream.pipe(res);\n\n};\n\nAnd handle the case where the file does not exist by catching errors from the stream.\n\nfileStream.on('error', () => {\n\n res.writeHead(404);\n\n res.end('File not found');\n\n});\n\nSecond, enhancing Content-Type mapping.\n\nconst mimeTypes = {\n\n '.html': 'text/html',\n\n '.js': 'text/javascript',\n\n '.css': 'text/css',\n\n '.json': 'application/json',\n\n '.jpg': 'image/jpeg',\n\n '.png': 'image/png',\n\n // Add more as needed\n\n};\n\nfunction getContentType(ext) {\n\n return mimeTypes[ext] || 'application/octet-stream';\n\n}\n\nThird, checking if the directory exists and is accessible.\n\ntry {\n\n fs.accessSync(directory, fs.constants.R_OK);\n\n} catch (e) {\n\n console.error(`Directory ${directory} does not exist or is not readable`);\n\n process.exit(1);\n\n}\n\nFourth, checking Content-Type for POST requests.\n\nif (req.method === 'POST' && req.url === '/save') {\n\n const contentType = req.headers['content-type'];\n\n if (contentType !== 'application/json') {\n\n res.writeHead(400);\n\n res.end('Invalid Content-Type. Expected application/json.');\n\n return;\n\n }\n\n // Proceed to saveJsonData\n\n}\n\nFifth, limiting request body size.\n\nI can set a maximum allowed size, say 1MB, and accumulate the data chunks, checking the total size.\n\nconst MAX_REQUEST_SIZE = 1e6; // 1MB\n\nlet body = '';\n\nreq.on('data', chunk => {\n\n if (req.headers['content-length'] > MAX_REQUEST_SIZE) {\n\n res.writeHead(413);\n\n res.end('Request Entity Too Large');\n\n } else {\n\n body += chunk;\n\n }\n\n});\n\nSixth, logging requests.\n\nI can add a console.log statement in the request handler to log the method and URL.\n\nconsole.log(`${req.method} ${req.url}`);\n\nSimilarly, log any errors that occur.\n\nNow, let's think about putting all these pieces together.\n\nI need to make sure that the serveStaticFile function uses streams and handles errors appropriately.\n\nI need to have a comprehensive list of MIME types.\n\nI need to check if the directory exists and is accessible before starting the server.\n\nI need to validate the Content-Type for POST requests and limit the request body size.\n\nI need to add logging for requests and errors.\n\nAlso, I should consider handling other HTTP methods besides GET and POST, perhaps by sending a 405 Method Not Allowed response.\n\nAdditionally, for better security, I should prevent directory traversal attacks by sanitizing the requested paths and ensuring that only files within the specified directory can be accessed.\n\nI can use path.normalize() and path.resolve() to canonicalize the paths and verify that they are within the serving directory.\n\nLet me think about implementing path validation to prevent directory traversal.\n\nI can get the canonical path of the requested file using path.resolve(directory, req.url).\n\nThen, I can check if the requested file path is within the serving directory by verifying that it starts with the serving directory path.\n\nIf not, it's a security breach attempt, and I should respond with 403 Forbidden.\n\nHere's how I can implement it:\n\nconst requestedPath = path.resolve(directory, req.url);\n\nif (!requestedPath.startsWith(path.resolve(directory))) {\n\n res.writeHead(403);\n\n res.end('Forbidden');\n\n return;\n\n}\n\nThis way, even if someone tries to access ../ etc., it will be blocked.\n\nGood, that adds an extra layer of security.\n\nNow, let's think about implementing all these improvements in code.\n\nI'll update the serveStaticFile function to use streams.\n\nI'll create a mimeTypes object for content type mapping.\n\nI'll add checks for directory existence and accessibility.\n\nI'll enhance the POST endpoint to check Content-Type and limit request size.\n\nI'll add logging for requests and errors.\n\nI'll also add path validation to prevent directory traversal.\n\nLet me write the updated code structure.\n\nUpdated code structure:\n\nconst http = require('http');\n\nconst fs = require('fs');\n\nconst path = require('path');\n\nconst mimeTypes = {\n\n '.html': 'text/html',\n\n '.js': 'text/javascript',\n\n '.css': 'text/css',\n\n '.json': 'application/json',\n\n '.jpg': 'image/jpeg',\n\n '.png': 'image/png',\n\n // Add more as needed\n\n};\n\nfunction serveStaticFile(res, filePath, contentType) {\n\n const fileStream = fs.createReadStream(filePath);\n\n res.writeHead(200, { 'Content-Type': contentType });\n\n fileStream.pipe(res);\n\n fileStream.on('error', () => {\n\n res.writeHead(404);\n\n res.end('File not found');\n\n });\n\n}\n\nfunction saveJsonData(req, res) {\n\n const contentType = req.headers['content-type'];\n\n if (contentType !== 'application/json') {\n\n res.writeHead(400);\n\n res.end('Invalid Content-Type. Expected application/json.');\n\n return;\n\n }\n\n const MAX_REQUEST_SIZE = 1e6; // 1MB\n\n let body = '';\n\n req.on('data', chunk => {\n\n if (req.headers['content-length'] > MAX_REQUEST_SIZE) {\n\n res.writeHead(413);\n\n res.end('Request Entity Too Large');\n\n } else {\n\n body += chunk;\n\n }\n\n });\n\n req.on('end', () => {\n\n try {\n\n const data = JSON.parse(body);\n\n const timestamp = new Date().toISOString().replace(/:/g, '-');\n\n const filename = `${timestamp}.json`;\n\n const subdir = path.join(process.argv[4], 'saved_data');\n\n if (!fs.existsSync(subdir)) {\n\n fs.mkdirSync(subdir);\n\n }\n\n const filePath = path.join(subdir, filename);\n\n fs.writeFile(filePath, JSON.stringify(data, null, 2), err => {\n\n if (err) {\n\n console.error(err);\n\n res.writeHead(500);\n\n res.end('Error saving file');\n\n } else {\n\n res.writeHead(200);\n\n res.end('File saved successfully');\n\n }\n\n });\n\n } catch (e) {\n\n res.writeHead(400);\n\n res.end('Invalid JSON data');\n\n }\n\n });\n\n}\n\nfunction main() {\n\n if (process.argv.length < 6) {\n\n console.log('Usage: node script.js <ip> <port> <directory>');\n\n process.exit(1);\n\n }\n\n const ip = process.argv[2];\n\n const port = parseInt(process.argv[3], 10);\n\n const directory = process.argv[4];\n\n try {\n\n fs.accessSync(directory, fs.constants.R_OK);\n\n } catch (e) {\n\n console.error(`Directory ${directory} does not exist or is not readable`);\n\n process.exit(1);\n\n }\n\n const server = http.createServer((req, res) => {\n\n console.log(`${req.method} ${req.url}`);\n\n if (req.method === 'GET') {\n\n const requestedPath = path.resolve(directory, req.url);\n\n if (!requestedPath.startsWith(path.resolve(directory))) {\n\n res.writeHead(403);\n\n res.end('Forbidden');\n\n return;\n\n }\n\n const extname = path.extname(requestedPath);\n\n const contentType = getContentType(extname);\n\n serveStaticFile(res, requestedPath, contentType);\n\n } else if (req.method === 'POST' && req.url === '/save') {\n\n saveJsonData(req, res);\n\n } else {\n\n res.writeHead(404);\n\n res.end('Not found');\n\n }\n\n });\n\n server.listen(port, ip, () => {\n\n console.log(`Server listening on http://${ip}:${port}`);\n\n });\n\n}\n\nfunction getContentType(ext) {\n\n return mimeTypes[ext] || 'application/octet-stream';\n\n}\n\nmain();\n\nThis looks better. I've incorporated most of the improvements I thought about.\n\nHowever, I should consider adding more error handling, such as handling errors when creating the subdirectory or writing the file.\n\nAlso, for the POST endpoint, I should consider handling cases where the JSON parsing fails due to invalid JSON.\n\nI should also think about adding a way to specify the subdirectory name via command line arguments, but for now, hardcoding it is acceptable.\n\nAdditionally, I should consider using a library like 'final-form' to handle form data, but since we're dealing with JSON, it's straightforward.\n\nI should also think about adding CORS headers if needed, but since the task doesn't specify, I'll omit them for now.\n\nMoreover, for production use, I should consider using a more robust server like Express.js, but again, the task is to use plain Node.js.\n\nI should also consider handling OPTIONS requests for CORS preflight, but since it's not required here, I'll skip it.\n\nNow, let's think about testing this script.\n\nI need to make sure that:\n\n1. The server starts successfully with the correct arguments.\n\n2. It serves static files correctly from the specified directory.\n\n3. It handles GET requests for existing files with the correct Content-Type.\n\n4. It returns 404 for non-existing files.\n\n5. It handles POST requests to '/save' correctly, saving the JSON data to a file with a timestamp filename in the subdirectory.\n\n6. It validates Content-Type for POST requests and returns 400 for invalid types.\n\n7. It limits the request body size and returns 413 for oversized requests.\n\n8. It prevents directory traversal attacks by not serving files outside the specified directory.\n\nI can write a series of test cases to verify each of these functionalities.\n\nFor example, I can use curl or Postman to send HTTP requests to the server and check the responses.\n\nI can also write automated tests using a testing framework like Mocha and Chai, but since this is a simple script, manual testing might suffice.\n\nLet me think about writing some example commands for testing.\n\nFirst, start the server:\n\nnode script.js 127.0.0.1 8080 /path/to/static/files\n\nThen, test serving a static file:\n\ncurl -i http://127.0.0.1:8080/index.html\n\nExpect to receive the content of index.html with Content-Type: text/html.\n\nTest a non-existing file:\n\ncurl -i http://127.0.0.1:8080/nonexistent.txt\n\nExpect a 404 response.\n\nTest the POST endpoint:\n\ncurl -i -X POST -H \"Content-Type: application/json\" -d '{\"key\":\"value\"}' http://127.0.0.1:8080/save\n\nExpect a 200 response with 'File saved successfully', and a new file in /path/to/static/files/saved_data with a timestamp filename containing the JSON data.\n\nTest with invalid JSON:\n\ncurl -i -X POST -H \"Content-Type: application/json\" -d '{invalid json}' http://127.0.0.1:8080/save\n\nExpect a 400 response with 'Invalid JSON data'.\n\nTest with incorrect Content-Type:\n\ncurl -i -X POST -H \"Content-Type: text/plain\" -d '{\"key\":\"value\"}' http://127.0.0.1:8080/save\n\nExpect a 400 response with 'Invalid Content-Type. Expected application/json.'\n\nTest directory traversal:\n\ncurl -i http://127.0.0.1:8080/../index.html\n\nExpect a 403 Forbidden response.\n\nI should also test with large POST requests to ensure that the size limit is enforced.\n\nOverall, this seems comprehensive.\n\nI should also consider edge cases, such as:\n\n- Serving files with query parameters in the URL.\n\n- Handling requests with unusual paths, like multiple slashes.\n\n- Ensuring that the timestamp filename is unique and doesn't cause overwrites.\n\n- Handling concurrent POST requests and ensuring that file writes don't interfere with each other.\n\nFor the timestamp filename, using ISOString with milliseconds should make it unique enough for most use cases.\n\nRegarding concurrent POST requests, fs.writeFile is asynchronous and should handle concurrent writes without issues, as Node.js handles file system operations in a non-blocking manner.\n\nHowever, to be extra cautious, I could use a library like 'async-file' to handle file writes with locks, but that might be overkill for this scenario.\n\nI should also consider adding date and time formatting to the timestamp to make it more readable, but ISOString is fine for now.\n\nAdditionally, I should think about the file system permissions for writing the saved files.\n\nEnsure that the user running the Node.js process has write permissions to the specified directory and the subdirectory.\n\nI should also consider adding error logging to a file instead of just console.log, but for simplicity, console.log will suffice.\n\nNow, let's think about refactoring the code for better readability and maintainability.\n\nI can extract functions for specific tasks, such as handling GET requests and handling POST requests.\n\nI can also add comments to explain what each part of the code does.\n\nI should also consider using Early Returns to flatten the code and make it easier to follow.\n\nLet me think about restructuring the main request handler.\n\nInstead of having a large if-else block, I can have separate functions for handling different HTTP methods and URLs.\n\nFor example:\n\nfunction handleRequest(req, res) {\n\n if (req.method === 'GET') {\n\n handleGetRequest(req, res);\n\n } else if (req.method === 'POST' && req.url === '/save') {\n\n handlePostSave(req, res);\n\n } else {\n\n res.writeHead(404);\n\n res.end('Not found');\n\n }\n\n}\n\nThen, define handleGetRequest and handlePostSave functions.\n\nThis will make the code cleaner and more modular.\n\nI can also create a function to get the MIME type based on the file extension, which I've already done as getContentType.\n\nAdditionally, I can create a function to validate the requested path to prevent directory traversal.\n\nfunction isPathSafe(baseDir, requestedPath) {\n\n const resolvedPath = path.resolve(baseDir, requestedPath);\n\n return resolvedPath.startsWith(path.resolve(baseDir));\n\n}\n\nThen, use it in the GET request handler.\n\nif (!isPathSafe(directory, req.url)) {\n\n res.writeHead(403);\n\n res.end('Forbidden');\n\n return;\n\n}\n\nThis makes the code more readable and separates concerns.\n\nI should also consider handling HEAD requests similarly to GET requests, but without sending the file content.\n\nHowever, for simplicity, I'll stick with GET and POST for now.\n\nAnother consideration is handling dotfiles (files starting with a dot). I might want to prevent serving them directly.\n\nI can add a check to see if the requested file is a dotfile and deny access if it is.\n\nfunction isDotfile(filePath) {\n\n return path.basename(filePath).startsWith('.');\n\n}\n\nThen, in the GET request handler:\n\nconst requestedPath = path.resolve(directory, req.url);\n\nif (!isPathSafe(directory, req.url) || isDotfile(requestedPath)) {\n\n res.writeHead(403);\n\n res.end('Forbidden');\n\n return;\n\n}\n\nThis adds an extra layer of security.\n\nNow, let's think about implementing range requests for files, which would allow resuming downloads or seeking in media files.\n\nThis would involve checking for the 'Range' header in the request and sending partial content with the appropriate status code and Content-Range header.\n\nHowever, implementing range requests is somewhat involved and might be beyond the scope of this task.\n\nFor now, I'll omit it, but it's good to know for future enhancements.\n\nI should also consider handling etags for caching purposes, but again, that's a more advanced feature.\n\nFor this basic implementation, serving the entire file on each request is sufficient.\n\nAnother aspect is handling different HTTP versions. The built-in 'http' module in Node.js handles HTTP/1.1 by default.\n\nIf I need to support HTTP/2, I would need to use the 'http2' module, but that's beyond the current requirements.\n\nNow, let's think about writing the final code with all these improvements and considerations.\n\nI'll organize the code into functions and add comments for clarity.\n\nI'll also make sure to handle errors appropriately and log them.\n\nFinally, I'll test the script thoroughly to ensure that it works as expected.\n\nOnce I'm confident about its functionality, I'll consider it complete.\n\n## Final Solution\nTo accomplish the task of creating a Node.js script that serves static files and handles POST requests to save JSON data, follow the steps below. This solution involves setting up a basic HTTP server that listens on a specified IP address and port, serves static files from a given directory, and saves incoming JSON data from POST requests to a subdirectory using timestamps as filenames.\n\n### Solution Code\n\n```javascript\nconst http = require('http');\nconst fs = require('fs');\nconst path = require('path');\n\n// MIME types for different file extensions\nconst mimeTypes = {\n    '.html': 'text/html',\n    '.js': 'text/javascript',\n    '.css': 'text/css',\n    '.json': 'application/json',\n    '.jpg': 'image/jpeg',\n    '.png': 'image/png',\n    // Add more as needed\n};\n\n// Function to serve static files using streams\nfunction serveStaticFile(res, filePath, contentType) {\n    const fileStream = fs.createReadStream(filePath);\n    res.writeHead(200, { 'Content-Type': contentType });\n    fileStream.pipe(res);\n    fileStream.on('error', () => {\n        res.writeHead(404);\n        res.end('File not found');\n    });\n}\n\n// Function to handle POST requests to '/save'\nfunction saveJsonData(req, res) {\n    const contentType = req.headers['content-type'];\n    if (contentType !== 'application/json') {\n        res.writeHead(400);\n        res.end('Invalid Content-Type. Expected application/json.');\n        return;\n    }\n    const MAX_REQUEST_SIZE = 1e6; // 1MB\n    let body = '';\n    req.on('data', chunk => {\n        if (req.headers['content-length'] > MAX_REQUEST_SIZE) {\n            res.writeHead(413);\n            res.end('Request Entity Too Large');\n        } else {\n            body += chunk;\n        }\n    });\n    req.on('end', () => {\n        try {\n            const data = JSON.parse(body);\n            const timestamp = new Date().toISOString().replace(/:/g, '-');\n            const filename = `${timestamp}.json`;\n            const subdir = path.join(process.argv[4], 'saved_data');\n            if (!fs.existsSync(subdir)) {\n                fs.mkdirSync(subdir);\n            }\n            const filePath = path.join(subdir, filename);\n            fs.writeFile(filePath, JSON.stringify(data, null, 2), err => {\n                if (err) {\n                    console.error(err);\n                    res.writeHead(500);\n                    res.end('Error saving file');\n                } else {\n                    res.writeHead(200);\n                    res.end('File saved successfully');\n                }\n            });\n        } catch (e) {\n            res.writeHead(400);\n            res.end('Invalid JSON data');\n        }\n    });\n}\n\n// Function to get content type based on file extension\nfunction getContentType(ext) {\n    return mimeTypes[ext] || 'application/octet-stream';\n}\n\n// Function to check if the requested path is safe\nfunction isPathSafe(baseDir, requestedPath) {\n    const resolvedPath = path.resolve(baseDir, requestedPath);\n    return resolvedPath.startsWith(path.resolve(baseDir));\n}\n\n// Function to check if the file is a dotfile\nfunction isDotfile(filePath) {\n    return path.basename(filePath).startsWith('.');\n}\n\n// Main function to set up the server\nfunction main() {\n    if (process.argv.length < 6) {\n        console.log('Usage: node script.js <ip> <port> <directory>');\n        process.exit(1);\n    }\n    const ip = process.argv[2];\n    const port = parseInt(process.argv[3], 10);\n    const directory = process.argv[4];\n\n    try {\n        fs.accessSync(directory, fs.constants.R_OK);\n    } catch (e) {\n        console.error(`Directory ${directory} does not exist or is not readable`);\n        process.exit(1);\n    }\n\n    const server = http.createServer((req, res) => {\n        console.log(`${req.method} ${req.url}`);\n        if (req.method === 'GET') {\n            const requestedPath = path.resolve(directory, req.url);\n            if (!isPathSafe(directory, req.url) || isDotfile(requestedPath)) {\n                res.writeHead(403);\n                res.end('Forbidden');\n                return;\n            }\n            const extname = path.extname(requestedPath);\n            const contentType = getContentType(extname);\n            serveStaticFile(res, requestedPath, contentType);\n        } else if (req.method === 'POST' && req.url === '/save') {\n            saveJsonData(req, res);\n        } else {\n            res.writeHead(404);\n            res.end('Not found');\n        }\n    });\n\n    server.listen(port, ip, () => {\n        console.log(`Server listening on http://${ip}:${port}`);\n    });\n}\n\nmain();\n```\n\n### Explanation\n\n1. **Command Line Arguments Parsing:**\n   - The script expects three arguments: IP address, port number, and the directory to serve files from.\n   - Example usage: `node script.js 127.0.0.1 8080 /path/to/static/files`\n\n2. **HTTP Server Setup:**\n   - Uses the built-in `http` module to create an HTTP server.\n   - Listens on the specified IP and port.\n\n3. **Serving Static Files:**\n   - Handles GET requests by serving files from the specified directory.\n   - Uses streams to efficiently serve files without loading entire files into memory.\n   - Determines and sets the appropriate Content-Type based on file extensions.\n\n4. **Saving JSON Data from POST Requests:**\n   - Accepts POST requests at the '/save' endpoint.\n   - Expects JSON data in the request body and saves it to a subdirectory named 'saved_data' within the static files directory.\n   - Uses timestamps to name the saved files, ensuring uniqueness.\n   - Validates Content-Type and limits request size to prevent abuse.\n\n5. **Security Measures:**\n   - Prevents directory traversal attacks by validating requested file paths.\n   - Denies access to dotfiles to enhance security.\n\nThis script provides a robust foundation for serving static files and handling specific POST requests in a Node.js environment."
    }
]