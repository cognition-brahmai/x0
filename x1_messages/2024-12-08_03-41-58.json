[
    {
        "role": "user",
        "content": "Develop a Python function that determines whether a given year is a leap year or not."
    },
    {
        "role": "assistant",
        "content": "Certainly! I'd be happy to help you with that. So, first things first, what exactly is a leap year? I know it has something to do with February having 29 days instead of the usual 28, but there must be more to it. Maybe I should look up the rules for determining leap years.\n\nOkay, from what I recall, a leap year is divisible by 4, but there are exceptions. For example, years divisible by 100 are not leap years unless they're also divisible by 400. So, like, 2000 was a leap year because it's divisible by 400, but 1900 wasn't, even though it's divisible by 4, because it's also divisible by 100 and not by 400. Does that sound right?\n\nLet me confirm that. According to various sources, a year is a leap year if:\n\n1. It is evenly divisible by 4;\n\n2. If it is divisible by 100, it must also be divisible by 400.\n\nSo, in other words, if a year is divisible by 4, it might be a leap year, but if it's also divisible by 100, it's not a leap year unless it's also divisible by 400.\n\nAlright, with that in mind, how do I translate this into Python code? I need to write a function that takes a year as input and returns True if it's a leap year, and False otherwise.\n\nLet me think about the logic step by step.\n\nFirst, check if the year is divisible by 4. If it's not, then it's not a leap year.\n\nIf it is divisible by 4, then check if it's divisible by 100. If it's not, then it is a leap year.\n\nIf it is divisible by 100, then check if it's divisible by 400. If it is, then it's a leap year; if not, it's not a leap year.\n\nSo, in code, that would look something like:\n\nif year % 4 != 0:\n\nreturn False\n\nelif year % 100 != 0:\n\nreturn True\n\nelif year % 400 != 0:\n\nreturn False\n\nelse:\n\nreturn True\n\nDoes that make sense? Let me test this logic with some examples.\n\nTake 2000:\n\n2000 % 4 = 0\n\nSo, it's divisible by 4.\n\n2000 % 100 = 0\n\nSo, it's divisible by 100.\n\n2000 % 400 = 0\n\nSo, it's divisible by 400.\n\nTherefore, it's a leap year. Correct.\n\nTake 1900:\n\n1900 % 4 = 0\n\nDivisible by 4.\n\n1900 % 100 = 0\n\nDivisible by 100.\n\n1900 % 400 = 300\n\nNot divisible by 400.\n\nTherefore, not a leap year. Correct.\n\nTake 2004:\n\n2004 % 4 = 0\n\nDivisible by 4.\n\n2004 % 100 = 4\n\nNot divisible by 100.\n\nTherefore, it's a leap year. Correct.\n\nTake 2001:\n\n2001 % 4 = 1\n\nNot divisible by 4.\n\nTherefore, not a leap year. Correct.\n\nSeems like the logic holds up with these test cases.\n\nNow, I need to write this as a Python function. Should I include any input validation? For example, ensuring that the year is a positive integer and makes sense in the context of the Gregorian calendar.\n\nWell, for simplicity, I'll assume that the input is a valid year in the Gregorian calendar, which starts from the year 1582 when the Gregorian calendar was first introduced. But to make the function more robust, maybe I should check if the year is an integer and greater than or equal to 1582.\n\nBut perhaps that's overkill for this scenario. If the user provides a year before 1582, the function might not be accurate because the Gregorian calendar wasn't in use then, but for now, I'll keep it simple and assume the year is valid.\n\nSo, here's a basic implementation of the function:\n\ndef is_leap_year(year):\n\nif year % 4 != 0:\n\nreturn False\n\nelif year % 100 != 0:\n\nreturn True\n\nelif year % 400 != 0:\n\nreturn False\n\nelse:\n\nreturn True\n\nThat seems straightforward. But I've heard that using multiple return statements can make the code harder to follow. Maybe there's a way to simplify this.\n\nLet me think differently. I can combine these conditions into a single return statement.\n\nSomething like:\n\ndef is_leap_year(year):\n\nreturn year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)\n\nThis should do the same thing. Let's test it with the previous examples.\n\nFor 2000:\n\n2000 % 4 == 0 -> True\n\n2000 % 100 != 0 -> False\n\n2000 % 400 == 0 -> True\n\nSo, False or True -> True\n\nTrue and True -> True. Correct.\n\nFor 1900:\n\n1900 % 4 == 0 -> True\n\n1900 % 100 != 0 -> False\n\n1900 % 400 == 0 -> False\n\nFalse or False -> False\n\nTrue and False -> False. Correct.\n\nFor 2004:\n\n2004 % 4 == 0 -> True\n\n2004 % 100 != 0 -> True\n\n2004 % 400 == 0 -> False\n\nTrue or False -> True\n\nTrue and True -> True. Correct.\n\nFor 2001:\n\n2001 % 4 == 0 -> False\n\nRest doesn't matter, since it's already False.\n\nFalse and (anything) -> False. Correct.\n\nThis seems to work just as well and is more concise. Perhaps this is a better way to write the function.\n\nNow, I should think about edge cases. What about the year 0? Is year 0 a leap year? Historically, year 0 doesn't exist, but in programming, we might need to handle it. For the sake of simplicity, I'll assume year 0 doesn't exist or handle positive integers only.\n\nWhat about negative years? Again, in the Gregorian calendar, years before 1582 are not covered, and negative years are not standard. But if we consider them, the leap year rules should still apply in theory.\n\nHowever, to keep things simple, I'll assume that the year is a positive integer greater than or equal to 1.\n\nLet me write a docstring for the function to explain what it does.\n\ndef is_leap_year(year):\n\n\"\"\"\n\nDetermine whether a given year is a leap year.\n\nA leap year is divisible by 4, but years divisible by 100 are not leap years\n\nunless they are also divisible by 400.\n\nParameters:\n\nyear (int): The year to check.\n\nReturns:\n\nbool: True if the year is a leap year, False otherwise.\n\n\"\"\"\n\nreturn year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)\n\nThat should suffice.\n\nTo make sure, I'll test it with a few more years.\n\nLet's try 2400:\n\n2400 % 4 == 0 -> True\n\n2400 % 100 != 0 -> False\n\n2400 % 400 == 0 -> True\n\nFalse or True -> True\n\nTrue and True -> True. So, 2400 is a leap year. Correct.\n\n2100:\n\n2100 % 4 == 0 -> True\n\n2100 % 100 != 0 -> False\n\n2100 % 400 == 0 -> False\n\nFalse or False -> False\n\nTrue and False -> False. Not a leap year. Correct.\n\n1600:\n\n1600 % 4 == 0 -> True\n\n1600 % 100 != 0 -> False\n\n1600 % 400 == 0 -> True\n\nFalse or True -> True\n\nTrue and True -> True. Leap year. Correct.\n\n1700:\n\n1700 % 4 == 0 -> True\n\n1700 % 100 != 0 -> False\n\n1700 % 400 == 0 -> False\n\nFalse or False -> False\n\nTrue and False -> False. Not a leap year. Correct.\n\nSeems solid.\n\nMaybe I should consider non-integer inputs. What if someone passes a float?\n\nFor example, 2000.0:\n\n2000.0 % 4 == 0 -> True\n\n2000.0 % 100 != 0 -> False\n\n2000.0 % 400 == 0 -> True\n\nFalse or True -> True\n\nTrue and True -> True. So, it works, but technically, years should be integers.\n\nTo handle floats, I could convert the input to an integer, assuming that decimal parts are not significant.\n\nAlternatively, I could raise an error if the input is not an integer to prevent any confusion.\n\nLet me add a check for that.\n\ndef is_leap_year(year):\n\nif not isinstance(year, int):\n\nraise ValueError(\"Year must be an integer.\")\n\nreturn year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)\n\nNow, if someone passes a float, it will raise an error.\n\nIs there any other edge case I should consider? How about the current year or a future year?\n\nLet's check 2024:\n\n2024 % 4 == 0 -> True\n\n2024 % 100 != 0 -> True\n\n2024 % 400 == 0 -> False\n\nTrue or False -> True\n\nTrue and True -> True. Leap year. Correct, because I know 2024 is a leap year.\n\nAnd 2023:\n\n2023 % 4 == 3 -> False\n\nNot a leap year. Correct.\n\nI think this function is reliable for determining leap years.\n\n## Final Solution\nTo determine whether a given year is a leap year, we can follow the rules defined by the Gregorian calendar. A year is a leap year if it is divisible by 4, except for years that are divisible by 100 unless they are also divisible by 400. This logic can be implemented efficiently in Python.\n\n### Approach\n1. **Check Divisibility**:\n   - If the year is not divisible by 4, it is not a leap year.\n   - If the year is divisible by 4 but not by 100, it is a leap year.\n   - If the year is divisible by both 4 and 100, it is a leap year only if it is also divisible by 400.\n\n2. **Input Validation**:\n   - Ensure the input is an integer representing the year.\n\n3. **Efficient Calculation**:\n   - Use a single return statement with logical operators to determine if the year is a leap year.\n\n### Solution Code\n\n```python\ndef is_leap_year(year):\n    \"\"\"\n    Determine whether a given year is a leap year.\n    \n    A leap year is divisible by 4, but years divisible by 100 are not leap years\n    unless they are also divisible by 400.\n    \n    Parameters:\n    year (int): The year to check.\n    \n    Returns:\n    bool: True if the year is a leap year, False otherwise.\n    \n    Raises:\n    ValueError: If the year is not an integer.\n    \"\"\"\n    if not isinstance(year, int):\n        raise ValueError(\"Year must be an integer.\")\n    return year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)\n```\n\n### Explanation\n- **Divisibility Rules**:\n  - The expression `year % 4 == 0` checks if the year is divisible by 4.\n  - The expression `year % 100 != 0` checks if the year is not divisible by 100.\n  - The expression `year % 400 == 0` checks if the year is divisible by 400.\n  - Combining these with logical operators ensures the correct determination of leap years.\n\n- **Input Validation**:\n  - The function checks if the input is an integer and raises a `ValueError` if it is not, ensuring that the function behaves correctly with valid inputs.\n\nThis approach provides a straightforward and efficient way to determine if a given year is a leap year, adhering to the rules of the Gregorian calendar."
    }
]