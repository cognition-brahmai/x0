[
    {
        "role": "user",
        "content": "Create a C++ program that connects to a Cassandra database and performs basic CRUD operations (Create, Read, Update, Delete) on a table containing employee information (ID, name, department, salary). Use prepared statements for queries and ensure proper error handling.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Alright, I'm going to help you create a C++ program that connects to a Cassandra database and performs basic CRUD operations on a table containing employee information. We'll use prepared statements for queries and make sure to handle errors properly.\n\nFirst, you'll need to have the DataStax C++ Driver for Apache Cassandra installed on your system. If you haven't installed it yet, you can follow the instructions on their GitHub page: [DataStax C++ Driver](https://github.com/datastax/cpp-driver)\n\nAssuming you have the driver installed, let's proceed step by step.\n\n### Step 1: Set Up Your Environment\n\nMake sure you have the necessary includes and link against the DataStax C++ Driver libraries.\n\n```cpp\n#include <stdio.h>\n#include <stdlib.h>\n#include <string>\n#include <vector>\n#include <iostream>\n#include <cassandra.h>\n```\n\n### Step 2: Connect to the Cassandra Cluster\n\nYou need to create a cluster object, set the contact points, and then connect to the cluster.\n\n```cpp\nCassCluster* cluster = cass_cluster_new();\nCassSession* session = cass_session_new();\n\n// Set contact points\ncass_cluster_set_contact_points(cluster, \"127.0.0.1\");\n\n// Optional: Set other cluster configurations\n// cass_cluster_set_port(cluster, 9042);\n\n// Connect to the cluster\nCassFuture* connect_future = cass_session_connect(session, cluster);\nif (cass_future_error_code(connect_future) == CASS_OK) {\n    printf(\"Connected to the cluster.\\n\");\n} else {\n    const char* message;\n    size_t message_length;\n    cass_future_error_message(connect_future, &message, &message_length);\n    fprintf(stderr, \"Error connecting to the cluster: %.*s\\n\", (int)message_length, message);\n    cass_future_free(connect_future);\n    cass_cluster_free(cluster);\n    cass_session_free(session);\n    return -1;\n}\ncass_future_free(connect_future);\n```\n\n### Step 3: Create a Keyspace and Table\n\nFor this example, let's assume you have a keyspace named `employee_db` and a table named `employees` with columns `id`, `name`, `department`, and `salary`.\n\nIf you need to create them, you can execute the following CQL statements:\n\n```cpp\nconst char* create_keyspace = \"CREATE KEYSPACE IF NOT EXISTS employee_db WITH replication = {'class':'SimpleStrategy', 'replication_factor':1};\";\nconst char* create_table = \"CREATE TABLE IF NOT EXISTS employee_db.employees (id UUID PRIMARY KEY, name text, department text, salary double);\";\n\nCassFuture* future = cass_session_execute(session, cass_statement_new(create_keyspace, 0));\nif (cass_future_error_code(future) != CASS_OK) {\n    const char* message;\n    size_t message_length;\n    cass_future_error_message(future, &message, &message_length);\n    fprintf(stderr, \"Error creating keyspace: %.*s\\n\", (int)message_length, message);\n}\ncass_future_free(future);\n\nfuture = cass_session_execute(session, cass_statement_new(create_table, 0));\nif (cass_future_error_code(future) != CASS_OK) {\n    const char* message;\n    size_t message_length;\n    cass_future_error_message(future, &message, &message_length);\n    fprintf(stderr, \"Error creating table: %.*s\\n\", (int)message_length, message);\n}\ncass_future_free(future);\n```\n\n### Step 4: Prepare Statements for CRUD Operations\n\nPrepare statements for inserting, selecting, updating, and deleting records.\n\n```cpp\nCassFuture* prepare_future = NULL;\nCassStatement* statement = NULL;\n\n// Prepare INSERT statement\nconst char* insert_query = \"INSERT INTO employee_db.employees (id, name, department, salary) VALUES (uuid(), ?, ?, ?);\";\nprepare_future = cass_session_prepare(session, insert_query);\nif (cass_future_error_code(prepare_future) != CASS_OK) {\n    const char* message;\n    size_t message_length;\n    cass_future_error_message(prepare_future, &message, &message_length);\n    fprintf(stderr, \"Error preparing insert statement: %.*s\\n\", (int)message_length, message);\n} else {\n    CassPrepared* prepared = cass_future_get_prepared(prepare_future);\n    statement = cass_statement_new_prepared(prepared);\n    cass_prepared_free(prepared);\n}\ncass_future_free(prepare_future);\n\n// Prepare SELECT statement\nconst char* select_query = \"SELECT id, name, department, salary FROM employee_db.employees WHERE id = ?;\";\nprepare_future = cass_session_prepare(session, select_query);\nif (cass_future_error_code(prepare_future) != CASS_OK) {\n    const char* message;\n    size_t message_length;\n    cass_future_error_message(prepare_future, &message, &message_length);\n    fprintf(stderr, \"Error preparing select statement: %.*s\\n\", (int)message_length, message);\n} else {\n    CassPrepared* prepared = cass_future_get_prepared(prepare_future);\n    statement = cass_statement_new_prepared(prepared);\n    cass_prepared_free(prepared);\n}\ncass_future_free(prepare_future);\n\n// Prepare UPDATE statement\nconst char* update_query = \"UPDATE employee_db.employees SET name = ?, department = ?, salary = ? WHERE id = ?;\";\nprepare_future = cass_session_prepare(session, update_query);\nif (cass_future_error_code(prepare_future) != CASS_OK) {\n    const char* message;\n    size_t message_length;\n    cass_future_error_message(prepare_future, &message, &message_length);\n    fprintf(stderr, \"Error preparing update statement: %.*s\\n\", (int)message_length, message);\n} else {\n    CassPrepared* prepared = cass_future_get_prepared(prepare_future);\n    statement = cass_statement_new_prepared(prepared);\n    cass_prepared_free(prepared);\n}\ncass_future_free(prepare_future);\n\n// Prepare DELETE statement\nconst char* delete_query = \"DELETE FROM employee_db.employees WHERE id = ?;\";\nprepare_future = cass_session_prepare(session, delete_query);\nif (cass_future_error_code(prepare_future) != CASS_OK) {\n    const char* message;\n    size_t message_length;\n    cass_future_error_message(prepare_future, &message, &message_length);\n    fprintf(stderr, \"Error preparing delete statement: %.*s\\n\", (int)message_length, message);\n} else {\n    CassPrepared* prepared = cass_future_get_prepared(prepare_future);\n    statement = cass_statement_new_prepared(prepared);\n    cass_prepared_free(prepared);\n}\ncass_future_free(prepare_future);\n```\n\n### Step 5: Perform CRUD Operations\n\nNow, let's define functions for each CRUD operation.\n\n#### Insert (Create)\n\n```cpp\nvoid insertEmployee(CassSession* session, const std::string& name, const std::string& department, double salary) {\n    CassStatement* statement = cass_statement_new(\"INSERT INTO employee_db.employees (id, name, department, salary) VALUES (uuid(), ?, ?, ?);\", 3);\n    cass_statement_bind_string(statement, 0, name.c_str());\n    cass_statement_bind_string(statement, 1, department.c_str());\n    cass_statement_bind_double(statement, 2, salary);\n\n    CassFuture* future = cass_session_execute(session, statement);\n    if (cass_future_error_code(future) != CASS_OK) {\n        const char* message;\n        size_t message_length;\n        cass_future_error_message(future, &message, &message_length);\n        fprintf(stderr, \"Error inserting employee: %.*s\\n\", (int)message_length, message);\n    } else {\n        printf(\"Employee inserted successfully.\\n\");\n    }\n    cass_future_free(future);\n    cass_statement_free(statement);\n}\n```\n\n#### Read\n\n```cpp\nvoid selectEmployee(CassSession* session, const std::string& id) {\n    CassStatement* statement = cass_statement_new(\"SELECT id, name, department, salary FROM employee_db.employees WHERE id = ?;\", 1);\n    cass_statement_bind_uuid_string(statement, 0, id.c_str());\n\n    CassFuture* future = cass_session_execute(session, statement);\n    if (cass_future_error_code(future) != CASS_OK) {\n        const char* message;\n        size_t message_length;\n        cass_future_error_message(future, &message, &message_length);\n        fprintf(stderr, \"Error selecting employee: %.*s\\n\", (int)message_length, message);\n    } else {\n        CassResult* result = cass_future_get_result(future);\n        CassIterator* iterator = cass_iterator_from_result(result);\n        while (cass_iterator_next(iterator)) {\n            CassRow* row = cass_iterator_get_row(iterator);\n            const CassValue* id_value = cass_row_get_column_by_name(row, \"id\");\n            const CassValue* name_value = cass_row_get_column_by_name(row, \"name\");\n            const CassValue* department_value = cass_row_get_column_by_name(row, \"department\");\n            const CassValue* salary_value = cass_row_get_column_by_name(row, \"salary\");\n\n            uuid_string id_str;\n            cass_value_get_uuid_string(id_value, &id_str.data, id_str.size);\n            const char* name = cass_value_get_string(name_value);\n            const char* department = cass_value_get_string(department_value);\n            double salary = cass_value_get_double(salary_value);\n\n            printf(\"ID: %s, Name: %s, Department: %s, Salary: %.2f\\n\", id_str.data, name, department, salary);\n        }\n        cass_result_free(result);\n        cass_iterator_free(iterator);\n    }\n    cass_future_free(future);\n    cass_statement_free(statement);\n}\n```\n\n#### Update\n\n```cpp\nvoid updateEmployee(CassSession* session, const std::string& id, const std::string& name, const std::string& department, double salary) {\n    CassStatement* statement = cass_statement_new(\"UPDATE employee_db.employees SET name = ?, department = ?, salary = ? WHERE id = ?;\", 4);\n    cass_statement_bind_string(statement, 0, name.c_str());\n    cass_statement_bind_string(statement, 1, department.c_str());\n    cass_statement_bind_double(statement, 2, salary);\n    cass_statement_bind_uuid_string(statement, 3, id.c_str());\n\n    CassFuture* future = cass_session_execute(session, statement);\n    if (cass_future_error_code(future) != CASS_OK) {\n        const char* message;\n        size_t message_length;\n        cass_future_error_message(future, &message, &message_length);\n        fprintf(stderr, \"Error updating employee: %.*s\\n\", (int)message_length, message);\n    } else {\n        printf(\"Employee updated successfully.\\n\");\n    }\n    cass_future_free(future);\n    cass_statement_free(statement);\n}\n```\n\n#### Delete\n\n```cpp\nvoid deleteEmployee(CassSession* session, const std::string& id) {\n    CassStatement* statement = cass_statement_new(\"DELETE FROM employee_db.employees WHERE id = ?;\", 1);\n    cass_statement_bind_uuid_string(statement, 0, id.c_str());\n\n    CassFuture* future = cass_session_execute(session, statement);\n    if (cass_future_error_code(future) != CASS_OK) {\n        const char* message;\n        size_t message_length;\n        cass_future_error_message(future, &message, &message_length);\n        fprintf(stderr, \"Error deleting employee: %.*s\\n\", (int)message_length, message);\n    } else {\n        printf(\"Employee deleted successfully.\\n\");\n    }\n    cass_future_free(future);\n    cass_statement_free(statement);\n}\n```\n\n### Step 6: Main Function\n\nNow, let's put it all together in the `main` function.\n\n```cpp\nint main() {\n    CassCluster* cluster = cass_cluster_new();\n    CassSession* session = cass_session_new();\n\n    // Set contact points\n    cass_cluster_set_contact_points(cluster, \"127.0.0.1\");\n\n    // Connect to the cluster\n    CassFuture* connect_future = cass_session_connect(session, cluster);\n    if (cass_future_error_code(connect_future) != CASS_OK) {\n        const char* message;\n        size_t message_length;\n        cass_future_error_message(connect_future, &message, &message_length);\n        fprintf(stderr, \"Error connecting to the cluster: %.*s\\n\", (int)message_length, message);\n        cass_future_free(connect_future);\n        cass_cluster_free(cluster);\n        cass_session_free(session);\n        return -1;\n    }\n    cass_future_free(connect_future);\n\n    // Create keyspace and table if not exists\n    const char* create_keyspace = \"CREATE KEYSPACE IF NOT EXISTS employee_db WITH replication = {'class':'SimpleStrategy', 'replication_factor':1};\";\n    const char* create_table = \"CREATE TABLE IF NOT EXISTS employee_db.employees (id UUID PRIMARY KEY, name text, department text, salary double);\";\n\n    CassFuture* future = cass_session_execute(session, cass_statement_new(create_keyspace, 0));\n    if (cass_future_error_code(future) != CASS_OK) {\n        const char* message;\n        size_t message_length;\n        cass_future_error_message(future, &message, &message_length);\n        fprintf(stderr, \"Error creating keyspace: %.*s\\n\", (int)message_length, message);\n    }\n    cass_future_free(future);\n\n    future = cass_session_execute(session, cass_statement_new(create_table, 0));\n    if (cass_future_error_code(future) != CASS_OK) {\n        const char* message;\n        size_t message_length;\n        cass_future_error_message(future, &message, &message_length);\n        fprintf(stderr, \"Error creating table: %.*s\\n\", (int)message_length, message);\n    }\n    cass_future_free(future);\n\n    // Insert an employee\n    insertEmployee(session, \"John Doe\", \"HR\", 50000.0);\n\n    // Select an employee\n    selectEmployee(session, \"some-uuid-string\");\n\n    // Update an employee\n    updateEmployee(session, \"some-uuid-string\", \"John Doe\", \"IT\", 55000.0);\n\n    // Delete an employee\n    deleteEmployee(session, \"some-uuid-string\");\n\n    // Close the session and cluster\n    cass_session_close(session);\n    cass_cluster_free(cluster);\n    cass_session_free(session);\n\n    return 0;\n}\n```\n\n### Notes:\n\n1. **UUID Handling**: In Cassandra, UUIDs are used for unique identifiers. Make sure to handle UUIDs properly, especially when binding them in statements.\n2. **Error Handling**: Always check the error code of futures to handle any errors that may occur during database operations.\n3. **Resource Management**: Free all allocated resources using the appropriate Cassandra C Driver functions to avoid memory leaks.\n\nThis should give you a solid starting point for performing basic CRUD operations with Cassandra using C++. You can expand upon this by adding more features or handling more complex scenarios as needed."
    }
]