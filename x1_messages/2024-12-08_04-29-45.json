[
    {
        "role": "user",
        "content": "Write a C++ program that implements a simple Binary Search Tree (BST) data structure with insertion, deletion, and search operations. The BST should store integer values, and the program should allow the user to interactively perform these operations.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Sure, I can help you with that! Let's create a simple Binary Search Tree (BST) in C++ that can store integer values and allows for insertion, deletion, and search operations. We'll also make it interactive so that users can perform these operations dynamically.\n\nFirst, let's understand what a BST is. A Binary Search Tree is a node-based binary tree data structure that has the following properties:\n\n1. **The left subtree of a node contains only nodes with keys lesser than the node\u2019s key.**\n\n2. **The right subtree of a node contains only nodes with keys greater than the node\u2019s key.**\n\n3. **The left and right subtree each must also be a binary search tree.**\n\n4. **There must be no duplicate nodes.**\n\nGiven these properties, operations like insertion, deletion, and search can be efficiently performed.\n\n### Plan\n\n1. **Define the Node Structure:** Each node will hold an integer value, a pointer to the left child, and a pointer to the right child.\n\n2. **Implement Insertion:** This involves adding a new node to the BST while maintaining the BST properties.\n\n3. **Implement Search:** This involves finding a node with a specific value in the BST.\n\n4. **Implement Deletion:** This is a bit tricky as it involves handling different cases:\n   - Deleting a leaf node.\n   - Deleting a node with one child.\n   - Deleting a node with two children.\n\n5. **Create an Interactive Menu:** Allow the user to choose operations (insert, delete, search, exit) and perform them accordingly.\n\n### Solution Code\n\n```cpp\n#include <iostream>\nusing namespace std;\n\nclass Node {\npublic:\n    int data;\n    Node* left;\n    Node* right;\n    Node(int val) {\n        data = val;\n        left = right = nullptr;\n    }\n};\n\nclass BST {\nprivate:\n    Node* root;\n\n    Node* insert(Node* node, int val) {\n        if (node == nullptr) return new Node(val);\n        if (val < node->data)\n            node->left = insert(node->left, val);\n        else if (val > node->data)\n            node->right = insert(node->right, val);\n        return node;\n    }\n\n    Node* minValueNode(Node* node) {\n        Node* current = node;\n        while (current && current->left != nullptr)\n            current = current->left;\n        return current;\n    }\n\n    Node* deleteNode(Node* node, int val) {\n        if (node == nullptr) return node;\n        if (val < node->data)\n            node->left = deleteNode(node->left, val);\n        else if (val > node->data)\n            node->right = deleteNode(node->right, val);\n        else {\n            if (node->left == nullptr) {\n                Node* temp = node->right;\n                delete node;\n                return temp;\n            } else if (node->right == nullptr) {\n                Node* temp = node->left;\n                delete node;\n                return temp;\n            }\n            Node* temp = minValueNode(node->right);\n            node->data = temp->data;\n            node->right = deleteNode(node->right, temp->data);\n        }\n        return node;\n    }\n\n    bool search(Node* node, int val) {\n        if (node == nullptr) return false;\n        if (node->data == val) return true;\n        if (val < node->data)\n            return search(node->left, val);\n        else\n            return search(node->right, val);\n    }\n\npublic:\n    BST() : root(nullptr) {}\n\n    void insert(int val) {\n        root = insert(root, val);\n    }\n\n    void deleteNode(int val) {\n        root = deleteNode(root, val);\n    }\n\n    bool search(int val) {\n        return search(root, val);\n    }\n};\n\nint main() {\n    BST bst;\n    int choice, val;\n\n    do {\n        cout << \"\\nBinary Search Tree Operations\\n\";\n        cout << \"1. Insert\\n\";\n        cout << \"2. Delete\\n\";\n        cout << \"3. Search\\n\";\n        cout << \"4. Exit\\n\";\n        cout << \"Enter your choice: \";\n        cin >> choice;\n\n        switch(choice) {\n            case 1:\n                cout << \"Enter value to insert: \";\n                cin >> val;\n                bst.insert(val);\n                break;\n            case 2:\n                cout << \"Enter value to delete: \";\n                cin >> val;\n                bst.deleteNode(val);\n                break;\n            case 3:\n                cout << \"Enter value to search: \";\n                cin >> val;\n                if(bst.search(val))\n                    cout << \"Found!\\n\";\n                else\n                    cout << \"Not Found!\\n\";\n                break;\n            case 4:\n                cout << \"Exiting...\\n\";\n                break;\n            default:\n                cout << \"Invalid choice. Please try again.\\n\";\n        }\n    } while(choice != 4);\n\n    return 0;\n}\n```\n\n### Explanation\n\n1. **Node Structure:** Each node contains an integer value and pointers to its left and right children.\n\n2. **Insertion:** We recursively find the correct position for the new value based on BST properties and insert a new node there.\n\n3. **Deletion:** This handles three cases:\n   - Deleting a leaf node: Simply remove it.\n   - Deleting a node with one child: Remove the node and replace it with its child.\n   - Deleting a node with two children: Find the in-order successor (smallest in the right subtree), replace the node's value with it, and then delete the successor node.\n\n4. **Search:** Recursively search for the value in the tree, returning true if found, else false.\n\n5. **Interactive Menu:** A simple menu-driven interface allows the user to choose operations and inputs values accordingly until they decide to exit.\n\nThis should give you a good starting point for working with BSTs in C++. If you have any questions or need further explanations, feel free to ask!"
    }
]