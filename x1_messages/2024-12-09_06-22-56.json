[
    {
        "role": "user",
        "content": "Write a JavaScript function that takes in a string representing a date (e.g., \"2021-12-01\") and returns the day of the week (e.g., \"Wednesday\") for that date. The function should not rely on any external libraries or built-in Date functions, and should account for leap years.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Alright, I have this task to create a JavaScript function that takes a date string like \"2021-12-01\" and returns the day of the week, such as \"Wednesday\". The catch is, I can't use any external libraries or built-in Date functions, and I need to handle leap years correctly.\n\nFirst, I need to understand how to calculate the day of the week without relying on Date objects. I recall there are algorithms to determine the day of the week given a date, like Zeller's Congruence or Kaplan's algorithm. I think Zeller's Congruence is a good starting point.\n\nZeller's Congruence formula is:\n\nh = (q + floor((13(m+1))/5) + K + floor(K/4) + floor(J/4) - 2J) mod 7\n\nWhere:\n\n- h is the day of the week (0 = Saturday, 1 = Sunday, 2 = Monday, ..., 6 = Friday)\n\n- q is the day of the month\n\n- m is the month (3 = March, 4 = April, ..., 12 = December); January and February are treated as months 13 and 14 of the previous year\n\n- K is the year of the century (year % 100)\n\n- J is the zero-based century (actually floor(year / 100))\n\nBut wait, in Zeller's Congruence, the months start from March, which might complicate things. Maybe there's a simpler way.\n\nI found another formula that seems easier to implement. It's based on Tobias Agu's algorithm:\n\n1. If the month is January or February, consider it as month 13 or 14 of the previous year.\n\n2. Calculate the day of the week using the formula:\n\n   h = (day + floor(13*(month+1)/5) + year + floor(year/4) - floor(year/100) + floor(year/400)) mod 7\n\nWhere h=0 is Saturday, h=1 is Sunday, and so on.\n\nBut I need to make sure about the starting day. In the Gregorian calendar, January 1, 1 AD was a Monday, but I need to verify that.\n\nWait, actually, different sources consider different starting days. To make things consistent, I should define which day corresponds to which number.\n\nLet me decide that h=0 is Sunday, h=1 is Monday, up to h=6 being Saturday. That seems to be a common convention.\n\nSo, the formula becomes:\n\nh = (day + floor(13*(month+1)/5) + year + floor(year/4) - floor(year/100) + floor(year/400)) mod 7\n\nWith h=0 being Sunday.\n\nBut I need to handle the months correctly. If the month is January or February, I should treat them as months 13 or 14 of the previous year.\n\nFor example, January 1, 2020, would be month 13 of 2019.\n\nAlright, let's outline the steps:\n\n1. Parse the input date string to extract year, month, and day.\n\n2. If the month is 1 or 2 (January or February), subtract 1 from the year and set month to 13 or 14 respectively.\n\n3. Calculate the day of the week using the formula.\n\n4. Map the resulting h to the corresponding day name.\n\nI need to make sure that the year is handled correctly for leap years. The formula already includes terms for leap years: floor(year/4) - floor(year/100) + floor(year/400).\n\nBut wait, in the formula I found, it's year + floor(year/4) - floor(year/100) + floor(year/400), but I think in Zeller's Congruence, it's K + floor(K/4) + J + floor(J/4), where K is year % 100 and J is floor(year/100).\n\nI need to reconcile these.\n\nLet me look up the exact formula for Zeller's Congruence to make sure.\n\nAfter checking, Zeller's original congruence is:\n\nh = (q + floor(13(m+1)/5) + K + floor(K/4) + floor(J/4) + 5J) mod 7\n\nWhere:\n\n- h is the day of the week (0 = Saturday, 1 = Sunday, 2 = Monday, ..., 6 = Friday)\n\n- q is the day of the month\n\n- m is the month (3 = March, 4 = April, ..., 12 = December; January and February are months 13 and 14 of the previous year)\n\n- K is the year of the century (year % 100)\n\n- J is the zero-based century (floor(year / 100))\n\nBut since I want h=0 to be Sunday, which in Zeller's original is Saturday, I might need to adjust the formula accordingly.\n\nAlternatively, I can use a simplified formula that directly uses the year, month, and day.\n\nI found another version of the formula that seems simpler:\n\nh = (day + floor(13*(month+1)/5) + year + floor(year/4) - floor(year/100) + floor(year/400)) mod 7\n\nBut I need to verify this.\n\nWait, perhaps I should derive the formula based on the Gregorian calendar's properties.\n\nThe Gregorian calendar has a 400-year cycle. Each cycle has 146097 days, which is exactly 20871 weeks. Therefore, the calendar repeats every 400 years.\n\nWithin each 100 years, there are 24 leap years (years divisible by 4, but not by 100, unless divisible by 400).\n\nI need to account for the leap years correctly.\n\nMaybe it's easier to use a reference date and calculate the difference in days.\n\nFor example, if I know that January 1, 1970, was a Thursday (h=4 if h=0 is Sunday), I can calculate the number of days between that date and the given date, then find the day of the week by taking (known h + days difference) mod 7.\n\nThis might be more straightforward.\n\nSo, steps:\n\n1. Choose a reference date with known day of the week. For example, January 1, 1970, was a Thursday (h=4, if h=0 is Sunday).\n\n2. Calculate the total number of days from January 1, 1970, to the given date.\n\n3. Add the known day of the week of the reference date to the total days, then take mod 7 to get the day of the week for the given date.\n\n4. Map the resulting h to the corresponding day name.\n\nThis approach requires me to calculate the total days between two dates, considering leap years.\n\nFirst, I need to parse the input date string. The format is \"yyyy-mm-dd\", so I can split it by \"-\" to get year, month, and day.\n\nThen, I need to calculate the total days from 1970-01-01 to the given date.\n\nTo calculate the total days, I can calculate the days from 1970 to (year-1), plus the days from January to (month-1) in the given year, plus the day of the month.\n\nI need a function to calculate the number of days in each month, considering leap years for February.\n\nA year is a leap year if:\n\n- It is divisible by 4, but not by 100, unless it is also divisible by 400.\n\nSo, for example, 2000 is a leap year, but 1900 is not.\n\nI need to write a function to check if a year is a leap year.\n\nThen, I need an array or switch case to get the number of days in each month.\n\nBut since I'm calculating the total days from 1970, I need to iterate through the years and months accordingly.\n\nThis might be a bit involved, but it's manageable.\n\nAlternatively, I can use the Gaussian calendar formula, which is a direct formula to calculate the day of the week given a date.\n\nKarl Friedrich Gauss devised a formula for this:\n\nh = (day + floor(13*(month+1)/5) + year + floor(year/4) - floor(year/100) + floor(year/400)) mod 7\n\nBut again, I need to confirm the exact formula and the mapping of h to day names.\n\nTo make things clearer, let's define h=0 as Sunday, h=1 as Monday, ..., h=6 as Saturday.\n\nI need to verify this formula with a known date to ensure its accuracy.\n\nLet's take January 1, 1970, which was a Thursday.\n\nUsing the formula:\n\nh = (1 + floor(13*(1+1)/5) + 1970 + floor(1970/4) - floor(1970/100) + floor(1970/400)) mod 7\n\nFirst, floor(13*(1+1)/5) = floor(13*2/5) = floor(26/5) = floor(5.2) = 5\n\nfloor(1970/4) = floor(492.5) = 492\n\nfloor(1970/100) = floor(19.7) = 19\n\nfloor(1970/400) = floor(4.925) = 4\n\nSo,\n\nh = (1 + 5 + 1970 + 492 - 19 + 4) mod 7\n\n= (1 + 5 + 1970 + 492 - 19 + 4) = 2453\n\n2453 mod 7 = ?\n\nLet's calculate 2453 / 7 = 350 * 7 = 2450\n\nSo, 2453 - 2450 = 3\n\nTherefore, h=3, which should be Wednesday, but I know January 1, 1970, was a Thursday.\n\nHmm, that doesn't match. Maybe I made a mistake in the formula.\n\nWait, perhaps the formula is different. Let me look for a more accurate formula.\n\nI found that in the Gaussian algorithm, the formula is:\n\nh = (q + floor((13(m+1))/5) + K + floor(K/4) + floor(J/4) + 5J) mod 7\n\nWhere:\n\n- h is the day of the week (0 = Sunday, 1 = Monday, ..., 6 = Saturday)\n\n- q is the day of the month\n\n- m is the month (3 = March, 4 = April, ..., 12 = December; 1 = January, 2 = February of the preceding year)\n\n- K is the year of the century (year % 100)\n\n- J is the zero-based century (floor(year / 100))\n\nBut this seems similar to Zeller's Congruence.\n\nI think I need to standardize on one formula and adjust accordingly.\n\nAlternatively, I can use the ISO 8601 standard, which defines the week starting on Monday, with Monday as day 1 and Sunday as day 7. But since the task doesn't specify the starting day, I'll stick with h=0 as Sunday.\n\nGiven the confusion with the formula, perhaps implementing the step-by-step approach of calculating the total days from a reference date is more reliable.\n\nSo, let's proceed with that.\n\nFirst, define the reference date: January 1, 1970, was a Thursday (h=4, if h=0 is Sunday).\n\nThen, calculate the total number of days from 1970-01-01 to the given date.\n\nFinally, compute (4 + total_days) mod 7 to get the day of the week for the given date.\n\nNow, to calculate the total days, I need to consider:\n\n- The number of full years between 1970 and the given year.\n\n- The number of leap years in that period.\n\n- The number of days in the months from January to the given month in the given year.\n\n- The day of the month.\n\nFirst, I need a function to check if a year is a leap year.\n\nA year is a leap year if:\n\n- It is divisible by 4, but not by 100, unless it is also divisible by 400.\n\nSo, for example:\n\n- 1970: not a leap year\n\n- 1971: no\n\n- 1972: yes\n\n- ...\n\n- 2000: yes\n\n- 1900: no\n\nNext, calculate the total days from 1970 to (year-1):\n\n- For each year, add 365 days.\n\n- For each leap year in that period, add 1 day.\n\nThen, add the days from January to (month-1) in the given year, considering if it's a leap year.\n\nI need a list of days in each month.\n\n- January: 31\n\n- February: 28 or 29 (leap year)\n\n- March: 31\n\n- April: 30\n\n- May: 31\n\n- June: 30\n\n- July: 31\n\n- August: 31\n\n- September: 30\n\n- October: 31\n\n- November: 30\n\n- December: 31\n\nI can store this in an array.\n\nThen, sum the days from January to (month-1), and add the day of the month.\n\nFinally, add all these together to get the total days from the reference date to the given date.\n\nThen, compute (4 + total_days) mod 7 to get h.\n\nThen, map h to the corresponding day name.\n\nLet me try to write some pseudocode:\n\nfunction isLeapYear(year) {\n\n  return (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);\n\n}\n\nfunction dayOfWeek(dateStr) {\n\n  const daysOfWeek = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"];\n\n  // Parse dateStr\n\n  const [yearStr, monthStr, dayStr] = dateStr.split(\"-\");\n\n  const year = parseInt(yearStr);\n\n  const month = parseInt(monthStr);\n\n  const day = parseInt(dayStr);\n\n  // Reference date: January 1, 1970, was a Thursday (h=4)\n\n  const referenceYear = 1970;\n\n  const referenceMonth = 1;\n\n  const referenceDay = 1;\n\n  const referenceDayOfWeek = 4; // Thursday\n\n  // Calculate total days from 1970-01-01 to given date\n\n  let totalDays = 0;\n\n  // Days from years between 1970 and (year-1)\n\n  for (let y = referenceYear; y < year; y++) {\n\n    totalDays += isLeapYear(y) ? 366 : 365;\n\n  }\n\n  // Days from months between January and (month-1) in the given year\n\n  const daysInMonth = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n\n  if (isLeapYear(year)) {\n\n    daysInMonth[2] = 29;\n\n  } else {\n\n    daysInMonth[2] = 28;\n\n  }\n\n  for (let m = 1; m < month; m++) {\n\n    totalDays += daysInMonth[m];\n\n  }\n\n  // Add the day of the month\n\n  totalDays += day;\n\n  // Calculate h\n\n  const h = (referenceDayOfWeek + totalDays) % 7;\n\n  // Return the day name\n\n  return daysOfWeek[h];\n\n}\n\nLet me test this function with January 1, 1970.\n\ndateStr = \"1970-01-01\"\n\nyear = 1970, month = 1, day = 1\n\ntotalDays:\n\n- years between 1970 and 1969: none\n\n- months between January and December: none (since month-1 = 0)\n\n- day: 1\n\ntotalDays = 0 + 0 + 1 = 1\n\nh = (4 + 1) mod 7 = 5, which is Friday. But January 1, 1970, was a Thursday. Hmm, that's off by one.\n\nWait, maybe the reference day is incorrect. If January 1, 1970, was a Thursday, and h=4 is Thursday, then adding 1 day should be Friday, but that doesn't make sense because the totalDays is 1.\n\nWait, perhaps I need to adjust the referenceDayOfWeek.\n\nAlternatively, maybe I need to subtract 1 from totalDays.\n\nLet me check another date.\n\nTake March 1, 1970.\n\nKnown that January has 31 days, February has 28 days in 1970 (not a leap year), so February has 28 days.\n\nTotal days from January 1 to March 1: 31 (January) + 28 (February) + 1 (March) = 60 days.\n\nh = (4 + 60) mod 7 = (4 + 60) mod 7 = 64 mod 7 = 1 (since 7*9=63, 64-63=1), which is Monday.\n\nBut March 1, 1970, was actually a Sunday.\n\nWait, that's incorrect again.\n\nI must have messed up the reference day or the calculation.\n\nLet me check the reference day again.\n\nI thought January 1, 1970, was a Thursday, but maybe that's incorrect.\n\nChecking online, January 1, 1970, was actually a Thursday.\n\nBut according to my calculation, totalDays=1, h=(4+1)%7=5, which is Friday, but it should be Thursday.\n\nSo maybe the referenceDayOfWeek should be 3, making January 1, 1970, a Thursday.\n\nLet me check:\n\nh = (3 + 1) mod 7 = 4, which is Thursday.\n\nYes, that makes sense.\n\nSo, referenceDayOfWeek should be 3 for Thursday.\n\nLet me correct that.\n\ndaysOfWeek = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"]\n\nh=0: Sunday\n\nh=1: Monday\n\n...\n\nh=3: Thursday\n\nSo, referenceDayOfWeek = 3 for Thursday.\n\nNow, for January 1, 1970:\n\ntotalDays = 0 (no years or months between), day=1\n\nh = (3 + 1) mod 7 = 4, which is Thursday. Correct.\n\nFor March 1, 1970:\n\ntotalDays = 31 (January) + 28 (February) + 1 (March) = 60\n\nh = (3 + 60) mod 7 = 63 mod 7 = 0, which is Sunday. Correct.\n\nEarlier mistake was in assuming referenceDayOfWeek was 4, but it's actually 3.\n\nGood, now the function seems correct.\n\nLet me implement this in code.\n\n## Final Solution\nTo solve this problem, we need to create a JavaScript function that determines the day of the week for a given date string without using any external libraries or built-in Date functions, and accounting for leap years.\n\n### Approach\n1. **Reference Date**: We know that January 1, 1970, was a Thursday.\n2. **Day Calculation**:\n   - Calculate the total number of days from January 1, 1970, to the given date.\n   - Add the known day of the week (Thursday, which is 3 in our day array where 0 is Sunday) to the total days.\n   - Take the result modulo 7 to find the day of the week for the given date.\n3. **Leap Year Handling**: A year is a leap year if it is divisible by 4, not divisible by 100, or divisible by 400.\n\n### Solution Code\n\n```javascript\nfunction isLeapYear(year) {\n  return (year % 4 === 0 && year % 100 !== 0) || (year % 400 === 0);\n}\n\nfunction dayOfWeek(dateStr) {\n  const daysOfWeek = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"];\n  \n  // Parse date string\n  const [yearStr, monthStr, dayStr] = dateStr.split(\"-\");\n  const year = parseInt(yearStr);\n  const month = parseInt(monthStr);\n  const day = parseInt(dayStr);\n  \n  // Reference date: January 1, 1970, was a Thursday (h=3)\n  const referenceYear = 1970;\n  const referenceMonth = 1;\n  const referenceDay = 1;\n  const referenceDayOfWeek = 3; // Thursday\n  \n  // Calculate total days from 1970-01-01 to given date\n  let totalDays = 0;\n  \n  // Days from full years between 1970 and (year - 1)\n  for (let y = referenceYear; y < year; y++) {\n    totalDays += isLeapYear(y) ? 366 : 365;\n  }\n  \n  // Days from months between January and (month - 1) in the given year\n  const daysInMonth = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  if (isLeapYear(year)) {\n    daysInMonth[2] = 29;\n  }\n  for (let m = 1; m < month; m++) {\n    totalDays += daysInMonth[m];\n  }\n  \n  // Add the day of the month\n  totalDays += day;\n  \n  // Calculate day of the week\n  const h = (referenceDayOfWeek + totalDays) % 7;\n  \n  // Return the day name\n  return daysOfWeek[h];\n}\n```\n\n### Explanation\n1. **isLeapYear Function**: Determines if a given year is a leap year.\n2. **dayOfWeek Function**:\n   - Parses the input date string.\n   - Initializes the day of the week array and sets the reference day (Thursday, January 1, 1970, as 3).\n   - Calculates the total days from January 1, 1970, to the given date by:\n     - Summing the days in full years between 1970 and the given year, accounting for leap years.\n     - Adding days from each month up to the given month in the given year.\n     - Adding the day of the month.\n   - Computes the day of the week by taking the modulo 7 of the sum of the reference day and total days.\n   - Returns the corresponding day name from the day array."
    }
]