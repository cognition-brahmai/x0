[
    {
        "role": "user",
        "content": "Develop a C++ program that implements a simple text-based hangman game. The game should have the following features:\n   - A predefined list of words for the player to guess.\n   - Display the partially guessed word with underscores for unguessed letters.\n   - Allow the player to enter one letter at a time until they either guess the word correctly or run out of attempts.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Alright, I've got this task to create a simple text-based Hangman game in C++. I need to make sure it has a list of words for the player to guess, displays the partially guessed word with underscores for letters that haven't been guessed yet, and allows the player to enter one letter at a time. They should keep guessing until they either figure out the word or they've used up all their attempts.\n\nFirst things first, I need to think about how to structure this program. I should probably start by defining the list of words. Maybe I can put them in an array or a vector. Let me consider using a vector because it's more flexible in terms of adding or removing words later on.\n\nSo, I'll include the necessary headers. I'll need <iostream> for input and output, <vector> for the word list, and <ctime> to seed the random number generator so that the word selection is different each time the game is played.\n\nNext, I need to select a word randomly from the list. I can use the rand() function along with modulo to get a random index from the vector.\n\nOnce I have the word, I need to hide it and show underscores for each letter. I can create a string of underscores that's the same length as the word.\n\nThen, I need to handle the player's guesses. I should probably set a limit on the number of attempts, like 6 or 7, similar to the traditional hangman game.\n\nI need to take input from the player, one letter at a time, and check if that letter is in the word. If it is, I need to reveal its position in the partially guessed word. If not, I need to decrement the attempt count.\n\nI should also make sure that the player can't guess the same letter twice. So, I need to keep track of the letters that have already been guessed.\n\nAdditionally, I need to handle both uppercase and lowercase inputs since C++ is case-sensitive. Maybe I'll convert all inputs to lowercase to simplify things.\n\nI should also think about how to display the current state of the game, like the partially guessed word, the letters already guessed, and the remaining attempts.\n\nOnce the player guesses the word correctly or runs out of attempts, I need to display the appropriate message and ask if they want to play again.\n\nLet me start by writing down the steps in pseudocode:\n\n1. Include necessary headers\n\n2. Define the list of words in a vector\n\n3. Seed the random number generator\n\n4. Select a random word from the vector\n\n5. Initialize the partially guessed word with underscores\n\n6. Set the number of attempts (e.g., 6)\n\n7. Create an empty set or vector to track guessed letters\n\n8. Start a loop for player turns:\n\na. Display the current state: partially guessed word, letters already guessed, attempts left\n\nb. Ask the player to enter a letter\n\nc. Take the input and convert it to lowercase\n\nd. Check if the letter has already been guessed\n\ni. If yes, inform the player and skip to the next turn\n\ne. If not, check if the letter is in the word\n\ni. If yes, reveal its position(s) in the partially guessed word\n\nii. If no, decrement the attempt count and add the letter to the guessed letters\n\nf. Check if the player has won (no underscores left) or lost (attempts == 0)\n\ng. If the game is over, ask if the player wants to play again\n\n9. If the player wants to play again, repeat the game with a new word\n\nOkay, that seems like a solid plan. Now, let's start translating this into actual C++ code.\n\nFirst, include the necessary headers:\n\n#include <iostream>\n\n#include <vector>\n\n#include <ctime>\n\n#include <cctype>  // for tolower\n\n#include <set>\n\nThen, define the list of words:\n\nstd::vector<std::string> wordList = {\"apple\", \"banana\", \"cherry\", \"date\", \"fig\", \"grape\", \"kiwi\", \"lemon\", \"mango\", \"orange\"};\n\nSeed the random number generator:\n\nsrand(time(0));\n\nSelect a random word:\n\nint index = rand() % wordList.size();\n\nstd::string word = wordList[index];\n\nInitialize the partially guessed word:\n\nstd::string guessedWord(word.length(), '_');\n\nSet the number of attempts:\n\nconst int maxAttempts = 6;\n\nCreate a set for guessed letters:\n\nstd::set<char> guessedLetters;\n\nNow, start the game loop:\n\nwhile (attempts > 0 && guessedWord.find('_') != std::string::npos) {\n\n// Display current state\n\nstd::cout << \"Current word: \" << guessedWord << std::endl;\n\nstd::cout << \"Guessed letters: \";\n\nfor (char c : guessedLetters) {\n\nstd::cout << c << \" \";\n\n}\n\nstd::cout << std::endl;\n\nstd::cout << \"Attempts left: \" << attempts << std::endl;\n\n// Ask for input\n\nchar guess;\n\nstd::cout << \"Enter a letter: \";\n\nstd::cin >> guess;\n\nguess = tolower(guess);\n\n// Check if already guessed\n\nif (guessedLetters.find(guess) != guessedLetters.end()) {\n\nstd::cout << \"You already guessed that letter. Try again.\" << std::endl;\n\ncontinue;\n\n}\n\nguessedLetters.insert(guess);\n\n// Check if the letter is in the word\n\nif (word.find(guess) != std::string::npos) {\n\n// Letter is in the word; update guessedWord\n\nfor (size_t i = 0; i < word.length(); ++i) {\n\nif (word[i] == guess) {\n\nguessedWord[i] = guess;\n\n}\n\n}\n\nstd::cout << \"Good guess!\" << std::endl;\n\n} else {\n\n// Letter not in word; decrement attempts\n\nattempts--;\n\nstd::cout << \"Sorry, that letter is not in the word.\" << std::endl;\n\n}\n\n}\n\nAfter the loop, check if the player won or lost:\n\nif (guessedWord.find('_') == std::string::npos) {\n\nstd::cout << \"Congratulations! You've guessed the word: \" << word << std::endl;\n\n} else {\n\nstd::cout << \"Sorry, you've run out of attempts. The word was: \" << word << std::endl;\n\n}\n\nThen, ask if they want to play again:\n\nchar playAgain;\n\nstd::cout << \"Play again? (y/n): \";\n\nstd::cin >> playAgain;\n\nif (tolower(playAgain) != 'y') {\n\nbreak;\n\n}\n\nI should probably put the game logic in a loop so that the player can play multiple times.\n\nAlso, I need to make sure to handle cases where the player inputs something other than a single letter, but for simplicity, I might not worry about that initially.\n\nLet me think about how to organize the code. Maybe I can put the game logic in a function to make it cleaner.\n\nHere's a rough structure:\n\n#include <iostream>\n\n#include <vector>\n\n#include <ctime>\n\n#include <cctype>\n\n#include <set>\n\nstd::vector<std::string> wordList = {\"apple\", \"banana\", \"cherry\", \"date\", \"fig\", \"grape\", \"kiwi\", \"lemon\", \"mango\", \"orange\"};\n\nvoid playHangman() {\n\nsrand(time(0));\n\nint index = rand() % wordList.size();\n\nstd::string word = wordList[index];\n\nstd::string guessedWord(word.length(), '_');\n\nconst int maxAttempts = 6;\n\nint attempts = maxAttempts;\n\nstd::set<char> guessedLetters;\n\nwhile (attempts > 0 && guessedWord.find('_') != std::string::npos) {\n\n// Display state\n\n// Ask for input\n\n// Handle guess\n\n}\n\n// Game over messages\n\n}\n\nint main() {\n\ndo {\n\nplayHangman();\n\nchar playAgain;\n\nstd::cout << \"Play again? (y/n): \";\n\nstd::cin >> playAgain;\n\n} while (tolower(playAgain) == 'y');\n\nreturn 0;\n\n}\n\nThis looks good. Now, I need to fill in the details for displaying the state and handling the guesses.\n\nI should also consider adding some introductory messages to explain how to play the game.\n\nMaybe I can add a function to check if the input is a valid single letter to make the code cleaner.\n\nBut for now, I'll keep it simple.\n\nLet me think about how to display the partially guessed word. If the word is \"apple\" and the player has guessed 'p' and 'e', it should display \"_ p p _ e\".\n\nI need to make sure that the underscores and guessed letters are in the correct positions.\n\nAlso, I need to handle the case where the word contains multiple instances of the same letter.\n\nI think using a loop to iterate through the word and update the guessedWord string accordingly should work.\n\nLet me write a small snippet for that:\n\nfor (size_t i = 0; i < word.length(); ++i) {\n\nif (word[i] == guess) {\n\nguessedWord[i] = guess;\n\n}\n\n}\n\nYes, that should do it.\n\nNow, for the guessed letters, I'm using a set to keep track of them, which automatically handles uniqueness.\n\nI should also think about how to handle uppercase and lowercase letters. Since C++ is case-sensitive, I'll convert all inputs to lowercase and store everything in lowercase to make comparisons easier.\n\nI'll need to make sure that the word list consists of lowercase words as well.\n\nLooking back at the word list I defined, they are all in lowercase, which is good.\n\nNow, about the number of attempts. Traditionally, hangman has 6 or 7 incorrect attempts before the player loses. I'll set it to 6 for simplicity.\n\nI need to decrement the attempts only when the player guesses a letter that's not in the word.\n\nIf they guess a letter that's already been guessed, I won't decrement the attempts.\n\nI should also inform the player if they've already guessed a letter to avoid confusion.\n\nLet me think about the flow again:\n\n1. Display the current state: partially guessed word, guessed letters, attempts left\n\n2. Ask for a letter\n\n3. Read the input and convert to lowercase\n\n4. Check if the letter has already been guessed:\n\na. If yes, inform the player and skip to the next turn\n\nb. If no, proceed\n\n5. Check if the letter is in the word:\n\na. If yes, reveal its positions in the guessedWord\n\nb. If no, decrement the attempts\n\n6. Check if the game is over:\n\na. If no underscores are left, the player wins\n\nb. If attempts reach zero, the player loses\n\n7. If the game isn't over, repeat from step 1\n\n8. If the game is over, ask if the player wants to play again\n\nI think that covers everything.\n\nLet me consider adding some decorative elements, like drawing the hangman based on the number of incorrect attempts.\n\nBut for a simple text-based game, maybe that's overkill. I'll keep it straightforward with just the word and state information.\n\nI should also handle the case where the player inputs something other than a single letter, like a number or a symbol, but to keep it simple, I might not bother for now.\n\nNow, let's think about how to implement this in code.\n\nI'll define the word list as a vector of strings.\n\nI'll use the <ctime> library to seed the random number generator with the current time, so that the word selection is different each time the program runs.\n\nThen, I'll select a random word from the list using rand() % wordList.size().\n\nI'll create a string called guessedWord initialized with underscores '_' of the same length as the selected word.\n\nI'll set a constant for the maximum number of attempts, say 6.\n\nI'll use a set to keep track of the letters that have already been guessed.\n\nThen, I'll enter a loop that continues as long as there are attempts left and there are underscores in the guessedWord.\n\nWithin the loop:\n\n- Display the current state: guessedWord, guessedLetters, attempts left\n\n- Prompt the player to enter a letter\n\n- Read the input and convert it to lowercase\n\n- Check if the letter has already been guessed:\n\n- If yes, inform the player and skip to the next iteration\n\n- If no, proceed\n\n- Check if the letter is in the word:\n\n- If yes, update the guessedWord to reveal the positions of the guessed letter\n\n- If no, decrement the attempts\n\n- Check if the game is over:\n\n- If no underscores are left, the player wins\n\n- If attempts reach zero, the player loses\n\nAfter the loop, display the appropriate win or lose message and reveal the word.\n\nThen, ask if the player wants to play again.\n\nIf yes, repeat the game; if not, exit.\n\nI should also consider adding some error handling, like making sure that the player inputs a single character, but for now, I'll assume that the player behaves correctly.\n\nLet me start writing the code based on this plan.\n\nFirst, include the necessary headers:\n\n#include <iostream>\n\n#include <vector>\n\n#include <ctime>\n\n#include <cctype>  // for tolower\n\n#include <set>\n\nDefine the word list:\n\nstd::vector<std::string> wordList = {\"apple\", \"banana\", \"cherry\", \"date\", \"fig\", \"grape\", \"kiwi\", \"lemon\", \"mango\", \"orange\"};\n\nSeed the random number generator in the playHangman function:\n\nsrand(time(0));\n\nSelect a random word:\n\nint index = rand() % wordList.size();\n\nstd::string word = wordList[index];\n\nInitialize guessedWord:\n\nstd::string guessedWord(word.length(), '_');\n\nSet maxAttempts:\n\nconst int maxAttempts = 6;\n\nint attempts = maxAttempts;\n\nInitialize guessedLetters as an empty set:\n\nstd::set<char> guessedLetters;\n\nStart the game loop:\n\nwhile (attempts > 0 && guessedWord.find('_') != std::string::npos) {\n\n// Display current state\n\nstd::cout << \"Current word: \" << guessedWord << std::endl;\n\nstd::cout << \"Guessed letters: \";\n\nfor (char c : guessedLetters) {\n\nstd::cout << c << \" \";\n\n}\n\nstd::cout << std::endl;\n\nstd::cout << \"Attempts left: \" << attempts << std::endl;\n\n// Ask for input\n\nchar guess;\n\nstd::cout << \"Enter a letter: \";\n\nstd::cin >> guess;\n\nguess = tolower(guess);\n\n// Check if already guessed\n\nif (guessedLetters.find(guess) != guessedLetters.end()) {\n\nstd::cout << \"You already guessed that letter. Try again.\" << std::endl;\n\ncontinue;\n\n}\n\nguessedLetters.insert(guess);\n\n// Check if the letter is in the word\n\nif (word.find(guess) != std::string::npos) {\n\n// Update guessedWord\n\nfor (size_t i = 0; i < word.length(); ++i) {\n\nif (word[i] == guess) {\n\nguessedWord[i] = guess;\n\n}\n\n}\n\nstd::cout << \"Good guess!\" << std::endl;\n\n} else {\n\n// Decrement attempts\n\nattempts--;\n\nstd::cout << \"Sorry, that letter is not in the word.\" << std::endl;\n\n}\n\n}\n\nAfter the loop, check if the player won or lost:\n\nif (guessedWord.find('_') == std::string::npos) {\n\nstd::cout << \"Congratulations! You've guessed the word: \" << word << std::endl;\n\n} else {\n\nstd::cout << \"Sorry, you've run out of attempts. The word was: \" << word << std::endl;\n\n}\n\nThen, ask if they want to play again:\n\nchar playAgain;\n\nstd::cout << \"Play again? (y/n): \";\n\nstd::cin >> playAgain;\n\nif (tolower(playAgain) != 'y') {\n\nbreak;\n\n}\n\nI should put this game logic in a function, say playHangman(), and call it in a loop in the main function.\n\nAlso, I need to make sure that the random seed is set only once, perhaps in the main function.\n\nWait, no. srand() should be called only once per program execution, so it's better to call it in the main function.\n\nLet me adjust the structure accordingly.\n\nHere's an improved structure:\n\n#include <iostream>\n\n#include <vector>\n\n#include <ctime>\n\n#include <cctype>\n\n#include <set>\n\nstd::vector<std::string> wordList = {\"apple\", \"banana\", \"cherry\", \"date\", \"fig\", \"grape\", \"kiwi\", \"lemon\", \"mango\", \"orange\"};\n\nvoid playHangman() {\n\nint index = rand() % wordList.size();\n\nstd::string word = wordList[index];\n\nstd::string guessedWord(word.length(), '_');\n\nconst int maxAttempts = 6;\n\nint attempts = maxAttempts;\n\nstd::set<char> guessedLetters;\n\nwhile (attempts > 0 && guessedWord.find('_') != std::string::npos) {\n\n// Display state\n\n// Ask for input\n\n// Handle guess\n\n}\n\n// Game over messages\n\n}\n\nint main() {\n\nsrand(time(0));\n\ndo {\n\nplayHangman();\n\nchar playAgain;\n\nstd::cout << \"Play again? (y/n): \";\n\nstd::cin >> playAgain;\n\n} while (tolower(playAgain) == 'y');\n\nreturn 0;\n\n}\n\nThis way, the random seed is set only once when the program starts.\n\nNow, I need to implement the playHangman function with the game logic.\n\nI should also consider adding some introductory messages in the main function to explain how to play.\n\nFor example:\n\nstd::cout << \"Welcome to Hangman!\" << std::endl;\n\nstd::cout << \"Try to guess the word by suggesting letters.\" << std::endl;\n\nstd::cout << \"You have 6 attempts to guess the word correctly.\" << std::endl;\n\nI can place this before the do-while loop.\n\nAdditionally, I can add a message when the game starts a new round.\n\nLet me think about the overall structure again:\n\n- Include headers\n\n- Define wordList\n\n- Define playHangman function\n\n- In main:\n\n- Set random seed\n\n- Display introductory messages\n\n- Loop:\n\n- Call playHangman\n\n- Ask if the player wants to play again\n\n- If not, break the loop\n\nNow, let's think about how to make the code more efficient or cleaner.\n\nI can consider creating a function to handle getting valid input from the player, but for simplicity, I'll assume that the player enters a single character each time.\n\nAnother thing is that using a set for guessedLetters might not be necessary if I'm only checking for uniqueness. I could use a string instead and check if the guessed letter is in that string.\n\nUsing a set is fine, though, and it's efficient for lookups.\n\nAlternatively, I could use an array of booleans to track which letters have been guessed, but a set is more straightforward.\n\nI think the current approach is acceptable for a simple implementation.\n\nLet me proceed to write the playHangman function.\n\nHere's a draft:\n\nvoid playHangman() {\n\nint index = rand() % wordList.size();\n\nstd::string word = wordList[index];\n\nstd::string guessedWord(word.length(), '_');\n\nconst int maxAttempts = 6;\n\nint attempts = maxAttempts;\n\nstd::set<char> guessedLetters;\n\nwhile (attempts > 0 && guessedWord.find('_') != std::string::npos) {\n\n// Display current state\n\nstd::cout << \"Current word: \" << guessedWord << std::endl;\n\nstd::cout << \"Guessed letters: \";\n\nfor (char c : guessedLetters) {\n\nstd::cout << c << \" \";\n\n}\n\nstd::cout << std::endl;\n\nstd::cout << \"Attempts left: \" << attempts << std::endl;\n\n// Ask for input\n\nchar guess;\n\nstd::cout << \"Enter a letter: \";\n\nstd::cin >> guess;\n\nguess = tolower(guess);\n\n// Check if already guessed\n\nif (guessedLetters.find(guess) != guessedLetters.end()) {\n\nstd::cout << \"You already guessed that letter. Try again.\" << std::endl;\n\ncontinue;\n\n}\n\nguessedLetters.insert(guess);\n\n// Check if the letter is in the word\n\nif (word.find(guess) != std::string::npos) {\n\n// Update guessedWord\n\nfor (size_t i = 0; i < word.length(); ++i) {\n\nif (word[i] == guess) {\n\nguessedWord[i] = guess;\n\n}\n\n}\n\nstd::cout << \"Good guess!\" << std::endl;\n\n} else {\n\n// Decrement attempts\n\nattempts--;\n\nstd::cout << \"Sorry, that letter is not in the word.\" << std::endl;\n\n}\n\n}\n\n// Game over\n\nif (guessedWord.find('_') == std::string::npos) {\n\nstd::cout << \"Congratulations! You've guessed the word: \" << word << std::endl;\n\n} else {\n\nstd::cout << \"Sorry, you've run out of attempts. The word was: \" << word << std::endl;\n\n}\n\n}\n\nLooks good. Now, I need to make sure that the word list is diverse enough to keep the game interesting.\n\nI can add more words to the wordList vector to increase the variety.\n\nAlso, I should consider using a larger word list, perhaps loaded from a file, for a more extensive game, but that might be beyond the scope of this simple implementation.\n\nFor now, the predefined list should suffice.\n\nI should also ensure that the words in the list are all in lowercase to match the input handling.\n\nLet me double-check the wordList:\n\nstd::vector<std::string> wordList = {\"apple\", \"banana\", \"cherry\", \"date\", \"fig\", \"grape\", \"kiwi\", \"lemon\", \"mango\", \"orange\"};\n\nAll lowercase, which is perfect.\n\nNow, I need to think about how to handle the case where the player inputs something other than a single letter, like a number or a symbol.\n\nIn this simple version, I'll assume that the player enters valid single letters.\n\nIf I want to make it more robust, I could add checks to ensure that the input is a single alphabetical character.\n\nBut for now, I'll skip that.\n\nAnother consideration is that if the word contains spaces or special characters, my current implementation might not handle them correctly.\n\nBut since I'm using fruit names, which shouldn't have spaces or special characters, I don't need to worry about that in this context.\n\nHowever, to make the game more versatile, I could modify it to handle words with spaces or other characters.\n\nBut again, that might be unnecessary for this simple implementation.\n\nI should also think about international characters, like accented letters, but since the word list consists of English fruit names, that shouldn't be an issue.\n\nNow, let's consider adding a welcome message and instructions in the main function.\n\nSomething like:\n\nstd::cout << \"Welcome to Hangman!\" << std::endl;\n\nstd::cout << \"Try to guess the word by suggesting letters.\" << std::endl;\n\nstd::cout << \"You have 6 attempts to guess the word correctly.\" << std::endl;\n\nstd::cout << \"Enter one letter at a time.\" << std::endl;\n\nstd::cout << \"Good luck!\" << std::endl;\n\nI can place this before the do-while loop.\n\nAlso, after each game, I can ask if the player wants to play again, and if not, exit the loop.\n\nI need to make sure that the program handles the playAgain input correctly, considering both 'y' and 'Y' as yes, and anything else as no.\n\nI can do this by converting the input to lowercase and checking if it's 'y'.\n\nNow, let's think about how to organize the code for better readability.\n\nI can add comments to explain each section of the code.\n\nI can also consider formatting the output nicely, perhaps by adding spaces or using std::left or std::right manipulators from <iomanip>.\n\nBut for simplicity, plain output should be fine.\n\nAnother thing is that I'm using std::string's find function to check if a letter is in the word.\n\nThis works, but since we're dealing with single characters, I could also iterate through the word and check for equality.\n\nUsing find is efficient enough for this purpose, though.\n\nLet me consider writing a small function to handle updating the guessedWord for clarity.\n\nFor example:\n\nvoid updateGuessedWord(const std::string& word, const char guess, std::string& guessedWord) {\n\nfor (size_t i = 0; i < word.length(); ++i) {\n\nif (word[i] == guess) {\n\nguessedWord[i] = guess;\n\n}\n\n}\n\n}\n\nThen, in the main game loop, I can call this function when the guess is correct.\n\nThis might make the code a bit cleaner.\n\nSimilarly, I could create a function to display the current state.\n\nFor example:\n\nvoid displayState(const std::string& guessedWord, const std::set<char>& guessedLetters, int attempts) {\n\nstd::cout << \"Current word: \" << guessedWord << std::endl;\n\nstd::cout << \"Guessed letters: \";\n\nfor (char c : guessedLetters) {\n\nstd::cout << c << \" \";\n\n}\n\nstd::cout << std::endl;\n\nstd::cout << \"Attempts left: \" << attempts << std::endl;\n\n}\n\nThis would help in keeping the game loop tidy.\n\nLet me refactor the playHangman function using these helper functions.\n\nFirst, define the helper functions:\n\nvoid updateGuessedWord(const std::string& word, const char guess, std::string& guessedWord) {\n\nfor (size_t i = 0; i < word.length(); ++i) {\n\nif (word[i] == guess) {\n\nguessedWord[i] = guess;\n\n}\n\n}\n\n}\n\nvoid displayState(const std::string& guessedWord, const std::set<char>& guessedLetters, int attempts) {\n\nstd::cout << \"Current word: \" << guessedWord << std::endl;\n\nstd::cout << \"Guessed letters: \";\n\nfor (char c : guessedLetters) {\n\nstd::cout << c << \" \";\n\n}\n\nstd::cout << std::endl;\n\nstd::cout << \"Attempts left: \" << attempts << std::endl;\n\n}\n\nNow, the playHangman function can be rewritten as:\n\nvoid playHangman() {\n\nint index = rand() % wordList.size();\n\nstd::string word = wordList[index];\n\nstd::string guessedWord(word.length(), '_');\n\nconst int maxAttempts = 6;\n\nint attempts = maxAttempts;\n\nstd::set<char> guessedLetters;\n\nwhile (attempts > 0 && guessedWord.find('_') != std::string::npos) {\n\ndisplayState(guessedWord, guessedLetters, attempts);\n\nchar guess;\n\nstd::cout << \"Enter a letter: \";\n\nstd::cin >> guess;\n\nguess = tolower(guess);\n\nif (guessedLetters.find(guess) != guessedLetters.end()) {\n\nstd::cout << \"You already guessed that letter. Try again.\" << std::endl;\n\ncontinue;\n\n}\n\nguessedLetters.insert(guess);\n\nif (word.find(guess) != std::string::npos) {\n\nupdateGuessedWord(word, guess, guessedWord);\n\nstd::cout << \"Good guess!\" << std::endl;\n\n} else {\n\nattempts--;\n\nstd::cout << \"Sorry, that letter is not in the word.\" << std::endl;\n\n}\n\n}\n\nif (guessedWord.find('_') == std::string::npos) {\n\nstd::cout << \"Congratulations! You've guessed the word: \" << word << std::endl;\n\n} else {\n\nstd::cout << \"Sorry, you've run out of attempts. The word was: \" << word << std::endl;\n\n}\n\n}\n\nThis looks cleaner and more organized.\n\nNow, I need to ensure that the program compiles and runs without errors.\n\nI should also test it with different inputs to make sure it works as expected.\n\nFor example:\n\n- Guessing all the correct letters within the attempt limit\n\n- Running out of attempts before guessing the word\n\n- Guessing the same letter multiple times\n\n- Entering letters that are not in the word\n\nI should also check for edge cases, like words with repeated letters or words with only one letter (though my word list doesn't have single-letter words).\n\nWait, actually, \"fig\" has three letters, which is acceptable for this game.\n\nI should also make sure that the program doesn't crash or behave unexpectedly if the word list is empty, but since I have a predefined list, that's unlikely.\n\nHowever, to make the code more robust, I could add a check to ensure that the word list is not empty before selecting a word.\n\nBut for this simple implementation, I'll assume that the word list is always populated.\n\nAnother thing to consider is that if the player guesses the entire word correctly in one go, but the game only accepts one letter at a time, they would have to guess each letter individually.\n\nSince the game is designed to take one letter at a time, guessing the whole word at once isn't allowed.\n\nIf I wanted to add that feature, it would complicate the game logic, so I'll stick with single-letter guesses.\n\nNow, let's think about how to handle the input if the player enters more than one character or a non-letter character.\n\nIn the current implementation, std::cin reads a single character, so if the player enters more than one character, only the first one is read.\n\nHowever, if the player enters a non-letter character, like a number or a symbol, it will still be treated as a guess, which might not be desirable.\n\nTo handle this, I could add a check to ensure that the input is an alphabetical character.\n\nIf it's not, I can inform the player and ask for input again.\n\nBut for now, I'll keep it simple and assume that the player enters valid single letters.\n\nIf I decide to add input validation, I can do something like:\n\nchar guess;\n\nstd::cout << \"Enter a letter: \";\n\nstd::cin >> guess;\n\nif (!isalpha(guess)) {\n\nstd::cout << \"Please enter a valid letter.\" << std::endl;\n\ncontinue;\n\n}\n\nguess = tolower(guess);\n\nThis ensures that only alphabetical characters are accepted as guesses.\n\nI can consider adding this later if needed.\n\nNow, I should write the main function to tie everything together.\n\nHere's a draft:\n\nint main() {\n\nsrand(time(0));\n\nstd::cout << \"Welcome to Hangman!\" << std::endl;\n\nstd::cout << \"Try to guess the word by suggesting letters.\" << std::endl;\n\nstd::cout << \"You have 6 attempts to guess the word correctly.\" << std::endl;\n\nstd::cout << \"Enter one letter at a time.\" << std::endl;\n\nstd::cout << \"Good luck!\" << std::endl;\n\ndo {\n\nplayHangman();\n\nchar playAgain;\n\nstd::cout << \"Play again? (y/n): \";\n\nstd::cin >> playAgain;\n\n} while (tolower(playAgain) == 'y');\n\nreturn 0;\n\n}\n\nThis should work.\n\nI need to make sure that all necessary headers are included.\n\nLet me list them again:\n\n#include <iostream>\n\n#include <vector>\n\n#include <ctime>\n\n#include <cctype>  // for tolower and isalpha\n\n#include <set>\n\nI should also include <algorithm> if I need any algorithms, but for now, I don't think I do.\n\nNow, I can compile and run the program to see if it works as expected.\n\nI should test it with different words from the wordList and different guessing scenarios.\n\nFor example:\n\n- Guessing all letters correctly within attempts\n\n- Guessing some correct letters and some incorrect ones, eventually winning\n\n- Guessing only incorrect letters and losing\n\n- Guessing the same letter multiple times\n\nI need to ensure that the program handles all these cases correctly.\n\nAlso, I should check that the program doesn't have any infinite loops or logical errors.\n\nOnce I'm satisfied with the functionality, I can consider adding more features, like:\n\n- Drawing the hangman based on the number of incorrect attempts\n\n- Allowing the player to guess the whole word\n\n- Using a larger and more diverse word list\n\n- Implementing a timer for each guess\n\nBut for a simple text-based hangman game, the current implementation should suffice.\n\nI should also think about code optimization, but since this is a small program with minimal computational requirements, optimization isn't a concern here.\n\nFinally, I need to make sure that the code is clean, well-organized, and properly commented for readability.\n\nI can add comments to explain the purpose of each function and significant code blocks.\n\nLet me write the complete code with comments.\n\n## Final Solution\nTo create a simple text-based Hangman game in C++, follow the steps below. This game includes features such as a predefined list of words, displaying the partially guessed word with underscores for unguessed letters, and allowing the player to enter one letter at a time until they either guess the word correctly or run out of attempts.\n\n### Approach\n\n1. **Word List and Random Selection**: Use a vector to store the list of words and select a random word for each game.\n2. **Game State Management**: Track the player's guesses, attempts left, and the current state of the guessed word.\n3. **User Input Handling**: Read player inputs, ensure they are single letters, and handle already guessed letters.\n4. **Win and Lose Conditions**: Check if the player has guessed the word correctly or run out of attempts.\n5. **Replay Option**: Ask the player if they want to play again after the game ends.\n\n### Solution Code\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <ctime>\n#include <cctype>  // for tolower\n#include <set>\n\n// List of words for the game\nstd::vector<std::string> wordList = {\"apple\", \"banana\", \"cherry\", \"date\", \"fig\", \"grape\", \"kiwi\", \"lemon\", \"mango\", \"orange\"};\n\n// Function to play the hangman game\nvoid playHangman() {\n    // Select a random word\n    int index = rand() % wordList.size();\n    std::string word = wordList[index];\n    \n    // Initialize the guessed word with underscores\n    std::string guessedWord(word.length(), '_');\n    \n    // Set the maximum number of attempts\n    const int maxAttempts = 6;\n    int attempts = maxAttempts;\n    \n    // Set to track guessed letters\n    std::set<char> guessedLetters;\n    \n    // Game loop\n    while (attempts > 0 && guessedWord.find('_') != std::string::npos) {\n        // Display current state\n        std::cout << \"Current word: \" << guessedWord << std::endl;\n        std::cout << \"Guessed letters: \";\n        for (char c : guessedLetters) {\n            std::cout << c << \" \";\n        }\n        std::cout << std::endl;\n        std::cout << \"Attempts left: \" << attempts << std::endl;\n        \n        // Ask for input\n        char guess;\n        std::cout << \"Enter a letter: \";\n        std::cin >> guess;\n        guess = tolower(guess);\n        \n        // Check if already guessed\n        if (guessedLetters.find(guess) != guessedLetters.end()) {\n            std::cout << \"You already guessed that letter. Try again.\" << std::endl;\n            continue;\n        }\n        \n        guessedLetters.insert(guess);\n        \n        // Check if the letter is in the word\n        if (word.find(guess) != std::string::npos) {\n            // Update guessedWord\n            for (size_t i = 0; i < word.length(); ++i) {\n                if (word[i] == guess) {\n                    guessedWord[i] = guess;\n                }\n            }\n            std::cout << \"Good guess!\" << std::endl;\n        } else {\n            // Decrement attempts\n            attempts--;\n            std::cout << \"Sorry, that letter is not in the word.\" << std::endl;\n        }\n    }\n    \n    // Game over messages\n    if (guessedWord.find('_') == std::string::npos) {\n        std::cout << \"Congratulations! You've guessed the word: \" << word << std::endl;\n    } else {\n        std::cout << \"Sorry, you've run out of attempts. The word was: \" << word << std::endl;\n    }\n}\n\nint main() {\n    // Seed the random number generator\n    srand(time(0));\n    \n    // Welcome message\n    std::cout << \"Welcome to Hangman!\" << std::endl;\n    std::cout << \"Try to guess the word by suggesting letters.\" << std::endl;\n    std::cout << \"You have 6 attempts to guess the word correctly.\" << std::endl;\n    std::cout << \"Enter one letter at a time.\" << std::endl;\n    std::cout << \"Good luck!\" << std::endl;\n    \n    // Game loop\n    do {\n        playHangman();\n        char playAgain;\n        std::cout << \"Play again? (y/n): \";\n        std::cin >> playAgain;\n    } while (tolower(playAgain) == 'y');\n    \n    return 0;\n}\n```\n\n### Explanation\n\n1. **Word List and Random Selection**:\n   - A vector `wordList` contains the words the player can guess.\n   - A random word is selected using `rand() % wordList.size()`.\n\n2. **Game State Management**:\n   - `guessedWord` is initialized with underscores representing unguessed letters.\n   - `guessedLetters` keeps track of letters already guessed by the player.\n   - `attempts` limits the number of incorrect guesses the player can make.\n\n3. **User Input Handling**:\n   - The player inputs one letter at a time, which is converted to lowercase.\n   - The program checks if the letter has already been guessed and handles it accordingly.\n\n4. **Win and Lose Conditions**:\n   - The game continues until the player has no attempts left or has guessed the entire word.\n   - Appropriate messages are displayed based on whether the player wins or loses.\n\n5. **Replay Option**:\n   - After the game ends, the player is asked if they want to play again.\n   - The game restarts with a new word if the player chooses to play again."
    }
]