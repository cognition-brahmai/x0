[
    {
        "role": "user",
        "content": "Develop a Python script that simulates the game of Tic Tac Toe. The game should be played against an AI opponent, which uses a simple strategy to determine its moves. The board state should be displayed in the console after each move."
    },
    {
        "role": "assistant",
        "content": "Alright, I'm going to attempt to create a Tic Tac Toe game in Python where a human player can play against an AI opponent. I'll need to think about how to represent the game board, handle player inputs, and implement a simple strategy for the AI.\n\nFirst, I need to decide how to represent the game board. A common way is to use a list of lists, like a 3x3 grid. Each cell can be empty, or occupied by 'X' or 'O'. I'll probably use a list of lists for this.\n\nNext, I need to handle user input. The player should be able to choose where to place their 'X' or 'O' by selecting a position on the grid. I need to make sure that the input is valid and that the chosen spot isn't already taken.\n\nFor the AI, I need a simple strategy. Maybe I can make it choose a random empty spot. That's the simplest way, but it won't be very smart. Maybe I can make it check if it can win in the next move, or block the player from winning. That sounds better.\n\nI should also think about how to check for a win or a draw. I need to check rows, columns, and diagonals to see if three in a row are the same symbol. For a draw, I need to check if all spots are filled without a win.\n\nLet me outline the steps:\n\n1. Create the game board.\n\n2. Decide who goes first.\n\n3. Display the board.\n\n4. If it's the player's turn:\n\na. Ask for the player's move.\n\nb. Update the board.\n\nc. Check for win or draw.\n\n5. If it's the AI's turn:\n\na. Choose a move based on simple strategy.\n\nb. Update the board.\n\nc. Check for win or draw.\n\n6. Repeat steps 3-5 until there's a winner or a draw.\n\nI need to define functions for each of these steps. Let's start by defining the board.\n\nI'll represent the board as a list of three lists, each containing three elements, initialized to empty spaces.\n\nLike this:\n\nboard = [\n\n[' ', ' ', ' '],\n\n[' ', ' ', ' '],\n\n[' ', ' ', ' ']\n\n]\n\nI need a function to display the board in the console. It should print the grid with rows and columns labeled appropriately.\n\nNext, I need a function to handle the player's move. The player should input the row and column where they want to place their symbol. I need to validate that the input is within bounds and that the spot is empty.\n\nFor the AI's move, I need to implement a simple strategy. At first, I'll make it choose a random empty spot. But later, I can enhance it to check for possible wins or blocks.\n\nI should also create a function to check for a win. This function should check all rows, columns, and diagonals to see if any of them have three matching symbols.\n\nSimilarly, I need a function to check for a draw. This would be the case when the board is full and there's no win.\n\nLet me think about the game loop. It should alternate between player and AI turns until there's a winner or a draw.\n\nI should also allow the player to choose their symbol, 'X' or 'O', and let the AI have the opposite symbol.\n\nLet me start by writing some pseudocode.\n\nInitialize board\n\nDisplay board\n\nAsk player to choose symbol 'X' or 'O'\n\nAssign the other symbol to AI\n\nDetermine who goes first\n\nWhile game not over:\n\nIf player's turn:\n\nAsk for player's move\n\nUpdate board\n\nCheck for win or draw\n\nElse:\n\nAI makes a move\n\nUpdate board\n\nCheck for win or draw\n\nDisplay board\n\nIf winner, congratulate winner\n\nElse, it's a draw\n\nThat's a basic outline. Now, let's think about implementing each part.\n\nFirst, initializing the board.\n\nI can define a function called create_board() that returns a 3x3 list of empty spaces.\n\nNext, displaying the board.\n\nI need to print the grid with rows and columns. Maybe something like:\n\nprint(\" --- --- ---\")\n\nfor row in board:\n\nprint(\"|\", row[0], \"|\", row[1], \"|\", row[2], \"|\")\n\nprint(\" --- --- ---\")\n\nThat should give a nice grid appearance.\n\nNow, asking the player to choose their symbol.\n\nI can ask the player to input 'X' or 'O', and assign the opposite to the AI.\n\nI need to validate that the input is either 'X' or 'O'.\n\nThen, determine who goes first.\n\nI can randomly choose who goes first using random.choice(['player', 'ai']).\n\nFor the player's move, I need to ask for row and column inputs.\n\nI should accept integers from 1 to 3 for row and column.\n\nI need to check if the spot is empty, and if not, ask again.\n\nFor the AI's move, initially, I'll make it choose a random empty spot.\n\nI can flatten the board into a list of 9 elements and choose a random empty one.\n\nBut later, I can enhance this strategy.\n\nTo check for a win, I need to check:\n\n- All rows for three matching symbols\n\n- All columns for three matching symbols\n\n- Both diagonals for three matching symbols\n\nI can write a function that checks all these conditions.\n\nTo check for a draw, I can check if the board is full and no win is present.\n\nI can count the number of empty spots; if it's zero and no win, it's a draw.\n\nNow, let's think about enhancing the AI strategy.\n\nA simple way is to implement the Minimax algorithm, but that might be overkill for Tic Tac Toe.\n\nSince Tic Tac Toe is a small game, I can implement a simple version of Minimax.\n\nBut to keep it simple, maybe I'll just make the AI check if it can win in the next move, or block the player from winning.\n\nSo, in the AI's turn, first check if it can win in the next move. If not, check if the player can win in the next move and block them. If neither, choose a random empty spot.\n\nThat should be sufficient for a basic AI.\n\nLet me outline the AI's decision process:\n\n1. Loop through all empty spots and see if placing the AI's symbol there would result in a win. If so, choose that spot.\n\n2. If no winning move, loop through all empty spots and see if placing the player's symbol there would result in a win for the player. If so, block that spot.\n\n3. If neither, choose a random empty spot.\n\nThis is a common and simple strategy for Tic Tac Toe AI.\n\nI need to write functions to check if a move results in a win.\n\nI can reuse the win checking function for this.\n\nSo, overall, the steps are:\n\n- Initialize the board\n\n- Display the board\n\n- Ask player to choose symbol\n\n- Assign the other symbol to AI\n\n- Determine who goes first\n\n- While the game is not over:\n\n- If it's player's turn:\n\n- Ask for player's move\n\n- Update the board\n\n- Check for win or draw\n\n- Else:\n\n- AI makes a move based on simple strategy\n\n- Update the board\n\n- Check for win or draw\n\n- Display the board\n\n- If there's a winner, congratulate them\n\n- Else, it's a draw\n\nI should also think about error handling, like invalid inputs from the player.\n\nFor example, if the player enters non-integer values for row and column, or chooses a spot that's already taken.\n\nI need to handle these cases gracefully and ask for input again.\n\nLet me think about how to structure the code.\n\nI can have the following functions:\n\n- create_board(): returns a 3x3 list of empty spaces\n\n- display_board(board): prints the board in the console\n\n- choose_symbol(): asks the player to choose 'X' or 'O', returns a tuple (player_symbol, ai_symbol)\n\n- check_win(board, symbol): checks if the given symbol has won\n\n- check_draw(board): checks if the board is full and no win\n\n- player_move(board, symbol): asks for player's move and updates the board\n\n- ai_move(board, ai_symbol, player_symbol): makes a move for the AI based on simple strategy and updates the board\n\n- main(): the main game loop\n\nI need to make sure that the board is updated correctly after each move and that the win and draw conditions are checked appropriately.\n\nLet me think about the data types.\n\nThe board is a list of three lists, each containing three strings: 'X', 'O', or ' '.\n\nThe symbols are strings 'X' and 'O'.\n\nI need to make sure that when updating the board, I'm using integers for row and column, ranging from 0 to 2 (since list indices start at 0).\n\nBut for player input, it's more natural to use 1-based indexing, so I'll need to convert the player's input from 1-3 to 0-2.\n\nNow, let's think about implementing the AI's move function.\n\nI need to implement the simple strategy I outlined earlier.\n\nFirst, loop through all empty spots and see if placing the AI's symbol there would result in a win.\n\nTo do this, I can loop through all empty spots, temporarily place the AI's symbol there, check if it's a win, and if so, choose that spot.\n\nIf no winning move is found, then loop through all empty spots again, temporarily place the player's symbol there, check if it's a win for the player, and if so, block that spot.\n\nIf neither, choose a random empty spot.\n\nI need to implement this logic carefully to avoid errors.\n\nI should also make sure that the AI doesn't try to place its symbol in an already occupied spot.\n\nNow, let's think about how to check for a win.\n\nI need to check:\n\n- All rows: if all three elements are the same and not empty\n\n- All columns: if all three elements are the same and not empty\n\n- Both diagonals: if all three elements are the same and not empty\n\nI can write a function that iterates through rows, columns, and diagonals and checks for this condition.\n\nSimilarly, to check for a draw, I can count the number of empty spots on the board. If there are no empty spots and no win, it's a draw.\n\nI need to make sure that the game loop continues until there's a win or a draw.\n\nNow, let's consider the main game loop.\n\nI can set a variable game_over to False initially.\n\nWhile not game_over:\n\nIf it's player's turn:\n\nAsk for player's move\n\nUpdate board\n\nCheck for win or draw\n\nIf winner or draw, set game_over to True\n\nElse:\n\nAI makes a move\n\nUpdate board\n\nCheck for win or draw\n\nIf winner or draw, set game_over to True\n\nDisplay the board after each move.\n\nAfter the loop, print the result: winner or draw.\n\nI should also think about how to handle invalid inputs from the player.\n\nFor example, if the player enters a non-integer value for row or column, or chooses a spot that's already occupied.\n\nI need to handle these cases with try-except blocks and prompt the player again.\n\nLet me think about the user interface.\n\nAfter each move, the board should be displayed, showing the latest update.\n\nI should provide clear instructions and feedback to the player.\n\nFor example, after the player makes a move, display the board, then show the AI's move, and display the board again.\n\nI should also indicate whose turn it is.\n\nNow, let's think about implementing the win check function.\n\nI can define a function check_win(board, symbol):\n\n# Check rows\n\nfor row in board:\n\nif all(cell == symbol for cell in row):\n\nreturn True\n\n# Check columns\n\nfor col in range(3):\n\nif all(board[row][col] == symbol for row in range(3)):\n\nreturn True\n\n# Check diagonals\n\nif all(board[i][i] == symbol for i in range(3)):\n\nreturn True\n\nif all(board[i][2 - i] == symbol for i in range(3)):\n\nreturn True\n\nreturn False\n\nThis should work.\n\nSimilarly, for check_draw(board):\n\nif any(' ' in row for row in board):\n\nreturn False\n\nelse:\n\nreturn True\n\nThis checks if there are any empty spots left.\n\nNow, for the player_move function.\n\nI need to ask the player for row and column inputs, convert them to integers, subtract 1 to get 0-based indices, and check if the spot is empty.\n\nI should handle cases where the input is not an integer or out of bounds.\n\nI can use a loop to keep asking until a valid input is provided.\n\nSomething like:\n\nwhile True:\n\ntry:\n\nrow = int(input(\"Enter row (1-3): \")) - 1\n\ncol = int(input(\"Enter column (1-3): \")) - 1\n\nif 0 <= row < 3 and 0 <= col < 3 and board[row][col] == ' ':\n\nboard[row][col] = symbol\n\nbreak\n\nelse:\n\nprint(\"Invalid spot. Choose again.\")\n\nexcept ValueError:\n\nprint(\"Enter numbers only.\")\n\nThis should handle most common errors.\n\nNow, for the ai_move function.\n\nI need to implement the simple strategy:\n\n1. Loop through all empty spots and see if placing AI's symbol there results in a win.\n\n2. If not, loop through all empty spots and see if placing player's symbol there results in a win for the player, and block it.\n\n3. If neither, choose a random empty spot.\n\nFirst, I need a way to find all empty spots on the board.\n\nI can iterate through the board and collect a list of (row, col) tuples where board[row][col] == ' '.\n\nThen, for each empty spot, temporarily place the AI's symbol there, check if it's a win, and if so, choose that spot.\n\nIf no winning move is found, repeat the process for the player's symbol to block potential wins.\n\nIf neither, choose a random empty spot.\n\nI need to make sure to revert the temporary placement after checking.\n\nWait, actually, since I'm only checking, I don't need to update the board permanently. I can just check the condition without modifying the board.\n\nWait, no. To check if placing the AI's symbol in a spot results in a win, I need to temporarily place it there, check for a win, and then remove it.\n\nSimilarly for blocking the player's win.\n\nI need to implement this carefully to avoid modifying the board accidentally.\n\nAlternatively, I can pass a copy of the board to the check_win function.\n\nBut that might be inefficient for such a small board, but since it's small, it's manageable.\n\nWait, actually, for such a small game, efficiency isn't a concern.\n\nSo, I can proceed with copying the board for checking purposes.\n\nLet me think about it.\n\nDefine a function get_empty_spots(board):\n\nempty_spots = []\n\nfor row in range(3):\n\nfor col in range(3):\n\nif board[row][col] == ' ':\n\nempty_spots.append((row, col))\n\nreturn empty_spots\n\nThen, in ai_move:\n\nempty_spots = get_empty_spots(board)\n\n# Check if AI can win\n\nfor spot in empty_spots:\n\nrow, col = spot\n\ntemp_board = [row[:] for row in board]  # Make a copy of the board\n\ntemp_board[row][col] = ai_symbol\n\nif check_win(temp_board, ai_symbol):\n\nboard[row][col] = ai_symbol\n\nreturn\n\n# Check if player can win and block\n\nfor spot in empty_spots:\n\nrow, col = spot\n\ntemp_board = [row[:] for row in board]\n\ntemp_board[row][col] = player_symbol\n\nif check_win(temp_board, player_symbol):\n\nboard[row][col] = ai_symbol\n\nreturn\n\n# Otherwise, choose a random empty spot\n\nimport random\n\nrow, col = random.choice(empty_spots)\n\nboard[row][col] = ai_symbol\n\nThis should work.\n\nI need to make sure that the board is updated correctly in the main game loop.\n\nNow, let's think about the main function.\n\nI need to:\n\n- Create the board\n\n- Display the board\n\n- Let the player choose their symbol\n\n- Determine who goes first\n\n- Enter the game loop\n\n- After each move, check for win or draw\n\n- Display the board after each move\n\n- Congratulate the winner or declare a draw\n\nI should also think about making the game replayable, but for now, I'll just make a single-game version.\n\nLet me outline the main function:\n\ndef main():\n\nboard = create_board()\n\ndisplay_board(board)\n\n(player_symbol, ai_symbol) = choose_symbol()\n\ncurrent_player = choose_first()  # 'player' or 'ai'\n\nwhile True:\n\nif current_player == 'player':\n\nprint(\"Your turn.\")\n\nplayer_move(board, player_symbol)\n\nif check_win(board, player_symbol):\n\ndisplay_board(board)\n\nprint(\"You win!\")\n\nbreak\n\nelif check_draw(board):\n\ndisplay_board(board)\n\nprint(\"It's a draw!\")\n\nbreak\n\ncurrent_player = 'ai'\n\nelse:\n\nprint(\"AI's turn.\")\n\nai_move(board, ai_symbol, player_symbol)\n\nif check_win(board, ai_symbol):\n\ndisplay_board(board)\n\nprint(\"AI wins!\")\n\nbreak\n\nelif check_draw(board):\n\ndisplay_board(board)\n\nprint(\"It's a draw!\")\n\nbreak\n\ncurrent_player = 'player'\n\ndisplay_board(board)\n\nThis seems reasonable.\n\nI need to implement all the helper functions accordingly.\n\nNow, let's think about testing the game.\n\nI need to play through several scenarios:\n\n- Player wins\n\n- AI wins\n\n- Draw\n\n- Invalid inputs from player\n\nI should make sure that the AI doesn't make illegal moves, and that the game correctly identifies wins and draws.\n\nI should also test edge cases, like choosing the only remaining spot to block a win.\n\nAdditionally, I can think about making the AI's strategy a bit smarter, but for now, the simple strategy should suffice.\n\nI should also consider adding comments to the code for clarity and readability.\n\nNow, I'll proceed to implement the code based on this plan.\n\n## Final Solution\nTo create a Tic Tac Toe game in Python where a human player can play against an AI opponent, we need to handle several aspects including the game board representation, user input, AI decision-making, and game state checks. Below is a complete Python script that accomplishes this.\n\n### Approach\n\n1. **Game Board Representation**: Use a list of lists to represent the 3x3 Tic Tac Toe board.\n2. **User Input Handling**: Ensure the player provides valid inputs for their moves and handle any invalid inputs gracefully.\n3. **AI Strategy**: Implement a simple AI that first checks for a winning move, then blocks the player's winning move, and finally chooses a random empty spot.\n4. **Game State Checks**: Functions to check for winning conditions and draw.\n\n### Solution Code\n\n```python\nimport random\n\ndef create_board():\n    return [[' ' for _ in range(3)] for _ in range(3)]\n\ndef display_board(board):\n    for row in board:\n        print(\"|\".join(row))\n        print(\"-\" * 5)\n\ndef choose_symbol():\n    symbol = input(\"Choose 'X' or 'O': \").upper()\n    while symbol not in ['X', 'O']:\n        symbol = input(\"Invalid input. Choose 'X' or 'O': \").upper()\n    return (symbol, 'O' if symbol == 'X' else 'X')\n\ndef check_win(board, symbol):\n    # Check rows\n    for row in board:\n        if all(cell == symbol for cell in row):\n            return True\n    # Check columns\n    for col in range(3):\n        if all(board[row][col] == symbol for row in range(3)):\n            return True\n    # Check diagonals\n    if all(board[i][i] == symbol for i in range(3)):\n        return True\n    if all(board[i][2 - i] == symbol for i in range(3)):\n        return True\n    return False\n\ndef check_draw(board):\n    return all(all(cell != ' ' for cell in row) for row in board)\n\ndef player_move(board, symbol):\n    while True:\n        try:\n            row = int(input(\"Enter row (1-3): \")) - 1\n            col = int(input(\"Enter column (1-3): \")) - 1\n            if 0 <= row < 3 and 0 <= col < 3 and board[row][col] == ' ':\n                board[row][col] = symbol\n                break\n            else:\n                print(\"Invalid spot. Choose again.\")\n        except ValueError:\n            print(\"Enter numbers only.\")\n\ndef get_empty_spots(board):\n    return [(row, col) for row in range(3) for col in range(3) if board[row][col] == ' ']\n\ndef ai_move(board, ai_symbol, player_symbol):\n    empty_spots = get_empty_spots(board)\n    # Check if AI can win\n    for spot in empty_spots:\n        row, col = spot\n        temp_board = [list(row) for row in board]\n        temp_board[row][col] = ai_symbol\n        if check_win(temp_board, ai_symbol):\n            board[row][col] = ai_symbol\n            return\n    # Check if player can win and block\n    for spot in empty_spots:\n        row, col = spot\n        temp_board = [list(row) for row in board]\n        temp_board[row][col] = player_symbol\n        if check_win(temp_board, player_symbol):\n            board[row][col] = ai_symbol\n            return\n    # Choose a random empty spot\n    row, col = random.choice(empty_spots)\n    board[row][col] = ai_symbol\n\ndef choose_first():\n    return random.choice(['player', 'ai'])\n\ndef main():\n    board = create_board()\n    display_board(board)\n    (player_symbol, ai_symbol) = choose_symbol()\n    current_player = choose_first()\n    while True:\n        if current_player == 'player':\n            print(\"Your turn.\")\n            player_move(board, player_symbol)\n            if check_win(board, player_symbol):\n                display_board(board)\n                print(\"You win!\")\n                break\n            elif check_draw(board):\n                display_board(board)\n                print(\"It's a draw!\")\n                break\n            current_player = 'ai'\n        else:\n            print(\"AI's turn.\")\n            ai_move(board, ai_symbol, player_symbol)\n            if check_win(board, ai_symbol):\n                display_board(board)\n                print(\"AI wins!\")\n                break\n            elif check_draw(board):\n                display_board(board)\n                print(\"It's a draw!\")\n                break\n            current_player = 'player'\n        display_board(board)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation\n\n1. **Board Creation and Display**: The board is initialized as a 3x3 grid of spaces and displayed in a formatted manner.\n2. **Symbol Selection**: The player chooses to be 'X' or 'O', and the AI is assigned the opposite symbol.\n3. **Win and Draw Checks**: Functions to check for winning conditions in rows, columns, and diagonals, and to check for a draw.\n4. **Player Moves**: The player inputs row and column for their move, with input validation.\n5. **AI Moves**: The AI tries to win, blocks the player from winning, or chooses a random empty spot.\n6. **Game Loop**: Alternates between player and AI turns, checks for win or draw after each move, and displays the board accordingly.\n\nThis script provides a complete Tic Tac Toe game experience against a simple AI opponent in the console."
    }
]