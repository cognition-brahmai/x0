[
    {
        "role": "user",
        "content": "Implement a C++ program that simulates a simple chat server using sockets. The server should accept multiple client connections, broadcast messages received from one client to all other connected clients, and handle client disconnections gracefully.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Implementing a chat server in C++ using sockets involves several steps, including setting up a server socket, handling multiple client connections, broadcasting messages, and managing client disconnections. Below is a simple implementation using the Berkeley sockets API.\n\n### Server Code\n\n```cpp\n#include <iostream>\n#include <string>\n#include <vector>\n#include <thread>\n#include <mutex>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nstd::vector<int> client_socks;\nstd::mutex socks_mutex;\n\nvoid broadcast(int sender_sock, const std::string& message) {\n    std::lock_guard<std::mutex> lock(socks_mutex);\n    for (int sock : client_socks) {\n        if (sock != sender_sock) {\n            send(sock, message.c_str(), message.size(), 0);\n        }\n    }\n}\n\nvoid handle_client(int client_sock) {\n    char buffer[1024];\n    while (true) {\n        ssize_t bytes_received = recv(client_sock, buffer, sizeof(buffer), 0);\n        if (bytes_received <= 0) {\n            // Client disconnected\n            std::lock_guard<std::mutex> lock(socks_mutex);\n            auto it = std::find(client_socks.begin(), client_socks.end(), client_sock);\n            if (it != client_socks.end()) {\n                client_socks.erase(it);\n            }\n            close(client_sock);\n            break;\n        }\n        buffer[bytes_received] = '\\0';\n        std::string message = \"Client \" + std::to_string(client_sock) + \": \" + buffer;\n        broadcast(client_sock, message);\n    }\n}\n\nint main() {\n    int server_sock = socket(AF_INET, SOCK_STREAM, 0);\n    if (server_sock == -1) {\n        std::cerr << \"Could not create socket\" << std::endl;\n        return 1;\n    }\n\n    sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(12345);\n    server_addr.sin_addr.s_addr = INADDR_ANY;\n\n    if (bind(server_sock, (sockaddr*)&server_addr, sizeof(server_addr)) == -1) {\n        std::cerr << \"Bind failed\" << std::endl;\n        close(server_sock);\n        return 1;\n    }\n\n    if (listen(server_sock, 3) == -1) {\n        std::cerr << \"Listen failed\" << std::endl;\n        close(server_sock);\n        return 1;\n    }\n\n    std::cout << \"Server listening on port 12345\" << std::endl;\n\n    while (true) {\n        sockaddr_in client_addr;\n        socklen_t client_size = sizeof(client_addr);\n        int client_sock = accept(server_sock, (sockaddr*)&client_addr, &client_size);\n        if (client_sock == -1) {\n            std::cerr << \"Accept failed\" << std::endl;\n            continue;\n        }\n\n        std::lock_guard<std::mutex> lock(socks_mutex);\n        client_socks.push_back(client_sock);\n\n        std::thread client_thread(handle_client, client_sock);\n        client_thread.detach();\n\n        std::cout << \"Client connected: \" << inet_ntoa(client_addr.sin_addr) << \":\" << ntohs(client_addr.sin_port) << std::endl;\n    }\n\n    close(server_sock);\n    return 0;\n}\n```\n\n### Explanation\n\n1. **Socket Setup**:\n   - Create a server socket using `socket(AF_INET, SOCK_STREAM, 0)`.\n   - Bind the server socket to a port (e.g., 12345) and listen for incoming connections.\n\n2. **Handling Multiple Clients**:\n   - Use `accept` to accept incoming client connections.\n   - For each client, create a new thread to handle communication using `handle_client`.\n\n3. **Broadcasting Messages**:\n   - When a message is received from a client, broadcast it to all other connected clients using the `broadcast` function.\n\n4. **Handling Disconnections**:\n   - If a client disconnects (indicated by `recv` returning 0 or -1), remove the client socket from the list and close the socket.\n\n### Client Code\n\nTo test the server, you can use a simple TCP client. Here's an example client in C++:\n\n```cpp\n#include <iostream>\n#include <thread>\n#include <unistd.h>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n\nvoid read_from_server(int sock) {\n    char buffer[1024];\n    while (true) {\n        ssize_t bytes_received = recv(sock, buffer, sizeof(buffer), 0);\n        if (bytes_received <= 0) {\n            break;\n        }\n        buffer[bytes_received] = '\\0';\n        std::cout << buffer << std::endl;\n    }\n}\n\nint main() {\n    int sock = socket(AF_INET, SOCK_STREAM, 0);\n    if (sock == -1) {\n        std::cerr << \"Could not create socket\" << std::endl;\n        return 1;\n    }\n\n    sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(12345);\n    inet_pton(AF_INET, \"127.0.0.1\", &server_addr.sin_addr);\n\n    if (connect(sock, (sockaddr*)&server_addr, sizeof(server_addr)) == -1) {\n        std::cerr << \"Connect failed\" << std::endl;\n        close(sock);\n        return 1;\n    }\n\n    std::thread reader(read_from_server, sock);\n    reader.detach();\n\n    std::string line;\n    while (std::getline(std::cin, line)) {\n        send(sock, line.c_str(), line.size(), 0);\n    }\n\n    close(sock);\n    return 0;\n}\n```\n\n### Explanation\n\n1. **Connecting to Server**:\n   - Create a socket and connect to the server at `127.0.0.1:12345`.\n\n2. **Reading from Server**:\n   - In a separate thread, read messages from the server and print them to the console.\n\n3. **Sending Messages**:\n   - Read input from the console and send it to the server.\n\nThis simple chat server allows multiple clients to connect, send messages, and receive messages from other clients. It handles client disconnections gracefully by removing disconnected clients from the list and continuing to serve other clients."
    }
]