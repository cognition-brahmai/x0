[
    {
        "role": "user",
        "content": "Develop a Python program that performs image processing tasks (e.g., resizing, cropping, rotating) using the Pillow library. The user should be able to provide an input image file and specify the desired operations through command-line arguments. PLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Alright, I've got this task to create a Python program that does image processing using the Pillow library. The program should let users resize, crop, or rotate images, and they should be able to specify these operations using command-line arguments. Sounds straightforward, but I need to make sure I cover all the bases.\n\nFirst things first, I need to make sure I have Pillow installed. I can install it using pip if I don't have it already. So, in the terminal, it would be something like `pip install Pillow`. I should probably include this in the program's documentation so that users know to install it if they don't have it.\n\nNext, I need to think about how the user will interact with the program. Since it's through the command line, I'll need to use sys module to handle arguments. But handling arguments can get messy, so maybe I should use argparse module instead. Argparse is better for creating user-friendly command-line interfaces. It can also automatically generate help messages, which is useful.\n\nSo, I'll import argparse and set up the argument parser. The program should at least take the input image file path and the operation to perform. Then, depending on the operation, it might need additional parameters. For example, for resizing, it needs the new width and height; for cropping, it needs the coordinates of the crop box; for rotating, it needs the rotation angle.\n\nLet me think about the operations one by one.\n\n1. Resizing: The user provides the new width and height. I need to make sure that the new dimensions are integers and positive. I should also think about whether to keep the aspect ratio or not. Maybe I'll add an option to keep the aspect ratio if only one dimension is provided.\n\n2. Cropping: The user needs to specify the crop box, which is a tuple of four integers: left, upper, right, lower. I need to ensure that these values make sense and that the crop box is within the image boundaries.\n\n3. Rotating: The user specifies the rotation angle in degrees. I should allow for both positive and negative angles, as they represent clockwise and counterclockwise rotations, respectively.\n\nI should also think about the output file name. Maybe I can have an option for the user to specify the output file path, or else default to something like \"output.jpg\".\n\nNow, about handling the image operations using Pillow. I'll need to import the Image module from Pillow. Then, based on the operation specified, I'll call the corresponding method: resize for resizing, crop for cropping, and rotate for rotating.\n\nI should also handle any errors that might occur, like invalid file paths, incorrect parameter values, or issues with the image itself.\n\nLet me sketch a rough structure of the program in my mind.\n\n- Parse command-line arguments using argparse.\n\n- Validate the input file path to ensure it exists and is an image file.\n\n- Based on the operation specified, perform the corresponding image processing task.\n\n- Save the processed image to the specified output file path or the default one.\n\n- Handle any exceptions that might occur during these steps and provide meaningful error messages.\n\nI should also consider adding some help texts and examples in the argparse setup so that users know how to use the program correctly.\n\nLet me start by setting up the argparse parser. I'll define the following arguments:\n\n- --input or -i: Path to the input image file (required).\n\n- --operation or -o: The operation to perform (choices: resize, crop, rotate) (required).\n\nThen, depending on the operation, I'll have sub-arguments:\n\nFor resize:\n\n- --width or -w: New width (integer).\n\n- --height or -h: New height (integer).\n\nOptionally, I can have a flag to keep the aspect ratio if only one dimension is provided.\n\nFor crop:\n\n- --left or -l: Left coordinate of the crop box.\n\n- --upper or -u: Upper coordinate of the crop box.\n\n- --right or -r: Right coordinate of the crop box.\n\n- --lower or -t: Lower coordinate of the crop box.\n\nFor rotate:\n\n- --angle or -a: Rotation angle in degrees.\n\nAdditionally, I'll have:\n\n- --output or -o: Path to the output image file (optional, default is \"output.jpg\").\n\nI need to make sure that the sub-arguments are required based on the operation chosen. For example, if the operation is resize, then width and height are required.\n\nIn argparse, I can use mutually exclusive groups or subparsers to handle this, but maybe the simplest way is to have all the arguments and validate them based on the operation.\n\nWait, perhaps using subparsers would be a cleaner approach. I can have a subparser for each operation, and each subparser can have its own set of required arguments.\n\nYes, that sounds better. Let's try that.\n\nI'll create a top-level parser with required arguments for input and operation, and then have subparsers for each operation with their specific arguments.\n\nHere's a rough outline:\n\nimport argparse\n\nimport sys\n\nfrom PIL import Image\n\ndef main():\n\nparser = argparse.ArgumentParser(description=\"Image processing tool using Pillow.\")\n\nparser.add_argument(\"-i\", \"--input\", required=True, help=\"Path to the input image file.\")\n\nparser.add_argument(\"-o\", \"--operation\", required=True, choices=[\"resize\", \"crop\", \"rotate\"], help=\"Operation to perform.\")\n\nsubparsers = parser.add_subparsers(dest=\"operation\")\n\n# Subparser for resize\n\nresize_parser = subparsers.add_parser(\"resize\")\n\nresize_parser.add_argument(\"-w\", \"--width\", type=int, required=True, help=\"New width.\")\n\nresize_parser.add_argument(\"-h\", \"--height\", type=int, required=True, help=\"New height.\")\n\n# Subparser for crop\n\ncrop_parser = subparsers.add_parser(\"crop\")\n\ncrop_parser.add_argument(\"-l\", \"--left\", type=int, required=True, help=\"Left coordinate.\")\n\ncrop_parser.add_argument(\"-u\", \"--upper\", type=int, required=True, help=\"Upper coordinate.\")\n\ncrop_parser.add_argument(\"-r\", \"--right\", type=int, required=True, help=\"Right coordinate.\")\n\ncrop_parser.add_argument(\"-t\", \"--lower\", type=int, required=True, help=\"Lower coordinate.\")\n\n# Subparser for rotate\n\nrotate_parser = subparsers.add_parser(\"rotate\")\n\nrotate_parser.add_argument(\"-a\", \"--angle\", type=float, required=True, help=\"Rotation angle in degrees.\")\n\n# Common arguments\n\nparser.add_argument(\"-o\", \"--output\", default=\"output.jpg\", help=\"Path to the output image file.\")\n\nargs = parser.parse_args()\n\n# Rest of the code...\n\nif __name__ == \"__main__\":\n\nmain()\n\nThis way, based on the operation specified, the corresponding subparser will handle the additional arguments required for that operation.\n\nNow, inside the main function, after parsing the arguments, I need to perform the specified operation.\n\nFirst, I need to open the image using Pillow's Image.open() method.\n\nThen, based on the operation, I'll call the appropriate method.\n\nFor resizing:\n\nimage = Image.open(args.input)\n\nnew_size = (args.width, args.height)\n\nresized_image = image.resize(new_size)\n\nresized_image.save(args.output)\n\nFor cropping:\n\nimage = Image.open(args.input)\n\ncrop_box = (args.left, args.upper, args.right, args.lower)\n\ncropped_image = image.crop(crop_box)\n\ncropped_image.save(args.output)\n\nFor rotating:\n\nimage = Image.open(args.input)\n\nrotated_image = image.rotate(args.angle)\n\nrotated_image.save(args.output)\n\nSeems simple enough. But I need to handle some edge cases and ensure that the parameters make sense.\n\nFor resizing, I need to make sure that width and height are positive integers.\n\nFor cropping, I need to ensure that the crop box is within the image boundaries. I can get the image size using image.size and check if the crop box coordinates are within those bounds.\n\nFor rotating, the angle can be any float, positive or negative.\n\nAlso, I should allow the user to specify the resampling filter for resizing and rotating, but maybe that's optional for now.\n\nI should also think about preserving the image format. If the input image is a PNG, I should save the output in PNG; if JPEG, in JPEG, etc. So, maybe instead of hardcoding the output format in the filename, I should infer it from the input file extension.\n\nAlternatively, I can let Pillow handle the format based on the output file extension. According to the Pillow documentation, the save method infers the format from the file extension, so as long as the extension is correct, it should work.\n\nBut to make it more robust, maybe I should extract the file extension from the output file path and specify the format explicitly.\n\nWait, actually, Pillow automatically detects the format based on the output file extension, so it's probably fine to just provide the output file path.\n\nHowever, if the user specifies an output file path without an extension, I should handle that appropriately, maybe defaulting to JPEG or something.\n\nBut to keep it simple, I'll assume that the user provides a valid output file path with the desired extension.\n\nI should also handle cases where the input file does not exist or is not an image file.\n\nI can add try-except blocks to handle FileNotFoundError and PIL.UnidentifiedImageError.\n\nSimilarly, for cropping, if the crop box is out of bounds, Pillow will raise an IOError, so I need to catch that and provide a meaningful error message.\n\nLet me think about the sequence of operations:\n\n1. Parse command-line arguments.\n\n2. Open the input image file using Image.open().\n\n3. Perform the specified operation:\n\n- Resize: Call resize() with the new size.\n\n- Crop: Call crop() with the crop box.\n\n- Rotate: Call rotate() with the angle.\n\n4. Save the processed image to the output file path.\n\n5. Handle any exceptions that may occur at each step and provide user-friendly error messages.\n\nI should also consider adding some validation for the output file path, like ensuring that the directory exists and that the user has permission to write to it.\n\nAdditionally, I can add some verbosity or logging to inform the user about what's happening, like confirming that the image was processed and saved successfully.\n\nLet me also think about how to run the program. It should be a script that users can run from the command line, providing the necessary arguments.\n\nFor example:\n\npython image_processor.py -i input.jpg -o resize -w 800 -h 600 -o output.jpg\n\nOr:\n\npython image_processor.py -i input.jpg -o crop -l 100 -u 100 -r 300 -t 300 -o cropped.jpg\n\nOr:\n\npython image_processor.py -i input.jpg -o rotate -a 90 -o rotated.jpg\n\nI should also consider adding a --help or -h option to display usage information and examples.\n\nArgparse automatically generates help messages based on the argument definitions, so that should cover it.\n\nI should also think about adding version information or author information, but that's optional.\n\nNow, let me start writing some code.\n\nFirst, I'll set up the argparse parser with the required arguments and subparsers for each operation.\n\nThen, I'll write the code to open the image, perform the operation, and save the output.\n\nI'll also add try-except blocks to handle potential errors.\n\nLet me sketch a basic structure:\n\nimport argparse\n\nfrom PIL import Image\n\ndef main():\n\nparser = argparse.ArgumentParser(description=\"Image processing tool using Pillow.\")\n\nparser.add_argument(\"-i\", \"--input\", required=True, help=\"Path to the input image file.\")\n\nparser.add_argument(\"-o\", \"--operation\", required=True, choices=[\"resize\", \"crop\", \"rotate\"], help=\"Operation to perform.\")\n\nsubparsers = parser.add_subparsers(dest=\"operation\")\n\n# Subparser for resize\n\nresize_parser = subparsers.add_parser(\"resize\")\n\nresize_parser.add_argument(\"-w\", \"--width\", type=int, required=True, help=\"New width.\")\n\nresize_parser.add_argument(\"-h\", \"--height\", type=int, required=True, help=\"New height.\")\n\n# Subparser for crop\n\ncrop_parser = subparsers.add_parser(\"crop\")\n\ncrop_parser.add_argument(\"-l\", \"--left\", type=int, required=True, help=\"Left coordinate.\")\n\ncrop_parser.add_argument(\"-u\", \"--upper\", type=int, required=True, help=\"Upper coordinate.\")\n\ncrop_parser.add_argument(\"-r\", \"--right\", type=int, required=True, help=\"Right coordinate.\")\n\ncrop_parser.add_argument(\"-t\", \"--lower\", type=int, required=True, help=\"Lower coordinate.\")\n\n# Subparser for rotate\n\nrotate_parser = subparsers.add_parser(\"rotate\")\n\nrotate_parser.add_argument(\"-a\", \"--angle\", type=float, required=True, help=\"Rotation angle in degrees.\")\n\n# Common arguments\n\nparser.add_argument(\"-o\", \"--output\", default=\"output.jpg\", help=\"Path to the output image file.\")\n\nargs = parser.parse_args()\n\ntry:\n\nimage = Image.open(args.input)\n\nif args.operation == \"resize\":\n\nnew_size = (args.width, args.height)\n\nresized_image = image.resize(new_size)\n\nresized_image.save(args.output)\n\nprint(f\"Image resized to {new_size} and saved to {args.output}\")\n\nelif args.operation == \"crop\":\n\ncrop_box = (args.left, args.upper, args.right, args.lower)\n\ncropped_image = image.crop(crop_box)\n\ncropped_image.save(args.output)\n\nprint(f\"Image cropped to {crop_box} and saved to {args.output}\")\n\nelif args.operation == \"rotate\":\n\nrotated_image = image.rotate(args.angle)\n\nrotated_image.save(args.output)\n\nprint(f\"Image rotated by {args.angle} degrees and saved to {args.output}\")\n\nelse:\n\nprint(\"Invalid operation specified.\")\n\nexcept FileNotFoundError:\n\nprint(f\"Error: Input file {args.input} not found.\")\n\nexcept IOError as e:\n\nprint(f\"Error processing image: {e}\")\n\nif __name__ == \"__main__\":\n\nmain()\n\nThis is a basic structure. I need to test this to see if it works.\n\nLet me think about potential issues.\n\n1. If the input file path is incorrect or the file doesn't exist, FileNotFoundError will be raised, and I'm handling that.\n\n2. If the input file is not an image, PIL.UnidentifiedImageError will be raised when trying to open it. I should handle that specifically.\n\n3. If the crop box is out of bounds, Pillow will raise an IOError. I should catch that and inform the user to adjust the crop box coordinates.\n\n4. If the output directory doesn't exist or the user doesn't have permission to write to it, IOError will be raised when saving the file. I should handle that as well.\n\nLet me update the exception handling to cover these cases.\n\nimport argparse\n\nfrom PIL import Image\n\ndef main():\n\nparser = argparse.ArgumentParser(description=\"Image processing tool using Pillow.\")\n\nparser.add_argument(\"-i\", \"--input\", required=True, help=\"Path to the input image file.\")\n\nparser.add_argument(\"-o\", \"--operation\", required=True, choices=[\"resize\", \"crop\", \"rotate\"], help=\"Operation to perform.\")\n\nsubparsers = parser.add_subparsers(dest=\"operation\")\n\n# Subparser for resize\n\nresize_parser = subparsers.add_parser(\"resize\")\n\nresize_parser.add_argument(\"-w\", \"--width\", type=int, required=True, help=\"New width.\")\n\nresize_parser.add_argument(\"-h\", \"--height\", type=int, required=True, help=\"New height.\")\n\n# Subparser for crop\n\ncrop_parser = subparsers.add_parser(\"crop\")\n\ncrop_parser.add_argument(\"-l\", \"--left\", type=int, required=True, help=\"Left coordinate.\")\n\ncrop_parser.add_argument(\"-u\", \"--upper\", type=int, required=True, help=\"Upper coordinate.\")\n\ncrop_parser.add_argument(\"-r\", \"--right\", type=int, required=True, help=\"Right coordinate.\")\n\ncrop_parser.add_argument(\"-t\", \"--lower\", type=int, required=True, help=\"Lower coordinate.\")\n\n# Subparser for rotate\n\nrotate_parser = subparsers.add_parser(\"rotate\")\n\nrotate_parser.add_argument(\"-a\", \"--angle\", type=float, required=True, help=\"Rotation angle in degrees.\")\n\n# Common arguments\n\nparser.add_argument(\"-o\", \"--output\", default=\"output.jpg\", help=\"Path to the output image file.\")\n\nargs = parser.parse_args()\n\ntry:\n\nimage = Image.open(args.input)\n\nif args.operation == \"resize\":\n\nnew_size = (args.width, args.height)\n\nresized_image = image.resize(new_size)\n\nresized_image.save(args.output)\n\nprint(f\"Image resized to {new_size} and saved to {args.output}\")\n\nelif args.operation == \"crop\":\n\ncrop_box = (args.left, args.upper, args.right, args.lower)\n\ncropped_image = image.crop(crop_box)\n\ncropped_image.save(args.output)\n\nprint(f\"Image cropped to {crop_box} and saved to {args.output}\")\n\nelif args.operation == \"rotate\":\n\nrotated_image = image.rotate(args.angle)\n\nrotated_image.save(args.output)\n\nprint(f\"Image rotated by {args.angle} degrees and saved to {args.output}\")\n\nelse:\n\nprint(\"Invalid operation specified.\")\n\nexcept FileNotFoundError:\n\nprint(f\"Error: Input file {args.input} not found.\")\n\nexcept IOError as e:\n\nif \"cannot identify image file\" in str(e):\n\nprint(f\"Error: {args.input} is not a valid image file.\")\n\nelif \"decoder zip not available\" in str(e):\n\nprint(\"Error: Image format not supported. Try a different image file.\")\n\nelse:\n\nprint(f\"Error processing image: {e}\")\n\nexcept Exception as e:\n\nprint(f\"An error occurred: {e}\")\n\nif __name__ == \"__main__\":\n\nmain()\n\nThis should cover most of the common errors.\n\nI should also think about adding some validation for the crop box coordinates to ensure they are within the image boundaries before performing the crop operation. That way, I can provide more specific error messages.\n\nI can get the image size using image.size, which returns a tuple of width and height. Then, I can check if the crop box coordinates are within these limits.\n\nSimilarly, for resizing, I can check if width and height are positive integers.\n\nLet me add some validation steps before performing the operations.\n\nFor resizing:\n\nif args.width <= 0 or args.height <= 0:\n\nprint(\"Error: Width and height must be positive integers.\")\n\nsys.exit(1)\n\nFor cropping:\n\nimg_width, img_height = image.size\n\nif not (0 <= args.left < args.right <= img_width and 0 <= args.upper < args.lower <= img_height):\n\nprint(\"Error: Invalid crop box coordinates. Ensure that left < right and upper < lower within image boundaries.\")\n\nsys.exit(1)\n\nFor rotating, no specific validation is needed beyond what's already in place.\n\nI need to import sys to use sys.exit().\n\nLet me update the code accordingly.\n\nimport argparse\n\nimport sys\n\nfrom PIL import Image\n\ndef main():\n\nparser = argparse.ArgumentParser(description=\"Image processing tool using Pillow.\")\n\nparser.add_argument(\"-i\", \"--input\", required=True, help=\"Path to the input image file.\")\n\nparser.add_argument(\"-o\", \"--operation\", required=True, choices=[\"resize\", \"crop\", \"rotate\"], help=\"Operation to perform.\")\n\nsubparsers = parser.add_subparsers(dest=\"operation\")\n\n# Subparser for resize\n\nresize_parser = subparsers.add_parser(\"resize\")\n\nresize_parser.add_argument(\"-w\", \"--width\", type=int, required=True, help=\"New width.\")\n\nresize_parser.add_argument(\"-h\", \"--height\", type=int, required=True, help=\"New height.\")\n\n# Subparser for crop\n\ncrop_parser = subparsers.add_parser(\"crop\")\n\ncrop_parser.add_argument(\"-l\", \"--left\", type=int, required=True, help=\"Left coordinate.\")\n\ncrop_parser.add_argument(\"-u\", \"--upper\", type=int, required=True, help=\"Upper coordinate.\")\n\ncrop_parser.add_argument(\"-r\", \"--right\", type=int, required=True, help=\"Right coordinate.\")\n\ncrop_parser.add_argument(\"-t\", \"--lower\", type=int, required=True, help=\"Lower coordinate.\")\n\n# Subparser for rotate\n\nrotate_parser = subparsers.add_parser(\"rotate\")\n\nrotate_parser.add_argument(\"-a\", \"--angle\", type=float, required=True, help=\"Rotation angle in degrees.\")\n\n# Common arguments\n\nparser.add_argument(\"-o\", \"--output\", default=\"output.jpg\", help=\"Path to the output image file.\")\n\nargs = parser.parse_args()\n\ntry:\n\nimage = Image.open(args.input)\n\nif args.operation == \"resize\":\n\nif args.width <= 0 or args.height <= 0:\n\nprint(\"Error: Width and height must be positive integers.\")\n\nsys.exit(1)\n\nnew_size = (args.width, args.height)\n\nresized_image = image.resize(new_size)\n\nresized_image.save(args.output)\n\nprint(f\"Image resized to {new_size} and saved to {args.output}\")\n\nelif args.operation == \"crop\":\n\nimg_width, img_height = image.size\n\nif not (0 <= args.left < args.right <= img_width and 0 <= args.upper < args.lower <= img_height):\n\nprint(\"Error: Invalid crop box coordinates. Ensure that left < right and upper < lower within image boundaries.\")\n\nsys.exit(1)\n\ncrop_box = (args.left, args.upper, args.right, args.lower)\n\ncropped_image = image.crop(crop_box)\n\ncropped_image.save(args.output)\n\nprint(f\"Image cropped to {crop_box} and saved to {args.output}\")\n\nelif args.operation == \"rotate\":\n\nrotated_image = image.rotate(args.angle)\n\nrotated_image.save(args.output)\n\nprint(f\"Image rotated by {args.angle} degrees and saved to {args.output}\")\n\nelse:\n\nprint(\"Invalid operation specified.\")\n\nexcept FileNotFoundError:\n\nprint(f\"Error: Input file {args.input} not found.\")\n\nexcept IOError as e:\n\nif \"cannot identify image file\" in str(e):\n\nprint(f\"Error: {args.input} is not a valid image file.\")\n\nelif \"decoder zip not available\" in str(e):\n\nprint(\"Error: Image format not supported. Try a different image file.\")\n\nelse:\n\nprint(f\"Error processing image: {e}\")\n\nexcept Exception as e:\n\nprint(f\"An error occurred: {e}\")\n\nif __name__ == \"__main__\":\n\nmain()\n\nThis should cover the validation needs.\n\nI should also think about whether to allow overwriting of the output file if it already exists. Pillow's save method will overwrite the file by default, so I don't need to do anything special for that.\n\nAnother consideration is handling different image modes, like RGBA versus RGB. Pillow should handle this automatically, but I might want to preserve the original mode or convert it to a specific mode before saving.\n\nFor now, I'll assume that Pillow handles the image modes appropriately.\n\nI can also add more features, like adjusting brightness, contrast, or applying filters, but since the task is to perform basic operations, I'll keep it simple.\n\nI should test this program with different images and operations to ensure it works as expected.\n\nFor example:\n\n- Resize an image to a smaller size.\n\n- Resize an image to a larger size.\n\n- Crop a section from an image.\n\n- Rotate an image by a positive angle.\n\n- Rotate an image by a negative angle.\n\n- Provide invalid crop coordinates and see if it handles the error correctly.\n\n- Provide a non-existent input file and see if it handles the error correctly.\n\n- Provide a file that's not an image and see if it handles the error correctly.\n\nBy testing these scenarios, I can make sure that the program behaves as expected and provides useful error messages when something goes wrong.\n\nOnce I'm satisfied with the functionality, I can create a README file explaining how to use the program, including installation instructions, usage examples, and any requirements.\n\nThat should cover the task. Now, I'll proceed to write the code and test it.\n\n## Final Solution\nTo create a Python program that performs image processing tasks such as resizing, cropping, and rotating using the Pillow library, follow these steps:\n\n### Prerequisites\n- Ensure you have Python installed on your system.\n- Install the Pillow library using `pip install Pillow`.\n\n### Program Code\n\n```python\nimport argparse\nimport sys\nfrom PIL import Image\n\ndef main():\n    parser = argparse.ArgumentParser(description=\"Image processing tool using Pillow.\")\n    parser.add_argument(\"-i\", \"--input\", required=True, help=\"Path to the input image file.\")\n    parser.add_argument(\"-o\", \"--operation\", required=True, choices=[\"resize\", \"crop\", \"rotate\"], help=\"Operation to perform.\")\n    \n    subparsers = parser.add_subparsers(dest=\"operation\")\n    \n    # Subparser for resize\n    resize_parser = subparsers.add_parser(\"resize\")\n    resize_parser.add_argument(\"-w\", \"--width\", type=int, required=True, help=\"New width.\")\n    resize_parser.add_argument(\"-h\", \"--height\", type=int, required=True, help=\"New height.\")\n    \n    # Subparser for crop\n    crop_parser = subparsers.add_parser(\"crop\")\n    crop_parser.add_argument(\"-l\", \"--left\", type=int, required=True, help=\"Left coordinate.\")\n    crop_parser.add_argument(\"-u\", \"--upper\", type=int, required=True, help=\"Upper coordinate.\")\n    crop_parser.add_argument(\"-r\", \"--right\", type=int, required=True, help=\"Right coordinate.\")\n    crop_parser.add_argument(\"-t\", \"--lower\", type=int, required=True, help=\"Lower coordinate.\")\n    \n    # Subparser for rotate\n    rotate_parser = subparsers.add_parser(\"rotate\")\n    rotate_parser.add_argument(\"-a\", \"--angle\", type=float, required=True, help=\"Rotation angle in degrees.\")\n    \n    # Common arguments\n    parser.add_argument(\"-O\", \"--output\", default=\"output.jpg\", help=\"Path to the output image file.\")\n    \n    args = parser.parse_args()\n    \n    try:\n        image = Image.open(args.input)\n        \n        if args.operation == \"resize\":\n            if args.width <= 0 or args.height <= 0:\n                print(\"Error: Width and height must be positive integers.\")\n                sys.exit(1)\n            new_size = (args.width, args.height)\n            resized_image = image.resize(new_size)\n            resized_image.save(args.output)\n            print(f\"Image resized to {new_size} and saved to {args.output}\")\n        \n        elif args.operation == \"crop\":\n            img_width, img_height = image.size\n            if not (0 <= args.left < args.right <= img_width and 0 <= args.upper < args.lower <= img_height):\n                print(\"Error: Invalid crop box coordinates. Ensure that left < right and upper < lower within image boundaries.\")\n                sys.exit(1)\n            crop_box = (args.left, args.upper, args.right, args.lower)\n            cropped_image = image.crop(crop_box)\n            cropped_image.save(args.output)\n            print(f\"Image cropped to {crop_box} and saved to {args.output}\")\n        \n        elif args.operation == \"rotate\":\n            rotated_image = image.rotate(args.angle)\n            rotated_image.save(args.output)\n            print(f\"Image rotated by {args.angle} degrees and saved to {args.output}\")\n        \n        else:\n            print(\"Invalid operation specified.\")\n    \n    except FileNotFoundError:\n        print(f\"Error: Input file {args.input} not found.\")\n    except IOError as e:\n        if \"cannot identify image file\" in str(e):\n            print(f\"Error: {args.input} is not a valid image file.\")\n        elif \"decoder zip not available\" in str(e):\n            print(\"Error: Image format not supported. Try a different image file.\")\n        else:\n            print(f\"Error processing image: {e}\")\n    except Exception as e:\n        print(f\"An error occurred: {e}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Usage\n\n1. **Resize an image:**\n   ```sh\n   python image_processor.py -i input.jpg -o resize -w 800 -h 600 -O output.jpg\n   ```\n\n2. **Crop an image:**\n   ```sh\n   python image_processor.py -i input.jpg -o crop -l 100 -u 100 -r 300 -t 300 -O cropped.jpg\n   ```\n\n3. **Rotate an image:**\n   ```sh\n   python image_processor.py -i input.jpg -o rotate -a 90 -O rotated.jpg\n   ```\n\n### Explanation\n\n- **Argument Parsing:** Uses `argparse` to handle command-line arguments for different operations and their parameters.\n- **Image Operations:**\n  - **Resize:** Adjusts the image size to the specified width and height.\n  - **Crop:** Crops the image based on the provided coordinates.\n  - **Rotate:** Rotates the image by the specified angle in degrees.\n- **Error Handling:** Manages exceptions for file not found, invalid images, and incorrect coordinates, providing user-friendly error messages.\n- **Output:** Saves the processed image to the specified output path, defaulting to `output.jpg` if not specified."
    }
]