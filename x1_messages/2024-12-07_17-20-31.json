[
    {
        "role": "user",
        "content": "Design a Golang REST API that performs CRUD operations on a \"Product\" entity. The API should interact with a PostgreSQL database and include endpoints for creating, reading, updating, and deleting products. Additionally, implement pagination for listing products.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Designing a Golang REST API for CRUD operations on a \"Product\" entity involves several steps. We'll use Go's net/http package for handling HTTP requests and interactions with PostgreSQL will be managed using the database/sql package along with the pgx driver.\n\nFirst, make sure you have PostgreSQL installed and running. You'll need to create a database and a table for products. Here's a simple SQL script to create a products table:\n\n```sql\nCREATE TABLE products (\n    id SERIAL PRIMARY KEY,\n    name VARCHAR(255) NOT NULL,\n    price DECIMAL NOT NULL,\n    description TEXT\n);\n```\n\nNext, set up your Go environment and install the necessary packages:\n\n```bash\ngo get github.com/jackc/pgx/v4\ngo get github.com/gorilla/mux\n```\n\nHere's a basic outline of how your API might look:\n\n1. **Database Connection:**\n\nCreate a function to establish a connection to your PostgreSQL database.\n\n```go\nimport (\n    \"database/sql\"\n    \"log\"\n    \"github.com/jackc/pgx/v4/pgxpool\"\n)\n\nvar db *sql.DB\n\nfunc ConnectDB() {\n    connStr := \"postgresql://username:password@localhost/dbname?sslmode=disable\"\n    poolConfig, err := pgxpool.ParseConfig(connStr)\n    if err != nil {\n        log.Fatal(err)\n    }\n    pool, err := pgxpool.ConnectConfig(context.Background(), poolConfig)\n    if err != nil {\n        log.Fatal(err)\n    }\n    db = pool\n}\n```\n\n2. **Product Struct:**\n\nDefine a struct that matches your products table.\n\n```go\ntype Product struct {\n    ID          int    `json:\"id\"`\n    Name        string `json:\"name\"`\n    Price       float64 `json:\"price\"`\n    Description string `json:\"description\"`\n}\n```\n\n3. **CRUD Operations:**\n\nImplement functions for creating, reading, updating, and deleting products.\n\n- **Create Product:**\n\n```go\nfunc CreateProduct(product *Product) error {\n    sqlStatement := `INSERT INTO products (name, price, description) VALUES ($1, $2, $3) RETURNING id`\n    err := db.QueryRow(sqlStatement, product.Name, product.Price, product.Description).Scan(&product.ID)\n    if err != nil {\n        return err\n    }\n    return nil\n}\n```\n\n- **Get All Products with Pagination:**\n\n```go\nfunc GetProducts(page, pageSize int) ([]Product, error) {\n    offset := (page - 1) * pageSize\n    sqlStatement := `SELECT id, name, price, description FROM products LIMIT $1 OFFSET $2`\n    rows, err := db.Query(sqlStatement, pageSize, offset)\n    if err != nil {\n        return nil, err\n    }\n    defer rows.Close()\n    \n    var products []Product\n    for rows.Next() {\n        var product Product\n        err := rows.Scan(&product.ID, &product.Name, &product.Price, &product.Description)\n        if err != nil {\n            return nil, err\n        }\n        products = append(products, product)\n    }\n    return products, nil\n}\n```\n\n- **Get Single Product:**\n\n```go\nfunc GetProduct(id int) (*Product, error) {\n    sqlStatement := `SELECT id, name, price, description FROM products WHERE id=$1`\n    row := db.QueryRow(sqlStatement, id)\n    \n    var product Product\n    err := row.Scan(&product.ID, &product.Name, &product.Price, &product.Description)\n    if err != nil {\n        if err == sql.ErrNoRows {\n            return nil, nil // or handle as per your requirement\n        }\n        return nil, err\n    }\n    return &product, nil\n}\n```\n\n- **Update Product:**\n\n```go\nfunc UpdateProduct(product *Product) error {\n    sqlStatement := `UPDATE products SET name=$1, price=$2, description=$3 WHERE id=$4`\n    _, err := db.Exec(sqlStatement, product.Name, product.Price, product.Description, product.ID)\n    return err\n}\n```\n\n- **Delete Product:**\n\n```go\nfunc DeleteProduct(id int) error {\n    sqlStatement := `DELETE FROM products WHERE id=$1`\n    _, err := db.Exec(sqlStatement, id)\n    return err\n}\n```\n\n4. **HTTP Handlers:**\n\nUse Gorilla Mux for routing.\n\n- **Create Product:**\n\n```go\nfunc createProductHandler(w http.ResponseWriter, r *http.Request) {\n    var product Product\n    err := json.NewDecoder(r.Body).Decode(&product)\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusBadRequest)\n        return\n    }\n    err = CreateProduct(&product)\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n        return\n    }\n    json.NewEncoder(w).Encode(product)\n}\n```\n\n- **Get All Products:**\n\n```go\nfunc getProductsHandler(w http.ResponseWriter, r *http.Request) {\n    page, _ := strconv.Atoi(r.URL.Query().Get(\"page\"))\n    pageSize, _ := strconv.Atoi(r.URL.Query().Get(\"pageSize\"))\n    products, err := GetProducts(page, pageSize)\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n        return\n    }\n    json.NewEncoder(w).Encode(products)\n}\n```\n\n- **Get Single Product:**\n\n```go\nfunc getProductHandler(w http.ResponseWriter, r *http.Request) {\n    vars := mux.Vars(r)\n    id, err := strconv.Atoi(vars[\"id\"])\n    if err != nil {\n        http.Error(w, \"Invalid product ID\", http.StatusBadRequest)\n        return\n    }\n    product, err := GetProduct(id)\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n        return\n    }\n    if product == nil {\n        http.Error(w, \"Product not found\", http.StatusNotFound)\n        return\n    }\n    json.NewEncoder(w).Encode(product)\n}\n```\n\n- **Update Product:**\n\n```go\nfunc updateProductHandler(w http.ResponseWriter, r *http.Request) {\n    vars := mux.Vars(r)\n    id, err := strconv.Atoi(vars[\"id\"])\n    if err != nil {\n        http.Error(w, \"Invalid product ID\", http.StatusBadRequest)\n        return\n    }\n    var product Product\n    err = json.NewDecoder(r.Body).Decode(&product)\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusBadRequest)\n        return\n    }\n    product.ID = id\n    err = UpdateProduct(&product)\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n        return\n    }\n    json.NewEncoder(w).Encode(product)\n}\n```\n\n- **Delete Product:**\n\n```go\nfunc deleteProductHandler(w http.ResponseWriter, r *http.Request) {\n    vars := mux.Vars(r)\n    id, err := strconv.Atoi(vars[\"id\"])\n    if err != nil {\n        http.Error(w, \"Invalid product ID\", http.StatusBadRequest)\n        return\n    }\n    err = DeleteProduct(id)\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n        return\n    }\n    w.WriteHeader(http.StatusNoContent)\n}\n```\n\n5. **Routing:**\n\nSet up your routes using Gorilla Mux.\n\n```go\nfunc main() {\n    ConnectDB()\n    defer db.Close()\n    \n    router := mux.NewRouter()\n    router.HandleFunc(\"/products\", createProductHandler).Methods(\"POST\")\n    router.HandleFunc(\"/products\", getProductsHandler).Methods(\"GET\")\n    router.HandleFunc(\"/products/{id}\", getProductHandler).Methods(\"GET\")\n    router.HandleFunc(\"/products/{id}\", updateProductHandler).Methods(\"PUT\")\n    router.HandleFunc(\"/products/{id}\", deleteProductHandler).Methods(\"DELETE\")\n    \n    log.Fatal(http.ListenAndServe(\":8000\", router))\n}\n```\n\nThis is a basic implementation. In a production environment, you should consider adding error handling, input validation, and possibly using a more robust ORM or query builder. Also, ensure that your database connection is properly managed, especially in a high-concurrency scenario."
    }
]