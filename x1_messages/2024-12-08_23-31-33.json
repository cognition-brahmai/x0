[
    {
        "role": "user",
        "content": "Implement a C program that creates a child process using fork(). The parent process should send a string message to the child process through pipe communication. The child process receives the message, converts it to uppercase and sends it back to the parent process which then prints it."
    },
    {
        "role": "assistant",
        "content": "Implementing inter-process communication (IPC) in C using pipes and fork can be a bit tricky, but I'll guide you through it. We'll create a parent process that sends a string to a child process via a pipe, the child converts it to uppercase, and sends it back to the parent, which then prints it.\n\n### Approach\n\n1. **Create Pipes:** We need two pipes: one for the parent to write to the child, and another for the child to write back to the parent.\n2. **Fork a Child Process:** Use `fork()` to create a child process.\n3. **Redirect File Descriptors:** In both processes, close the unnecessary file descriptors of the pipes.\n4. **Write and Read from Pipes:** \n   - Parent writes the message to the child via the first pipe.\n   - Child reads the message, converts it to uppercase, and writes back via the second pipe.\n   - Parent reads the modified message from the second pipe and prints it.\n\n### Solution Code\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n\n#define BUFFER_SIZE 100\n\nint main() {\n    int fd1[2], fd2[2];\n    pid_t pid;\n    char buffer[BUFFER_SIZE];\n\n    // Step 1: Create two pipes\n    if (pipe(fd1) == -1 || pipe(fd2) == -1) {\n        perror(\"Pipe failed\");\n        exit(EXIT_FAILURE);\n    }\n\n    // Step 2: Fork a child process\n    pid = fork();\n    if (pid == -1) {\n        perror(\"Fork failed\");\n        exit(EXIT_FAILURE);\n    }\n\n    if (pid > 0) {\n        // Parent process\n        close(fd1[0]); // Close reading end of first pipe\n        close(fd2[1]); // Close writing end of second pipe\n\n        // Step 3: Write message to child via first pipe\n        const char *msg = \"Hello, Child!\";\n        write(fd1[1], msg, strlen(msg) + 1); // +1 for null terminator\n\n        // Step 4: Read the modified message from child via second pipe\n        read(fd2[0], buffer, BUFFER_SIZE);\n        printf(\"Parent received: %s\\n\", buffer);\n\n        close(fd1[1]);\n        close(fd2[0]);\n    } else {\n        // Child process\n        close(fd1[1]); // Close writing end of first pipe\n        close(fd2[0]); // Close reading end of second pipe\n\n        // Step 3: Read message from parent via first pipe\n        read(fd1[0], buffer, BUFFER_SIZE);\n\n        // Convert to uppercase\n        for (int i = 0; buffer[i]; i++) {\n            buffer[i] = toupper(buffer[i]);\n        }\n\n        // Step 4: Write the modified message back to parent via second pipe\n        write(fd2[1], buffer, strlen(buffer) + 1); // +1 for null terminator\n\n        close(fd1[0]);\n        close(fd2[1]);\n    }\n\n    return 0;\n}\n```\n\n### Explanation\n\n1. **Pipe Creation:** Two pipes are created using `pipe()`, one for each direction of communication.\n2. **Forking:** `fork()` is used to create a child process. The process ID (pid) determines whether the current execution is in the parent or child.\n3. **File Descriptor Management:** Unnecessary pipe ends are closed in both processes to prevent leaks and ensure proper communication.\n4. **Communication:**\n   - **Parent to Child:** The parent writes a string to the child via the first pipe.\n   - **Child to Parent:** The child reads the string, converts it to uppercase, and sends it back via the second pipe.\n   - **Parent Output:** The parent reads the modified string and prints it.\n\nThis setup ensures that the communication is bidirectional and that each process only uses the pipe ends it needs."
    }
]