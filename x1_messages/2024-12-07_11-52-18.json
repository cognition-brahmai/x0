[
    {
        "role": "user",
        "content": "In GoLang, write a RESTful API server that provides endpoints for CRUD (Create, Read, Update, Delete) operations on a collection of books. Each book should have attributes like title, author, publisher, and publication date. Use any lightweight database or even in-memory storage for this task. PLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Alright, I'm going to help you create a simple RESTful API server in GoLang that handles CRUD operations for a collection of books. We'll keep it straightforward and use an in-memory storage for simplicity.\n\nFirst, make sure you have Go installed on your machine. You can download it from [https://golang.org/dl/](https://golang.org/dl/).\n\n### Step 1: Project Setup\n\nCreate a new directory for your project:\n\n```bash\nmkdir book-api\ncd book-api\n```\n\nInitialize a new Go module:\n\n```bash\ngo mod init book-api\n```\n\n### Step 2: Define the Book Model\n\nCreate a `book.go` file to define the Book struct:\n\n```go\npackage model\n\ntype Book struct {\n\tID             string `json:\"id\"`\n\tTitle          string `json:\"title\"`\n\tAuthor         string `json:\"author\"`\n\tPublisher      string `json:\"publisher\"`\n\tPublicationDate string `json:\"publication_date\"`\n}\n```\n\n### Step 3: Implement In-Memory Storage\n\nCreate a `storage.go` file to handle data storage:\n\n```go\npackage storage\n\nimport (\n\t\"sync\"\n\t\"book-api/model\"\n)\n\ntype BookStorage struct {\n\tmu    sync.RWMutex\n\tbooks map[string]*model.Book\n}\n\nfunc NewBookStorage() *BookStorage {\n\treturn &BookStorage{\n\t\tbooks: make(map[string]*model.Book),\n\t}\n}\n\nfunc (s *BookStorage) CreateBook(book *model.Book) {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\ts.books[book.ID] = book\n}\n\nfunc (s *BookStorage) GetBook(id string) (*model.Book, bool) {\n\ts.mu.RLock()\n\tdefer s.mu.RUnlock()\n\tbook, exists := s.books[id]\n\tif exists {\n\t\treturn book, true\n\t}\n\treturn nil, false\n}\n\nfunc (s *BookStorage) GetAllBooks() []*model.Book {\n\ts.mu.RLock()\n\tdefer s.mu.RUnlock()\n\tvar books []*model.Book\n\tfor _, book := range s.books {\n\t\tbooks = append(books, book)\n\t}\n\treturn books\n}\n\nfunc (s *BookStorage) UpdateBook(id string, updates map[string]interface{}) (*model.Book, bool) {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\tbook, exists := s.books[id]\n\tif exists {\n\t\tfor key, value := range updates {\n\t\t\tswitch key {\n\t\t\tcase \"title\":\n\t\t\t\tbook.Title = value.(string)\n\t\t\tcase \"author\":\n\t\t\t\tbook.Author = value.(string)\n\t\t\tcase \"publisher\":\n\t\t\t\tbook.Publisher = value.(string)\n\t\t\tcase \"publication_date\":\n\t\t\t\tbook.PublicationDate = value.(string)\n\t\t\t}\n\t\t}\n\t\treturn book, true\n\t}\n\treturn nil, false\n}\n\nfunc (s *BookStorage) DeleteBook(id string) bool {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\t_, exists := s.books[id]\n\tdelete(s.books, id)\n\treturn exists\n}\n```\n\n### Step 4: Set Up the HTTP Server\n\nCreate a `server.go` file to set up the HTTP server and define the API endpoints:\n\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"net/http\"\n\t\"github.com/gorilla/mux\"\n\t\"book-api/model\"\n\t\"book-api/storage\"\n)\n\nvar bookStorage = storage.NewBookStorage()\n\nfunc main() {\n\tr := mux.NewRouter()\n\n\tr.HandleFunc(\"/books\", createBook).Methods(\"POST\")\n\tr.HandleFunc(\"/books\", getBooks).Methods(\"GET\")\n\tr.HandleFunc(\"/books/{id}\", getBook).Methods(\"GET\")\n\tr.HandleFunc(\"/books/{id}\", updateBook).Methods(\"PUT\")\n\tr.HandleFunc(\"/books/{id}\", deleteBook).Methods(\"DELETE\")\n\n\thttp.ListenAndServe(\":8000\", r)\n}\n\nfunc createBook(w http.ResponseWriter, r *http.Request) {\n\tvar book model.Book\n\terr := json.NewDecoder(r.Body).Decode(&book)\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n\t\treturn\n\t}\n\tbookStorage.CreateBook(&book)\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(w).Encode(book)\n}\n\nfunc getBooks(w http.ResponseWriter, r *http.Request) {\n\tbooks := bookStorage.GetAllBooks()\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(w).Encode(books)\n}\n\nfunc getBook(w http.ResponseWriter, r *http.Request) {\n\tid := mux.Vars(r)[\"id\"]\n\tbook, exists := bookStorage.GetBook(id)\n\tif !exists {\n\t\thttp.Error(w, \"Book not found\", http.StatusNotFound)\n\t\treturn\n\t}\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(w).Encode(book)\n}\n\nfunc updateBook(w http.ResponseWriter, r *http.Request) {\n\tid := mux.Vars(r)[\"id\"]\n\tvar updates map[string]interface{}\n\terr := json.NewDecoder(r.Body).Decode(&updates)\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n\t\treturn\n\t}\n\tbook, exists := bookStorage.UpdateBook(id, updates)\n\tif !exists {\n\t\thttp.Error(w, \"Book not found\", http.StatusNotFound)\n\t\treturn\n\t}\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(w).Encode(book)\n}\n\nfunc deleteBook(w http.ResponseWriter, r *http.Request) {\n\tid := mux.Vars(r)[\"id\"]\n\texists := bookStorage.DeleteBook(id)\n\tif !exists {\n\t\thttp.Error(w, \"Book not found\", http.StatusNotFound)\n\t\treturn\n\t}\n\tw.WriteHeader(http.StatusNoContent)\n}\n```\n\n### Step 5: Run the Server\n\nSave all the files and run the server:\n\n```bash\ngo run server.go\n```\n\nYour API server should now be running on [http://localhost:8000](http://localhost:8000).\n\n### Step 6: Test the API\n\nYou can use tools like Postman or curl to test the API endpoints.\n\n- **Create a book (POST /books):**\n\n```bash\ncurl -X POST http://localhost:8000/books -H \"Content-Type: application/json\" -d '{\n    \"id\": \"1\",\n    \"title\": \"Sample Book\",\n    \"author\": \"John Doe\",\n    \"publisher\": \"Sample Publisher\",\n    \"publication_date\": \"2023-01-01\"\n}'\n```\n\n- **Get all books (GET /books):**\n\n```bash\ncurl http://localhost:8000/books\n```\n\n- **Get a book by ID (GET /books/{id}):**\n\n```bash\ncurl http://localhost:8000/books/1\n```\n\n- **Update a book (PUT /books/{id}):**\n\n```bash\ncurl -X PUT http://localhost:8000/books/1 -H \"Content-Type: application/json\" -d '{\n    \"title\": \"Updated Sample Book\"\n}'\n```\n\n- **Delete a book (DELETE /books/{id}):**\n\n```bash\ncurl -X DELETE http://localhost:8000/books/1\n```\n\nThat's it! You've created a simple RESTful API server in GoLang for managing a collection of books using in-memory storage.\n\n### Additional Notes\n\n- **Error Handling:** Basic error handling is implemented, but you might want to enhance it based on your requirements.\n\n- **Data Validation:** Consider adding validation for the book fields to ensure data integrity.\n\n- **Database Integration:** For a production-level application, replace the in-memory storage with a proper database like PostgreSQL, MongoDB, etc.\n\n- **Middleware:** You can add middleware for logging, authentication, etc., using Gorilla Mux or other libraries.\n\n- **Documentation:** Use tools like Swagger to document your API endpoints.\n\nThis should give you a good starting point for building more complex API servers in GoLang."
    }
]