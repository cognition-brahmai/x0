[
    {
        "role": "user",
        "content": "Create a Java application that connects to a PostgreSQL database, reads data from multiple tables, and generates a report based on specified criteria. For example, given tables \"orders\", \"products\", and \"customers\", generate a report of all orders placed by customers in a specific city within a date range, along with product details.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Alright, I'm going to try to create a Java application that connects to a PostgreSQL database and generates a report based on some criteria. The database has tables for orders, products, and customers, and I need to generate a report of orders placed by customers in a specific city within a certain date range, including product details.\n\nFirst, I need to set up the Java environment. I should make sure I have JDK installed and set up a new Java project. I might use an IDE like IntelliJ IDEA or Eclipse to make things easier.\n\nNext, I need to connect to the PostgreSQL database from Java. For that, I'll need the PostgreSQL JDBC driver. I can add it to my project dependencies. If I'm using Maven, I can add the dependency in the pom.xml file.\n\nLet me recall the JDBC steps:\n\n1. Load the JDBC driver.\n\n2. Establish a connection to the database.\n\n3. Create a statement or prepared statement.\n\n4. Execute the query.\n\n5. Process the result set.\n\n6. Close the resources.\n\nI need to read data from multiple tables: orders, products, and customers. So, I'll probably need to write a SQL query that joins these tables based on their relationships.\n\nAssuming the tables have the following structure:\n\n- customers: customer_id (primary key), name, city, ...\n\n- orders: order_id (primary key), customer_id (foreign key), order_date, ...\n\n- products: product_id (primary key), name, description, ...\n\n- order_items: order_id (foreign key), product_id (foreign key), quantity, price, ...\n\nWait, I think there might be an order_items table that connects orders and products, indicating which products are in which orders and their quantities.\n\nSo, I might need to join orders, customers, and order_items, and then products.\n\nLet me sketch a rough SQL query:\n\nSELECT o.order_id, c.name AS customer_name, p.name AS product_name, oi.quantity, oi.price\n\nFROM orders o\n\nJOIN customers c ON o.customer_id = c.customer_id\n\nJOIN order_items oi ON o.order_id = oi.order_id\n\nJOIN products p ON oi.product_id = p.product_id\n\nWHERE c.city = 'specified_city'\n\nAND o.order_date BETWEEN 'start_date' AND 'end_date';\n\nYes, that seems about right. I need to parameterize the city and date range in my Java code.\n\nIn Java, I'll need to get user input for the city and date range, or perhaps these could be passed as command-line arguments or configured in a properties file.\n\nFor handling dates, I should use java.time package, specifically LocalDate or LocalDateTime, depending on the precision needed.\n\nI need to make sure that the dates are parsed correctly and formatted to match the database's date format.\n\nOnce I have the SQL query ready with parameters, I'll use PreparedStatements to avoid SQL injection risks.\n\nAfter executing the query, I'll get a ResultSet that I need to iterate over to fetch the data.\n\nThen, I need to generate a report based on this data. The report could be a simple text file, or perhaps a PDF, or just printed to the console.\n\nFor simplicity, let's say I'll print it to the console first, and maybe later think about generating a file.\n\nSo, in the loop where I process the ResultSet, I'll print out the order details, customer name, product name, quantity, and price.\n\nI should also calculate totals, like the total amount for each order, and perhaps a grand total for all orders in the report.\n\nLet me think about error handling. What if the database connection fails? What if the query returns no results? I need to handle such scenarios gracefully.\n\nAlso, I should make sure to close the database resources properly, especially the ResultSet, Statement, and Connection, preferably using try-with-resources to ensure they are closed even if an exception occurs.\n\nLet me outline the steps in code:\n\n1. Load the JDBC driver.\n\n2. Establish a connection to the database using Connection.\n\n3. Create a PreparedStatement with the SQL query, incorporating parameters for city and date range.\n\n4. Set the parameters in the PreparedStatement.\n\n5. Execute the query and get the ResultSet.\n\n6. Process the ResultSet:\n\na. Iterate over the rows.\n\nb. For each row, print the order details, customer name, product name, quantity, and price.\n\nc. Calculate totals as needed.\n\n7. Close the resources.\n\nI should also consider logging instead of just printing to the console, but for simplicity, I'll stick with console output for now.\n\nLet me think about how to structure the Java classes. Maybe have a main class that handles the database connection and report generation.\n\nAlternatively, I could have a separate class for database operations and another for report generation, but for a simple application, keeping it in one class might be sufficient.\n\nI should also consider encapsulating the database credentials in a properties file or environment variables for security.\n\nOkay, I think I have a plan. Let me start implementing this step by step.\n\nFirst, set up a new Java project.\n\nThen, add the PostgreSQL JDBC driver to the project dependencies.\n\nIf using Maven, add the following to pom.xml:\n\n<dependency>\n\n<groupId>org.postgresql</groupId>\n\n<artifactId>postgresql</artifactId>\n\n<version>42.2.18</version>\n\n</dependency>\n\nNext, create a new Java class, say, ReportGenerator.\n\nIn ReportGenerator, define the main method.\n\nIn the main method, load the JDBC driver using Class.forName(\"org.postgresql.Driver\");\n\nThen, establish a connection using DriverManager.getConnection(url, user, password).\n\nI need to define the database URL, username, and password. For now, I'll hardcode them, but ideally, they should be externalized.\n\nAssuming the database is running locally, the URL might be \"jdbc:postgresql://localhost:5432/mydatabase\".\n\nNext, define the SQL query as a String, using placeholders for parameters.\n\nString sql = \"SELECT o.order_id, c.name AS customer_name, p.name AS product_name, oi.quantity, oi.price \" +\n\n\"FROM orders o \" +\n\n\"JOIN customers c ON o.customer_id = c.customer_id \" +\n\n\"JOIN order_items oi ON o.order_id = oi.order_id \" +\n\n\"JOIN products p ON oi.product_id = p.product_id \" +\n\n\"WHERE c.city = ? \" +\n\n\"AND o.order_date BETWEEN ? AND ?\";\n\nThen, create a PreparedStatement using connection.prepareStatement(sql).\n\nSet the parameters using preparedStatement.setString(1, city);\n\npreparedStatement.setDate(2, java.sql.Date.valueOf(startDate));\n\npreparedStatement.setDate(3, java.sql.Date.valueOf(endDate));\n\nAssuming city is a String, and startDate and endDate are LocalDate objects.\n\nExecute the query using preparedStatement.executeQuery() to get the ResultSet.\n\nThen, iterate over the ResultSet:\n\nwhile (resultSet.next()) {\n\nint orderId = resultSet.getInt(\"order_id\");\n\nString customerName = resultSet.getString(\"customer_name\");\n\nString productName = resultSet.getString(\"product_name\");\n\nint quantity = resultSet.getInt(\"quantity\");\n\ndouble price = resultSet.getDouble(\"price\");\n\n// Print or process the data\n\n}\n\nI should also handle any SQLExceptions that might be thrown, using try-catch blocks.\n\nAlso, use try-with-resources to ensure that the ResultSet, PreparedStatement, and Connection are closed automatically.\n\nLet me write a rough skeleton of the code:\n\ntry (Connection connection = DriverManager.getConnection(url, user, password);\n\nPreparedStatement preparedStatement = connection.prepareStatement(sql)) {\n\npreparedStatement.setString(1, city);\n\npreparedStatement.setDate(2, java.sql.Date.valueOf(startDate));\n\npreparedStatement.setDate(3, java.sql.Date.valueOf(endDate));\n\nResultSet resultSet = preparedStatement.executeQuery();\n\nwhile (resultSet.next()) {\n\n// Fetch and print data\n\n}\n\n} catch (SQLException e) {\n\ne.printStackTrace();\n\n}\n\nI need to get the city, startDate, and endDate from somewhere. For now, I can hardcode them in the main method, but eventually, I should make them configurable.\n\nMaybe accept them as command-line arguments.\n\nIn the main method:\n\npublic static void main(String[] args) {\n\nif (args.length != 3) {\n\nSystem.out.println(\"Usage: java ReportGenerator <city> <start_date> <end_date>\");\n\nSystem.exit(1);\n\n}\n\nString city = args[0];\n\nLocalDate startDate = LocalDate.parse(args[1]);\n\nLocalDate endDate = LocalDate.parse(args[2]);\n\n// Proceed with database connection and query\n\n}\n\nThis way, the user can specify the city and date range when running the program.\n\nI need to make sure that the date formats are correct; LocalDate expects dates in yyyy-MM-dd format.\n\nI should also add some validation to ensure that startDate is before endDate.\n\nNow, in the ResultSet processing loop, I'll print the order details.\n\nBut since there can be multiple products per order, I need to group the data by order_id to avoid duplicate order information.\n\nOne way is to keep track of the current order_id and only print order information when it changes.\n\nFor example:\n\nint currentOrderId = -1;\n\nwhile (resultSet.next()) {\n\nint orderId = resultSet.getInt(\"order_id\");\n\nif (orderId != currentOrderId) {\n\n// Print order header\n\nSystem.out.println(\"Order ID: \" + orderId);\n\nSystem.out.println(\"Customer: \" + resultSet.getString(\"customer_name\"));\n\n// Reset totals or other order-level data\n\ncurrentOrderId = orderId;\n\n}\n\n// Print product details\n\nSystem.out.println(\" Product: \" + resultSet.getString(\"product_name\"));\n\nSystem.out.println(\" Quantity: \" + resultSet.getInt(\"quantity\"));\n\nSystem.out.println(\" Price: \" + resultSet.getDouble(\"price\"));\n\n// Calculate totals\n\n}\n\nThis way, for each new order, I print the order header with customer information, and then list the products in that order.\n\nI should also calculate the total amount for each order and perhaps a grand total for all orders.\n\nTo do that, I can keep track of the subtotal for each order and the grand total separately.\n\nLet me adjust the code:\n\ndouble grandTotal = 0.0;\n\nint currentOrderId = -1;\n\ndouble subtotal = 0.0;\n\nwhile (resultSet.next()) {\n\nint orderId = resultSet.getInt(\"order_id\");\n\nif (orderId != currentOrderId) {\n\nif (currentOrderId != -1) {\n\n// Print subtotal for the previous order\n\nSystem.out.println(\" Subtotal: \" + subtotal);\n\n}\n\n// Print order header\n\nSystem.out.println(\"Order ID: \" + orderId);\n\nSystem.out.println(\"Customer: \" + resultSet.getString(\"customer_name\"));\n\ncurrentOrderId = orderId;\n\nsubtotal = 0.0;\n\n}\n\n// Print product details\n\nString productName = resultSet.getString(\"product_name\");\n\nint quantity = resultSet.getInt(\"quantity\");\n\ndouble price = resultSet.getDouble(\"price\");\n\ndouble lineTotal = quantity * price;\n\nsubtotal += lineTotal;\n\ngrandTotal += lineTotal;\n\nSystem.out.println(\" Product: \" + productName);\n\nSystem.out.println(\" Quantity: \" + quantity);\n\nSystem.out.println(\" Price: \" + price);\n\nSystem.out.println(\" Line Total: \" + lineTotal);\n\n}\n\n// Print subtotal for the last order\n\nif (currentOrderId != -1) {\n\nSystem.out.println(\" Subtotal: \" + subtotal);\n\n}\n\n// Print grand total\n\nSystem.out.println(\"Grand Total: \" + grandTotal);\n\nThis should give a nicely formatted report with order headers, product details, subtotals per order, and a grand total.\n\nI should also handle cases where there are no results. Maybe check if the ResultSet is empty and print a message accordingly.\n\nTo do that, I can check if the ResultSet has any rows after executing the query.\n\ntry (ResultSet resultSet = preparedStatement.executeQuery()) {\n\nif (!resultSet.isBeforeFirst()) {\n\nSystem.out.println(\"No orders found for the specified criteria.\");\n\n} else {\n\n// Process the ResultSet\n\n}\n\n}\n\nBut actually, resultSet.isBeforeFirst() returns false if there are no rows, so I need to adjust that.\n\nWait, according to the JavaDocs, resultSet.isBeforeFirst() returns true if the cursor is before the first row.\n\nSo, to check if there are no rows, I can do:\n\nif (!resultSet.isBeforeFirst() && !resultSet.isAfterLast()) {\n\nSystem.out.println(\"No orders found for the specified criteria.\");\n\n} else {\n\n// Process the ResultSet\n\n}\n\nBut this seems a bit cumbersome.\n\nAn alternative is to use resultSet.next() and check if it returns false immediately.\n\ntry (ResultSet resultSet = preparedStatement.executeQuery()) {\n\nif (!resultSet.next()) {\n\nSystem.out.println(\"No orders found for the specified criteria.\");\n\n} else {\n\n// Move the cursor back to the first row\n\nresultSet.previous();\n\n// Process the ResultSet\n\nwhile (resultSet.next()) {\n\n// Fetch and print data\n\n}\n\n}\n\n}\n\nThis way, I can check if there are any rows by calling resultSet.next(), and if not, print the message.\n\nBut I need to move the cursor back to the first row using resultSet.previous() before processing the ResultSet in the while loop.\n\nHowever, not all ResultSet types support moving the cursor backwards, so a better approach might be to use a do-while loop:\n\ntry (ResultSet resultSet = preparedStatement.executeQuery()) {\n\nboolean rowsExists = resultSet.next();\n\nif (!rowsExists) {\n\nSystem.out.println(\"No orders found for the specified criteria.\");\n\n} else {\n\ndo {\n\n// Process each row\n\n} while (resultSet.next());\n\n}\n\n}\n\nBut in my earlier code, I need to handle printing the order headers only when the order_id changes, which requires a different structure.\n\nMaybe I can set a flag to check if any rows were processed.\n\nHere's an adjusted version:\n\nboolean hasRows = false;\n\nint currentOrderId = -1;\n\ndouble grandTotal = 0.0;\n\ntry (ResultSet resultSet = preparedStatement.executeQuery()) {\n\nwhile (resultSet.next()) {\n\nhasRows = true;\n\nint orderId = resultSet.getInt(\"order_id\");\n\nif (orderId != currentOrderId) {\n\nif (currentOrderId != -1) {\n\n// Print subtotal for the previous order\n\nSystem.out.println(\" Subtotal: \" + subtotal);\n\n}\n\n// Print order header\n\nSystem.out.println(\"Order ID: \" + orderId);\n\nSystem.out.println(\"Customer: \" + resultSet.getString(\"customer_name\"));\n\ncurrentOrderId = orderId;\n\nsubtotal = 0.0;\n\n}\n\n// Print product details\n\nString productName = resultSet.getString(\"product_name\");\n\nint quantity = resultSet.getInt(\"quantity\");\n\ndouble price = resultSet.getDouble(\"price\");\n\ndouble lineTotal = quantity * price;\n\nsubtotal += lineTotal;\n\ngrandTotal += lineTotal;\n\nSystem.out.println(\" Product: \" + productName);\n\nSystem.out.println(\" Quantity: \" + quantity);\n\nSystem.out.println(\" Price: \" + price);\n\nSystem.out.println(\" Line Total: \" + lineTotal);\n\n}\n\nif (hasRows) {\n\n// Print subtotal for the last order\n\nSystem.out.println(\" Subtotal: \" + subtotal);\n\n}\n\n// Print grand total\n\nSystem.out.println(\"Grand Total: \" + grandTotal);\n\n} catch (SQLException e) {\n\ne.printStackTrace();\n\n}\n\nif (!hasRows) {\n\nSystem.out.println(\"No orders found for the specified criteria.\");\n\n}\n\nThis should cover the case when there are no results.\n\nI should also make sure that the database columns match the ones I'm trying to access in the ResultSet.\n\nIf there are any mismatches in column names or types, I need to adjust the query or the code accordingly.\n\nAdditionally, I should consider formatting the currency values to have two decimal places for better readability.\n\nI can use DecimalFormat or String.format to achieve that.\n\nFor example:\n\nDecimalFormat df = new DecimalFormat(\"#,##0.00\");\n\nSystem.out.println(\" Price: \" + df.format(price));\n\nSystem.out.println(\" Line Total: \" + df.format(lineTotal));\n\nSystem.out.println(\" Subtotal: \" + df.format(subtotal));\n\nSystem.out.println(\"Grand Total: \" + df.format(grandTotal));\n\nThis will format the numbers with two decimal places and comma separators for thousands.\n\nAlso, I should ensure that the database connection is closed properly after the operations are done.\n\nUsing try-with-resources takes care of that, so I don't need to worry about it.\n\nI should also think about optimizing the SQL query if the tables are large.\n\nFor example, indexing on city, order_date, and join columns could improve performance.\n\nBut that's more on the database side.\n\nIn the Java code, I can set the fetch size for the ResultSet to improve performance, but for a small to medium-sized report, it might not be necessary.\n\nAnother consideration is handling large result sets that might not fit into memory.\n\nIn such cases, processing the ResultSet in batches or using streaming approaches would be beneficial.\n\nBut for now, assuming the result set is manageable, I'll proceed without such optimizations.\n\nLet me think about how to handle potential null values in the ResultSet.\n\nFor example, if a customer's name is null, or a product's name is null, I need to handle that to avoid NullPointerExceptions.\n\nI can use resultSet.getString(\"column_name\") which returns null if the value is NULL in the database, and handle it accordingly.\n\nFor example:\n\nString customerName = resultSet.getString(\"customer_name\");\n\nif (customerName == null) {\n\ncustomerName = \"Unknown\";\n\n}\n\nSimilarly for other columns.\n\nI should also ensure that the order_date is within the specified range.\n\nIn the SQL query, I'm already filtering based on order_date BETWEEN start_date AND end_date, so that should take care of it.\n\nBut I need to make sure that the date columns are of compatible types in the database and in Java.\n\nAssuming order_date is of type DATE in PostgreSQL, and I'm using java.sql.Date in Java, that should be fine.\n\nIf order_date includes time, I might need to use java.sql.Timestamp instead.\n\nI need to verify the data types in the database schema.\n\nAssuming order_date is DATE, using java.sql.Date is appropriate.\n\nIf it's TIMESTAMP, I should use java.sql.Timestamp and parse the dates accordingly.\n\nNext, I should consider internationalization if the application needs to support multiple languages, but for simplicity, I'll assume English is sufficient.\n\nAlso, I should think about how to package and distribute the application.\n\nSince it's a command-line application, I can create a JAR file with dependencies included and provide instructions to run it with Java.\n\nI might also want to add comments and documentation to the code for clarity.\n\nLet me summarize the steps I need to implement:\n\n1. Set up a new Java project with PostgreSQL JDBC driver.\n\n2. Create a ReportGenerator class with a main method.\n\n3. Load the JDBC driver.\n\n4. Establish a database connection.\n\n5. Accept city, start_date, and end_date as command-line arguments.\n\n6. Validate the date formats and ensure startDate is before endDate.\n\n7. Construct the SQL query with parameters for city, start_date, and end_date.\n\n8. Execute the query using PreparedStatement.\n\n9. Process the ResultSet:\n\na. Check if there are any results and handle accordingly.\n\nb. Group the data by order_id to print order headers only once.\n\nc. Print product details for each order.\n\nd. Calculate and print subtotals per order and a grand total.\n\n10. Format currency values for better readability.\n\n11. Handle any potential null values in the ResultSet.\n\n12. Close database resources using try-with-resources.\n\n13. Handle exceptions gracefully, preferably with meaningful error messages.\n\nI should also write some test cases or at least test the application with sample data to ensure it works as expected.\n\nI can create a sample PostgreSQL database with the required tables and insert some test data to verify that the report is generated correctly.\n\nLet me think about the database schema.\n\nSample schema:\n\nCREATE TABLE customers (\n\ncustomer_id SERIAL PRIMARY KEY,\n\nname VARCHAR(100),\n\ncity VARCHAR(100)\n\n);\n\nCREATE TABLE products (\n\nproduct_id SERIAL PRIMARY KEY,\n\nname VARCHAR(100),\n\ndescription TEXT\n\n);\n\nCREATE TABLE orders (\n\norder_id SERIAL PRIMARY KEY,\n\ncustomer_id INTEGER REFERENCES customers(customer_id),\n\norder_date DATE\n\n);\n\nCREATE TABLE order_items (\n\norder_id INTEGER REFERENCES orders(order_id),\n\nproduct_id INTEGER REFERENCES products(product_id),\n\nquantity INTEGER,\n\nprice DECIMAL(10,2),\n\nPRIMARY KEY (order_id, product_id)\n\n);\n\nI can insert some sample data into these tables to test the report generation.\n\nFor example:\n\nINSERT INTO customers (name, city) VALUES\n\n('John Doe', 'New York'),\n\n('Jane Smith', 'Los Angeles'),\n\n('Alice Johnson', 'Chicago');\n\nINSERT INTO products (name, description) VALUES\n\n('Laptop', 'High-performance laptop'),\n\n('Smartphone', 'Latest model smartphone'),\n\n('Tablet', 'Portable tablet device');\n\nINSERT INTO orders (customer_id, order_date) VALUES\n\n(1, '2023-01-15'),\n\n(2, '2023-02-20'),\n\n(1, '2023-03-10');\n\nINSERT INTO order_items (order_id, product_id, quantity, price) VALUES\n\n(1, 1, 1, 1200.00),\n\n(1, 2, 2, 800.00),\n\n(2, 3, 1, 600.00),\n\n(3, 2, 1, 800.00);\n\nWith this data, I can test the report generation for customers in 'New York' between '2023-01-01' and '2023-03-31', which should include orders from John Doe.\n\nI should also test with a city that has no orders or a date range with no orders to verify the no results message.\n\nOkay, I think I have a good plan. Now, I'll proceed to implement the Java code based on this plan.\n\n## Final Solution\nTo create a Java application that connects to a PostgreSQL database, reads data from multiple tables, and generates a report based on specified criteria, follow the steps below.\n\n### Prerequisites\n1. **Java Development Kit (JDK)** installed.\n2. **PostgreSQL** database set up with the required tables.\n3. **Maven** for managing dependencies.\n\n### Solution Code\n\n#### Step 1: Set Up the Maven Project\nCreate a new Maven project and add the PostgreSQL JDBC driver dependency to your `pom.xml`:\n\n```xml\n<dependencies>\n    <dependency>\n        <groupId>org.postgresql</groupId>\n        <artifactId>postgresql</artifactId>\n        <version>42.2.18</version>\n    </dependency>\n</dependencies>\n```\n\n#### Step 2: Create the Report Generator Class\nCreate a class named `ReportGenerator` with the following code:\n\n```java\nimport java.sql.*;\nimport java.time.LocalDate;\nimport java.text.DecimalFormat;\n\npublic class ReportGenerator {\n\n    public static void main(String[] args) {\n        if (args.length != 3) {\n            System.out.println(\"Usage: java ReportGenerator <city> <start_date> <end_date>\");\n            System.exit(1);\n        }\n\n        String city = args[0];\n        LocalDate startDate = LocalDate.parse(args[1]);\n        LocalDate endDate = LocalDate.parse(args[2]);\n\n        String url = \"jdbc:postgresql://localhost:5432/mydatabase\";\n        String user = \"myuser\";\n        String password = \"mypassword\";\n\n        String sql = \"SELECT o.order_id, c.name AS customer_name, p.name AS product_name, oi.quantity, oi.price \"\n                + \"FROM orders o \"\n                + \"JOIN customers c ON o.customer_id = c.customer_id \"\n                + \"JOIN order_items oi ON o.order_id = oi.order_id \"\n                + \"JOIN products p ON oi.product_id = p.product_id \"\n                + \"WHERE c.city = ? \"\n                + \"AND o.order_date BETWEEN ? AND ?\";\n\n        try (Connection connection = DriverManager.getConnection(url, user, password);\n             PreparedStatement preparedStatement = connection.prepareStatement(sql)) {\n\n            preparedStatement.setString(1, city);\n            preparedStatement.setDate(2, java.sql.Date.valueOf(startDate));\n            preparedStatement.setDate(3, java.sql.Date.valueOf(endDate));\n\n            try (ResultSet resultSet = preparedStatement.executeQuery()) {\n                boolean hasRows = false;\n                int currentOrderId = -1;\n                double grandTotal = 0.0;\n                double subtotal = 0.0;\n\n                DecimalFormat df = new DecimalFormat(\"#,##0.00\");\n\n                while (resultSet.next()) {\n                    hasRows = true;\n\n                    int orderId = resultSet.getInt(\"order_id\");\n                    if (orderId != currentOrderId) {\n                        if (currentOrderId != -1) {\n                            System.out.println(\" Subtotal: \" + df.format(subtotal));\n                        }\n                        System.out.println(\"Order ID: \" + orderId);\n                        String customerName = resultSet.getString(\"customer_name\");\n                        if (customerName == null) {\n                            customerName = \"Unknown\";\n                        }\n                        System.out.println(\"Customer: \" + customerName);\n                        currentOrderId = orderId;\n                        subtotal = 0.0;\n                    }\n\n                    String productName = resultSet.getString(\"product_name\");\n                    if (productName == null) {\n                        productName = \"Unknown\";\n                    }\n                    int quantity = resultSet.getInt(\"quantity\");\n                    double price = resultSet.getDouble(\"price\");\n                    double lineTotal = quantity * price;\n                    subtotal += lineTotal;\n                    grandTotal += lineTotal;\n\n                    System.out.println(\" Product: \" + productName);\n                    System.out.println(\" Quantity: \" + quantity);\n                    System.out.println(\" Price: \" + df.format(price));\n                    System.out.println(\" Line Total: \" + df.format(lineTotal));\n                }\n\n                if (hasRows) {\n                    System.out.println(\" Subtotal: \" + df.format(subtotal));\n                }\n                System.out.println(\"Grand Total: \" + df.format(grandTotal));\n            }\n        } catch (SQLException e) {\n            e.printStackTrace();\n        }\n\n        if (!hasRows) {\n            System.out.println(\"No orders found for the specified criteria.\");\n        }\n    }\n}\n```\n\n### Explanation\n1. **Database Connection**: The application connects to a PostgreSQL database using JDBC.\n2. **SQL Query**: It constructs a SQL query to join multiple tables and filters orders based on the specified city and date range.\n3. **Report Generation**: It processes the query results to generate a formatted report, including order details and totals.\n4. **Command-Line Arguments**: It accepts city, start date, and end date as command-line arguments for flexibility.\n\nThis solution ensures that the application is robust, handles exceptions gracefully, and provides useful output based on the database query results."
    }
]