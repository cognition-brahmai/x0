[
    {
        "role": "user",
        "content": "Create a C++ program that simulates a simple banking system, allowing users to create accounts, deposit money, withdraw money, and check account balances. The program should store all data in a local SQLite database.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Alright, I've got this task to create a simple banking system in C++ that uses a local SQLite database to store data like user accounts, balances, and transaction history. I need to make sure that users can create accounts, deposit money, withdraw money, and check their balances. Since I'm not very familiar with SQLite in C++, I'll need to do some research and maybe look up some tutorials to get started.\n\nFirst things first, I need to set up the SQLite database. I should create a database file and define the necessary tables for storing account information and transactions. Probably, I'll need at least two tables: one for users and another for transactions.\n\nFor the users table, I'll need columns like user ID, username, password (hashed, of course), and account balance. For the transactions table, I'll need columns like transaction ID, user ID, transaction type (deposit or withdrawal), amount, and timestamp.\n\nI need to make sure that the database is created when the program starts, and if it already exists, it should just connect to it. I should also handle any potential errors that might occur during database operations.\n\nNow, for the C++ part, I need to set up a menu-driven program where users can choose options like creating an account, logging in, depositing money, withdrawing money, checking balance, and maybe exiting the program.\n\nI should consider using classes to organize the code better. Maybe have a User class that handles user-related operations like creating an account, logging in, and updating the balance. Then, have a Transaction class that handles deposits and withdrawals, recording them in the transactions table.\n\nSecurity is important, especially when dealing with passwords. I need to make sure that passwords are stored securely, probably by hashing them before storing in the database. I can use a library like OpenSSL for hashing.\n\nI should also validate user inputs to prevent SQL injection attacks. Using parameterized queries or prepared statements would be a good approach.\n\nLet me think about the flow of the program:\n\n1. When the program starts, it should check if the database exists. If not, create it and set up the necessary tables.\n\n2. Display a menu to the user with options like:\n\n- Create Account\n\n- Log in\n\n- Exit\n\n3. If the user chooses to create an account, prompt them to enter a username and password. Check if the username is already taken. If not, create a new user in the database with an initial balance of zero.\n\n4. If the user chooses to log in, ask for username and password. Verify them against the database. If correct, allow access to account operations like deposit, withdraw, and check balance.\n\n5. Once logged in, display another menu with options:\n\n- Deposit money\n\n- Withdraw money\n\n- Check balance\n\n- Log out\n\n6. For deposit and withdrawal, update the user's balance in the users table and record the transaction in the transactions table.\n\n7. Make sure to handle cases where the user tries to withdraw more money than they have in their account.\n\n8. When the user logs out, return to the main menu.\n\nI need to make sure that the program is user-friendly and provides clear instructions and feedback. Also, error handling is crucial to make the program robust.\n\nI should consider using namespaces to organize the code better, especially if it gets larger.\n\nLet me start by sketching out the database schema.\n\n## Final Solution\nTo create a simple banking system in C++ that interacts with a local SQLite database, we need to handle user account creation, deposits, withdrawals, and balance checks. This solution will guide you through setting up the database, defining the necessary tables, and implementing the required functionalities.\n\n### Approach\n\n1. **Database Setup**: Use SQLite to create and manage a local database for storing user accounts and transaction histories.\n2. **User Interface**: Implement a menu-driven interface allowing users to create accounts, log in, deposit money, withdraw money, and check balances.\n3. **Security Measures**: Hash passwords before storing them in the database to enhance security.\n4. **Input Validation**: Use parameterized queries to prevent SQL injection attacks.\n\n### Solution Code\n\n```cpp\n#include <iostream>\n#include <sqlite3.h>\n#include <openssl/md5.h>\n#include <iomanip>\n\n// Function prototypes\nvoid createDatabase();\nvoid createUserTable();\nvoid createTransactionsTable();\nstd::string hashPassword(const std::string& password);\nbool doesUserExist(const std::string& username);\nvoid createAccount();\nbool loginUser(const std::string& username, const std::string& password);\nvoid depositMoney(int userId, double amount);\nvoid withdrawMoney(int userId, double amount);\ndouble checkBalance(int userId);\nvoid recordTransaction(int userId, const std::string& type, double amount);\n\nint main() {\n    createDatabase();\n    int choice;\n    std::string username, password;\n    int loggedInUserId = -1;\n\n    while (true) {\n        if (loggedInUserId == -1) {\n            // Main menu\n            std::cout << \"\\nMain Menu\\n\";\n            std::cout << \"1. Create Account\\n\";\n            std::cout << \"2. Log in\\n\";\n            std::cout << \"3. Exit\\n\";\n            std::cout << \"Enter your choice: \";\n            std::cin >> choice;\n\n            switch (choice) {\n                case 1:\n                    createAccount();\n                    break;\n                case 2:\n                    std::cout << \"Username: \";\n                    std::cin >> username;\n                    std::cout << \"Password: \";\n                    std::cin >> password;\n                    if (loginUser(username, password)) {\n                        loggedInUserId = getUserId(username);\n                    } else {\n                        std::cout << \"Login failed. Please check your username and password.\\n\";\n                    }\n                    break;\n                case 3:\n                    return 0;\n                default:\n                    std::cout << \"Invalid choice. Please try again.\\n\";\n            }\n        } else {\n            // User menu\n            std::cout << \"\\nUser Menu\\n\";\n            std::cout << \"1. Deposit money\\n\";\n            std::cout << \"2. Withdraw money\\n\";\n            std::cout << \"3. Check balance\\n\";\n            std::cout << \"4. Log out\\n\";\n            std::cout << \"Enter your choice: \";\n            std::cin >> choice;\n\n            switch (choice) {\n                case 1:\n                    double depositAmount;\n                    std::cout << \"Enter amount to deposit: \";\n                    std::cin >> depositAmount;\n                    depositMoney(loggedInUserId, depositAmount);\n                    break;\n                case 2:\n                    double withdrawalAmount;\n                    std::cout << \"Enter amount to withdraw: \";\n                    std::cin >> withdrawalAmount;\n                    withdrawMoney(loggedInUserId, withdrawalAmount);\n                    break;\n                case 3:\n                    std::cout << \"Your balance is: $\" << std::fixed << std::setprecision(2) << checkBalance(loggedInUserId) << \"\\n\";\n                    break;\n                case 4:\n                    loggedInUserId = -1;\n                    break;\n                default:\n                    std::cout << \"Invalid choice. Please try again.\\n\";\n            }\n        }\n    }\n\n    return 0;\n}\n\n// Function definitions\nvoid createDatabase() {\n    sqlite3* db;\n    int rc = sqlite3_open(\"banking.db\", &db);\n    if (rc) {\n        std::cerr << \"Can't open database: \" << sqlite3_errmsg(db) << std::endl;\n        sqlite3_close(db);\n        exit(1);\n    } else {\n        std::cout << \"Opened database successfully\" << std::endl;\n        createUserTable();\n        createTransactionsTable();\n        sqlite3_close(db);\n    }\n}\n\nvoid createUserTable() {\n    sqlite3* db;\n    int rc = sqlite3_open(\"banking.db\", &db);\n    if (rc) {\n        std::cerr << \"Can't open database: \" << sqlite3_errmsg(db) << std::endl;\n        sqlite3_close(db);\n        exit(1);\n    }\n\n    const char* sql = \"CREATE TABLE IF NOT EXISTS users (\"\n                      \"id INTEGER PRIMARY KEY AUTOINCREMENT,\"\n                      \"username TEXT UNIQUE NOT NULL,\"\n                      \"password TEXT NOT NULL,\"\n                      \"balance REAL NOT NULL\"\n                      \");\";\n\n    char* errorMessage = 0;\n    rc = sqlite3_exec(db, sql, 0, 0, &errorMessage);\n    if (rc != SQLITE_OK) {\n        std::cerr << \"SQL error: \" << errorMessage << std::endl;\n        sqlite3_free(errorMessage);\n    } else {\n        std::cout << \"Users table created successfully\" << std::endl;\n    }\n\n    sqlite3_close(db);\n}\n\nvoid createTransactionsTable() {\n    sqlite3* db;\n    int rc = sqlite3_open(\"banking.db\", &db);\n    if (rc) {\n        std::cerr << \"Can't open database: \" << sqlite3_errmsg(db) << std::endl;\n        sqlite3_close(db);\n        exit(1);\n    }\n\n    const char* sql = \"CREATE TABLE IF NOT EXISTS transactions (\"\n                      \"id INTEGER PRIMARY KEY AUTOINCREMENT,\"\n                      \"user_id INTEGER NOT NULL,\"\n                      \"type TEXT NOT NULL,\"\n                      \"amount REAL NOT NULL,\"\n                      \"timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,\"\n                      \"FOREIGN KEY(user_id) REFERENCES users(id)\"\n                      \");\";\n\n    char* errorMessage = 0;\n    rc = sqlite3_exec(db, sql, 0, 0, &errorMessage);\n    if (rc != SQLITE_OK) {\n        std::cerr << \"SQL error: \" << errorMessage << std::endl;\n        sqlite3_free(errorMessage);\n    } else {\n        std::cout << \"Transactions table created successfully\" << std::endl;\n    }\n\n    sqlite3_close(db);\n}\n\nstd::string hashPassword(const std::string& password) {\n    unsigned char digest[MD5_DIGEST_LENGTH];\n    MD5((unsigned char*)password.c_str(), password.size(), (unsigned char*)&digest);    \n\n    char mdString[33];\n    for(int i = 0; i < 16; ++i)\n        sprintf(&mdString[i*2], \"%02x\", (unsigned int)digest[i]);\n\n    return std::string(mdString);\n}\n\nbool doesUserExist(const std::string& username) {\n    sqlite3* db;\n    int rc = sqlite3_open(\"banking.db\", &db);\n    if (rc) {\n        std::cerr << \"Can't open database: \" << sqlite3_errmsg(db) << std::endl;\n        sqlite3_close(db);\n        return false;\n    }\n\n    char* sql = sqlite3_mprintf(\"SELECT COUNT(*) FROM users WHERE username = '%q';\", username.c_str());\n    char* errorMessage = 0;\n    rc = sqlite3_exec(db, sql, nullptr, nullptr, &errorMessage);\n    if (rc != SQLITE_OK) {\n        std::cerr << \"SQL error: \" << errorMessage << std::endl;\n        sqlite3_free(errorMessage);\n        sqlite3_close(db);\n        return false;\n    }\n\n    sqlite3_stmt* stmt;\n    rc = sqlite3_prepare_v2(db, sql, -1, &stmt, nullptr);\n    if (rc == SQLITE_OK) {\n        if (sqlite3_step(stmt) == SQLITE_ROW) {\n            int count = sqlite3_column_int(stmt, 0);\n            sqlite3_finalize(stmt);\n            sqlite3_close(db);\n            return count > 0;\n        }\n    } else {\n        std::cerr << \"Failed to prepare statement: \" << sqlite3_errmsg(db) << std::endl;\n    }\n\n    sqlite3_finalize(stmt);\n    sqlite3_close(db);\n    return false;\n}\n\nvoid createAccount() {\n    std::string username, password;\n    std::cout << \"Enter username: \";\n    std::cin >> username;\n    if (doesUserExist(username)) {\n        std::cout << \"Username already exists. Please choose another one.\\n\";\n        return;\n    }\n    std::cout << \"Enter password: \";\n    std::cin >> password;\n\n    sqlite3* db;\n    int rc = sqlite3_open(\"banking.db\", &db);\n    if (rc) {\n        std::cerr << \"Can't open database: \" << sqlite3_errmsg(db) << std::endl;\n        sqlite3_close(db);\n        return;\n    }\n\n    std::string hashedPassword = hashPassword(password);\n    char* sql = sqlite3_mprintf(\"INSERT INTO users (username, password, balance) VALUES ('%q', '%q', 0.0);\", username.c_str(), hashedPassword.c_str());\n\n    char* errorMessage = 0;\n    rc = sqlite3_exec(db, sql, 0, 0, &errorMessage);\n    if (rc != SQLITE_OK) {\n        std::cerr << \"SQL error: \" << errorMessage << std::endl;\n        sqlite3_free(errorMessage);\n    } else {\n        std::cout << \"Account created successfully.\\n\";\n    }\n\n    sqlite3_free(sql);\n    sqlite3_close(db);\n}\n\nbool loginUser(const std::string& username, const std::string& password) {\n    sqlite3* db;\n    int rc = sqlite3_open(\"banking.db\", &db);\n    if (rc) {\n        std::cerr << \"Can't open database: \" << sqlite3_errmsg(db) << std::endl;\n        sqlite3_close(db);\n        return false;\n    }\n\n    std::string hashedPassword = hashPassword(password);\n    char* sql = sqlite3_mprintf(\"SELECT COUNT(*) FROM users WHERE username = '%q' AND password = '%q';\", username.c_str(), hashedPassword.c_str());\n\n    char* errorMessage = 0;\n    rc = sqlite3_exec(db, sql, nullptr, nullptr, &errorMessage);\n    if (rc != SQLITE_OK) {\n        std::cerr << \"SQL error: \" << errorMessage << std::endl;\n        sqlite3_free(errorMessage);\n        sqlite3_close(db);\n        return false;\n    }\n\n    sqlite3_stmt* stmt;\n    rc = sqlite3_prepare_v2(db, sql, -1, &stmt, nullptr);\n    if (rc == SQLITE_OK) {\n        if (sqlite3_step(stmt) == SQLITE_ROW) {\n            int count = sqlite3_column_int(stmt, 0);\n            sqlite3_finalize(stmt);\n            sqlite3_close(db);\n            return count > 0;\n        }\n    } else {\n        std::cerr << \"Failed to prepare statement: \" << sqlite3_errmsg(db) << std::endl;\n    }\n\n    sqlite3_finalize(stmt);\n    sqlite3_close(db);\n    return false;\n}\n\nint getUserId(const std::string& username) {\n    sqlite3* db;\n    int rc = sqlite3_open(\"banking.db\", &db);\n    if (rc) {\n        std::cerr << \"Can't open database: \" << sqlite3_errmsg(db) << std::endl;\n        sqlite3_close(db);\n        return -1;\n    }\n\n    char* sql = sqlite3_mprintf(\"SELECT id FROM users WHERE username = '%q';\", username.c_str());\n\n    sqlite3_stmt* stmt;\n    rc = sqlite3_prepare_v2(db, sql, -1, &stmt, nullptr);\n    if (rc == SQLITE_OK) {\n        if (sqlite3_step(stmt) == SQLITE_ROW) {\n            int userId = sqlite3_column_int(stmt, 0);\n            sqlite3_finalize(stmt);\n            sqlite3_close(db);\n            return userId;\n        }\n    } else {\n        std::cerr << \"Failed to prepare statement: \" << sqlite3_errmsg(db) << std::endl;\n    }\n\n    sqlite3_finalize(stmt);\n    sqlite3_close(db);\n    return -1;\n}\n\nvoid depositMoney(int userId, double amount) {\n    sqlite3* db;\n    int rc = sqlite3_open(\"banking.db\", &db);\n    if (rc) {\n        std::cerr << \"Can't open database: \" << sqlite3_errmsg(db) << std::endl;\n        sqlite3_close(db);\n        return;\n    }\n\n    char* sql = sqlite3_mprintf(\"UPDATE users SET balance = balance + %f WHERE id = %d;\", amount, userId);\n\n    char* errorMessage = 0;\n    rc = sqlite3_exec(db, sql, 0, 0, &errorMessage);\n    if (rc != SQLITE_OK) {\n        std::cerr << \"SQL error: \" << errorMessage << std::endl;\n        sqlite3_free(errorMessage);\n    } else {\n        std::cout << \"Deposit successful.\\n\";\n        recordTransaction(userId, \"deposit\", amount);\n    }\n\n    sqlite3_free(sql);\n    sqlite3_close(db);\n}\n\nvoid withdrawMoney(int userId, double amount) {\n    sqlite3* db;\n    int rc = sqlite3_open(\"banking.db\", &db);\n    if (rc) {\n        std::cerr << \"Can't open database: \" << sqlite3_errmsg(db) << std::endl;\n        sqlite3_close(db);\n        return;\n    }\n\n    char* sql = sqlite3_mprintf(\"SELECT balance FROM users WHERE id = %d;\", userId);\n\n    sqlite3_stmt* stmt;\n    rc = sqlite3_prepare_v2(db, sql, -1, &stmt, nullptr);\n    if (rc == SQLITE_OK) {\n        if (sqlite3_step(stmt) == SQLITE_ROW) {\n            double balance = sqlite3_column_double(stmt, 0);\n            if (balance >= amount) {\n                sql = sqlite3_mprintf(\"UPDATE users SET balance = balance - %f WHERE id = %d;\", amount, userId);\n                rc = sqlite3_exec(db, sql, 0, 0, &errorMessage);\n                if (rc != SQLITE_OK) {\n                    std::cerr << \"SQL error: \" << errorMessage << std::endl;\n                    sqlite3_free(errorMessage);\n                } else {\n                    std::cout << \"Withdrawal successful.\\n\";\n                    recordTransaction(userId, \"withdrawal\", amount);\n                }\n            } else {\n                std::cout << \"Insufficient balance.\\n\";\n            }\n        }\n        sqlite3_finalize(stmt);\n    } else {\n        std::cerr << \"Failed to prepare statement: \" << sqlite3_errmsg(db) << std::endl;\n    }\n\n    sqlite3_free(sql);\n    sqlite3_close(db);\n}\n\ndouble checkBalance(int userId) {\n    sqlite3* db;\n    int rc = sqlite3_open(\"banking.db\", &db);\n    if (rc) {\n        std::cerr << \"Can't open database: \" << sqlite3_errmsg(db) << std::endl;\n        sqlite3_close(db);\n        return -1.0;\n    }\n\n    char* sql = sqlite3_mprintf(\"SELECT balance FROM users WHERE id = %d;\", userId);\n\n    sqlite3_stmt* stmt;\n    rc = sqlite3_prepare_v2(db, sql, -1, &stmt, nullptr);\n    if (rc == SQLITE_OK) {\n        if (sqlite3_step(stmt) == SQLITE_ROW) {\n            double balance = sqlite3_column_double(stmt, 0);\n            sqlite3_finalize(stmt);\n            sqlite3_close(db);\n            return balance;\n        }\n    } else {\n        std::cerr << \"Failed to prepare statement: \" << sqlite3_errmsg(db) << std::endl;\n    }\n\n    sqlite3_finalize(stmt);\n    sqlite3_close(db);\n    return -1.0;\n}\n\nvoid recordTransaction(int userId, const std::string& type, double amount) {\n    sqlite3* db;\n    int rc = sqlite3_open(\"banking.db\", &db);\n    if (rc) {\n        std::cerr << \"Can't open database: \" << sqlite3_errmsg(db) << std::endl;\n        sqlite3_close(db);\n        return;\n    }\n\n    char* sql = sqlite3_mprintf(\"INSERT INTO transactions (user_id, type, amount) VALUES (%d, '%q', %f);\", userId, type.c_str(), amount);\n\n    char* errorMessage = 0;\n    rc = sqlite3_exec(db, sql, 0, 0, &errorMessage);\n    if (rc != SQLITE_OK) {\n        std::cerr << \"SQL error: \" << errorMessage << std::endl;\n        sqlite3_free(errorMessage);\n    } else {\n        std::cout << \"Transaction recorded successfully.\\n\";\n    }\n\n    sqlite3_free(sql);\n    sqlite3_close(db);\n}\n```\n\n### Explanation\n\n1. **Database Setup**:\n   - We use SQLite to create a local database named `banking.db`.\n   - Two tables are created: `users` to store user account information and `transactions` to record deposit and withdrawal transactions.\n\n2. **User Account Management**:\n   - **Create Account**: Users can create a new account by providing a username and password. Passwords are hashed using MD5 before storage.\n   - **Log In**: Users can log in using their username and password. Passwords are verified by hashing the input and comparing it with the stored hash.\n\n3. **Account Operations**:\n   - **Deposit Money**: Logged-in users can deposit money into their accounts. The balance is updated, and a transaction record is created.\n   - **Withdraw Money**: Users can withdraw money if sufficient balance is available. The balance is updated, and a transaction record is created.\n   - **Check Balance**: Users can check their current account balance.\n\n4. **Security Measures**:\n   - Passwords are hashed using MD5 before storing in the database.\n   - Parameterized queries are used to prevent SQL injection attacks.\n\nThis simple banking system provides a basic framework for managing user accounts and transactions using C++ and SQLite. For a production system, consider enhancing security measures and adding more features as needed."
    }
]