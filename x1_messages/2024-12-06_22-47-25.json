[
    {
        "role": "user",
        "content": "Create a bash script that monitors the CPU usage on a Linux system. If the CPU usage exceeds 80% for more than 2 minutes, send an alert email to the system administrator. PLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Alright, I've got this task to create a bash script that monitors CPU usage on a Linux system. If the CPU usage goes above 80% and stays there for more than 2 minutes, it should send an alert email to the system administrator. Sounds straightforward, but I need to make sure I get all the parts right.\n\nFirst, I need to figure out how to monitor CPU usage in bash. I know that Linux has a bunch of commands for system monitoring, like top, htop, vmstat, and mpstat. But for scripting, especially in bash, I think top or vmstat would be more suitable because they can output to stdout and are easier to parse.\n\nLet me consider top first. Top provides a dynamic real-time view of a running system. It can be run in batch mode, which is better for scripting because it provides a single snapshot of the system statistics. The command would be something like `top -bn1`. This will run top in batch mode with 1 iteration.\n\nNow, I need to extract the CPU usage from the top command's output. The CPU usage is usually shown in the second line of the top output, under the \"Cpu(s):\" section. It shows percentages for user, system, nice, idle, etc. I'm interested in the total CPU usage, which would be 100% minus the idle percentage.\n\nSo, I need to parse that line to get the idle percentage and then calculate the CPU usage. Maybe I can use awk or grep to extract the idle percentage.\n\nLet me think about how to do that. I can run `top -bn1 | grep \"Cpu(s)\"` to get the line with CPU usage. Then, I can use awk to extract the idle percentage. The output of top's CPU line looks something like this:\n\n`Cpu(s):  5.0%us,  1.5%sy,  0.0%ni, 93.5%id,  0.0%wa,  0.0%hi,  0.0%si,  0.0%st`\n\nSo, if I use `top -bn1 | grep \"Cpu(s)\" | awk '{print $8}'`, I should get the idle percentage, which is 93.5%id in this case. Then, I can remove the %id part to get just the number.\n\nWait, actually, $8 would be 0.0%wa, not the idle percentage. Let me check the position again. Counting the fields:\n\n1. Cpu(s):\n\n2. 5.0%us,\n\n3. 1.5%sy,\n\n4. 0.0%ni,\n\n5. 93.5%id,\n\n6. 0.0%wa,\n\n7. 0.0%hi,\n\n8. 0.0%si,\n\n9. 0.0%st\n\nSo, the idle percentage is in the fifth field. Therefore, I should use `top -bn1 | grep \"Cpu(s)\" | awk '{print $5}'`. But this will give me \"93.5%id\", and I need just the number without the % or id.\n\nI can use awk to further process this. Maybe something like `top -bn1 | grep \"Cpu(s)\" | awk '{print $5}' | sed 's/%id//'`. This should remove the %id part and leave me with just the number.\n\nAlternatively, awk can handle this entirely. I can use `top -bn1 | grep \"Cpu(s)\" | awk '{print 100 - $(NF-3)}'`. Wait, NF is the number of fields, and $(NF-3) would be the third field from the end. Let's see:\n\nFields are:\n\n1. Cpu(s):\n\n2. 5.0%us,\n\n3. 1.5%sy,\n\n4. 0.0%ni,\n\n5. 93.5%id,\n\n6. 0.0%wa,\n\n7. 0.0%hi,\n\n8. 0.0%si,\n\n9. 0.0%st\n\nSo, NF is 9. NF-3 would be 6, which is 0.0%wa. That's not what I want. I need the fifth field, which is the idle percentage.\n\nMaybe it's better to stick with `awk '{print $5}'` and then remove the %id part.\n\nLet me try that in the terminal.\n\n`top -bn1 | grep \"Cpu(s)\" | awk '{print $5}'`\n\nOutput: 93.5%id\n\nNow, to remove %id, I can use `sed 's/%id//'`\n\nSo, `top -bn1 | grep \"Cpu(s)\" | awk '{print $5}' | sed 's/%id//'`\n\nThis should give me just 93.5.\n\nThen, CPU usage is 100% minus idle percentage, which would be 100 - 93.5 = 6.5%.\n\nWait, but in my earlier example, if idle is 93.5%, then CPU usage is 6.5%, not 80%. Maybe I need to verify this.\n\nActually, I think I have it backwards. If idle is high, CPU usage is low, and vice versa. So, yes, 100% - idle% should give me the CPU usage.\n\nNow, I need to check if this CPU usage exceeds 80%. If it does, I need to track how long it stays above 80% and send an email if it's more than 2 minutes.\n\nTo track the time, I need to take timestamp readings or something similar. Maybe I can record the time whenever the CPU usage is above 80% and check if it's been more than 2 minutes continuously.\n\nBut that might be a bit complicated in bash. Maybe I can use a loop that runs every minute and checks the CPU usage. If it's above 80%, I can start a counter. If it stays above 80% for 2 consecutive checks (i.e., 2 minutes), then send the email.\n\nWait, but that might not capture the exact time it exceeds 80%. Maybe I need a more precise way.\n\nAlternatively, I can use the time stamp from the system and calculate the duration for which CPU usage has been above 80%.\n\nBut that seems a bit involved. Maybe I can simplify it by having a loop that runs every minute, checks the CPU usage, and if it's above 80%, increment a counter. Once the counter reaches 2, send the email.\n\nBut I need to make sure that the counter resets if the CPU usage drops below 80%.\n\nAlso, I need to think about how to handle the script running continuously. Maybe I can run it as a cron job that runs every minute.\n\nWait, but if I run it as a cron job every minute, and in the script, I check the CPU usage, and if it's above 80% for 2 consecutive minutes, send an email.\n\nBut how do I track the previous state in a cron job? Each cron job run is independent.\n\nMaybe I need the script to log the state to a file, like a counter file, and increment the counter each time CPU is above 80%, and reset it when it's below.\n\nSo, here's a plan:\n\n1. The script runs every minute via cron.\n\n2. It checks the CPU usage.\n\n3. If CPU usage > 80%, it reads a counter file (if exists), increments it, and writes it back.\n\n4. If the counter reaches 2, send an email.\n\n5. If CPU usage <= 80%, it resets the counter to 0.\n\nThis way, it only sends an email if CPU usage is above 80% for 2 consecutive minutes.\n\nI need to decide where to store the counter file. Maybe in /var/tmp or somewhere similar.\n\nAlso, I need to make sure that the counter file is handled properly, like checking if it exists, reading it, incrementing, writing it back.\n\nAdditionally, I need to handle email sending. For that, I can use the mail command or mutt.\n\nAssuming mailutils are installed, I can use the mail command.\n\nSo, in the script, if the counter reaches 2, I can use something like:\n\n`echo \"CPU usage is above 80% for more than 2 minutes.\" | mail -s \"CPU Usage Alert\" admin@example.com`\n\nI need to replace admin@example.com with the actual administrator's email.\n\nAlso, I need to make sure that the mail command is installed and configured on the system.\n\nNow, let's think about the script structure.\n\n- Check CPU usage using top and calculate it as 100% - idle%.\n\n- Compare it with 80%.\n\n- If above 80%:\n\n- Check if counter file exists.\n\n- If exists, read the value, increment it.\n\n- If not, create it with value 1.\n\n- If counter >= 2, send email.\n\n- If <= 80%, reset counter to 0.\n\nAlso, I need to make sure that the counter is not incremented more than necessary. Maybe set a maximum counter value.\n\nWait, in this case, since it's checking every minute, and if it's above 80% for 2 consecutive minutes, send email, and reset if it drops below.\n\nI think that should work.\n\nLet me think about potential errors.\n\n- top command might not be available.\n\n- mail command might not be installed or configured.\n\n- Permission issues with writing counter file.\n\n- Incorrect parsing of top output.\n\nTo handle these:\n\n- Check if top command is available.\n\n- Check if mail command is available.\n\n- Run the script as a user who has permissions to write to the counter file location.\n\n- Make sure the parsing of top output is robust.\n\nAlternatively, maybe I can use vmstat to get CPU usage. Vmstat is another command that reports information about processes, memory, paging, block IO, traps, and CPU activity.\n\nVmstat can be run with a delay and count to get multiple samples.\n\nFor example, `vmstat 1 2` will run vmstat twice, with a 1-second delay between samples.\n\nThe output of vmstat includes a 'us' (user), 'sy' (system), 'id' (idle), 'wa' (wait), etc., in the last row.\n\nTo get CPU usage, again, it's 100% - idle%.\n\nI can parse vmstat's output similarly to top.\n\nMaybe vmstat is more suitable for scripting because its output is simpler and more consistent.\n\nLet me check the output of vmstat.\n\n`vmstat 1 2`\n\nThis will give two samples, 1 second apart.\n\nThe last row is the average since boot, which might not be useful for me.\n\nWait, actually, vmstat with a delay and count provides multiple samples, and the last line is the average of those samples.\n\nSo, `vmstat 1 2` will give two samples, 1 second apart, and the last line is the average.\n\nI can use that average to get the CPU usage.\n\nSo, `vmstat 1 2 | tail -1` will give the last line, which is the average.\n\nThen, I can extract the idle percentage from there.\n\nLet's see an example output:\n\n`procs -----------memory---------- ---swap-- -----io---- -system-- ----cpu-----\n\n r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st\n\n 1  0      0 123456 789012 345678    0    0     0     0 1234 5678 10  5 85  0  0`\n\nSo, the last row has the CPU percentages: us, sy, id, wa, st.\n\nAgain, CPU usage is 100% - id%.\n\nSo, I can use `vmstat 1 2 | tail -1 | awk '{print $14}'` to get the idle percentage.\n\nThen, calculate CPU usage as 100 - idle%.\n\nWait, in the header, the columns are:\n\n1. procs\n\n2. memory\n\n3. swap\n\n4. io\n\n5. system\n\n6. cpu\n\nWithin cpu, the columns are us, sy, id, wa, st.\n\nSo, in the output, us is column 13, sy is 14, id is 15, wa is 16, st is 17.\n\nSo, to get idle, it's column 15.\n\nTherefore, `vmstat 1 2 | tail -1 | awk '{print $15}'`\n\nThis should give me the idle percentage.\n\nThen, CPU usage is 100 - idle%.\n\nI need to make sure that the column positions are consistent across different systems.\n\nAlternatively, I can use the -o option with vmstat to specify the output format, but that might not be available in all versions.\n\nTo make it more robust, maybe I should parse the header to determine the column positions.\n\nBut that might be overkill for a simple bash script.\n\nAlternatively, I can hardcode the column positions, assuming they are standard.\n\nI think for most Linux systems, the idle percentage is in column 15.\n\nIf that's the case, then using `vmstat 1 2 | tail -1 | awk '{print $15}'` should work.\n\nNow, I need to decide between top and vmstat.\n\nTop might be more user-friendly, but vmstat is lighter and might be more suitable for scripting.\n\nI think I'll go with vmstat for this script.\n\nSo, in the script, I'll run `vmstat 1 2 | tail -1 | awk '{print $15}'` to get the idle percentage.\n\nThen, calculate CPU usage as 100 - idle%.\n\nThen, compare it with 80%.\n\nIf above 80%, increment the counter.\n\nIf counter >= 2, send email.\n\nIf below or equal to 80%, reset counter to 0.\n\nI need to store the counter in a file.\n\nLet's decide on the counter file location.\n\nI'll use /var/tmp/cpu_alert_counter.txt.\n\nNeed to make sure that the script has write permissions to /var/tmp.\n\nAlso, I need to handle cases where the counter file doesn't exist.\n\nSo, in the script:\n\n- Check CPU usage.\n\n- If above 80%:\n\n- If counter file exists, read it, increment by 1.\n\n- If not, create it with value 1.\n\n- If counter >= 2, send email.\n\n- If below or equal to 80%, delete the counter file (to reset it).\n\nAlso, I need to make sure that the counter file is only modified if CPU is above 80%.\n\nIf CPU drops below 80%, delete the counter file.\n\nWait, but in my earlier plan, I said to reset it to 0. But in practice, deleting the file is equivalent to resetting it to 0.\n\nAlternatively, I can write 0 to the file.\n\nI think deleting the file is simpler.\n\nNow, let's think about sending the email.\n\nI need to use the mail command.\n\nAssuming mailutils are installed, the command would be:\n\n`echo \"CPU usage is above 80% for more than 2 minutes.\" | mail -s \"CPU Usage Alert\" admin@example.com`\n\nI need to replace admin@example.com with the actual administrator's email.\n\nAlso, I should include some system information in the email, like current time, CPU usage percentage, etc., for reference.\n\nSo, maybe something like:\n\n```\n\nSubject: CPU Usage Alert\n\nMessage:\n\nCPU usage is above 80% for more than 2 minutes.\n\nCurrent CPU usage: X%\n\nTime: YYYY-MM-DD HH:MM:SS\n\n```\n\nThis way, the administrator knows the current status when the alert was triggered.\n\nNow, I need to capture the current CPU usage and time in the script and include them in the email.\n\nI can store the current CPU usage and time in variables and then use them in the email body.\n\nAlso, I need to make sure that the email is only sent once per alert condition, i.e., once every time the CPU usage exceeds 80% for 2 minutes.\n\nTo achieve that, I can send the email only when the counter reaches 2, and then reset the counter after sending the email.\n\nWait, but if I delete the counter file after sending the email, and if the CPU usage is still above 80%, the next run will create a new counter file and start counting again.\n\nThat might lead to multiple emails being sent if the CPU stays above 80% for a long time.\n\nTo avoid that, maybe I should send the email when the counter reaches 2, and then reset the counter to 1, so that it doesn't send another email immediately.\n\nBut then, if CPU stays above 80%, it will send another email after another 2 minutes.\n\nMaybe it's acceptable, depending on how frequently the script runs.\n\nIf the script runs every minute via cron, and sends an email every 2 minutes as long as CPU is above 80%, that could be too frequent.\n\nAlternatively, I can send the email when the counter reaches 2, and then reset the counter to 0, so that it only sends one email per alert.\n\nBut then, if CPU stays above 80% for, say, 5 minutes, it will send one email at the 2-minute mark and then nothing else until CPU drops below 80% and then goes above again.\n\nI think sending one email per alert is sufficient.\n\nSo, in the script, when counter reaches 2, send email and reset counter to 0.\n\nNow, let's think about implementing this in bash.\n\nFirst, check CPU usage:\n\n- Run `vmstat 1 2 | tail -1 | awk '{print $15}'` to get idle percentage.\n\n- Calculate CPU usage as 100 - idle%.\n\n- Compare with 80%.\n\nIf above 80%:\n\n- Check if counter file exists.\n\n- If exists, read it, increment by 1.\n\n- If not, create it with value 1.\n\n- If counter >= 2, send email and reset counter to 0.\n\nElse (CPU <= 80%):\n\n- Delete the counter file to reset it.\n\nI need to handle file operations carefully, making sure to handle concurrency if the script is run multiple times simultaneously.\n\nBut since it's run via cron every minute, the chance of overlapping runs is low.\n\nStill, I should use locking to prevent race conditions.\n\nI can use a lock file to ensure that only one instance of the script is running at a time.\n\nSo, at the beginning of the script, try to create a lock file.\n\nIf it already exists, exit.\n\nAt the end of the script, remove the lock file.\n\nThis way, only one instance runs at a time.\n\nNow, let's think about the script structure.\n\nHere's a rough outline:\n\n```\n\n#!/bin/bash\n\nLOCK_FILE=\"/var/tmp/cpu_monitor.lock\"\n\nCOUNTER_FILE=\"/var/tmp/cpu_alert_counter.txt\"\n\nADMIN_EMAIL=\"admin@example.com\"\n\nTHRESHOLD=80\n\n# Check if lock file exists\n\nif [ -f \"$LOCK_FILE\" ]; then\n\necho \"Script is already running.\"\n\nexit 1\n\nfi\n\n# Create lock file\n\ntouch \"$LOCK_FILE\"\n\n# Function to send email\n\nsend_alert() {\n\ncurrent_time=$(date +\"%Y-%m-%d %H:%M:%S\")\n\ncpu_usage=$(vmstat 1 2 | tail -1 | awk '{print 100 - $15}')\n\necho \"CPU usage is above 80% for more than 2 minutes.\n\nCurrent CPU usage: ${cpu_usage}%\n\nTime: ${current_time}\" | mail -s \"CPU Usage Alert\" \"$ADMIN_EMAIL\"\n\n}\n\n# Check CPU usage\n\nidle_percent=$(vmstat 1 2 | tail -1 | awk '{print $15}')\n\ncpu_usage=$(echo \"100 - $idle_percent\" | bc)\n\nif (( $(echo \"$cpu_usage > $THRESHOLD\" | bc -l) )); then\n\nif [ -f \"$COUNTER_FILE\" ]; then\n\ncounter=$(cat \"$COUNTER_FILE\")\n\ncounter=$((counter + 1))\n\nelse\n\ncounter=1\n\nfi\n\necho \"$counter\" > \"$COUNTER_FILE\"\n\nif [ \"$counter\" -ge 2 ]; then\n\nsend_alert\n\nrm \"$COUNTER_FILE\"\n\nfi\n\nelse\n\nrm -f \"$COUNTER_FILE\"\n\nfi\n\n# Remove lock file\n\nrm \"$LOCK_FILE\"\n\n```\n\nThis is a basic structure. I need to test it to make sure it works as expected.\n\nSome points to note:\n\n- Use of lock file to prevent concurrent runs.\n\n- Calculation of CPU usage from vmstat output.\n\n- Handling of counter file to track consecutive minutes above threshold.\n\n- Sending email using mail command.\n\nI need to make sure that mailutils are installed on the system.\n\nAlso, bc is used for floating point arithmetic in CPU usage calculation.\n\nSo, I need to ensure that bc is installed.\n\nAlternatively, I can use awk for the calculation to avoid dependency on bc.\n\nLet me adjust that.\n\nIn the script, instead of:\n\n```\n\ncpu_usage=$(echo \"100 - $idle_percent\" | bc)\n\n```\n\nI can do:\n\n```\n\ncpu_usage=$(echo \"100 - $idle_percent\" | awk '{print $1 - $2}')\n\n```\n\nBut actually, awk can handle the entire calculation.\n\nWait, vmstat outputs idle percentage in $15, so I can calculate CPU usage directly in awk.\n\nLet me see.\n\nI can modify the command to:\n\n```\n\ncpu_usage=$(vmstat 1 2 | tail -1 | awk '{print 100 - $15}')\n\n```\n\nThis should give me the CPU usage directly.\n\nThen, in the script, I can compare it with the threshold.\n\nAlso, for sending email, I can capture the current CPU usage and time within the send_alert function.\n\nI need to make sure that the email includes relevant information.\n\nAlso, I should consider adding a subject and message body properly.\n\nMaybe use a here-document for the email content.\n\nLet me improve the send_alert function.\n\nHere's an updated version:\n\n```\n\nsend_alert() {\n\ncurrent_time=$(date +\"%Y-%m-%d %H:%M:%S\")\n\ncpu_usage=$(vmstat 1 2 | tail -1 | awk '{print 100 - $15}')\n\necho \"CPU usage is above 80% for more than 2 minutes.\n\nCurrent CPU usage: ${cpu_usage}%\n\nTime: ${current_time}\" | mail -s \"CPU Usage Alert\" \"$ADMIN_EMAIL\"\n\n}\n\n```\n\nThis should work.\n\nNow, I need to test this script.\n\nI can set up a cron job to run this script every minute.\n\nTo set up a cron job, I need to edit the crontab:\n\n```\n\ncrontab -e\n\n```\n\nThen, add a line:\n\n```\n\n* * * * * /path/to/script.sh\n\n```\n\nThis will run the script every minute.\n\nI need to make sure that the script has execute permissions.\n\n```\n\nchmod +x /path/to/script.sh\n\n```\n\nAlso, I need to make sure that all the commands used in the script are installed and accessible.\n\nLike vmstat, mail, date, awk, bc (if needed).\n\nAlternatively, I can avoid bc by using awk for calculations.\n\nLet me adjust the script to use awk for calculation.\n\nHere's an improved version:\n\n```\n\n#!/bin/bash\n\nLOCK_FILE=\"/var/tmp/cpu_monitor.lock\"\n\nCOUNTER_FILE=\"/var/tmp/cpu_alert_counter.txt\"\n\nADMIN_EMAIL=\"admin@example.com\"\n\nTHRESHOLD=80\n\n# Check if lock file exists\n\nif [ -f \"$LOCK_FILE\" ]; then\n\necho \"Script is already running.\"\n\nexit 1\n\nfi\n\n# Create lock file\n\ntouch \"$LOCK_FILE\"\n\n# Function to send email\n\nsend_alert() {\n\ncurrent_time=$(date +\"%Y-%m-%d %H:%M:%S\")\n\ncpu_usage=$(vmstat 1 2 | tail -1 | awk '{print 100 - $15}')\n\necho \"CPU usage is above 80% for more than 2 minutes.\n\nCurrent CPU usage: ${cpu_usage}%\n\nTime: ${current_time}\" | mail -s \"CPU Usage Alert\" \"$ADMIN_EMAIL\"\n\n}\n\n# Check CPU usage\n\ncpu_usage=$(vmstat 1 2 | tail -1 | awk '{print 100 - $15}')\n\nif (( $(echo \"$cpu_usage > $THRESHOLD\" | bc -l) )); then\n\nif [ -f \"$COUNTER_FILE\" ]; then\n\ncounter=$(cat \"$COUNTER_FILE\")\n\ncounter=$((counter + 1))\n\nelse\n\ncounter=1\n\nfi\n\necho \"$counter\" > \"$COUNTER_FILE\"\n\nif [ \"$counter\" -ge 2 ]; then\n\nsend_alert\n\nrm \"$COUNTER_FILE\"\n\nfi\n\nelse\n\nrm -f \"$COUNTER_FILE\"\n\nfi\n\n# Remove lock file\n\nrm \"$LOCK_FILE\"\n\n```\n\nThis should work.\n\nI need to test it by simulating high CPU usage.\n\nI can use a stress tool or some CPU-intensive process to test if the alert is triggered correctly.\n\nAlso, I need to make sure that the email is sent properly.\n\nI can test the email part separately by calling the send_alert function manually.\n\nOverall, this seems like a solid approach.\n\n## Final Solution\nTo monitor CPU usage and send an alert via email when CPU usage exceeds 80% for more than 2 minutes, you can use the following bash script. This script uses `vmstat` to monitor CPU usage and sends an email alert using the `mail` command.\n\n### Solution Code\n\n```bash\n#!/bin/bash\n\nLOCK_FILE=\"/var/tmp/cpu_monitor.lock\"\nCOUNTER_FILE=\"/var/tmp/cpu_alert_counter.txt\"\nADMIN_EMAIL=\"admin@example.com\"\nTHRESHOLD=80\n\n# Check if lock file exists\nif [ -f \"$LOCK_FILE\" ]; then\n    echo \"Script is already running.\"\n    exit 1\nfi\n\n# Create lock file\ntouch \"$LOCK_FILE\"\n\n# Function to send email\nsend_alert() {\n    current_time=$(date +\"%Y-%m-%d %H:%M:%S\")\n    cpu_usage=$(vmstat 1 2 | tail -1 | awk '{print 100 - $15}')\n    echo \"CPU usage is above 80% for more than 2 minutes.\nCurrent CPU usage: ${cpu_usage}%\nTime: ${current_time}\" | mail -s \"CPU Usage Alert\" \"$ADMIN_EMAIL\"\n}\n\n# Check CPU usage\ncpu_usage=$(vmstat 1 2 | tail -1 | awk '{print 100 - $15}')\n\nif (( $(echo \"$cpu_usage > $THRESHOLD\" | bc -l) )); then\n    if [ -f \"$COUNTER_FILE\" ]; then\n        counter=$(cat \"$COUNTER_FILE\")\n        counter=$((counter + 1))\n    else\n        counter=1\n    fi\n    echo \"$counter\" > \"$COUNTER_FILE\"\n    if [ \"$counter\" -ge 2 ]; then\n        send_alert\n        rm \"$COUNTER_FILE\"\n    fi\nelse\n    rm -f \"$COUNTER_FILE\"\nfi\n\n# Remove lock file\nrm \"$LOCK_FILE\"\n```\n\n### Explanation\n\n1. **Lock File Mechanism**: The script uses a lock file to ensure that only one instance of the script runs at a time.\n2. **CPU Usage Monitoring**: It uses `vmstat` to get CPU usage and calculates the usage percentage.\n3. **Counter Mechanism**: A counter file is used to track how many consecutive minutes the CPU usage has exceeded 80%.\n4. **Email Alert**: If the CPU usage exceeds 80% for more than 2 minutes, an email alert is sent to the administrator.\n5. **Cron Job**: Set up a cron job to run this script every minute to continuously monitor CPU usage.\n\n### Setup\n\n1. **Install Required Packages**: Ensure `mailutils` and `bc` are installed.\n    ```bash\n    sudo apt-get install mailutils bc\n    ```\n2. **Make Script Executable**:\n    ```bash\n    chmod +x /path/to/script.sh\n    ```\n3. **Set Up Cron Job**: Edit the crontab to run the script every minute.\n    ```bash\n    crontab -e\n    ```\n    Add the following line:\n    ```\n    * * * * * /path/to/script.sh\n    ```\n\nThis setup will effectively monitor CPU usage and alert the administrator via email if the usage remains above 80% for more than 2 minutes."
    }
]