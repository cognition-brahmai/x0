[
    {
        "role": "user",
        "content": "Implement a simple LRU (Least Recently Used) cache in Golang with the following features:\n   - Set and get methods for adding and retrieving data.\n   - A fixed size, specified during initialization.\n   - Automatic removal of the least recently used item when the cache is full.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Sure, I can help you implement a simple LRU cache in Golang with the specified features. We'll create a cache that has set and get methods for adding and retrieving data, a fixed size specified during initialization, and automatically removes the least recently used item when the cache is full.\n\nTo achieve this, we'll use a combination of a map for quick lookups and a doubly linked list to maintain the order of usage. The map will store the keys and their corresponding pointers to nodes in the linked list, allowing O(1) access time. The doubly linked list will help us manage the order of usage efficiently.\n\nHere's a step-by-step breakdown of the implementation:\n\n1. **Define the Cache Structure:**\n   - A map to store keys and their corresponding list nodes.\n   - A doubly linked list to maintain the order of usage.\n   - Pointers to the head and tail of the list.\n   - A counter to keep track of the current number of items in the cache.\n   - The cache size limit.\n\n2. **Set Method:**\n   - If the key already exists, update its value and move the node to the head of the list.\n   - If the key doesn't exist, create a new node, add it to the head of the list, and add it to the map.\n   - If the cache is full, remove the node at the tail of the list and delete the corresponding entry from the map.\n\n3. **Get Method:**\n   - If the key exists, retrieve its value, move the node to the head of the list, and return the value.\n   - If the key doesn't exist, return a default value or an error.\n\n4. **Helper Methods:**\n   - Methods to add a node to the head of the list.\n   - Methods to remove a node from the list.\n\nLet's write the code accordingly.\n\n## Final Solution\nTo implement a simple LRU (Least Recently Used) cache in Golang, we'll use a combination of a map for quick lookups and a doubly linked list to maintain the order of usage. This approach ensures that both the set and get operations are performed in constant time, O(1).\n\n### Approach\n\n1. **Data Structures:**\n   - **Doubly Linked List:** To maintain the order of usage. The most recently used item is at the head, and the least recently used is at the tail.\n   - **Map:** To store keys and their corresponding pointers to nodes in the linked list for O(1) access.\n\n2. **Operations:**\n   - **Get(key):** \n     - If the key exists, move the corresponding node to the head (making it the most recently used) and return its value.\n     - If the key doesn't exist, return -1.\n   - **Set(key, value):**\n     - If the key already exists, update its value and move the node to the head.\n     - If the key doesn't exist, create a new node, add it to the head, and add it to the map.\n     - If the cache is full, remove the node at the tail (least recently used) and delete the corresponding entry from the map.\n\n### Solution Code\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\ntype LRUCache struct {\n\tcapacity int\n\tsize     int\n\tcache    map[int]*DLinkedNode\n\thead     *DLinkedNode\n\ttail     *DLinkedNode\n}\n\ntype DLinkedNode struct {\n\tkey   int\n\tvalue int\n\tprev  *DLinkedNode\n\tnext  *DLinkedNode\n}\n\nfunc Constructor(capacity int) LRUCache {\n\tl := LRUCache{\n\t\tcapacity: capacity,\n\t\tsize:     0,\n\t\tcache:    make(map[int]*DLinkedNode),\n\t\thead:     &DLinkedNode{},\n\t\ttail:     &DLinkedNode{},\n\t}\n\t// Initialize the dummy head and tail\n\tl.head.next = l.tail\n\tl.tail.prev = l.head\n\treturn l\n}\n\nfunc (l *LRUCache) Get(key int) int {\n\tif node, found := l.cache[key]; found {\n\t\tl.moveToHead(node)\n\t\treturn node.value\n\t}\n\treturn -1\n}\n\nfunc (l *LRUCache) Put(key int, value int) {\n\tif node, found := l.cache[key]; found {\n\t\tnode.value = value\n\t\tl.moveToHead(node)\n\t} else {\n\t\tnewNode := &DLinkedNode{key: key, value: value}\n\t\tl.cache[key] = newNode\n\t\tl.addToHead(newNode)\n\t\tl.size++\n\t\tif l.size > l.capacity {\n\t\t\ttail := l.removeTail()\n\t\t\tdelete(l.cache, tail.key)\n\t\t\tl.size--\n\t\t}\n\t}\n}\n\nfunc (l *LRUCache) addToHead(node *DLinkedNode) {\n\tnode.prev = l.head\n\tnode.next = l.head.next\n\tl.head.next.prev = node\n\tl.head.next = node\n}\n\nfunc (l *LRUCache) removeNode(node *DLinkedNode) {\n\tnode.prev.next = node.next\n\tnode.next.prev = node.prev\n}\n\nfunc (l *LRUCache) moveToHead(node *DLinkedNode) {\n\tl.removeNode(node)\n\tl.addToHead(node)\n}\n\nfunc (l *LRUCache) removeTail() *DLinkedNode {\n\tnode := l.tail.prev\n\tl.removeNode(node)\n\treturn node\n}\n\nfunc main() {\n\tcache := Constructor(2)\n\tcache.Put(1, 1)\n\tcache.Put(2, 2)\n\tfmt.Println(cache.Get(1)) // returns 1\n\tcache.Put(3, 3)           // evicts key 2\n\tfmt.Println(cache.Get(2)) // returns -1 (not found)\n\tcache.Put(4, 4)           // evicts key 1\n\tfmt.Println(cache.Get(1)) // returns -1 (not found)\n\tfmt.Println(cache.Get(3)) // returns 3\n\tfmt.Println(cache.Get(4)) // returns 4\n}\n```\n\n### Explanation\n\n- **LRUCache Structure:**\n  - `capacity`: Maximum number of items the cache can hold.\n  - `size`: Current number of items in the cache.\n  - `cache`: Map to store keys and their corresponding DLinkedNode pointers.\n  - `head` and `tail`: Dummy nodes to simplify adding and removing nodes.\n\n- **DLinkedNode Structure:**\n  - `key` and `value`: Store the key-value pair.\n  - `prev` and `next`: Pointers to previous and next nodes in the doubly linked list.\n\n- **Constructor:**\n  - Initializes the LRUCache with given capacity.\n  - Sets up dummy head and tail nodes.\n\n- **Get Method:**\n  - Retrieves the value by key and moves the corresponding node to the head.\n  - Returns -1 if the key is not found.\n\n- **Put Method:**\n  - Adds or updates the key-value pair.\n  - Moves the updated node to the head.\n  - Evicts the least recently used item if the cache exceeds its capacity.\n\nThis implementation ensures efficient cache operations suitable for scenarios requiring limited memory and frequent access patterns."
    }
]