[
    {
        "role": "user",
        "content": "Design a simple chat application using WebSocket protocol in Golang. The server should accept incoming messages from clients, broadcast them to all connected clients, and maintain a history of the last 10 messages. Clients should be able to connect, send messages, and receive messages from the server.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Designing a simple chat application using the WebSocket protocol in Golang involves several steps. We'll create a server that manages multiple client connections, broadcasts messages to all connected clients, and maintains a history of the last 10 messages.\n\n### Step 1: Set Up the Project\n\nFirst, create a new directory for your project and initialize a new Go module.\n\n```bash\nmkdir websocket-chat\ncd websocket-chat\ngo mod init websocket.chat\n```\n\n### Step 2: Install Required Packages\n\nWe'll use the `gorilla/websocket` package for handling WebSockets in Go. Install it using:\n\n```bash\ngo get github.com/gorilla/websocket\n```\n\n### Step 3: Define the Server Structure\n\nWe need to maintain a list of connected clients and a history of messages. Define these in your server structure.\n\n```go\npackage main\n\nimport (\n\t\"log\"\n\t\"net/http\"\n\t\"sync\"\n)\n\ntype client struct {\n\tconn   *websocket.Conn\n\tsend   chan []byte\n}\n\ntype server struct {\n\tclients       map[*client]bool\n\tbroadcast     chan []byte\n\tregister      chan *client\n\tunregister    chan *client\n\tmessageHistory [10][]byte\n\thistoryIndex   int\n\tmu             sync.Mutex\n}\n\nfunc newServer() *server {\n\treturn &server{\n\t\tclients:    make(map[*client]bool),\n\t\tbroadcast:  make(chan []byte),\n\t\tregister:   make(chan *client),\n\t\tunregister: make(chan *client),\n\t}\n}\n```\n\n### Step 4: Implement Server Methods\n\nImplement methods to handle registering and unregistering clients, broadcasting messages, and maintaining message history.\n\n```go\nfunc (s *server) start() {\n\tfor {\n\t\tselect {\n\t\tcase c := <-s.register:\n\t\t\ts.clients[c] = true\n\t\t\tfor _, msg := range s.messageHistory {\n\t\t\t\tc.send <- msg\n\t\t\t}\n\t\tcase c := <-s.unregister:\n\t\t\tif _, ok := s.clients[c]; ok {\n\t\t\t\tdelete(s.clients, c)\n\t\t\t\tclose(c.send)\n\t\t\t}\n\t\tcase msg := <-s.broadcast:\n\t\t\ts.mu.Lock()\n\t\t\ts.messageHistory[s.historyIndex] = msg\n\t\t\ts.historyIndex = (s.historyIndex + 1) % 10\n\t\t\ts.mu.Unlock()\n\n\t\t\tfor c := range s.clients {\n\t\t\t\tselect {\n\t\t\t\tcase c.send <- msg:\n\t\t\t\tdefault:\n\t\t\t\t\tclose(c.send)\n\t\t\t\t\tdelete(s.clients, c)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n### Step 5: Set Up HTTP Handlers\n\nSet up an HTTP handler for WebSocket connections and start the server.\n\n```go\nvar upgrader = websocket.Upgrader{\n\tReadBufferSize:  1024,\n\tWriteBufferSize: 1024,\n\tCheckOrigin: func(r *http.Request) bool {\n\t\treturn true\n\t},\n}\n\nfunc handleConnections(s *server) http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t ws, err := upgrader.Upgrade(w, r, nil)\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t\tdefer ws.Close()\n\n\t\tclient := &client{conn: ws, send: make(chan []byte, 256)}\n\t\ts.register <- client\n\n\t\tgo client.writePump()\n\t\tgo client.readPump()\n\t}\n}\n\nfunc (c *client) readPump() {\n\tdefer func() {\n\t\tserver.unregister <- c\n\t\tc.conn.Close()\n\t}()\n\tfor {\n\t\t_, message, err := c.conn.ReadMessage()\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\t\tserver.broadcast <- message\n\t}\n}\n\nfunc (c *client) writePump() {\n\tfor {\n\t\tselect {\n\t\tcase message, ok := <-c.send:\n\t\t\tif !ok {\n\t\t\t\tc.conn.WriteMessage(websocket.CloseMessage, []byte{})\n\t\t\t\treturn\n\t\t\t}\n\t\t\terr := c.conn.WriteMessage(websocket.TextMessage, message)\n\t\t\tif err != nil {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n### Step 6: Start the Server\n\nInitialize the server and start listening for connections.\n\n```go\nfunc main() {\n\tserver := newServer()\n\tgo server.start()\n\n\thttp.HandleFunc(\"/ws\", handleConnections(server))\n\terr := http.ListenAndServe(\":8080\", nil)\n\tif err != nil {\n\t\tlog.Fatal(\"ListenAndServe: \", err)\n\t}\n}\n```\n\n### Step 7: Create a Simple Client\n\nFor testing, you can create a simple HTML page with JavaScript to connect to the WebSocket server.\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n\t<title>WebSocket Chat</title>\n</head>\n<body>\n\t<input id=\"input\" type=\"text\" />\n\t<button onclick=\"sendMessage()\">Send</button>\n\t<ul id=\"messages\"></ul>\n\n\t<script>\n\t\tconst socket = new WebSocket(\"ws://localhost:8080/ws\");\n\n\t\tsocket.onmessage = function(event) {\n\t\t\tconst li = document.createElement(\"li\");\n\t\t\tli.textContent = event.data;\n\t\t\tdocument.getElementById(\"messages\").appendChild(li);\n\t\t};\n\n\t\tfunction sendMessage() {\n\t\t\tconst input = document.getElementById(\"input\");\n\t\t\tconst msg = input.value;\n\t\t\tsocket.send(msg);\n\t\t\tinput.value = \"\";\n\t\t}\n\t</script>\n</body>\n</html>\n```\n\n### Explanation\n\n1. **Server Structure**: Maintains a list of connected clients and a history of the last 10 messages.\n2. **Registration and Unregistration**: Manages client connections and disconnections.\n3. **Broadcasting**: Sends messages to all connected clients and updates the message history.\n4. **HTTP Handlers**: Upgrades HTTP connections to WebSocket connections.\n5. **Client Handling**: Reads messages from clients and broadcasts them to all connected clients.\n6. **Client Page**: A simple HTML page with JavaScript to interact with the WebSocket server.\n\nThis setup provides a basic chat application where multiple clients can connect, send messages, and receive messages from other clients in real-time.\n"
    }
]