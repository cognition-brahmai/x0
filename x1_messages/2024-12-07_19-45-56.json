[
    {
        "role": "user",
        "content": "Create a Java-based web server that listens on a specified port and serves static HTML files from a given directory. The server should also support an endpoint to accept file uploads and save them in the specified directory using their MD5 hash as the filename."
    },
    {
        "role": "assistant",
        "content": "I'm going to create a simple web server in Java that can serve static HTML files and handle file uploads, saving them with their MD5 hash as the filename. I'll use the built-in Java libraries to achieve this, without relying on external frameworks like Spring or Servlets, to keep it as basic as possible.\n\n### Step 1: Set Up the Project\n\nFirst, I'll set up a basic Java project structure. Since I'm keeping it simple, I won't use any build tools like Maven or Gradle. I'll just have a simple Java class that starts the server.\n\n### Step 2: Create the Server Class\n\nI'll create a class called `SimpleWebServer` that will handle incoming HTTP requests. To handle multiple clients, I'll use multi-threading, where each client connection is handled in a separate thread.\n\n### Step 3: Handle GET Requests for Static Files\n\nFor GET requests, I'll check if the requested path corresponds to a file in the specified directory. If it does, I'll read the file and send it back to the client with the appropriate content type.\n\n### Step 4: Handle POST Requests for File Uploads\n\nFor POST requests to a specific endpoint, say `/upload`, I'll read the uploaded file, compute its MD5 hash, and save it with that hash as the filename in the specified directory.\n\n### Step 5: Implement MD5 Hashing\n\nI'll need a method to compute the MD5 hash of the uploaded file to use as its filename.\n\n### Step 6: Test the Server\n\nFinally, I'll test the server by starting it and accessing it via a web browser to retrieve static HTML files and using a tool like Postman to test file uploads.\n\n### Solution Code\n\nHere's a basic implementation of the requirements:\n\n```java\nimport java.io.*;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.security.MessageDigest;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class SimpleWebServer {\n    private int port;\n    private String rootDirectory;\n\n    public SimpleWebServer(int port, String rootDirectory) {\n        this.port = port;\n        this.rootDirectory = rootDirectory;\n    }\n\n    public static void main(String[] args) {\n        if (args.length != 2) {\n            System.out.println(\"Usage: java SimpleWebServer <port> <root_directory>\");\n            System.exit(1);\n        }\n\n        int port = Integer.parseInt(args[0]);\n        String rootDirectory = args[1];\n\n        new SimpleWebServer(port, rootDirectory).start();\n    }\n\n    public void start() {\n        try (ServerSocket serverSocket = new ServerSocket(port)) {\n            System.out.println(\"Server started on port \" + port);\n            ExecutorService executor = Executors.newFixedThreadPool(10);\n\n            while (true) {\n                Socket clientSocket = serverSocket.accept();\n                executor.execute(new ClientHandler(clientSocket, rootDirectory));\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\nclass ClientHandler implements Runnable {\n    private Socket socket;\n    private String rootDirectory;\n\n    public ClientHandler(Socket socket, String rootDirectory) {\n        this.socket = socket;\n        this.rootDirectory = rootDirectory;\n    }\n\n    @Override\n    public void run() {\n        try {\n            BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n            PrintWriter out = new PrintWriter(socket.getOutputStream(), true);\n\n            String requestLine = in.readLine();\n            if (requestLine == null || requestLine.isEmpty()) {\n                return;\n            }\n\n            String[] parts = requestLine.split(\" \");\n            if (parts.length < 2) {\n                return;\n            }\n\n            String method = parts[0];\n            String path = parts[1];\n\n            if (\"GET\".equals(method)) {\n                handleGet(out, path);\n            } else if (\"POST\".equals(method)) {\n                handlePost(out, in, path);\n            } else {\n                sendResponse(out, 501, \"Not Implemented\", \"text/plain\", \"Method not implemented\");\n            }\n\n            socket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void handleGet(PrintWriter out, String path) throws IOException {\n        if (\"/\".equals(path)) {\n            path = \"/index.html\";\n        }\n\n        File file = new File(rootDirectory + path);\n        if (!file.exists() || !file.isFile()) {\n            sendResponse(out, 404, \"Not Found\", \"text/plain\", \"File not found\");\n            return;\n        }\n\n        String contentType = getContentType(path);\n        sendFile(out, file, contentType);\n    }\n\n    private void handlePost(PrintWriter out, BufferedReader in, String path) throws IOException {\n        if (!\"/upload\".equals(path)) {\n            sendResponse(out, 404, \"Not Found\", \"text/plain\", \"Endpoint not found\");\n            return;\n        }\n\n        String boundary = getBoundary(in);\n        if (boundary == null) {\n            sendResponse(out, 400, \"Bad Request\", \"text/plain\", \"Invalid request\");\n            return;\n        }\n\n        File uploadedFile = saveUpload(in, boundary);\n        if (uploadedFile == null) {\n            sendResponse(out, 500, \"Internal Server Error\", \"text/plain\", \"Failed to save file\");\n            return;\n        }\n\n        String md5Filename = getMD5Filename(uploadedFile);\n        File destFile = new File(rootDirectory + \"/\" + md5Filename);\n        uploadedFile.renameTo(destFile);\n\n        sendResponse(out, 200, \"OK\", \"text/plain\", \"File uploaded successfully as \" + md5Filename);\n    }\n\n    private String getBoundary(BufferedReader in) throws IOException {\n        String headerLine;\n        while ((headerLine = in.readLine()) != null && !headerLine.isEmpty()) {\n            if (headerLine.startsWith(\"Content-Type:\")) {\n                String[] parts = headerLine.split(\";\");\n                for (String part : parts) {\n                    part = part.trim();\n                    if (part.startsWith(\"boundary=\")) {\n                        return part.substring(\"boundary=\".length());\n                    }\n                }\n            }\n        }\n        return null;\n    }\n\n    private File saveUpload(BufferedReader in, String boundary) throws IOException {\n        StringBuilder content = new StringBuilder();\n        String line;\n        while ((line = in.readLine()) != null) {\n            content.append(line).append(\"\\n\");\n        }\n\n        String body = content.toString();\n        int start = body.indexOf(boundary) + boundary.length();\n        int end = body.indexOf(\"--\", start);\n        String fileData = body.substring(start, end).trim();\n\n        File tempFile = File.createTempFile(\"upload\", null);\n        try (FileWriter fw = new FileWriter(tempFile)) {\n            fw.write(fileData);\n        }\n\n        return tempFile;\n    }\n\n    private String getMD5Filename(File file) throws IOException {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            try (InputStream is = new FileInputStream(file)) {\n                byte[] buffer = new byte[8192];\n                int read;\n                while ((read = is.read(buffer)) > 0) {\n                    md.update(buffer, 0, read);\n                }\n            }\n            byte[] digest = md.digest();\n            StringBuilder hexString = new StringBuilder();\n            for (byte b : digest) {\n                String hex = Integer.toHexString(0xff & b);\n                if (hex.length() == 1) hexString.append('0');\n                hexString.append(hex);\n            }\n            return hexString.toString();\n        } catch (Exception e) {\n            e.printStackTrace();\n            throw new IOException(\"Failed to compute MD5 hash\");\n        }\n    }\n\n    private void sendFile(PrintWriter out, File file, String contentType) throws IOException {\n        try (FileInputStream fis = new FileInputStream(file);\n             BufferedInputStream bis = new BufferedInputStream(fis)) {\n\n            byte[] buffer = new byte[4096];\n            int bytes;\n\n            out.println(\"HTTP/1.1 200 OK\");\n            out.println(\"Content-Type: \" + contentType);\n            out.println();\n\n            OutputStream os = socket.getOutputStream();\n            while ((bytes = bis.read(buffer)) != -1) {\n                os.write(buffer, 0, bytes);\n            }\n        }\n    }\n\n    private void sendResponse(PrintWriter out, int statusCode, String statusMessage, String contentType, String body) {\n        out.println(\"HTTP/1.1 \" + statusCode + \" \" + statusMessage);\n        out.println(\"Content-Type: \" + contentType);\n        out.println(\"Content-Length: \" + body.length());\n        out.println();\n        out.println(body);\n    }\n\n    private String getContentType(String path) {\n        if (path.endsWith(\".html\")) return \"text/html\";\n        if (path.endsWith(\".css\")) return \"text/css\";\n        if (path.endsWith(\".js\")) return \"application/javascript\";\n        if (path.endsWith(\".jpg\") || path.endsWith(\".jpeg\")) return \"image/jpeg\";\n        if (path.endsWith(\".png\")) return \"image/png\";\n        if (path.endsWith(\".gif\")) return \"image/gif\";\n        return \"application/octet-stream\";\n    }\n}\n```\n\n### Explanation\n\n1. **Server Setup**: The `SimpleWebServer` class sets up a server socket on the specified port and handles client connections using a fixed thread pool.\n2. **Request Handling**: The `ClientHandler` class processes each client request. It supports GET and POST methods.\n3. **Static File Serving**: For GET requests, it serves static files from the specified root directory, determining the content type based on the file extension.\n4. **File Upload Handling**: For POST requests to `/upload`, it reads the uploaded file, computes its MD5 hash, and saves it with the hash as the filename in the root directory.\n5. **MD5 Hashing**: The `getMD5Filename` method computes the MD5 hash of the uploaded file to generate a unique filename.\n\nThis basic implementation should serve as a starting point for a simple web server in Java that handles static file serving and file uploads with MD5 hashing."
    }
]