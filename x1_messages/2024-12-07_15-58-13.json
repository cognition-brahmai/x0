[
    {
        "role": "user",
        "content": "In GoLang, implement a RESTful API that interacts with a Cassandra database. The API should provide endpoints to perform CRUD operations on a 'Users' table. Each user record should contain fields like id, name, email, and password. PLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Alright, I've got this task to create a RESTful API in Go that interacts with a Cassandra database for CRUD operations on a 'Users' table. Sounds straightforward, but I need to make sure I cover all the bases here. Let's break it down step by step.\n\nFirst things first, I need to set up a Go project structure. I'll create a new directory for my project, say, 'user-api', and inside that, I'll have folders for 'models', 'handlers', 'db', and maybe 'middleware' if needed later on.\n\nNext, I need to connect to a Cassandra database. I'll need to install the Go driver for Cassandra. I can do that using 'go get github.com/gocql/gocql'. Once that's installed, I can set up a connection in my 'db' package.\n\nLet me think about the 'Users' table schema. It should have fields like id, name, email, and password. For id, I'll probably use UUIDs to avoid collisions and make it scalable. Name and email will be strings, and password should be stored securely, probably hashed.\n\nWait, security is important here. Storing passwords in plain text is a big no-no. I need to hash them using a strong hashing algorithm like bcrypt before storing in the database. I should also make sure that the API handles HTTPS to encrypt data in transit.\n\nOkay, moving on to the API endpoints. For CRUD operations, I'll need:\n\n- GET /users to list all users\n\n- POST /users to create a new user\n\n- GET /users/:id to get a single user by ID\n\n- PUT /users/:id to update a user\n\n- DELETE /users/:id to delete a user\n\nI should also think about error handling and response formats. I'll probably use JSON for all responses and requests.\n\nLet me sketch out the basic structure of the Go code.\n\nFirst, the main function will set up the router and database connection.\n\nIn the 'models' package, I'll define the User struct:\n\ntype User struct {\n\nID       gocql.UUID\n\nName     string\n\nEmail    string\n\nPassword string\n\n}\n\nIn the 'db' package, I'll create functions to Connect, CreateUser, GetUser, UpdateUser, and DeleteUser.\n\nIn the 'handlers' package, I'll write functions for each endpoint:\n\n- ListUsersHandler\n\n- CreateUserHandler\n\n- GetUserHandler\n\n- UpdateUserHandler\n\n- DeleteUserHandler\n\nEach handler will handle the HTTP request, interact with the database through the 'db' package functions, and return an appropriate JSON response.\n\nI need to make sure that the API is secure. For authentication, maybe I can add token-based authentication using JWT, but that might be beyond the scope of this task. For now, I'll focus on the basic CRUD operations.\n\nData validation is also important. I should validate that the required fields are present and that email is in the correct format before storing or updating user data.\n\nLet me think about how to handle UUIDs. Go's gocql package has a UUID type, and I can generate new UUIDs using gocql.TimeUUID().\n\nFor hashing passwords, I'll need to install a package like 'golang.org/x/crypto/bcrypt' to hash passwords before storing them.\n\nAlso, when retrieving users, I shouldn't return the password field; it's a security risk.\n\nFor the HTTP server, I can use net/http or a third-party package like Gorilla Mux for better routing.\n\nLet me outline the steps in code:\n\n1. Set up database connection in 'db/connect.go'\n\n2. Define User model in 'models/user.go'\n\n3. Create database functions in 'db/user.go'\n\n4. Write handlers in 'handlers/users.go'\n\n5. Set up routes in 'main.go'\n\nI should also consider using environment variables for database connection settings for better security and flexibility.\n\nOkay, let's start writing some code.\n\nFirst, create the project structure:\n\n- user-api\n\n- db\n\n- connect.go\n\n- user.go\n\n- handlers\n\n- users.go\n\n- models\n\n- user.go\n\n- main.go\n\nIn 'db/connect.go', set up the database connection:\n\npackage db\n\nimport (\n\n\"gocql\"\n\n\"log\"\n\n)\n\nvar session *gocql.Session\n\nfunc Connect() {\n\ncluster := gocql.NewCluster(\"127.0.0.1\")\n\ncluster.Keyspace = \"mykeyspace\"\n\nvar err error\n\nsession, err = cluster.CreateSession()\n\nif err != nil {\n\nlog.Fatal(err)\n\n}\n\n}\n\nfunc GetSession() *gocql.Session {\n\nreturn session\n\n}\n\nIn 'models/user.go', define the User struct:\n\npackage models\n\nimport (\n\n\"gocql\"\n\n)\n\ntype User struct {\n\nID       gocql.UUID `json:\"id\"`\n\nName     string    `json:\"name\"`\n\nEmail    string    `json:\"email\"`\n\nPassword string    `json:\"password\"`\n\n}\n\nIn 'db/user.go', create functions to interact with the database:\n\npackage db\n\nimport (\n\n\"gocql\"\n\n\"User-API/models\"\n\n)\n\nfunc CreateUser(user *models.User) error {\n\nquery := `INSERT INTO users (id, name, email, password) VALUES (?, ?, ?, ?)`\n\nerr := session.Query(query, user.ID, user.Name, user.Email, user.Password).Exec()\n\nreturn err\n\n}\n\nfunc GetUser(id gocql.UUID) (*models.User, error) {\n\nvar user models.User\n\nerr := session.Query(\"SELECT id, name, email FROM users WHERE id = ?\", id).Scan(&user.ID, &user.Name, &user.Email)\n\nif err != nil {\n\nreturn nil, err\n\n}\n\nreturn &user, nil\n\n}\n\nfunc UpdateUser(user *models.User) error {\n\nquery := `UPDATE users SET name = ?, email = ? WHERE id = ?`\n\nreturn session.Query(query, user.Name, user.Email, user.ID).Exec()\n\n}\n\nfunc DeleteUser(id gocql.UUID) error {\n\nquery := `DELETE FROM users WHERE id = ?`\n\nreturn session.Query(query, id).Exec()\n\n}\n\nIn 'handlers/users.go', write the handler functions:\n\npackage handlers\n\nimport (\n\n\"net/http\"\n\n\"github.com/gorilla/mux\"\n\n\"User-API/db\"\n\n\"User-API/models\"\n\n\"encoding/json\"\n\n)\n\nfunc ListUsersHandler(w http.ResponseWriter, r *http.Request) {\n\n// Implement listing all users\n\n}\n\nfunc CreateUserHandler(w http.ResponseWriter, r *http.Request) {\n\nvar user models.User\n\nerr := json.NewDecoder(r.Body).Decode(&user)\n\nif err != nil {\n\nhttp.Error(w, err.Error(), http.StatusBadRequest)\n\nreturn\n\n}\n\nerr = db.CreateUser(&user)\n\nif err != nil {\n\nhttp.Error(w, err.Error(), http.StatusInternalServerError)\n\nreturn\n\n}\n\nw.WriteHeader(http.StatusCreated)\n\njson.NewEncoder(w).Encode(user)\n\n}\n\nfunc GetUserHandler(w http.ResponseWriter, r *http.Request) {\n\nvars := mux.Vars(r)\n\nidStr := vars[\"id\"]\n\nid, err := gocql.ParseUUID(idStr)\n\nif err != nil {\n\nhttp.Error(w, err.Error(), http.StatusBadRequest)\n\nreturn\n\n}\n\nuser, err := db.GetUser(id)\n\nif err != nil {\n\nhttp.Error(w, err.Error(), http.StatusNotFound)\n\nreturn\n\n}\n\njson.NewEncoder(w).Encode(user)\n\n}\n\nfunc UpdateUserHandler(w http.ResponseWriter, r *http.Request) {\n\nvars := mux.Vars(r)\n\nidStr := vars[\"id\"]\n\nid, err := gocql.ParseUUID(idStr)\n\nif err != nil {\n\nhttp.Error(w, err.Error(), http.StatusBadRequest)\n\nreturn\n\n}\n\nvar user models.User\n\nerr = json.NewDecoder(r.Body).Decode(&user)\n\nif err != nil {\n\nhttp.Error(w, err.Error(), http.StatusBadRequest)\n\nreturn\n\n}\n\nuser.ID = id\n\nerr = db.UpdateUser(&user)\n\nif err != nil {\n\nhttp.Error(w, err.Error(), http.StatusInternalServerError)\n\nreturn\n\n}\n\njson.NewEncoder(w).Encode(user)\n\n}\n\nfunc DeleteUserHandler(w http.ResponseWriter, r *http.Request) {\n\nvars := mux.Vars(r)\n\nidStr := vars[\"id\"]\n\nid, err := gocql.ParseUUID(idStr)\n\nif err != nil {\n\nhttp.Error(w, err.Error(), http.StatusBadRequest)\n\nreturn\n\n}\n\nerr = db.DeleteUser(id)\n\nif err != nil {\n\nhttp.Error(w, err.Error(), http.StatusInternalServerError)\n\nreturn\n\n}\n\nw.WriteHeader(http.StatusNoContent)\n\n}\n\nIn 'main.go', set up the router and database connection:\n\npackage main\n\nimport (\n\n\"log\"\n\n\"net/http\"\n\n\"User-API/db\"\n\n\"User-API/handlers\"\n\n\"github.com/gorilla/mux\"\n\n)\n\nfunc main() {\n\ndb.Connect()\n\nrouter := mux.NewRouter()\n\nrouter.HandleFunc(\"/users\", handlers.ListUsersHandler).Methods(\"GET\")\n\nrouter.HandleFunc(\"/users\", handlers.CreateUserHandler).Methods(\"POST\")\n\nrouter.HandleFunc(\"/users/{id}\", handlers.GetUserHandler).Methods(\"GET\")\n\nrouter.HandleFunc(\"/users/{id}\", handlers.UpdateUserHandler).Methods(\"PUT\")\n\nrouter.HandleFunc(\"/users/{id}\", handlers.DeleteUserHandler).Methods(\"DELETE\")\n\nlog.Fatal(http.ListenAndServe(\":8080\", router))\n\n}\n\nWait, I need to implement the ListUsersHandler. Let's do that in 'handlers/users.go':\n\nfunc ListUsersHandler(w http.ResponseWriter, r *http.Request) {\n\nvar users []*models.User\n\n iter := db.GetSession().Query(\"SELECT id, name, email FROM users\").Iter()\n\n for iter.Scan(&user.ID, &user.Name, &user.Email) {\n\n users = append(users, &user)\n\n }\n\n if err := iter.Close(); err != nil {\n\n http.Error(w, err.Error(), http.StatusInternalServerError)\n\n return\n\n }\n\n json.NewEncoder(w).Encode(users)\n\n}\n\nAlso, I need to make sure that the Cassandra keyspace and table are created beforehand. I'll need to run some CQL commands to set that up.\n\nLet me write the CQL commands for creating the keyspace and table.\n\nCreate the keyspace:\n\nCREATE KEYSPACE IF NOT EXISTS mykeyspace\n\nWITH replication = {'class': 'SimpleStrategy', 'replication_factor': 1};\n\nUse the keyspace:\n\nUSE mykeyspace;\n\nCreate the users table:\n\nCREATE TABLE IF NOT EXISTS users (\n\nid UUID PRIMARY KEY,\n\nname TEXT,\n\nemail TEXT,\n\npassword TEXT\n\n);\n\nI should also think about indexing email for faster lookups, but for now, I'll keep it simple.\n\nAlright, now, regarding password hashing. I need to hash the password before storing it in the database.\n\nLet me add that to the 'db/user.go' in the CreateUser function.\n\nFirst, install the bcrypt package:\n\ngo get golang.org/x/crypto/bcrypt\n\nThen, in 'db/user.go':\n\nimport (\n\n\"gocql\"\n\n\"User-API/models\"\n\n\"golang.org/x/crypto/bcrypt\"\n\n)\n\nfunc CreateUser(user *models.User) error {\n\nhashedPassword, err := bcrypt.GenerateFromPassword([]byte(user.Password), bcrypt.DefaultCost)\n\nif err != nil {\n\nreturn err\n\n}\n\nuser.Password = string(hashedPassword)\n\nquery := `INSERT INTO users (id, name, email, password) VALUES (?, ?, ?, ?)`\n\nerr = session.Query(query, user.ID, user.Name, user.Email, user.Password).Exec()\n\nreturn err\n\n}\n\nAnd when retrieving users, make sure not to include the password field in the SELECT statement.\n\nWait, in the GetUser function, I already have that:\n\nfunc GetUser(id gocql.UUID) (*models.User, error) {\n\nvar user models.User\n\nerr := session.Query(\"SELECT id, name, email FROM users WHERE id = ?\", id).Scan(&user.ID, &user.Name, &user.Email)\n\nif err != nil {\n\nreturn nil, err\n\n}\n\nreturn &user, nil\n\n}\n\nThat's good. Password is not included in the response.\n\nSimilarly, in ListUsersHandler, only id, name, and email are selected.\n\nNow, for updating a user, if the password is being updated, I need to hash it again before storing.\n\nIn UpdateUserHandler, I need to check if the password field is present in the request and hash it if it is.\n\nLet me modify the UpdateUser function in 'db/user.go' to handle password hashing if the password is provided.\n\nfunc UpdateUser(user *models.User) error {\n\nif user.Password != \"\" {\n\nhashedPassword, err := bcrypt.GenerateFromPassword([]byte(user.Password), bcrypt.DefaultCost)\n\nif err != nil {\n\nreturn err\n\n}\n\nuser.Password = string(hashedPassword)\n\n} else {\n\n// If password is not provided, don't update it\n\nquery := `UPDATE users SET name = ?, email = ? WHERE id = ?`\n\nreturn session.Query(query, user.Name, user.Email, user.ID).Exec()\n\n}\n\nquery := `UPDATE users SET name = ?, email = ?, password = ? WHERE id = ?`\n\nreturn session.Query(query, user.Name, user.Email, user.Password, user.ID).Exec()\n\n}\n\nWait, but in the UpdateUserHandler, I'm decoding the entire User struct from the request body, including password. If the client doesn't provide a password, it should leave the password field unchanged.\n\nSo, in the handler, I need to check if the password field is present in the request JSON.\n\nAlternatively, I can expect the client to send only the fields they want to update, but that complicates things.\n\nMaybe it's simpler to require the client to send the entire user object, including the current password if they want to update it.\n\nBut that might not be ideal. Perhaps a better approach is to require the client to send only the fields they want to update, and handle partial updates.\n\nLet me adjust the UpdateUserHandler to handle partial updates.\n\nFirst, in the handler, decode the request body into a map of strings to interface{} to handle partial updates.\n\nThen, build the CQL query dynamically based on the fields provided.\n\nThis sounds a bit involved, but it's a good practice.\n\nIn 'handlers/users.go', modify UpdateUserHandler:\n\nfunc UpdateUserHandler(w http.ResponseWriter, r *http.Request) {\n\nvars := mux.Vars(r)\n\nidStr := vars[\"id\"]\n\nid, err := gocql.ParseUUID(idStr)\n\nif err != nil {\n\nhttp.Error(w, err.Error(), http.StatusBadRequest)\n\nreturn\n\n}\n\nvar updates map[string]interface{}\n\nerr = json.NewDecoder(r.Body).Decode(&updates)\n\nif err != nil {\n\nhttp.Error(w, err.Error(), http.StatusBadRequest)\n\nreturn\n\n}\n\nif password, ok := updates[\"password\"].(string); ok && password != \"\" {\n\nhashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)\n\nif err != nil {\n\nhttp.Error(w, err.Error(), http.StatusInternalServerError)\n\nreturn\n\n}\n\nupdates[\"password\"] = string(hashedPassword)\n\n}\n\nfields := make([]string, 0, len(updates))\n\nvalues := make([]interface{}, 0, len(updates))\n\nfor k, v := range updates {\n\nfields = append(fields, k+\" = ?\")\n\nvalues = append(values, v)\n\n}\n\nquery := \"UPDATE users SET \" + strings.Join(fields, \", \") + \" WHERE id = ?\"\n\nvalues = append(values, id)\n\nstmt, err := db.GetSession().Prepare(query)\n\nif err != nil {\n\nhttp.Error(w, err.Error(), http.StatusInternalServerError)\n\nreturn\n\n}\n\nerr = db.GetSession().Query(stmt, values...).Exec()\n\nif err != nil {\n\nhttp.Error(w, err.Error(), http.StatusInternalServerError)\n\nreturn\n\n}\n\n// Retrieve the updated user to return in the response\n\nuser, err := db.GetUser(id)\n\nif err != nil {\n\nhttp.Error(w, err.Error(), http.StatusInternalServerError)\n\nreturn\n\n}\n\njson.NewEncoder(w).Encode(user)\n\n}\n\nThis way, the client can send only the fields they want to update, and the API will handle hashing the password if it's provided.\n\nFor example, to update only the name:\n\nPUT /users/{id}\n\n{\n\n\"name\": \"New Name\"\n\n}\n\nTo update name and password:\n\nPUT /users/{id}\n\n{\n\n\"name\": \"New Name\",\n\n\"password\": \"newpassword\"\n\n}\n\nThe password will be hashed before storing.\n\nNow, for deleting a user, it's straightforward. Just execute the DELETE query based on the ID.\n\nI should also think about error handling. For example, if a user with the given ID doesn't exist, I should return a 404 Not Found error.\n\nIn GetUserHandler, I can check if the user is nil and return 404.\n\nSimilarly, in DeleteUserHandler, if the delete operation doesn't affect any rows, I can return 404.\n\nWait, in gocql, the Delete query doesn't return the number of affected rows. It just executes the delete operation.\n\nSo, perhaps after deleting, I can try to get the user and if it's not found, confirm that the deletion was successful.\n\nBut that might be inefficient. Maybe I can assume that if there's no error in the delete operation, it was successful.\n\nCassandra doesn't guarantee that the row existed before deletion; it just deletes it if it exists.\n\nSo, for simplicity, I'll assume that if the delete operation succeeds without error, the user was deleted, even if it didn't exist in the first place.\n\nNow, for the ListUsersHandler, I need to retrieve all users from the database.\n\nIn a large dataset, this could be problematic, so maybe I should implement pagination.\n\nBut for now, I'll keep it simple and retrieve all users.\n\nI should also consider the performance implications of selecting all users in a Cassandra cluster, but again, for this basic example, it should be fine.\n\nAnother thing to consider is that Cassandra is eventually consistent, so reads might not immediately reflect recent writes.\n\nBut for this simple API, I'll assume strong consistency for reads and writes.\n\nAlso, I should make sure to handle errors properly in all handlers and ensure that the database connection is closed properly when the application exits.\n\nI can add a function to close the session in 'db/connect.go':\n\nfunc Close() {\n\nif session != nil {\n\nsession.Close()\n\n}\n\n}\n\nAnd in 'main.go', I can use defer to close the session when the main function exits:\n\nfunc main() {\n\ndb.Connect()\n\ndefer db.Close()\n\n// Set up router and start server\n\n}\n\nNow, to test the API, I can use tools like curl or Postman to send HTTP requests to the endpoints.\n\nFor example, to create a new user:\n\ncurl -X POST -H \"Content-Type: application/json\" -d '{\"name\":\"John Doe\",\"email\":\"john@example.com\",\"password\":\"secret\"}' http://localhost:8080/users\n\nThis should return the created user with an assigned ID and a 201 Created status code.\n\nTo get a user by ID:\n\ncurl -X GET http://localhost:8080/users/{id}\n\nTo update a user:\n\ncurl -X PUT -H \"Content-Type: application/json\" -d '{\"name\":\"Jane Doe\",\"email\":\"jane@example.com\"}' http://localhost:8080/users/{id}\n\nTo delete a user:\n\ncurl -X DELETE http://localhost:8080/users/{id}\n\nI should also make sure to handle invalid UUIDs and other input validation errors.\n\nAdditionally, I can add logging to the handlers to log requests and errors.\n\nFor example, using the standard log package:\n\nlog.Println(\"Received request to create user:\", user)\n\nOr using a more advanced logging library like logrus.\n\nSecurity-wise, besides hashing passwords, I should make sure that the API is only accessible over HTTPS to encrypt data in transit.\n\nI can configure the server to use TLS certificates, but that's beyond the scope of this basic implementation.\n\nAlso, I should consider rate limiting to prevent abuse of the API, but again, that's a further enhancement.\n\nError responses should be in JSON format, providing meaningful error messages without exposing sensitive information.\n\nFor example:\n\n{\n\n\"error\": \"User not found\"\n\n}\n\nOr\n\n{\n\n\"error\": \"Invalid UUID format\"\n\n}\n\nI should avoid\u6cc4\u9732\u4efb\u4f55\u654f\u611f\u4fe1\u606f\uff0c\u5982\u6570\u636e\u5e93\u9519\u8bef\u6d88\u606f\u3002\n\n\u6700\u540e\uff0c\u6211\u9700\u8981\u786e\u4fdd\u4ee3\u7801\u662f\u53ef\u7ef4\u62a4\u7684\uff0c\u5e76\u4e14\u6709\u9002\u5f53\u7684\u6ce8\u91ca\u3002\n\n\u6211\u53ef\u80fd\u8fd8\u9700\u8981\u7f16\u5199\u4e00\u4e9b\u5355\u5143\u6d4b\u8bd5\u6765\u9a8c\u8bc1\u6570\u636e\u5e93\u64cd\u4f5c\u548c\u5904\u7406\u7a0b\u5e8f\u7684\u529f\u80fd\u3002\n\n\u603b\u7684\u6765\u8bf4\uff0c\u8fd9\u4e2a\u4efb\u52a1\u9700\u8981\u6211\u8bbe\u7f6e\u4e00\u4e2aGo\u9879\u76ee\uff0c\u8fde\u63a5\u5230Cassandra\u6570\u636e\u5e93\uff0c\u5b9a\u4e49\u7528\u6237\u6a21\u578b\uff0c\u5b9e\u73b0CRUD\u64cd\u4f5c\u7684\u5904\u7406\u7a0b\u5e8f\uff0c\u5e76\u8bbe\u7f6e\u8def\u7531\u6765\u5904\u7406HTTP\u8bf7\u6c42\u3002\n\n\u901a\u8fc7\u9010\u6b65\u6784\u5efa\u6bcf\u4e2a\u90e8\u5206\uff0c\u5e76\u786e\u4fdd\u6bcf\u4e2a\u7ec4\u4ef6\u90fd\u80fd\u6b63\u5e38\u5de5\u4f5c\uff0c\u6211\u5e94\u8be5\u80fd\u591f\u6210\u529f\u5730\u521b\u5efa\u8fd9\u4e2aRESTful API\u3002\n\n**\u6700\u7ec8\u4ee3\u7801**\n\n\u4ee5\u4e0b\u662f\u5b8c\u6574\u7684\u4ee3\u7801\u5b9e\u73b0\uff1a\n\n### \u76ee\u5f55\u7ed3\u6784\n\n```\nuser-api\n\n\u251c\u2500\u2500 db\n\n\u2502   \u251c\u2500\u2500 connect.go\n\n\u2502   \u2514\u2500\u2500 user.go\n\n\u251c\u2500\u2500 handlers\n\n\u2502   \u2514\u2500\u2500 users.go\n\n\u251c\u2500\u2500 models\n\n\u2502   \u2514\u2500\u2500 user.go\n\n\u251c\u2500\u2500 main.go\n\n```\n\n### db/connect.go\n\n```go\npackage db\n\nimport (\n    \"gocql\"\n    \"log\"\n)\n\nvar session *gocql.Session\n\nfunc Connect() {\n    cluster := gocql.NewCluster(\"127.0.0.1\")\n    cluster.Keyspace = \"mykeyspace\"\n    var err error\n    session, err = cluster.CreateSession()\n    if err != nil {\n        log.Fatal(err)\n    }\n}\n\nfunc GetSession() *gocql.Session {\n    return session\n}\n\nfunc Close() {\n    if session != nil {\n        session.Close()\n    }\n}\n```\n\n### models/user.go\n\n```go\npackage models\n\nimport (\n    \"gocql\"\n)\n\ntype User struct {\n    ID       gocql.UUID `json:\"id\"`\n    Name     string    `json:\"name\"`\n    Email    string    `json:\"email\"`\n    Password string    `json:\"password\"`\n}\n```\n\n### db/user.go\n\n```go\npackage db\n\nimport (\n    \"gocql\"\n    \"User-API/models\"\n    \"golang.org/x/crypto/bcrypt\"\n)\n\nfunc CreateUser(user *models.User) error {\n    hashedPassword, err := bcrypt.GenerateFromPassword([]byte(user.Password), bcrypt.DefaultCost)\n    if err != nil {\n        return err\n    }\n    user.Password = string(hashedPassword)\n    query := `INSERT INTO users (id, name, email, password) VALUES (?, ?, ?, ?)`\n    err = session.Query(query, user.ID, user.Name, user.Email, user.Password).Exec()\n    return err\n}\n\nfunc GetUser(id gocql.UUID) (*models.User, error) {\n    var user models.User\n    err := session.Query(\"SELECT id, name, email FROM users WHERE id = ?\", id).Scan(&user.ID, &user.Name, &user.Email)\n    if err != nil {\n        return nil, err\n    }\n    return &user, nil\n}\n\nfunc UpdateUser(user *models.User) error {\n    if user.Password != \"\" {\n        hashedPassword, err := bcrypt.GenerateFromPassword([]byte(user.Password), bcrypt.DefaultCost)\n        if err != nil {\n            return err\n        }\n        user.Password = string(hashedPassword)\n    } else {\n        // If password is not provided, don't update it\n        query := `UPDATE users SET name = ?, email = ? WHERE id = ?`\n        return session.Query(query, user.Name, user.Email, user.ID).Exec()\n    }\n    query := `UPDATE users SET name = ?, email = ?, password = ? WHERE id = ?`\n    return session.Query(query, user.Name, user.Email, user.Password, user.ID).Exec()\n}\n\nfunc DeleteUser(id gocql.UUID) error {\n    query := `DELETE FROM users WHERE id = ?`\n    return session.Query(query, id).Exec()\n}\n```\n\n### handlers/users.go\n\n```go\npackage handlers\n\nimport (\n    \"encoding/json\"\n    \"net/http\"\n    \"github.com/gorilla/mux\"\n    \"User-API/db\"\n    \"User-API/models\"\n    \"strings\"\n)\n\nfunc ListUsersHandler(w http.ResponseWriter, r *http.Request) {\n    var users []*models.User\n    iter := db.GetSession().Query(\"SELECT id, name, email FROM users\").Iter()\n    for iter.Scan(&user.ID, &user.Name, &user.Email) {\n        users = append(users, &user)\n    }\n    if err := iter.Close(); err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n        return\n    }\n    json.NewEncoder(w).Encode(users)\n}\n\nfunc CreateUserHandler(w http.ResponseWriter, r *http.Request) {\n    var user models.User\n    err := json.NewDecoder(r.Body).Decode(&user)\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusBadRequest)\n        return\n    }\n    err = db.CreateUser(&user)\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n        return\n    }\n    w.WriteHeader(http.StatusCreated)\n    json.NewEncoder(w).Encode(user)\n}\n\nfunc GetUserHandler(w http.ResponseWriter, r *http.Request) {\n    vars := mux.Vars(r)\n    idStr := vars[\"id\"]\n    id, err := gocql.ParseUUID(idStr)\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusBadRequest)\n        return\n    }\n    user, err := db.GetUser(id)\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusNotFound)\n        return\n    }\n    json.NewEncoder(w).Encode(user)\n}\n\nfunc UpdateUserHandler(w http.ResponseWriter, r *http.Request) {\n    vars := mux.Vars(r)\n    idStr := vars[\"id\"]\n    id, err := gocql.ParseUUID(idStr)\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusBadRequest)\n        return\n    }\n\n    var updates map[string]interface{}\n    err = json.NewDecoder(r.Body).Decode(&updates)\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusBadRequest)\n        return\n    }\n\n    if password, ok := updates[\"password\"].(string); ok && password != \"\" {\n        hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)\n        if err != nil {\n            http.Error(w, err.Error(), http.StatusInternalServerError)\n            return\n        }\n        updates[\"password\"] = string(hashedPassword)\n    }\n\n    fields := make([]string, 0, len(updates))\n    values := make([]interface{}, 0, len(updates))\n    for k, v := range updates {\n        fields = append(fields, k+\" = ?\")\n        values = append(values, v)\n    }\n    query := \"UPDATE users SET \" + strings.Join(fields, \", \") + \" WHERE id = ?\"\n    values = append(values, id)\n\n    stmt, err := db.GetSession().Prepare(query)\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n        return\n    }\n\n    err = db.GetSession().Query(stmt, values...).Exec()\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n        return\n    }\n\n    user, err := db.GetUser(id)\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n        return\n    }\n    json.NewEncoder(w).Encode(user)\n}\n\nfunc DeleteUserHandler(w http.ResponseWriter, r *http.Request) {\n    vars := mux.Vars(r)\n    idStr := vars[\"id\"]\n    id, err := gocql.ParseUUID(idStr)\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusBadRequest)\n        return\n    }\n    err = db.DeleteUser(id)\n    if err != nil {\n        http.Error(w, err.Error(), http.StatusInternalServerError)\n        return\n    }\n    w.WriteHeader(http.StatusNoContent)\n}\n```\n\n### main.go\n\n```go\npackage main\n\nimport (\n    \"log\"\n    \"net/http\"\n    \"User-API/db\"\n    \"User-API/handlers\"\n    \"github.com/gorilla/mux\"\n)\n\nfunc main() {\n    db.Connect()\n    defer db.Close()\n\n    router := mux.NewRouter()\n    router.HandleFunc(\"/users\", handlers.ListUsersHandler).Methods(\"GET\")\n    router.HandleFunc(\"/users\", handlers.CreateUserHandler).Methods(\"POST\")\n    router.HandleFunc(\"/users/{id}\", handlers.GetUserHandler).Methods(\"GET\")\n    router.HandleFunc(\"/users/{id}\", handlers.UpdateUserHandler).Methods(\"PUT\")\n    router.HandleFunc(\"/users/{id}\", handlers.DeleteUserHandler).Methods(\"DELETE\")\n\n    log.Fatal(http.ListenAndServe(\":8080\", router))\n}\n```\n\n### \u8bf4\u660e\n\n1. **\u6570\u636e\u5e93\u8fde\u63a5**\uff1a\u5728 `db/connect.go` \u4e2d\u8bbe\u7f6e Cassandra \u8fde\u63a5\u3002\n2. **\u6a21\u578b\u5b9a\u4e49**\uff1a\u5728 `models/user.go` \u4e2d\u5b9a\u4e49 User \u7ed3\u6784\u4f53\u3002\n3. **\u6570\u636e\u5e93\u64cd\u4f5c**\uff1a\u5728 `db/user.go` \u4e2d\u5b9e\u73b0\u7528\u6237\u521b\u5efa\u3001\u8bfb\u53d6\u3001\u66f4\u65b0\u548c\u5220\u9664\u529f\u80fd\uff0c\u5e76\u5bf9\u5bc6\u7801\u8fdb\u884c\u54c8\u5e0c\u5904\u7406\u3002\n4. **\u5904\u7406\u7a0b\u5e8f**\uff1a\u5728 `handlers/users.go` \u4e2d\u5904\u7406 HTTP \u8bf7\u6c42\uff0c\u5305\u62ec\u5217\u8868\u3001\u521b\u5efa\u3001\u8bfb\u53d6\u3001\u66f4\u65b0\u548c\u5220\u9664\u7528\u6237\u3002\n5. **\u4e3b\u51fd\u6570**\uff1a\u5728 `main.go` \u4e2d\u8bbe\u7f6e\u8def\u7531\u548c\u542f\u52a8 HTTP \u670d\u52a1\u5668\u3002\n\n\u786e\u4fdd\u5728\u8fd0\u884c\u6b64\u4ee3\u7801\u4e4b\u524d\uff0c\u5df2\u7ecf\u8bbe\u7f6e\u4e86 Cassandra \u6570\u636e\u5e93\uff0c\u5e76\u4e14\u521b\u5efa\u4e86\u76f8\u5e94\u7684\u952e\u7a7a\u95f4\u548c\u7528\u6237\u8868\u3002 #"
    }
]