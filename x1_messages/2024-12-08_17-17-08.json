[
    {
        "role": "user",
        "content": "Create a Golang web server that serves static files from a directory and has endpoints for uploading new files and deleting existing ones. The server should use HTTP Basic Authentication for securing access to these endpoints.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Alright, I'm going to help you create a simple web server in Go that serves static files, allows uploading and deleting files, and uses HTTP Basic Authentication for security. Sounds like a plan?\n\nFirst, make sure you have Go installed on your machine. You can download it from golang.org if you haven't already.\n\nWe'll need a few packages:\n\n- `net/http` for the web server\n\n- `path/filepath` to handle file paths\n\n- `io/ioutil` for reading files\n\n- `encoding/base64` for decoding the Basic Auth credentials\n\n- `strings` for string operations\n\nLet's start by setting up the basic structure of the server.\n\n## Step 1: Set up the server\n\nCreate a new Go file, say `main.go`, and start by importing the necessary packages:\n\n```go\npackage main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n```\n\nNext, define a function to handle Basic Auth. We'll check the username and password in the headers.\n\n```go\nfunc basicAuth(handler http.HandlerFunc, username, password string) http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tauth := r.Header.Get(\"Authorization\")\n\t\tif auth == \"\" {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tparts := strings.SplitN(auth, \" \", 2)\n\t\tif len(parts) != 2 || parts[0] != \"Basic\" {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tdecoded := make([]byte, base64.StdEncoding.DecodedLen(len(parts[1])))\n\t\tn, err := base64.StdEncoding.Decode(decoded, []byte(parts[1]))\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tcreds := strings.SplitN(string(decoded[:n]), \":\", 2)\n\t\tif len(creds) != 2 || creds[0] != username || creds[1] != password {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\thandler(w, r)\n\t}\n}\n```\n\nThis function checks if the provided credentials match the expected username and password.\n\n## Step 2: Serve static files\n\nWe'll use Go's built-in `http.FileServer` to serve static files from a specified directory.\n\n```go\nfunc staticHandler(dir string) http.Handler {\n\tfs := http.FileServer(http.Dir(dir))\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tpath := r.URL.Path\n\t\tif path == \"/\" {\n\t\t\tpath = \"/index.html\"\n\t\t}\n\t\tfile := filepath.Join(dir, path[1:])\n\t\tinfo, err := os.Stat(file)\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"File not found\", http.StatusNotFound)\n\t\t\treturn\n\t\t}\n\t\tif info.IsDir() {\n\t\t\tfile = filepath.Join(file, \"index.html\")\n\t\t\t_, err := os.Stat(file)\n\t\t\tif err != nil {\n\t\t\t\thttp.Error(w, \"Directory index forbidden\", http.StatusForbidden)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tfs.ServeHTTP(w, r)\n\t})\n}\n```\n\nThis handler serves files from the specified directory and attempts to serve `index.html` for directory requests.\n\n## Step 3: Implement file upload\n\nCreate an endpoint to handle file uploads.\n\n```go\nfunc uploadHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != \"POST\" {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tfile, header, err := r.FormFile(\"file\")\n\tif err != nil {\n\t\thttp.Error(w, \"Failed to read file\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tdefer file.Close()\n\n\tout, err := os.Create(filepath.Join(uploadDir, header.Filename))\n\tif err != nil {\n\t\thttp.Error(w, \"Failed to create file\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\tdefer out.Close()\n\n\t_, err = io.Copy(out, file)\n\tif err != nil {\n\t\thttp.Error(w, \"Failed to save file\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tw.WriteHeader(http.StatusCreated)\n\tfmt.Fprintf(w, \"File uploaded: %s\", header.Filename)\n}\n```\n\nThis handler expects a file sent as `file` in a POST request and saves it to the upload directory.\n\n## Step 4: Implement file deletion\n\nCreate an endpoint to handle file deletions.\n\n```go\nfunc deleteHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != \"DELETE\" {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tfilename := r.URL.Query().Get(\"filename\")\n\tif filename == \"\" {\n\t\thttp.Error(w, \"Filename is required\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tfilePath := filepath.Join(uploadDir, filename)\n\terr := os.Remove(filePath)\n\tif err != nil {\n\t\thttp.Error(w, \"Failed to delete file\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, \"File deleted: %s\", filename)\n}\n```\n\nThis handler expects a `filename` query parameter in a DELETE request and removes the corresponding file from the upload directory.\n\n## Step 5: Set up routes and start the server\n\nNow, let's set up the routes and start the server.\n\n```go\nfunc main() {\n\tstaticDir := \"./static\"\n\tuploadDir := \"./uploads\"\n\n\t// Create upload directory if it doesn't exist\n\terr := os.MkdirAll(uploadDir, os.ModePerm)\n\tif err != nil {\n\t\tfmt.Println(\"Failed to create upload directory:\", err)\n\t\treturn\n\t}\n\n\thttp.Handle(\"/static/\", staticHandler(staticDir))\n\thttp.HandleFunc(\"/upload\", basicAuth(uploadHandler, \"admin\", \"password\"))\n\thttp.HandleFunc(\"/delete\", basicAuth(deleteHandler, \"admin\", \"password\"))\n\n\tfmt.Println(\"Starting server at :8080\")\n\terr = http.ListenAndServe(\":8080\", nil)\n\tif err != nil {\n\t\tfmt.Println(\"Server error:\", err)\n\t}\n}\n```\n\nIn this setup:\n\n- Static files are served from the `./static` directory at `/static/...`.\n\n- File uploads are handled at `/upload` with HTTP Basic Auth.\n\n- File deletions are handled at `/delete?filename=...` with HTTP Basic Auth.\n\nMake sure to replace `\"admin\"` and `\"password\"` with your desired username and password.\n\n## Testing the server\n\n1. **Serve static files:** Access `http://localhost:8080/static/yourfile.html` to serve files from the `static` directory.\n\n2. **Upload a file:** Use a tool like `curl` or Postman to send a POST request to `http://localhost:8080/upload` with the file in form data. Include Basic Auth headers.\n\n   Example with `curl`:\n\n   ```sh\n   curl -u admin:password -F \"file=@path/to/yourfile.txt\" http://localhost:8080/upload\n   ```\n\n3. **Delete a file:** Use a tool like `curl` or Postman to send a DELETE request to `http://localhost:8080/delete?filename=yourfile.txt`. Include Basic Auth headers.\n\n   Example with `curl`:\n\n   ```sh\n   curl -u admin:password -X DELETE http://localhost:8080/delete?filename=yourfile.txt\n   ```\n\nThat's it! You now have a basic web server in Go that serves static files, allows uploading and deleting files with HTTP Basic Auth protection.\n\n## Full Code\n\nFor reference, here's the full code combined:\n\n```go\npackage main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\nfunc basicAuth(handler http.HandlerFunc, username, password string) http.HandlerFunc {\n\treturn func(w http.ResponseWriter, r *http.Request) {\n\t\tauth := r.Header.Get(\"Authorization\")\n\t\tif auth == \"\" {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tparts := strings.SplitN(auth, \" \", 2)\n\t\tif len(parts) != 2 || parts[0] != \"Basic\" {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tdecoded := make([]byte, base64.StdEncoding.DecodedLen(len(parts[1])))\n\t\tn, err := base64.StdEncoding.Decode(decoded, []byte(parts[1]))\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\tcreds := strings.SplitN(string(decoded[:n]), \":\", 2)\n\t\tif len(creds) != 2 || creds[0] != username || creds[1] != password {\n\t\t\thttp.Error(w, \"Not authorized\", http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\n\t\thandler(w, r)\n\t}\n}\n\nfunc staticHandler(dir string) http.Handler {\n\tfs := http.FileServer(http.Dir(dir))\n\treturn http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n\t\tpath := r.URL.Path\n\t\tif path == \"/\" {\n\t\t\tpath = \"/index.html\"\n\t\t}\n\t\tfile := filepath.Join(dir, path[1:])\n\t\tinfo, err := os.Stat(file)\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"File not found\", http.StatusNotFound)\n\t\t\treturn\n\t\t}\n\t\tif info.IsDir() {\n\t\t\tfile = filepath.Join(file, \"index.html\")\n\t\t\t_, err := os.Stat(file)\n\t\t\tif err != nil {\n\t\t\t\thttp.Error(w, \"Directory index forbidden\", http.StatusForbidden)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tfs.ServeHTTP(w, r)\n\t})\n}\n\nfunc uploadHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != \"POST\" {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tfile, header, err := r.FormFile(\"file\")\n\tif err != nil {\n\t\thttp.Error(w, \"Failed to read file\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tdefer file.Close()\n\n\tout, err := os.Create(filepath.Join(uploadDir, header.Filename))\n\tif err != nil {\n\t\thttp.Error(w, \"Failed to create file\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\tdefer out.Close()\n\n\t_, err = io.Copy(out, file)\n\tif err != nil {\n\t\thttp.Error(w, \"Failed to save file\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tw.WriteHeader(http.StatusCreated)\n\tfmt.Fprintf(w, \"File uploaded: %s\", header.Filename)\n}\n\nfunc deleteHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method != \"DELETE\" {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tfilename := r.URL.Query().Get(\"filename\")\n\tif filename == \"\" {\n\t\thttp.Error(w, \"Filename is required\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tfilePath := filepath.Join(uploadDir, filename)\n\terr := os.Remove(filePath)\n\tif err != nil {\n\t\thttp.Error(w, \"Failed to delete file\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tw.WriteHeader(http.StatusOK)\n\tfmt.Fprintf(w, \"File deleted: %s\", filename)\n}\n\nfunc main() {\n\tstaticDir := \"./static\"\n\tuploadDir := \"./uploads\"\n\n\terr := os.MkdirAll(uploadDir, os.ModePerm)\n\tif err != nil {\n\t\tfmt.Println(\"Failed to create upload directory:\", err)\n\t\treturn\n\t}\n\n\thttp.Handle(\"/static/\", staticHandler(staticDir))\n\thttp.HandleFunc(\"/upload\", basicAuth(uploadHandler, \"admin\", \"password\"))\n\thttp.HandleFunc(\"/delete\", basicAuth(deleteHandler, \"admin\", \"password\"))\n\n\tfmt.Println(\"Starting server at :8080\")\n\terr = http.ListenAndServe(\":8080\", nil)\n\tif err != nil {\n\t\tfmt.Println(\"Server error:\", err)\n\t}\n}\n```\n\nMake sure to adjust the `staticDir` and `uploadDir` paths as needed for your project structure.\n\nI hope this helps! Let me know if you have any questions or need further assistance."
    }
]