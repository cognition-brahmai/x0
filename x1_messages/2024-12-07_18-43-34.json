[
    {
        "role": "user",
        "content": "Design a C++ class called \"Matrix\" that represents a 2D matrix of integers. The class should include methods for adding, subtracting, and multiplying matrices, as well as finding the transpose and determinant of the matrix. Include proper error handling for invalid operations, such as adding matrices of different dimensions.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Alright, I'm going to design a C++ class called \"Matrix\" that handles 2D matrices of integers. It needs to support addition, subtraction, multiplication, transpose, and determinant calculations. Also, I need to make sure that there's proper error handling for operations that can't be performed due to mismatched dimensions or other issues.\n\nFirst, I need to think about how to represent the matrix internally. Since it's a 2D matrix of integers, a vector of vectors or a dynamic 2D array could work. I'll go with a vector of vectors because it's more flexible and easier to handle in C++.\n\nSo, I'll include the necessary headers:\n\n```cpp\n#include <vector>\n#include <iostream>\n```\n\nNow, I'll define the Matrix class. It should have private members to store the matrix data, rows, and columns.\n\n```cpp\nclass Matrix {\nprivate:\n    std::vector<std::vector<int>> data;\n    size_t rows;\n    size_t cols;\n};\n```\n\nI need a constructor that takes the number of rows and columns and optionally initializes the matrix with some values. If no values are provided, I'll initialize it with zeros.\n\n```cpp\nMatrix(size_t r, size_t c, int initValue = 0) : rows(r), cols(c), data(r, std::vector<int>(c, initValue)) {}\n```\n\nNext, I should provide a way to access and modify the elements of the matrix. I'll implement operator overloading for this.\n\n```cpp\nint& operator()(size_t r, size_t c) {\n    if (r >= rows || c >= cols) {\n        throw std::out_of_range(\"Index out of range\");\n    }\n    return data[r][c];\n}\n\nint operator()(size_t r, size_t c) const {\n    if (r >= rows || c >= cols) {\n        throw std::out_of_range(\"Index out of range\");\n    }\n    return data[r][c];\n}\n```\n\nNow, for adding two matrices, they must have the same dimensions. I'll implement a method for addition and include error handling.\n\n```cpp\nMatrix operator+(const Matrix& other) const {\n    if (rows != other.rows || cols != other.cols) {\n        throw std::invalid_argument(\"Matrices must have the same dimensions to add\");\n    }\n    Matrix result(rows, cols);\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 0; j < cols; ++j) {\n            result(i, j) = data[i][j] + other.data[i][j];\n        }\n    }\n    return result;\n}\n```\n\nSimilarly, subtraction will follow the same logic.\n\n```cpp\nMatrix operator-(const Matrix& other) const {\n    if (rows != other.rows || cols != other.cols) {\n        throw std::invalid_argument(\"Matrices must have the same dimensions to subtract\");\n    }\n    Matrix result(rows, cols);\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 0; j < cols; ++j) {\n            result(i, j) = data[i][j] - other.data[i][j];\n        }\n    }\n    return result;\n}\n```\n\nFor matrix multiplication, the number of columns in the first matrix must match the number of rows in the second matrix.\n\n```cpp\nMatrix operator*(const Matrix& other) const {\n    if (cols != other.rows) {\n        throw std::invalid_argument(\"Number of columns in first matrix must match number of rows in second matrix\");\n    }\n    Matrix result(rows, other.cols);\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 0; j < other.cols; ++j) {\n            int sum = 0;\n            for (size_t k = 0; k < cols; ++k) {\n                sum += data[i][k] * other.data[k][j];\n            }\n            result(i, j) = sum;\n        }\n    }\n    return result;\n}\n```\n\nNext, the transpose of a matrix is obtained by flipping the matrix over its diagonal, which switches the row and column indices of the elements.\n\n```cpp\nMatrix transpose() const {\n    Matrix result(cols, rows);\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 0; j < cols; ++j) {\n            result(j, i) = data[i][j];\n        }\n    }\n    return result;\n}\n```\n\nCalculating the determinant is a bit more complex and only makes sense for square matrices. I'll implement a method that checks if the matrix is square and then computes the determinant recursively.\n\n```cpp\nint determinant() const {\n    if (rows != cols) {\n        throw std::invalid_argument(\"Matrix must be square to compute determinant\");\n    }\n    if (rows == 1) {\n        return data[0][0];\n    } else if (rows == 2) {\n        return data[0][0] * data[1][1] - data[0][1] * data[1][0];\n    } else {\n        int det = 0;\n        for (size_t c = 0; c < cols; ++c) {\n            det += data[0][c] * cofactor(0, c);\n        }\n        return det;\n    }\n}\n\nprivate:\nint cofactor(size_t r, size_t c) const {\n    Matrix sub = minor(r, c);\n    int sign = (r + c) % 2 == 0 ? 1 : -1;\n    return sign * sub.determinant();\n}\n\nMatrix minor(size_t r, size_t c) const {\n    Matrix sub(rows - 1, cols - 1);\n    size_t subR = 0;\n    for (size_t i = 0; i < rows; ++i) {\n        if (i == r) continue;\n        size_t subC = 0;\n        for (size_t j = 0; j < cols; ++j) {\n            if (j == c) continue;\n            sub(subR, subC) = data[i][j];\n            subC++;\n        }\n        subR++;\n    }\n    return sub;\n}\n```\n\nI should also provide a method to print the matrix for easy visualization.\n\n```cpp\nvoid print() const {\n    for (const auto& row : data) {\n        for (int val : row) {\n            std::cout << val << \" \";\n        }\n        std::cout << std::endl;\n    }\n}\n```\n\nFinally, I need to make sure that all these methods work correctly by testing them. I'll write a main function to create some matrices and perform operations on them.\n\n```cpp\nint main() {\n    Matrix m1(2, 2);\n    m1(0, 0) = 1;\n    m1(0, 1) = 2;\n    m1(1, 0) = 3;\n    m1(1, 1) = 4;\n\n    Matrix m2(2, 2);\n    m2(0, 0) = 5;\n    m2(0, 1) = 6;\n    m2(1, 0) = 7;\n    m2(1, 1) = 8;\n\n    Matrix m3 = m1 + m2;\n    m3.print();\n\n    Matrix m4 = m1 * m2;\n    m4.print();\n\n    Matrix m5 = m1.transpose();\n    m5.print();\n\n    int det = m1.determinant();\n    std::cout << \"Determinant: \" << det << std::endl;\n\n    return 0;\n}\n```\n\nThis should cover the basic requirements. I might need to add more error checks and optimize some methods, but this is a good starting point.\n\n## Final Solution\nTo solve this problem, we need to design a C++ class called \"Matrix\" that represents a 2D matrix of integers and includes methods for various operations such as addition, subtraction, multiplication, transpose, and determinant calculation. We also need to handle errors for invalid operations.\n\n### Approach\n\n1. **Internal Representation**: Use a vector of vectors to store matrix data for flexibility.\n2. **Constructor**: Initialize the matrix with given dimensions and an optional initial value.\n3. **Element Access**: Implement operator overloading to access and modify elements with bounds checking.\n4. **Matrix Operations**:\n   - **Addition and Subtraction**: Require matrices to have the same dimensions.\n   - **Multiplication**: Requires the number of columns in the first matrix to match the number of rows in the second matrix.\n   - **Transpose**: Flip the matrix over its diagonal.\n   - **Determinant**: Computed recursively, applicable only to square matrices.\n5. **Error Handling**: Throw exceptions for invalid operations such as mismatched dimensions.\n\n### Solution Code\n\n```cpp\n#include <vector>\n#include <iostream>\n\nclass Matrix {\nprivate:\n    std::vector<std::vector<int>> data;\n    size_t rows;\n    size_t cols;\n\n    int cofactor(size_t r, size_t c) const;\n    Matrix minor(size_t r, size_t c) const;\n\npublic:\n    Matrix(size_t r, size_t c, int initValue = 0);\n    int& operator()(size_t r, size_t c);\n    int operator()(size_t r, size_t c) const;\n    Matrix operator+(const Matrix& other) const;\n    Matrix operator-(const Matrix& other) const;\n    Matrix operator*(const Matrix& other) const;\n    Matrix transpose() const;\n    int determinant() const;\n    void print() const;\n};\n\nMatrix::Matrix(size_t r, size_t c, int initValue) : rows(r), cols(c), data(r, std::vector<int>(c, initValue)) {}\n\nint& Matrix::operator()(size_t r, size_t c) {\n    if (r >= rows || c >= cols) {\n        throw std::out_of_range(\"Index out of range\");\n    }\n    return data[r][c];\n}\n\nint Matrix::operator()(size_t r, size_t c) const {\n    if (r >= rows || c >= cols) {\n        throw std::out_of_range(\"Index out of range\");\n    }\n    return data[r][c];\n}\n\nMatrix Matrix::operator+(const Matrix& other) const {\n    if (rows != other.rows || cols != other.cols) {\n        throw std::invalid_argument(\"Matrices must have the same dimensions to add\");\n    }\n    Matrix result(rows, cols);\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 0; j < cols; ++j) {\n            result(i, j) = data[i][j] + other.data[i][j];\n        }\n    }\n    return result;\n}\n\nMatrix Matrix::operator-(const Matrix& other) const {\n    if (rows != other.rows || cols != other.cols) {\n        throw std::invalid_argument(\"Matrices must have the same dimensions to subtract\");\n    }\n    Matrix result(rows, cols);\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 0; j < cols; ++j) {\n            result(i, j) = data[i][j] - other.data[i][j];\n        }\n    }\n    return result;\n}\n\nMatrix Matrix::operator*(const Matrix& other) const {\n    if (cols != other.rows) {\n        throw std::invalid_argument(\"Number of columns in first matrix must match number of rows in second matrix\");\n    }\n    Matrix result(rows, other.cols);\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 0; j < other.cols; ++j) {\n            int sum = 0;\n            for (size_t k = 0; k < cols; ++k) {\n                sum += data[i][k] * other.data[k][j];\n            }\n            result(i, j) = sum;\n        }\n    }\n    return result;\n}\n\nMatrix Matrix::transpose() const {\n    Matrix result(cols, rows);\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 0; j < cols; ++j) {\n            result(j, i) = data[i][j];\n        }\n    }\n    return result;\n}\n\nint Matrix::determinant() const {\n    if (rows != cols) {\n        throw std::invalid_argument(\"Matrix must be square to compute determinant\");\n    }\n    if (rows == 1) {\n        return data[0][0];\n    } else if (rows == 2) {\n        return data[0][0] * data[1][1] - data[0][1] * data[1][0];\n    } else {\n        int det = 0;\n        for (size_t c = 0; c < cols; ++c) {\n            det += data[0][c] * cofactor(0, c);\n        }\n        return det;\n    }\n}\n\nint Matrix::cofactor(size_t r, size_t c) const {\n    Matrix sub = minor(r, c);\n    int sign = (r + c) % 2 == 0 ? 1 : -1;\n    return sign * sub.determinant();\n}\n\nMatrix Matrix::minor(size_t r, size_t c) const {\n    Matrix sub(rows - 1, cols - 1);\n    size_t subR = 0;\n    for (size_t i = 0; i < rows; ++i) {\n        if (i == r) continue;\n        size_t subC = 0;\n        for (size_t j = 0; j < cols; ++j) {\n            if (j == c) continue;\n            sub(subR, subC) = data[i][j];\n            subC++;\n        }\n        subR++;\n    }\n    return sub;\n}\n\nvoid Matrix::print() const {\n    for (const auto& row : data) {\n        for (int val : row) {\n            std::cout << val << \" \";\n        }\n        std::cout << std::endl;\n    }\n}\n\n// Example usage\nint main() {\n    Matrix m1(2, 2);\n    m1(0, 0) = 1;\n    m1(0, 1) = 2;\n    m1(1, 0) = 3;\n    m1(1, 1) = 4;\n\n    Matrix m2(2, 2);\n    m2(0, 0) = 5;\n    m2(0, 1) = 6;\n    m2(1, 0) = 7;\n    m2(1, 1) = 8;\n\n    Matrix m3 = m1 + m2;\n    std::cout << \"Addition:\" << std::endl;\n    m3.print();\n\n    Matrix m4 = m1 * m2;\n    std::cout << \"Multiplication:\" << std::endl;\n    m4.print();\n\n    Matrix m5 = m1.transpose();\n    std::cout << \"Transpose:\" << std::endl;\n    m5.print();\n\n    int det = m1.determinant();\n    std::cout << \"Determinant: \" << det << std::endl;\n\n    return 0;\n}\n```\n\n### Explanation\n\n- **Internal Storage**: The matrix data is stored in a vector of vectors (`std::vector<std::vector<int>>`).\n- **Constructors and Operators**: The constructor initializes the matrix, and operator overloading provides easy access and modification of elements with bounds checking.\n- **Matrix Operations**: \n  - Addition and subtraction require matrices of the same dimensions.\n  - Multiplication requires the number of columns in the first matrix to equal the number of rows in the second.\n  - Transpose flips the matrix over its diagonal.\n  - Determinant is calculated recursively, suitable only for square matrices.\n- **Error Handling**: Exceptions are thrown for operations that are invalid due to dimension mismatches or non-square matrices.\n\nThis implementation provides a comprehensive set of operations for 2D integer matrices with necessary error handling."
    }
]