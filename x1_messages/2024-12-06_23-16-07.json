[
    {
        "role": "user",
        "content": "Create a C++ class implementing a trie data structure, with methods to insert words, delete words, and check if a word exists in the trie."
    },
    {
        "role": "assistant",
        "content": "I'm here to help you with that! Creating a Trie data structure in C++ is a great way to handle operations like inserting, deleting, and checking for words efficiently. A Trie, also known as a prefix tree, is particularly useful for tasks involving strings where you need quick lookups based on prefixes.\n\nBelow is a simple implementation of a Trie in C++. This class will include methods to insert a word, delete a word, and check if a word exists in the Trie.\n\n```cpp\n#include <iostream>\n#include <unordered_map>\n\nclass TrieNode {\npublic:\n    std::unordered_map<char, TrieNode*> children;\n    bool isEndOfWord;\n\n    TrieNode() : isEndOfWord(false) {}\n};\n\nclass Trie {\nprivate:\n    TrieNode* root;\n\n    // Helper function to delete the Trie recursively\n    void deleteHelper(TrieNode* node) {\n        for (auto& pair : node->children) {\n            deleteHelper(pair.second);\n        }\n        delete node;\n    }\n\npublic:\n    Trie() {\n        root = new TrieNode();\n    }\n\n    ~Trie() {\n        deleteHelper(root);\n    }\n\n    // Insert a word into the Trie\n    void insert(const std::string& word) {\n        TrieNode* current = root;\n        for (char ch : word) {\n            if (current->children.find(ch) == current->children.end()) {\n                current->children[ch] = new TrieNode();\n            }\n            current = current->children[ch];\n        }\n        current->isEndOfWord = true;\n    }\n\n    // Check if a word exists in the Trie\n    bool search(const std::string& word) {\n        TrieNode* current = root;\n        for (char ch : word) {\n            if (current->children.find(ch) == current->children.end()) {\n                return false;\n            }\n            current = current->children[ch];\n        }\n        return current->isEndOfWord;\n    }\n\n    // Delete a word from the Trie\n    bool deleteWord(const std::string& word) {\n        return deleteWordHelper(root, word, 0);\n    }\n\nprivate:\n    // Helper function for deletion\n    bool deleteWordHelper(TrieNode* node, const std::string& word, int index) {\n        if (index == word.size()) {\n            if (!node->isEndOfWord) {\n                return false; // Word not found\n            }\n            node->isEndOfWord = false;\n            // If this node has no other purposes, it can be deleted\n            if (node->children.empty()) {\n                delete node;\n                node = nullptr;\n                return true;\n            }\n            return false;\n        }\n\n        char ch = word[index];\n        if (node->children.find(ch) == node->children.end()) {\n            return false; // Word not found\n        }\n\n        bool shouldDeleteCurrentNode = deleteWordHelper(node->children[ch], word, index + 1);\n\n        if (shouldDeleteCurrentNode) {\n            delete node->children[ch];\n            node->children.erase(ch);\n            // If this node has no other purposes, it can be deleted\n            if (node->children.empty() && !node->isEndOfWord) {\n                delete node;\n                node = nullptr;\n                return true;\n            }\n        }\n\n        return false;\n    }\n};\n\nint main() {\n    Trie trie;\n    trie.insert(\"hello\");\n    trie.insert(\"helmet\");\n    std::cout << \"Search 'hello': \" << trie.search(\"hello\") << std::endl; // Should return 1 (true)\n    std::cout << \"Search 'helmet': \" << trie.search(\"helmet\") << std::endl; // Should return 1 (true)\n    std::cout << \"Search 'hell': \" << trie.search(\"hell\") << std::endl; // Should return 0 (false)\n    trie.deleteWord(\"hello\");\n    std::cout << \"Search 'hello' after deletion: \" << trie.search(\"hello\") << std::endl; // Should return 0 (false)\n    std::cout << \"Search 'helmet' after deletion: \" << trie.search(\"helmet\") << std::endl; // Should return 1 (true)\n    return 0;\n}\n```\n\n### Explanation:\n\n1. **TrieNode Class**:\n   - Each node contains a map of characters to child nodes and a boolean flag `isEndOfWord` to mark the end of a word.\n\n2. **Trie Class**:\n   - **Constructor**: Initializes the root node.\n   - **Destructor**: Recursively deletes all nodes to free memory.\n   - **Insert Method**: Inserts a word into the Trie, creating new nodes as necessary.\n   - **Search Method**: Checks if a word exists in the Trie.\n   - **Delete Method**: Deletes a word from the Trie if it exists, and cleans up any unused nodes.\n\n3. **Main Function**:\n   - Demonstrates inserting words, searching for them, and deleting a word, then verifying the operations.\n\nThis implementation ensures that the Trie is efficiently managed with proper memory deallocation."
    }
]