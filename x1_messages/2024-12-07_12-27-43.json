[
    {
        "role": "user",
        "content": "Implement a Python function that checks if a given word is an anagram of another given word. PLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Alright, I need to create a Python function that checks if one word is an anagram of another. An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. For example, 'listen' and 'silent' are anagrams.\n\nFirst, I need to understand what the function should do. It should take two words as input and return True if they are anagrams and False otherwise. So, the function signature might look like this:\n\ndef is_anagram(word1, word2):\n\nI need to think about how to check if two words are anagrams. One straightforward way is to sort the letters of both words and see if the sorted versions are the same. For example, sorting 'listen' gives 'eilnst', and sorting 'silent' also gives 'eilnst', so they are anagrams.\n\nLet me try that approach. I'll write a simple function that sorts the letters of both words and compares the sorted strings.\n\ndef is_anagram(word1, word2):\n\nreturn sorted(word1) == sorted(word2)\n\nThat seems too easy. I should consider if there are any edge cases that this might not handle correctly. For example, what if one word is uppercase and the other is lowercase? Should the function be case-sensitive or case-insensitive?\n\nLet's assume that the function should be case-insensitive, meaning that 'Listen' and 'silent' should be considered anagrams. To handle this, I can convert both words to lowercase before sorting and comparing.\n\ndef is_anagram(word1, word2):\n\nreturn sorted(word1.lower()) == sorted(word2.lower())\n\nOkay, that should handle case-insensitivity. Are there any other considerations? What about spaces or punctuation? For simplicity, I'll assume that the input words consist only of letters and are already normalized, meaning no spaces or punctuation.\n\nBut to make the function more robust, maybe I should strip out any non-letter characters and handle spaces. However, since the problem statement says \"given word,\" I'll assume that the inputs are simple words without spaces or punctuation.\n\nAnother thing to consider is if the function should handle empty strings. If both words are empty, should they be considered anagrams? Technically, yes, since no letters are used in both. If one word is empty and the other is not, they are not anagrams.\n\nMy current implementation would consider two empty strings as anagrams, which is correct, and different lengths would naturally return False since sorted lists would have different lengths.\n\nLet me test this function with some examples:\n\n- is_anagram('listen', 'silent') should return True\n\n- is_anagram('hello', 'world') should return False\n\n- is_anagram('Triangle', 'Integral') should return True\n\n- is_anagram('apple', 'pale') should return False\n\nLet's check these:\n\n1. 'listen' and 'silent':\n\n- sorted('listen'.lower()) -> ['e', 'i', 'l', 'n', 's', 't']\n\n- sorted('silent'.lower()) -> ['e', 'i', 'l', 'n', 's', 't']\n\n- They match, so True\n\n2. 'hello' and 'world':\n\n- sorted('hello'.lower()) -> ['e', 'h', 'l', 'l', 'o']\n\n- sorted('world'.lower()) -> ['d', 'l', 'o', 'r', 'w']\n\n- They don't match, so False\n\n3. 'Triangle' and 'Integral':\n\n- sorted('Triangle'.lower()) -> ['a', 'e', 'i', 'l', 'n', 'r', 't', 't']\n\n- sorted('Integral'.lower()) -> ['a', 'e', 'i', 'n', 'g', 'r', 't', 'a', 'l']\n\nWait, that doesn't look right. Let me double-check:\n\n- 'Triangle' lowercased is 'triangle'\n\n- sorted('triangle') -> ['a', 'e', 'i', 'l', 'n', 'r', 't', 't']\n\n- 'Integral' lowercased is 'integral'\n\n- sorted('integral') -> ['a', 'e', 'i', 'n', 'g', 'r', 't', 'a', 'l']\n\nWait, that's not correct. Let me sort 'integral':\n\n'integral' -> ['a', 'e', 'i', 'n', 'g', 'r', 't', 'a', 'l']\n\nWait, that's 9 letters, but 'integral' has 8 letters. Oh, I miscounted.\n\nActually, 'integral' has 8 letters: 'i', 'n', 't', 'e', 'g', 'r', 'a', 'l'\n\nSo sorted('integral') should be ['a', 'e', 'g', 'i', 'l', 'n', 'r', 't']\n\nSimilarly, sorted('triangle') is ['a', 'e', 'i', 'l', 'n', 'r', 't', 't']\n\nSo they are not the same, because 'triangle' has two 't's and 'integral' has only one 't'.\n\nWait, but I think 'triangle' and 'integral' are supposed to be anagrams. Let me check:\n\n- triangle: t,r,i,a,n,g,l,e -> 8 letters\n\n- integral: i,n,t,e,g,r,a,l -> 8 letters\n\nComparing letter counts:\n\n- t: 2 in 'triangle', 1 in 'integral'\n\n- r: 1 in both\n\n- i: 1 in both\n\n- a: 1 in both\n\n- n: 1 in both\n\n- g: 1 in both\n\n- l: 1 in 'triangle', 1 in 'integral'\n\n- e: 1 in 'triangle', 1 in 'integral'\n\nWait, 'triangle' has two 't's, while 'integral' has only one 't'. So they are not anagrams. Hmm, I thought they were. Maybe I was mistaken.\n\nSo, my function should correctly identify that 'triangle' and 'integral' are not anagrams because of the differing number of 't's.\n\nAnother test:\n\n- 'apple' and 'pale':\n\n- sorted('apple'.lower()) -> ['a', 'e', 'p', 'p', 'l']\n\n- sorted('pale'.lower()) -> ['a', 'e', 'l', 'p']\n\n- They don't match, so False\n\nSeems correct.\n\nAlternatively, maybe I can use counting of letters instead of sorting. I can create a frequency dictionary for each word and compare the dictionaries.\n\nFor example:\n\ndef is_anagram(word1, word2):\n\nfrom collections import Counter\n\nreturn Counter(word1.lower()) == Counter(word2.lower())\n\nThis might be more efficient than sorting, especially for longer words, because counting elements is generally O(n) while sorting is O(n log n).\n\nLet me compare the two approaches.\n\nSorting approach:\n\n- Convert both words to lowercase: O(n) + O(m)\n\n- Sort each word: O(n log n) + O(m log m)\n\n- Compare the sorted lists: O(n)\n\nTotal time complexity: O(n log n + m log m)\n\nCounting approach:\n\n- Convert both words to lowercase: O(n) + O(m)\n\n- Count frequencies: O(n) + O(m)\n\n- Compare the frequency dictionaries: O(n)\n\nTotal time complexity: O(n + m)\n\nSo the counting approach is more efficient, especially for larger inputs.\n\nSpace-wise, both approaches use additional space for the sorted lists or the frequency dictionaries, which is O(n + m).\n\nI should also consider if the inputs contain non-alphabetic characters. If the problem assumes only letters, then this is fine. But to make it more robust, I could add preprocessing to remove non-alphabetic characters.\n\nHowever, since the problem statement specifies \"given word,\" I'll assume that inputs are simple words consisting of letters only.\n\nLet me consider if there are any words with accented characters, like 'caf\u00e9' and 'face'. Should the function handle accents? For simplicity, I'll assume that words are in plain ASCII.\n\nAlso, what about diacritics? Again, to keep it simple, I'll ignore that.\n\nAnother consideration is performance. For very large words, the counting approach would be faster. But since we're dealing with words, which are typically not very long, both approaches should be acceptable.\n\nBut since the counting approach is more efficient, I'll go with that.\n\nSo, my function would be:\n\nfrom collections import Counter\n\ndef is_anagram(word1, word2):\n\nreturn Counter(word1.lower()) == Counter(word2.lower())\n\nThis is concise and efficient.\n\nLet me test this function with the previous examples:\n\n- is_anagram('listen', 'silent') -> True\n\n- is_anagram('hello', 'world') -> False\n\n- is_anagram('triangle', 'integral') -> False\n\n- is_anagram('apple', 'pale') -> False\n\nSeems correct.\n\nAnother test case: words with different lengths.\n\n- is_anagram('abcd', 'abc') -> False\n\nBecause their lengths are different.\n\nEdge cases:\n\n- is_anagram('', '') -> True\n\n- is_anagram('', 'a') -> False\n\n- is_anagram('a', '') -> False\n\nThese should be handled correctly by the function.\n\nAlso, words with repeated letters:\n\n- is_anagram('aabb', 'abab') -> True\n\n- is_anagram('aabb', 'aabc') -> False\n\nThe counting approach should handle repeated letters correctly.\n\nI think this implementation is sufficient for the given problem.\n\n## Final Solution\nTo solve this problem, we need to determine if one word is an anagram of another. An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\n\n### Approach\n1. **Problem Understanding**:\n   - We need to create a function that takes two words as input and checks if they are anagrams of each other.\n   - The function should be case-insensitive, meaning 'Listen' and 'silent' should be considered anagrams.\n\n2. **Initial Idea**:\n   - Sort the letters of both words and compare the sorted versions.\n   - Convert both words to lowercase to handle case-insensitivity.\n\n3. **Efficient Solution**:\n   - Use a frequency counter to count the occurrences of each letter in both words and compare the counters.\n   - This approach is more efficient than sorting, especially for longer words.\n\n4. **Considerations**:\n   - Assume inputs are simple words consisting of letters only.\n   - Handle edge cases such as empty strings and words of different lengths.\n\n### Solution Code\n```python\nfrom collections import Counter\n\ndef is_anagram(word1, word2):\n    return Counter(word1.lower()) == Counter(word2.lower())\n```\n\n### Explanation\n- **Step 1**: Convert both words to lowercase to ensure the comparison is case-insensitive.\n- **Step 2**: Use `Counter` from the `collections` module to count the frequency of each letter in both words.\n- **Step 3**: Compare the two frequency counters. If they are equal, the words are anagrams; otherwise, they are not.\n\nThis approach is efficient with a time complexity of O(n + m), where n and m are the lengths of the two words, making it suitable even for longer inputs."
    }
]