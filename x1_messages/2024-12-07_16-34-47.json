[
    {
        "role": "user",
        "content": "Using PowerShell, create a script that checks disk space on a Windows server. If any drive has less than 20% free space, the script should generate a report detailing the size and percentage of used space for each folder in that drive. PLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Alright, I've got this task to create a PowerShell script that checks disk space on a Windows server. Specifically, if any drive has less than 20% free space, the script should generate a report detailing the size and percentage of used space for each folder in that drive. Sounds straightforward, but let's break it down step by step to ensure I cover all the bases.\n\nFirst things first, I need to get a list of all drives on the server. In PowerShell, I can use the `Get-PSDrive` cmdlet to achieve this. However, I should be careful to filter out non-fixed drives like CD-ROMs or network drives, as they might not be relevant for disk space monitoring. So, I'll probably use `Get-WmiObject -Class Win32_LogicalDisk` instead, which allows me to specify that I only want fixed drives.\n\nOnce I have the list of drives, I need to check the free space percentage for each one. To do this, I can calculate the free space percentage using the `FreeSpace` and `Size` properties available in the `Win32_LogicalDisk` class. The formula would be `(FreeSpace / Size) * 100`. If this value is less than 20%, then I need to generate a report for that drive.\n\nNow, for generating the report, I need to detail the size and percentage of used space for each folder in the drive. This sounds like I need to traverse each folder in the drive, calculate its size, and then determine what percentage of the total drive space it occupies.\n\nBut wait, calculating folder sizes can be resource-intensive, especially on large drives with many folders. I should consider optimizing this process to make it efficient. Maybe I can use the `Get-ChildItem` cmdlet with the `-Recurse` parameter to get all folders, and then use `Get-ItemProperty` to get their sizes. However, recursion can be slow; perhaps there's a better way.\n\nI recall that PowerShell has the `Get-ChildItem` cmdlet with the `-Directory` parameter to list only directories, and combining it with `-Recurse` would give me all subdirectories. But again, this might not be the most efficient approach for large directory structures.\n\nAlternatively, I could use the .NET namespace `System.IO` to access directory information, which might offer better performance. For example, using `System.IO.DirectoryInfo` to get directory sizes.\n\nLet me think about this. Maybe I can get a list of all top-level folders in the drive and calculate their sizes by summing up the sizes of all files and subfolders within them. That way, I'm not recursing into each subfolder individually, which should save time.\n\nWait, but the requirement is to detail the size and percentage for each folder in the drive, which probably includes subfolders as well. So, I might have to recurse through the folder structure anyway.\n\nTo make this more efficient, perhaps I can limit the depth of recursion or set some size thresholds to ignore very small folders. But that might not be necessary for now; I'll focus on getting the basic functionality working first and optimize later if needed.\n\nAssuming I proceed with recursion, I'll need to write a function that takes a folder path as input, calculates the total size of that folder (including all its subfolders and files), and then calculates the percentage of the drive's total size that this folder occupies.\n\nOnce I have this function, I can iterate over all top-level folders in the drive, apply this function to each, and collect the results into a report.\n\nThe report should include at least the folder path, its size, and the percentage of the drive's total size that it uses. It might also be useful to include the drive letter and the current free space percentage for context.\n\nI should also consider how to handle large drives with millions of files. Recursing through the entire directory structure could take a lot of time and resources. Maybe I can look into using background jobs or parallel processing to speed things up.\n\nAnother thing to think about is error handling. What if I don't have permissions to access certain folders? Or if some folders are offline or inaccessible? I need to make sure that the script can handle these scenarios gracefully without crashing.\n\nPerhaps I can use try-catch blocks around the folder access and size calculation code to catch any exceptions and log warnings or skip those folders.\n\nAlso, I should think about the output format of the report. Should it be a text file, CSV, HTML, or maybe sent via email? The requirements don't specify, so I'll need to make a decision.\n\nFor now, I'll assume that outputting the report to a CSV file is sufficient. CSV is easy to work with and can be opened in spreadsheet programs for further analysis.\n\nI should also consider where to save this report. Maybe specify a default location, or allow the user to specify the output path via a parameter in the script.\n\nSpeaking of parameters, I should design the script to accept input parameters so that it can be more flexible. For example, the threshold percentage for free space could be set by the user, not hardcoded to 20%.\n\nAdditionally, it might be useful to have options to specify which drives to check or to exclude certain drives.\n\nLet me start sketching out the basic structure of the script.\n\nFirst, define parameters for threshold percentage, output file path, etc.\n\nThen, get a list of all fixed drives using `Get-WmiObject -Class Win32_LogicalDisk -Filter \"DriveType=3\"`.\n\nFor each drive, calculate the free space percentage.\n\nIf the free space percentage is less than the threshold, proceed to generate the report for that drive.\n\nTo generate the report, get all top-level folders in the drive.\n\nFor each folder, calculate its total size and the percentage of the drive's total size.\n\nCollect this information into an array of custom objects, each representing a folder with properties like Path, Size, and Percentage.\n\nFinally, export this array to a CSV file specified by the user, or a default location.\n\nNow, let's think about how to calculate the folder sizes.\n\nOne approach is to use the `Get-ChildItem` cmdlet with the `-Recurse` parameter to get all items within the folder, then use `Measure-Object` to sum up their lengths.\n\nBut as I thought earlier, this could be slow for large folders.\n\nAn alternative is to use the .NET `System.IO.DirectoryInfo` class, which has a `GetFileSystemInfos` method that can be used to get all files and subdirectories.\n\nI can then iterate through these and sum up their lengths recursively.\n\nWait, but this still involves recursion, which might not be efficient.\n\nHmm.\n\nMaybe I can use the `robocopy` command with the `/\u955c` (mirroring) option and parse its output to get folder sizes. Robocopy is known for its fast directory listing and sizing capabilities.\n\nActually, robocopy has a `/ mir` option, but I think you're confusing it with the `/ mir` option for mirroring directories. For folder sizes, robocopy has the `/ mir` option, but it's not directly for sizing.\n\nWait, perhaps I should look into using robocopy with the `/ mir` option and parsing its output, but I'm not sure.\n\nAlternatively, I can use the `du` command in PowerShell, which is alias for `Get-ChildItem` with `-Recurse` and `Measure-Object`, but again, it's similar to the first approach.\n\nWait, no, `du` is actually a cmdlet in PowerShell that calculates disk usage.\n\nYes, `du` is a alias for `Get-ChildItem -Recurse | Measure-Object -Property Length -Sum`, but it's not efficient for large directories.\n\nI need a better way.\n\nPerhaps using the CIM cmdlets instead of WMI for getting disk information, as CIM is the successor to WMI and might be more efficient.\n\nBut for folder sizing, I'm not sure.\n\nWait, maybe I can use the `Get-Item` cmdlet on the folder and access its `Length` property, but I don't think that gives the total size including subfolders.\n\nLet me check.\n\nNo, `Get-Item` on a folder only gives information about the folder itself, not its contents.\n\nSo, I need to recurse into the folder structure to get the total size.\n\nThis seems inevitable.\n\nMaybe I can write a function that takes a folder path, uses `Get-ChildItem` with `-Recurse` and `-File` to get all files, then measures their total size.\n\nBut again, this could be slow.\n\nAlternatively, I can use the .NET `System.IO.Directory` class and its `GetFileSystemEntries` method to enumerate all files and subdirectories without recursion, and then sum their sizes.\n\nWait, but that still requires me to handle recursion manually.\n\nMaybe it's better to stick with PowerShell cmdlets for simplicity, even if it's not the most efficient.\n\nI can accept that for now, and if performance becomes an issue, I can look into optimizing it later.\n\nSo, in the script, I'll define a function, say, `Get-FolderSize`, which takes a folder path as input and returns the total size of that folder and its subfolders.\n\nInside this function, I'll use `Get-ChildItem -Path $folderPath -Recurse -File | Measure-Object -Property Length -Sum` to get the total size.\n\nThen, I'll calculate the percentage of the drive's total size using the formula `( $folderSize / $driveSize ) * 100`.\n\nAfter that, I'll collect this information for all top-level folders and export it to a CSV file.\n\nNow, to make this more efficient, maybe I can run the folder size calculations in parallel using PowerShell background jobs or the `ForEach-Object -Parallel` cmdlet (available in PowerShell 7).\n\nBut since the script needs to run on Windows Server, which might have varying PowerShell versions, I should check the PowerShell version first.\n\nAlternatively, I can use the `Start-Job` cmdlet to run folder size calculations in background jobs, and then collect the results.\n\nThis way, multiple folder sizes can be calculated simultaneously, speeding up the process.\n\nI need to consider the server's resources, though; running too many background jobs could overload the server.\n\nMaybe I can limit the number of concurrent jobs to a certain number, like 4 or 5.\n\nAlso, I need to handle the possibility of job failures or time-outs.\n\nThis is getting a bit complicated. Maybe for now, I'll stick with sequential folder size calculations and see how it performs.\n\nIf needed, I can add parallel processing later.\n\nNext, I need to think about how to handle drives with insufficient permissions.\n\nWhen trying to access a folder, if there are permission issues, PowerShell will throw an exception.\n\nTo handle this, I can wrap the folder size calculation in a try-catch block, and if an exception occurs, log a warning message and skip that folder.\n\nI should also consider excluding certain system folders, like `$Recycle.Bin` or `System Volume Information`, which might not be relevant for disk space analysis and could cause permission issues.\n\nMaybe I can maintain a list of folders to exclude based on their names.\n\nNow, let's think about the output report.\n\nAs I mentioned earlier, a CSV file seems appropriate.\n\nEach row in the CSV should represent a folder, with columns for Path, Size in bytes, Size in a more readable format (like MB or GB), and Percentage of drive's total size.\n\nI can create custom objects with these properties and then export them to CSV using `Export-Csv`.\n\nI should also include the drive letter and total size of the drive in the report for context.\n\nPerhaps add a header section in the CSV or include drive information in each row.\n\nAlternatively, I can create separate reports for each drive.\n\nBut to keep it simple, I'll include all folders from all drives that meet the criteria in a single CSV file, with a column for the drive letter.\n\nNow, regarding the size units, presenting sizes in bytes might not be very user-friendly.\n\nIt would be better to convert sizes to KB, MB, or GB.\n\nI can create a function to format the size into a human-readable string, like \"10.5 GB\".\n\nSimilarly, for percentages, I'll need to format them as percentages with one or two decimal places.\n\nI should also ensure that the script handles very large sizes correctly, considering that sizes can exceed 2^32-1 bytes, which is the maximum for a 32-bit integer.\n\nTherefore, I need to use 64-bit integers (`[long]`) for size calculations.\n\nNow, let's consider the script's parameters.\n\nI'll need at least the following parameters:\n\n- Threshold: the free space percentage below which to generate the report (default to 20%).\n\n- OutputPath: the path to save the report CSV file (with a default path).\n\n- IncludeDrives: an array of drive letters to include in the check (optional).\n\n- ExcludeDrives: an array of drive letters to exclude from the check (optional).\n\nThis way, the user can specify which drives to check or exclude, and set the threshold and output path as needed.\n\nI should also add some validation for these parameters, like ensuring that the threshold is a valid percentage (0-100), and that the output path is valid.\n\nNow, let's think about how to implement this in code.\n\nFirst, define the parameters at the top of the script.\n\nThen, get the list of drives to check, based on the IncludeDrives and ExcludeDrives parameters.\n\nFor each drive in the list, check its free space percentage.\n\nIf it's below the threshold, get all top-level folders and calculate their sizes using the `Get-FolderSize` function.\n\nCollect the results into an array of custom objects.\n\nFinally, export this array to the specified CSV file.\n\nI should also add some logging or output to inform the user about the progress, like which drives are being checked and whether reports are generated.\n\nNow, let's consider writing the `Get-FolderSize` function.\n\nThis function should take a folder path as input and return the total size of that folder and its subfolders.\n\nAs discussed earlier, I'll use `Get-ChildItem -Path $folderPath -Recurse -File | Measure-Object -Property Length -Sum` to get the total size.\n\nBut to handle permission errors, I'll wrap this in a try-catch block.\n\nIf an error occurs, I'll write a warning message and return a default value, like 0, for that folder's size.\n\nAdditionally, I can measure the time taken to calculate each folder's size, especially for large folders, to identify any performance bottlenecks.\n\nNow, to make the script more user-friendly, maybe I can display a progress bar or some indication of progress while checking multiple drives or calculating folder sizes.\n\nPowerShell has the `Write-Progress` cmdlet for this purpose.\n\nI can use it to show the progress of drive checks and folder size calculations.\n\nThis will help the user understand that the script is working and how much time might be left.\n\nAlso, I should consider the script's execution time, especially on servers with many drives and large directories.\n\nPerhaps I can add some timing code to measure how long the script takes to run.\n\nNow, let's think about testing the script.\n\nI need to test it on a Windows Server with multiple drives, some of which have less than 20% free space.\n\nI should verify that the script correctly identifies these drives and generates the report with accurate folder sizes and percentages.\n\nI also need to test permission scenarios, where the script doesn't have access to certain folders, to ensure that it handles those cases gracefully.\n\nAdditionally, I should test with different PowerShell versions to ensure compatibility.\n\nSince Windows Server can run different versions of PowerShell, I need to make sure that the script works at least with PowerShell 5.1, which is common on Windows Server 2016 and later.\n\nIf possible, I can make it compatible with older PowerShell versions as well.\n\nBut for now, focusing on PowerShell 5.1 should suffice.\n\nI should also consider any dependencies the script might have, like specific PowerShell modules, and ensure that they are either included or checked for presence in the script.\n\nIn this case, I don't think I need any additional modules beyond the core PowerShell cmdlets.\n\nNow, let's outline the steps in code:\n\n1. Define parameters: Threshold, OutputPath, IncludeDrives, ExcludeDrives.\n\n2. Get a list of fixed drives using `Get-WmiObject -Class Win32_LogicalDisk -Filter \"DriveType=3\"`.\n\n3. Filter the drives based on IncludeDrives and ExcludeDrives parameters.\n\n4. For each drive in the filtered list:\n\na. Get the drive's free space percentage.\n\nb. If the free space percentage is less than the threshold:\n\ni. Get all top-level folders in the drive.\n\nii. For each folder, calculate its size using the `Get-FolderSize` function.\n\niii. Calculate the percentage of the drive's total size that the folder occupies.\n\niv. Create a custom object with properties: DriveLetter, FolderPath, SizeBytes, SizeFormatted, PercentageUsed.\n\nv. Add the object to an array.\n\n5. Export the array to a CSV file specified by OutputPath.\n\n6. Optionally, output a message indicating where the report was saved.\n\nNow, let's think about writing the `Get-FolderSize` function.\n\nFunction Get-FolderSize ($folderPath) {\n\ntry {\n\n$files = Get-ChildItem -Path $folderPath -Recurse -File -ErrorAction Stop\n\n$totalSize = $files | Measure-Object -Property Length -Sum -ErrorAction Stop\n\nreturn $totalSize.Sum\n\n}\n\ncatch {\n\nWrite-Warning \"Access denied or error accessing $folderPath: $_\"\n\nreturn 0\n\n}\n\n}\n\nThis function attempts to get all files in the folder and its subfolders, sums their sizes, and returns the total.\n\nIf an error occurs, it writes a warning and returns 0.\n\nI should also consider that some folders might be empty, in which case the size would be 0, which is fine.\n\nNow, for formatting the size into a readable string, I can create another function, say, `Format-Size`, which takes a size in bytes and returns a string like \"10.5 GB\".\n\nFunction Format-Size ($sizeBytes) {\n\nif ($sizeBytes -ge 1TB) {\n\n\"{0:N2} TB\" -f ($sizeBytes / 1TB)\n\n}\n\nelseif ($sizeBytes -ge 1GB) {\n\n\"{0:N2} GB\" -f ($sizeBytes / 1GB)\n\n}\n\nelseif ($sizeBytes -ge 1MB) {\n\n\"{0:N2} MB\" -f ($sizeBytes / 1MB)\n\n}\n\nelseif ($sizeBytes -ge 1KB) {\n\n\"{0:N2} KB\" -f ($sizeBytes / 1KB)\n\n}\n\nelse {\n\n\"{0} B\" -f $sizeBytes\n\n}\n\n}\n\nThis function checks the size and formats it accordingly, using the appropriate unit (TB, GB, MB, KB, or bytes).\n\nNow, putting it all together, here's a rough draft of the script:\n\n# Define parameters\n\nparam (\n\n[parameter(Mandatory=$false)]\n\n[int]$Threshold = 20,\n\n[parameter(Mandatory=$false)]\n\n[string]$OutputPath = \"$env:windir\\temp\\disk_space_report.csv\",\n\n[parameter(Mandatory=$false)]\n\n[string[]]$IncludeDrives,\n\n[parameter(Mandatory=$false)]\n\n[string[]]$ExcludeDrives\n\n)\n\n# Function to get folder size\n\nFunction Get-FolderSize ($folderPath) {\n\ntry {\n\n$files = Get-ChildItem -Path $folderPath -Recurse -File -ErrorAction Stop\n\n$totalSize = $files | Measure-Object -Property Length -Sum -ErrorAction Stop\n\nreturn $totalSize.Sum\n\n}\n\ncatch {\n\nWrite-Warning \"Access denied or error accessing $folderPath: $_\"\n\nreturn 0\n\n}\n\n}\n\n# Function to format size\n\nFunction Format-Size ($sizeBytes) {\n\nif ($sizeBytes -ge 1TB) {\n\n\"{0:N2} TB\" -f ($sizeBytes / 1TB)\n\n}\n\nelseif ($sizeBytes -ge 1GB) {\n\n\"{0:N2} GB\" -f ($sizeBytes / 1GB)\n\n}\n\nelseif ($sizeBytes -ge 1MB) {\n\n\"{0:N2} MB\" -f ($sizeBytes / 1MB)\n\n}\n\nelseif ($sizeBytes -ge 1KB) {\n\n\"{0:N2} KB\" -f ($sizeBytes / 1KB)\n\n}\n\nelse {\n\n\"{0} B\" -f $sizeBytes\n\n}\n\n}\n\n# Get list of fixed drives\n\n$drives = Get-WmiObject -Class Win32_LogicalDisk -Filter \"DriveType=3\"\n\n# Filter drives based on IncludeDrives and ExcludeDrives parameters\n\nif ($IncludeDrives) {\n\n$drives = $drives | Where-Object { $_.DeviceID -in $IncludeDrives }\n\n}\n\nif ($ExcludeDrives) {\n\n$drives = $drives | Where-Object { $_.DeviceID -notin $ExcludeDrives }\n\n}\n\n# Array to hold report data\n\n$reportData = @()\n\n# Check each drive\n\nforeach ($drive in $drives) {\n\n$driveLetter = $drive.DeviceID\n\n$freeSpacePercent = ($drive.FreeSpace / $drive.Size) * 100\n\nif ($freeSpacePercent -lt $Threshold) {\n\nWrite-Output \"Drive $driveLetter has less than $Threshold% free space. Generating report.\"\n\n# Get all top-level folders\n\n$folders = Get-ChildItem -Path $driveLetter -Directory\n\nforeach ($folder in $folders) {\n\n$folderPath = $folder.FullName\n\n$folderSizeBytes = Get-FolderSize -folderPath $folderPath\n\n$driveSizeBytes = $drive.Size\n\n$percentageUsed = ($folderSizeBytes / $driveSizeBytes) * 100\n\n$formattedSize = Format-Size -sizeBytes $folderSizeBytes\n\n# Create custom object for report\n\n$reportObject = New-Object PSObject -Property @{\n\n'DriveLetter' = $driveLetter\n\n'FolderPath' = $folderPath\n\n'SizeBytes' = $folderSizeBytes\n\n'SizeFormatted' = $formattedSize\n\n'PercentageUsed' = \"{0:P2}\" -f $percentageUsed\n\n}\n\n# Add to report data array\n\n$reportData += $reportObject\n\n}\n\n}\n\n}\n\n# Export report to CSV\n\n$reportData | Export-Csv -Path $OutputPath -NoTypeInformation\n\nWrite-Output \"Report generated and saved to $OutputPath\"\n\nThis is a basic implementation of the script based on the requirements.\n\nHowever, there are a few improvements and considerations I should address:\n\n1. Error handling: While the `Get-FolderSize` function handles errors for individual folders, there might be errors at other stages, like accessing WMI data or writing to the output file. I should add try-catch blocks around critical sections to handle these errors gracefully.\n\n2. Performance: As discussed earlier, calculating folder sizes recursively can be slow for large directories. To improve performance, I could implement parallel processing using background jobs or runspaces. However, this complicates the script, so I might leave it for now and suggest it as a possible enhancement.\n\n3. Exclusion of specific folders: I should allow the script to exclude certain folders, like system folders, to avoid permission issues and irrelevant data in the report. This could be done by adding another parameter for excluded folders and skipping those in the folder size calculation.\n\n4. Logging: Instead of just writing output messages, I could implement a logging mechanism to record detailed information about the script's execution, including any errors or warnings.\n\n5. Parameter validation: I should add validation attributes to the script parameters to ensure that the input values are correct. For example, the threshold should be between 0 and 100, and the output path should be a valid file path.\n\n6. Compatibility: Ensure that the script works on different versions of PowerShell and Windows Server. Test it on various environments to confirm its reliability.\n\n7. Optimization: Consider using more efficient methods for folder size calculation, such as using the .NET Framework or alternative cmdlets that might offer better performance.\n\nGiven these considerations, I can refine the script accordingly. For now, this draft should serve as a starting point to fulfill the initial requirements.\n\n**Final Solution**\n\nTo create a PowerShell script that checks disk space on a Windows server and generates a report for drives with less than 20% free space, follow the steps below.\n\n## Approach\n\n1. **Parameter Definition**: Define script parameters for threshold, output path, and drive inclusion/exclusion.\n2. **Drive Enumeration**: Use WMI to get fixed drives and filter based on inclusion and exclusion parameters.\n3. **Free Space Check**: For each drive, calculate free space percentage and check against the threshold.\n4. **Folder Size Calculation**: For drives below the threshold, calculate sizes of top-level folders and their subfolders.\n5. **Report Generation**: Compile the data into a CSV report detailing folder paths, sizes, and usage percentages.\n\n## Solution Code\n\n```powershell\nparam (\n    [parameter(Mandatory=$false)]\n    [int]$Threshold = 20,\n    [parameter(Mandatory=$false)]\n    [string]$OutputPath = \"$env:windir\\temp\\disk_space_report.csv\",\n    [parameter(Mandatory=$false)]\n    [string[]]$IncludeDrives,\n    [parameter(Mandatory=$false)]\n    [string[]]$ExcludeDrives\n)\n\nFunction Get-FolderSize ($folderPath) {\n    try {\n        $files = Get-ChildItem -Path $folderPath -Recurse -File -ErrorAction Stop\n        $totalSize = $files | Measure-Object -Property Length -Sum -ErrorAction Stop\n        return $totalSize.Sum\n    }\n    catch {\n        Write-Warning \"Access denied or error accessing $folderPath: $_\"\n        return 0\n    }\n}\n\nFunction Format-Size ($sizeBytes) {\n    if ($sizeBytes -ge 1TB) {\n        \"{0:N2} TB\" -f ($sizeBytes / 1TB)\n    }\n    elseif ($sizeBytes -ge 1GB) {\n        \"{0:N2} GB\" -f ($sizeBytes / 1GB)\n    }\n    elseif ($sizeBytes -ge 1MB) {\n        \"{0:N2} MB\" -f ($sizeBytes / 1MB)\n    }\n    elseif ($sizeBytes -ge 1KB) {\n        \"{0:N2} KB\" -f ($sizeBytes / 1KB)\n    }\n    else {\n        \"{0} B\" -f $sizeBytes\n    }\n}\n\n$drives = Get-WmiObject -Class Win32_LogicalDisk -Filter \"DriveType=3\"\n\nif ($IncludeDrives) {\n    $drives = $drives | Where-Object { $_.DeviceID -in $IncludeDrives }\n}\n\nif ($ExcludeDrives) {\n    $drives = $drives | Where-Object { $_.DeviceID -notin $ExcludeDrives }\n}\n\n$reportData = @()\n\nforeach ($drive in $drives) {\n    $driveLetter = $drive.DeviceID\n    $freeSpacePercent = ($drive.FreeSpace / $drive.Size) * 100\n    if ($freeSpacePercent -lt $Threshold) {\n        Write-Output \"Drive $driveLetter has less than $Threshold% free space. Generating report.\"\n        $folders = Get-ChildItem -Path $driveLetter -Directory\n        foreach ($folder in $folders) {\n            $folderPath = $folder.FullName\n            $folderSizeBytes = Get-FolderSize -folderPath $folderPath\n            $driveSizeBytes = $drive.Size\n            $percentageUsed = ($folderSizeBytes / $driveSizeBytes) * 100\n            $formattedSize = Format-Size -sizeBytes $folderSizeBytes\n            $reportObject = New-Object PSObject -Property @{\n                'DriveLetter' = $driveLetter\n                'FolderPath' = $folderPath\n                'SizeBytes' = $folderSizeBytes\n                'SizeFormatted' = $formattedSize\n                'PercentageUsed' = \"{0:P2}\" -f $percentageUsed\n            }\n            $reportData += $reportObject\n        }\n    }\n}\n\n$reportData | Export-Csv -Path $OutputPath -NoTypeInformation\nWrite-Output \"Report generated and saved to $OutputPath\"\n```\n\n## Explanation\n\n1. **Parameters**: The script accepts parameters for the free space threshold, output file path, and drive inclusion/exclusion.\n2. **Functions**:\n   - `Get-FolderSize`: Recursively calculates the total size of a folder and handles access errors.\n   - `Format-Size`: Converts bytes into a human-readable format (KB, MB, GB, TB).\n3. **Drive Filtering**: Uses WMI to get fixed drives and filters based on inclusion and exclusion lists.\n4. **Free Space Check**: Calculates the free space percentage for each drive and checks against the threshold.\n5. **Folder Size Calculation**: For drives below the threshold, calculates the size of each top-level folder and its subfolders.\n6. **Report Generation**: Compiles the data into a CSV file with details on folder paths, sizes, and usage percentages."
    }
]