[
    {
        "role": "user",
        "content": "Implement a Python program that simulates the behavior of a Least Recently Used (LRU) Cache using a dictionary and a doubly-linked list. The cache should have methods for adding items, retrieving items by key, and removing the least recently used item when the cache reaches its capacity.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Sure, I can help you with that! Implementing an LRU Cache in Python using a dictionary and a doubly-linked list is a great way to understand both data structures and how they can be combined to achieve efficient operations.\n\nFirst, let's understand what an LRU Cache is. LRU stands for Least Recently Used, which is a caching strategy where the least recently accessed item is removed to make space for new entries when the cache reaches its capacity.\n\nIn this implementation, we'll use a combination of a dictionary and a doubly-linked list to maintain the order of items based on their usage. The dictionary will provide O(1) access time for retrieving items by key, and the doubly-linked list will help us manage the order of items and efficiently remove the least recently used item.\n\nHere's a step-by-step breakdown of the implementation:\n\n1. **Doubly Linked List Node**: We'll create a Node class for the doubly-linked list, which will have pointers to the next and previous nodes, as well as fields to store the key and value.\n\n2. **Doubly Linked List**: We'll implement a DoublyLinkedList class to manage the nodes. This class will have methods to add a node to the head, remove a node, and remove the tail node. The head of the list will represent the most recently used item, and the tail will represent the least recently used item.\n\n3. **LRUCache Class**: This is the main class that will use the dictionary and the doubly-linked list to implement the cache. It will have the following methods:\n   - `__init__(self, capacity)`: Initializes the cache with a given capacity.\n   - `get(self, key)`: Retrieves the value associated with the given key. If the key exists, it also moves the corresponding node to the head of the list to mark it as recently used.\n   - `put(self, key, value)`: Adds a new key-value pair to the cache. If the key already exists, it updates the value and moves the node to the head. If the cache is at capacity, it removes the least recently used item (the tail) before adding the new item.\n\nNow, let's dive into the code.\n\n## Final Solution\nTo implement an LRU Cache in Python, we can use a combination of a dictionary and a doubly-linked list. This approach ensures that both the `get` and `put` operations have a time complexity of O(1).\n\n### Approach\n\n1. **Node Class**:\n   - Represents an element in the doubly-linked list.\n   - Each node contains `key`, `value`, and pointers to the next and previous nodes.\n\n2. **Doubly Linked List**:\n   - Manages the order of elements based on their usage.\n   - The head represents the most recently used item.\n   - The tail represents the least recently used item.\n\n3. **LRUCache Class**:\n   - Uses a dictionary to store keys mapped to their corresponding nodes.\n   - Uses a doubly-linked list to maintain the order of usage.\n   - `get(key)`: Retrieves the value associated with the key and moves the accessed node to the head.\n   - `put(key, value)`: Adds or updates a key-value pair and moves the node to the head. If the cache exceeds its capacity, removes the least recently used item (the tail).\n\n### Solution Code\n\n```python\nclass Node:\n    def __init__(self, key, value):\n        self.key = key\n        self.value = value\n        self.prev = None\n        self.next = None\n\nclass DoublyLinkedList:\n    def __init__(self):\n        self.head = None\n        self.tail = None\n\n    def add_to_head(self, node):\n        if self.head is None:\n            self.head = node\n            self.tail = node\n            node.prev = None\n            node.next = None\n        else:\n            node.next = self.head\n            self.head.prev = node\n            self.head = node\n            node.prev = None\n\n    def remove(self, node):\n        if node.prev:\n            node.prev.next = node.next\n        else:\n            self.head = node.next\n        if node.next:\n            node.next.prev = node.prev\n        else:\n            self.tail = node.prev\n        node.prev = None\n        node.next = None\n\n    def remove_tail(self):\n        if self.tail is None:\n            return None\n        node = self.tail\n        self.remove(node)\n        return node\n\nclass LRUCache:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.size = 0\n        self.cache = {}\n        self.dll = DoublyLinkedList()\n\n    def get(self, key):\n        if key in self.cache:\n            node = self.cache[key]\n            self.dll.remove(node)\n            self.dll.add_to_head(node)\n            return node.value\n        else:\n            return -1\n\n    def put(self, key, value):\n        if key in self.cache:\n            node = self.cache[key]\n            node.value = value\n            self.dll.remove(node)\n            self.dll.add_to_head(node)\n        else:\n            new_node = Node(key, value)\n            self.cache[key] = new_node\n            self.dll.add_to_head(new_node)\n            self.size += 1\n            if self.size > self.capacity:\n                removed_node = self.dll.remove_tail()\n                del self.cache[removed_node.key]\n                self.size -= 1\n```\n\n### Explanation\n\n- **Node Class**:\n  - Each node contains `key`, `value`, and pointers to the next and previous nodes.\n\n- **Doubly Linked List**:\n  - `add_to_head(node)`: Adds a node to the head of the list.\n  - `remove(node)`: Removes a node from the list.\n  - `remove_tail()`: Removes the tail node from the list and returns it.\n\n- **LRUCache Class**:\n  - `get(key)`: Retrieves the value of the key and moves the corresponding node to the head of the list.\n  - `put(key, value)`: Adds or updates a key-value pair and moves the node to the head. If the cache exceeds its capacity, removes the least recently used item (the tail).\n\nThis implementation ensures efficient operations for an LRU Cache using a combination of dictionary and doubly-linked list."
    }
]