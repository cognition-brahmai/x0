[
    {
        "role": "user",
        "content": "Create a C++ application that interacts with the GitHub API to create a new repository, list all repositories for a user, and delete a specified repository. The program should authenticate using a personal access token provided as a command-line argument.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Alright, I've got this task to create a C++ application that interacts with the GitHub API to manage repositories: create a new one, list all for a user, and delete a specified one. It should use a personal access token provided at the command line for authentication. Okay, let's break this down.\n\nFirst, I need to understand how to interact with the GitHub API using C++. GitHub API is a REST API, so I'll need to make HTTP requests from my C++ program. I need to figure out how to do HTTP requests in C++. I know that C++ standard library has support for networking in C++11 and later, but I think for this task, I might need a third-party library that makes HTTP requests easier, like cURL or Boost.Beast.\n\nLet me consider cURL because it's widely used and supported. I need to see how to integrate cURL into my C++ project. I should check if cURL is already installed on my system; if not, I'll need to install it. Then, I need to include the necessary headers in my C++ code and link against the cURL library.\n\nNext, I need to understand the GitHub API endpoints for repository management. From the GitHub API documentation, I can see that to create a new repository, I need to make a POST request to `https://api.github.com/user/repos` with a JSON payload containing the repository name and other details. To list all repositories for a user, I need to make a GET request to `https://api.github.com/users/{username}/repos`. To delete a repository, I need to make a DELETE request to `https://api.github.com/repos/{username}/{reponame}`.\n\nFor authentication, GitHub recommends using a personal access token (PAT). The PAT should be passed in the request headers with the format `Authorization: token <your_token>`. Since the PAT is provided as a command-line argument, I need to handle command-line arguments in C++ and use that token for authentication in all API requests.\n\nI should also consider error handling. API requests can fail due to network issues, invalid tokens, or incorrect input. I need to handle these cases gracefully and provide meaningful error messages to the user.\n\nLet me outline the steps I need to implement:\n\n1. Parse command-line arguments to get the personal access token and the operation to perform (create, list, delete).\n\n2. Set up cURL to make HTTP requests to the GitHub API.\n\n3. For the \"create\" operation:\n\na. Get the repository name from the user.\n\nb. Construct the JSON payload with the repository name.\n\nc. Make a POST request to `https://api.github.com/user/repos` with the JSON payload and the authorization header.\n\nd. Handle the response and inform the user if the repository was created successfully.\n\n4. For the \"list\" operation:\n\na. Get the username from the user.\n\nb. Make a GET request to `https://api.github.com/users/{username}/repos` with the authorization header.\n\nc. Parse the JSON response to list all repositories.\n\n5. For the \"delete\" operation:\n\na. Get the repository name from the user.\n\nb. Make a DELETE request to `https://api.github.com/repos/{username}/{reponame}` with the authorization header.\n\nc. Handle the response and inform the user if the repository was deleted successfully.\n\nI need to decide how to handle JSON data in C++. There are several libraries available for JSON parsing and serialization in C++, such as nlohmann/json, which is a popular header-only library. I think I'll use nlohmann/json for its ease of use.\n\nSo, my plan is:\n\n- Include cURL and nlohmann/json in my project.\n\n- Write functions for each operation: create_repo, list_repos, delete_repo.\n\n- Each function will construct the appropriate HTTP request, send it using cURL, and handle the response.\n\n- Use command-line arguments to determine which operation to perform.\n\nI should also consider making the code modular and clean, perhaps using classes or structs to organize the code better.\n\nLet me start by setting up a basic C++ project with cURL and nlohmann/json.\n\nFirst, I need to install cURL if it's not already installed. On Ubuntu, I can use:\n\n```bash\n\nsudo apt-get install libcurl4-openssl-dev\n\n```\n\nFor nlohmann/json, since it's header-only, I can download the single header file and include it in my project, or use a package manager like vcpkg or conan to manage dependencies.\n\nI think I'll go with downloading the single header file for simplicity.\n\nNext, I need to set up my C++ project. I'll create a new directory for the project and set up a CMakeLists.txt file to manage the build process.\n\nHere's a basic structure:\n\n- github_repo_manager/\n\n- CMakeLists.txt\n\n- main.cpp\n\n- json.hpp (from nlohmann/json)\n\nIn main.cpp, I'll include the necessary headers and start implementing the functions.\n\nFirst, I need to handle command-line arguments. I'll expect the personal access token as the first argument and the operation as the second argument. Optionally, for create and delete operations, I'll need additional arguments for the repository name and possibly other details.\n\nFor example:\n\n- To create a repository: `./github_repo_manager <token> create <repo_name>`\n\n- To list repositories: `./github_repo_manager <token> list`\n\n- To delete a repository: `./github_repo_manager <token> delete <repo_name>`\n\nI need to parse these arguments in main.cpp and call the appropriate function based on the operation.\n\nLet me sketch a rough structure of main.cpp:\n\n#include <iostream>\n\n#include <curl/curl.h>\n\n#include \"json.hpp\"\n\nusing json = nlohmann::json;\n\n// Function prototypes\n\nvoid create_repo(const std::string& token, const std::string& repo_name);\n\nvoid list_repos(const std::string& token, const std::string& username);\n\nvoid delete_repo(const std::string& token, const std::string& username, const std::string& repo_name);\n\nint main(int argc, char* argv[]) {\n\nif (argc < 3) {\n\nstd::cerr << \"Usage: \" << argv[0] << \" <token> <operation> [options]\" << std::endl;\n\nreturn 1;\n\n}\n\nstd::string token = argv[1];\n\nstd::string operation = argv[2];\n\nif (operation == \"create\") {\n\nif (argc != 4) {\n\nstd::cerr << \"Usage: \" << argv[0] << \" <token> create <repo_name>\" << std::endl;\n\nreturn 1;\n\n}\n\nstd::string repo_name = argv[3];\n\ncreate_repo(token, repo_name);\n\n} else if (operation == \"list\") {\n\n// For list, we might need to ask for username or get it from token\n\n// Need to implement a way to get username\n\n} else if (operation == \"delete\") {\n\nif (argc != 4) {\n\nstd::cerr << \"Usage: \" << argv[0] << \" <token> delete <repo_name>\" << std::endl;\n\nreturn 1;\n\n}\n\nstd::string repo_name = argv[3];\n\n// Need to get username somehow\n\n} else {\n\nstd::cerr << \"Invalid operation. Use create, list, or delete.\" << std::endl;\n\nreturn 1;\n\n}\n\nreturn 0;\n\n}\n\nI realize that for the list and delete operations, I need the username. Maybe I should get the username from the user via input or find a way to retrieve it from the token.\n\nWait, perhaps I can make an API call to get the authenticated user's information using the token.\n\nLooking at the GitHub API documentation, there's an endpoint `https://api.github.com/user` which returns information about the authenticated user, including their username.\n\nSo, I can make a GET request to `https://api.github.com/user` with the token to retrieve the username.\n\nThat sounds like a good approach to automatically get the username without requiring the user to input it manually.\n\nI'll need to implement a function to get the authenticated user's information and extract the username from the JSON response.\n\nLet me add a function `get_authenticated_user(const std::string& token)` that makes a GET request to `https://api.github.com/user` and returns the username.\n\nThen, in the list and delete operations, I can use this function to get the username.\n\nThis will make the program more user-friendly.\n\nNow, let's think about implementing the `create_repo` function.\n\nI need to make a POST request to `https://api.github.com/user/repos` with a JSON payload containing the repository name.\n\nThe JSON payload should look like this:\n\n{\n\n\"name\": \"repo_name\",\n\n\"private\": false,\n\n\"auto_init\": true\n\n}\n\nI can construct this JSON object using nlohmann/json.\n\nThen, I need to set up cURL to make a POST request with the JSON data and the authorization header.\n\nI need to handle the response to check if the repository was created successfully.\n\nSimilarly, for the `list_repos` function, I need to make a GET request to `https://api.github.com/users/{username}/repos` and parse the JSON response to list the repository names.\n\nFor the `delete_repo` function, I need to make a DELETE request to `https://api.github.com/repos/{username}/{reponame}` and handle the response to confirm deletion.\n\nI should also consider rate limiting and other potential errors from the GitHub API and handle them appropriately.\n\nLet me start by implementing the `get_authenticated_user` function.\n\nFirst, I need to set up cURL to make a GET request to `https://api.github.com/user` with the authorization header containing the personal access token.\n\nI need to write a generic function to make HTTP requests with cURL, as I'll be using it in multiple places.\n\nLet's create a function `curl_request` that takes the HTTP method (GET, POST, DELETE), the URL, the request body (if any), and the authorization token, and returns the response body.\n\nHere's a rough sketch:\n\nCURLcode curl_request(const std::string& method, const std::string& url, const std::string& body, const std::string& token, std::string& response) {\n\nCURL* curl = curl_easy_init();\n\nif (!curl) {\n\nreturn CURLE_FAILED_INIT;\n\n}\n\ncurl_easy_setopt(curl, CURLOPT_URL, url.c_str());\n\ncurl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, method.c_str());\n\nif (!body.empty()) {\n\ncurl_easy_setopt(curl, CURLOPT_POSTFIELDS, body.c_str());\n\n}\n\nstd::string header_value = \"Authorization: token \" + token;\n\nstruct curl_slist* headers = NULL;\n\nheaders = curl_slist_append(headers, header_value.c_str());\n\ncurl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);\n\n// Write the response to a string\n\ncurl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_callback);\n\ncurl_easy_setopt(curl, CURLOPT_WRITEDATA, &response);\n\nCURLcode res = curl_easy_perform(curl);\n\ncurl_easy_cleanup(curl);\n\ncurl_slist_free_all(headers);\n\nreturn res;\n\n}\n\nI need to define a `write_callback` function that appends the received data to the response string.\n\nsize_t write_callback(char* contents, size_t size, size_t nmemb, void* userp) {\n\nsize_t total_size = size * nmemb;\n\nstd::string* str = static_cast<std::string*>(userp);\n\nstr->append(contents, total_size);\n\nreturn total_size;\n\n}\n\nNow, with this generic `curl_request` function, I can make HTTP requests easily.\n\nLet's implement `get_authenticated_user`.\n\nstd::string get_authenticated_user(const std::string& token) {\n\nstd::string url = \"https://api.github.com/user\";\n\nstd::string response;\n\nCURLcode res = curl_request(\"GET\", url, \"\", token, response);\n\nif (res != CURLE_OK) {\n\nstd::cerr << \"cURL error: \" << curl_easy_strerror(res) << std::endl;\n\nreturn \"\";\n\n}\n\ntry {\n\njson json_response = json::parse(response);\n\nreturn json_response[\"login\"];\n\n} catch (const json::exception& e) {\n\nstd::cerr << \"JSON parse error: \" << e.what() << std::endl;\n\nreturn \"\";\n\n}\n\n}\n\nThis function makes a GET request to the user endpoint, parses the JSON response, and returns the username (login field).\n\nNow, for the `create_repo` function.\n\nvoid create_repo(const std::string& token, const std::string& repo_name) {\n\nstd::string url = \"https://api.github.com/user/repos\";\n\njson payload = {\n\n{\"name\", repo_name},\n\n{\"private\", false},\n\n{\"auto_init\", true}\n\n};\n\nstd::string payload_str = payload.dump();\n\nstd::string response;\n\nCURLcode res = curl_request(\"POST\", url, payload_str, token, response);\n\nif (res != CURLE_OK) {\n\nstd::cerr << \"Failed to create repository: \" << curl_easy_strerror(res) << std::endl;\n\nreturn;\n\n}\n\ntry {\n\njson json_response = json::parse(response);\n\nstd::cout << \"Repository created: \" << json_response[\"html_url\"] << std::endl;\n\n} catch (const json::exception& e) {\n\nstd::cerr << \"JSON parse error: \" << e.what() << std::endl;\n\n}\n\n}\n\nSimilarly, for `list_repos`.\n\nvoid list_repos(const std::string& token, const std::string& username) {\n\nstd::string url = \"https://api.github.com/users/\" + username + \"/repos\";\n\nstd::string response;\n\nCURLcode res = curl_request(\"GET\", url, \"\", token, response);\n\nif (res != CURLE_OK) {\n\nstd::cerr << \"Failed to list repositories: \" << curl_easy_strerror(res) << std::endl;\n\nreturn;\n\n}\n\ntry {\n\njson json_response = json::parse(response);\n\nfor (const auto& repo : json_response) {\n\nstd::cout << repo[\"name\"] << std::endl;\n\n}\n\n} catch (const json::exception& e) {\n\nstd::cerr << \"JSON parse error: \" << e.what() << std::endl;\n\n}\n\n}\n\nAnd for `delete_repo`.\n\nvoid delete_repo(const std::string& token, const std::string& username, const std::string& repo_name) {\n\nstd::string url = \"https://api.github.com/repos/\" + username + \"/\" + repo_name;\n\nstd::string response;\n\nCURLcode res = curl_request(\"DELETE\", url, \"\", token, response);\n\nif (res != CURLE_OK) {\n\nstd::cerr << \"Failed to delete repository: \" << curl_easy_strerror(res) << std::endl;\n\nreturn;\n\n}\n\nstd::cout << \"Repository deleted successfully.\" << std::endl;\n\n}\n\nNow, in the `main` function, I can call these functions based on the operation specified.\n\nBut I need to think about how to handle the username for list and delete operations.\n\nIn the list operation, I can allow the user to specify a username as an additional argument, or use the authenticated user's username by default.\n\nSimilarly, for delete operation, I can use the authenticated user's username unless specified otherwise.\n\nPerhaps I should add an option for the user to specify a different username if needed.\n\nBut to keep it simple, I'll assume that for list and delete operations, the username is the authenticated user's username.\n\nSo, in the `main` function, I can get the authenticated user's username using the `get_authenticated_user` function and use it for list and delete operations.\n\nHere's an updated `main` function:\n\nint main(int argc, char* argv[]) {\n\nif (argc < 3) {\n\nstd::cerr << \"Usage: \" << argv[0] << \" <token> <operation> [options]\" << std::endl;\n\nreturn 1;\n\n}\n\nstd::string token = argv[1];\n\nstd::string operation = argv[2];\n\nstd::string username = get_authenticated_user(token);\n\nif (username.empty()) {\n\nstd::cerr << \"Failed to authenticate user.\" << std::endl;\n\nreturn 1;\n\n}\n\nif (operation == \"create\") {\n\nif (argc != 4) {\n\nstd::cerr << \"Usage: \" << argv[0] << \" <token> create <repo_name>\" << std::endl;\n\nreturn 1;\n\n}\n\nstd::string repo_name = argv[3];\n\ncreate_repo(token, repo_name);\n\n} else if (operation == \"list\") {\n\nlist_repos(token, username);\n\n} else if (operation == \"delete\") {\n\nif (argc != 4) {\n\nstd::cerr << \"Usage: \" << argv[0] << \" <token> delete <repo_name>\" << std::endl;\n\nreturn 1;\n\n}\n\nstd::string repo_name = argv[3];\n\ndelete_repo(token, username, repo_name);\n\n} else {\n\nstd::cerr << \"Invalid operation. Use create, list, or delete.\" << std::endl;\n\nreturn 1;\n\n}\n\nreturn 0;\n\n}\n\nThis should cover the basic functionality.\n\nI need to make sure to handle errors properly and provide useful messages to the user.\n\nAlso, I should consider rate limiting. GitHub API has rate limits, and if the rate limit is exceeded, the API will respond with a 403 Forbidden status.\n\nI should check the response status code and handle rate limiting accordingly.\n\nTo do this, I need to retrieve the HTTP response code from cURL.\n\nI can modify the `curl_request` function to return the HTTP response code.\n\nHere's an updated version:\n\nCURLcode curl_request(const std::string& method, const std::string& url, const std::string& body, const std::string& token, std::string& response, int& response_code) {\n\nCURL* curl = curl_easy_init();\n\nif (!curl) {\n\nreturn CURLE_FAILED_INIT;\n\n}\n\ncurl_easy_setopt(curl, CURLOPT_URL, url.c_str());\n\ncurl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, method.c_str());\n\nif (!body.empty()) {\n\ncurl_easy_setopt(curl, CURLOPT_POSTFIELDS, body.c_str());\n\n}\n\nstd::string header_value = \"Authorization: token \" + token;\n\nstruct curl_slist* headers = NULL;\n\nheaders = curl_slist_append(headers, header_value.c_str());\n\ncurl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);\n\n// Write the response to a string\n\ncurl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_callback);\n\ncurl_easy_setopt(curl, CURLOPT_WRITEDATA, &response);\n\n// Get the response code\n\ncurl_easy_setopt(curl, CURLOPT_RETURNTRANSFER, 1L);\n\ncurl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);\n\nCURLcode res = curl_easy_perform(curl);\n\ncurl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &response_code);\n\ncurl_easy_cleanup(curl);\n\ncurl_slist_free_all(headers);\n\nreturn res;\n\n}\n\nNow, in the functions that use `curl_request`, I can check the `response_code` to handle different scenarios.\n\nFor example, in `create_repo`, if the response code is 201, it means the repository was created successfully. If it's 422, it might mean the repository already exists.\n\nSimilarly, in `delete_repo`, a 204 response code indicates that the repository was deleted successfully.\n\nI need to update the functions to check the response code and handle different cases accordingly.\n\nLet's update `create_repo`:\n\nvoid create_repo(const std::string& token, const std::string& repo_name) {\n\nstd::string url = \"https://api.github.com/user/repos\";\n\njson payload = {\n\n{\"name\", repo_name},\n\n{\"private\", false},\n\n{\"auto_init\", true}\n\n};\n\nstd::string payload_str = payload.dump();\n\nstd::string response;\n\nint response_code;\n\nCURLcode res = curl_request(\"POST\", url, payload_str, token, response, response_code);\n\nif (res != CURLE_OK) {\n\nstd::cerr << \"Failed to create repository: \" << curl_easy_strerror(res) << std::endl;\n\nreturn;\n\n}\n\nif (response_code == 201) {\n\ntry {\n\njson json_response = json::parse(response);\n\nstd::cout << \"Repository created: \" << json_response[\"html_url\"] << std::endl;\n\n} catch (const json::exception& e) {\n\nstd::cerr << \"JSON parse error: \" << e.what() << std::endl;\n\n}\n\n} else if (response_code == 422) {\n\nstd::cerr << \"Repository already exists or invalid parameters.\" << std::endl;\n\n} else {\n\nstd::cerr << \"Failed to create repository. Status code: \" << response_code << std::endl;\n\n}\n\n}\n\nSimilarly, update `delete_repo`:\n\nvoid delete_repo(const std::string& token, const std::string& username, const std::string& repo_name) {\n\nstd::string url = \"https://api.github.com/repos/\" + username + \"/\" + repo_name;\n\nstd::string response;\n\nint response_code;\n\nCURLcode res = curl_request(\"DELETE\", url, \"\", token, response, response_code);\n\nif (res != CURLE_OK) {\n\nstd::cerr << \"Failed to delete repository: \" << curl_easy_strerror(res) << std::endl;\n\nreturn;\n\n}\n\nif (response_code == 204) {\n\nstd::cout << \"Repository deleted successfully.\" << std::endl;\n\n} else if (response_code == 404) {\n\nstd::cerr << \"Repository not found.\" << std::endl;\n\n} else {\n\nstd::cerr << \"Failed to delete repository. Status code: \" << response_code << std::endl;\n\n}\n\n}\n\nThis should make the error handling more robust.\n\nNow, I need to make sure that the program can handle different scenarios, like trying to create a repository that already exists, deleting a repository that doesn't exist, etc.\n\nI should also consider rate limiting. If the rate limit is exceeded, the API will respond with a 403 status code and a message indicating rate limiting.\n\nI can check for a 403 status code and print a message about rate limiting.\n\nAdditionally, the GitHub API includes headers with rate limit information, such as `X-RateLimit-Remaining`, `X-RateLimit-Limit`, and `X-RateLimit-Reset`.\n\nI can retrieve these headers from the cURL response and print them if needed.\n\nTo do this, I need to capture the response headers in cURL.\n\nI can set a write function for headers in cURL.\n\nHere's how I can modify the `curl_request` function to capture headers:\n\n#include <map>\n\nstd::map<std::string, std::string> headers;\n\nsize_t header_callback(char* buffer, size_t size, size_t nmemb, std::map<std::string, std::string>* lHeaders) {\n\nsize_t total_size = size * nmemb;\n\nstd::string header(buffer, total_size);\n\nsize_t pos = header.find(\": \");\n\nif (pos != std::string::npos) {\n\nstd::string key = header.substr(0, pos);\n\nstd::string value = header.substr(pos + 2);\n\n(*lHeaders)[key] = value;\n\n}\n\nreturn total_size;\n\n}\n\nThen, in `curl_request`:\n\nCURLcode curl_request(const std::string& method, const std::string& url, const std::string& body, const std::string& token, std::string& response, int& response_code, std::map<std::string, std::string>& headers) {\n\nCURL* curl = curl_easy_init();\n\nif (!curl) {\n\nreturn CURLE_FAILED_INIT;\n\n}\n\ncurl_easy_setopt(curl, CURLOPT_URL, url.c_str());\n\ncurl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, method.c_str());\n\nif (!body.empty()) {\n\ncurl_easy_setopt(curl, CURLOPT_POSTFIELDS, body.c_str());\n\n}\n\nstd::string header_value = \"Authorization: token \" + token;\n\nstruct curl_slist* header_list = NULL;\n\nheader_list = curl_slist_append(header_list, header_value.c_str());\n\ncurl_easy_setopt(curl, CURLOPT_HTTPHEADER, header_list);\n\n// Write the response to a string\n\ncurl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_callback);\n\ncurl_easy_setopt(curl, CURLOPT_WRITEDATA, &response);\n\n// Write headers to map\n\ncurl_easy_setopt(curl, CURLOPT_HEADERFUNCTION, header_callback);\n\ncurl_easy_setopt(curl, CURLOPT_HEADERDATA, &headers);\n\n// Get the response code\n\ncurl_easy_setopt(curl, CURLOPT_RETURNTRANSFER, 1L);\n\ncurl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);\n\nCURLcode res = curl_easy_perform(curl);\n\ncurl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &response_code);\n\ncurl_easy_cleanup(curl);\n\ncurl_slist_free_all(header_list);\n\nreturn res;\n\n}\n\nNow, in the functions that use `curl_request`, I can access the response headers to check for rate limit information.\n\nFor example, in `create_repo`:\n\nvoid create_repo(const std::string& token, const std::string& repo_name) {\n\nstd::string url = \"https://api.github.com/user/repos\";\n\njson payload = {\n\n{\"name\", repo_name},\n\n{\"private\", false},\n\n{\"auto_init\", true}\n\n};\n\nstd::string payload_str = payload.dump();\n\nstd::string response;\n\nint response_code;\n\nstd::map<std::string, std::string> headers;\n\nCURLcode res = curl_request(\"POST\", url, payload_str, token, response, response_code, headers);\n\nif (res != CURLE_OK) {\n\nstd::cerr << \"Failed to create repository: \" << curl_easy_strerror(res) << std::endl;\n\nreturn;\n\n}\n\nif (response_code == 201) {\n\ntry {\n\njson json_response = json::parse(response);\n\nstd::cout << \"Repository created: \" << json_response[\"html_url\"] << std::endl;\n\n} catch (const json::exception& e) {\n\nstd::cerr << \"JSON parse error: \" << e.what() << std::endl;\n\n}\n\n} else if (response_code == 422) {\n\nstd::cerr << \"Repository already exists or invalid parameters.\" << std::endl;\n\n} else if (response_code == 403) {\n\nstd::cerr << \"Rate limiting or other permission issue.\" << std::endl;\n\nif (headers.count(\"X-RateLimit-Remaining\") && headers.count(\"X-RateLimit-Limit\") && headers.count(\"X-RateLimit-Reset\")) {\n\nstd::cout << \"Rate limit remaining: \" << headers[\"X-RateLimit-Remaining\"] << \"/\" << headers[\"X-RateLimit-Limit\"] << std::endl;\n\nstd::time_t reset_time = std::stol(headers[\"X-RateLimit-Reset\"]);\n\nstd::cout << \"Rate limit resets at: \" << std::ctime(&reset_time);\n\n}\n\n} else {\n\nstd::cerr << \"Failed to create repository. Status code: \" << response_code << std::endl;\n\n}\n\n}\n\nThis way, if rate limiting is encountered, the user will be informed about the remaining rate limit and when it resets.\n\nI should apply similar handling to other functions that make API requests.\n\nNow, I need to make sure that all necessary headers are included and that the libraries are linked correctly.\n\nIn CMakeLists.txt, I need to find cURL and link it to my executable.\n\nHere's a basic CMakeLists.txt:\n\ncmake_minimum_required(VERSION 3.10)\n\nproject(GitHubRepoManager)\n\nset(CMAKE_CXX_STANDARD 14)\n\nfind_package(CURL REQUIRED)\n\ninclude_directories(${CURL_INCLUDE_DIR})\n\nadd_executable(github_repo_manager main.cpp)\n\ntarget_link_libraries(github_repo_manager ${CURL_LIBRARIES})\n\nI need to make sure that nlohmann/json is included correctly. Since it's a single header library, I can just include \"json.hpp\" in main.cpp.\n\nI should download json.hpp from the nlohmann/json repository and place it in the project directory.\n\nAlternatively, I can use a package manager like vcpkg to manage dependencies, but for simplicity, I'll use the single header approach.\n\nNow, I need to test the application.\n\nFirst, I need to compile it using CMake.\n\nIn the terminal:\n\ncd github_repo_manager\n\nmkdir build\n\ncd build\n\ncmake ..\n\nmake\n\nThen, I can run the application with a personal access token and the desired operation.\n\nFor example, to create a repository:\n\n./github_repo_manager <token> create test_repo\n\nTo list repositories:\n\n./github_repo_manager <token> list\n\nTo delete a repository:\n\n./github_repo_manager <token> delete test_repo\n\nI need to make sure that the personal access token has the necessary scopes to perform these operations. For repository management, the token should have the `repo` scope.\n\nI should also consider security aspects, such as not hardcoding the token in the source code and handling it carefully when passing it as a command-line argument.\n\nAdditionally, I should ensure that the program doesn't leak sensitive information in error messages or logs.\n\nOverall, this should cover the requirements of the task.\n\n## Final Solution\nTo create a C++ application that interacts with the GitHub API to manage repositories, you'll need to handle HTTP requests using cURL and parse JSON responses with the nlohmann/json library. This guide provides a step-by-step solution to achieve this.\n\n### Prerequisites\n1. **cURL Installation**: Ensure cURL is installed on your system. For Ubuntu, use:\n   ```bash\n   sudo apt-get install libcurl4-openssl-dev\n   ```\n2. **nlohmann/json Header**: Download the single header file from [nlohmann/json](https://github.com/nlohmann/json) and include it in your project.\n\n### Project Structure\n```\ngithub_repo_manager/\n\u251c\u2500\u2500 CMakeLists.txt\n\u251c\u2500\u2500 main.cpp\n\u2514\u2500\u2500 json.hpp\n```\n\n### Implementation\n\n#### CMakeLists.txt\n```cmake\ncmake_minimum_required(VERSION 3.10)\nproject(GitHubRepoManager)\n\nset(CMAKE_CXX_STANDARD 14)\n\nfind_package(CURL REQUIRED)\ninclude_directories(${CURL_INCLUDE_DIR})\n\nadd_executable(github_repo_manager main.cpp)\ntarget_link_libraries(github_repo_manager ${CURL_LIBRARIES})\n```\n\n#### main.cpp\n```cpp\n#include <iostream>\n#include <curl/curl.h>\n#include \"json.hpp\"\n\nusing json = nlohmann::json;\n\nstd::map<std::string, std::string> headers;\n\nsize_t write_callback(char* contents, size_t size, size_t nmemb, void* userp) {\n    ((std::string*)userp)->append(contents, size * nmemb);\n    return size * nmemb;\n}\n\nsize_t header_callback(char* buffer, size_t size, size_t nmemb, std::map<std::string, std::string>* lHeaders) {\n    size_t total_size = size * nmemb;\n    std::string header(buffer, total_size);\n    size_t pos = header.find(\": \");\n    if (pos != std::string::npos) {\n        std::string key = header.substr(0, pos);\n        std::string value = header.substr(pos + 2);\n        (*lHeaders)[key] = value;\n    }\n    return total_size;\n}\n\nCURLcode curl_request(const std::string& method, const std::string& url, const std::string& body, const std::string& token, std::string& response, int& response_code, std::map<std::string, std::string>& headers) {\n    CURL* curl = curl_easy_init();\n    if (!curl) {\n        return CURLE_FAILED_INIT;\n    }\n    curl_easy_setopt(curl, CURLOPT_URL, url.c_str());\n    curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, method.c_str());\n    if (!body.empty()) {\n        curl_easy_setopt(curl, CURLOPT_POSTFIELDS, body.c_str());\n    }\n    std::string header_value = \"Authorization: token \" + token;\n    struct curl_slist* header_list = NULL;\n    header_list = curl_slist_append(header_list, header_value.c_str());\n    curl_easy_setopt(curl, CURLOPT_HTTPHEADER, header_list);\n    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_callback);\n    curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response);\n    curl_easy_setopt(curl, CURLOPT_HEADERFUNCTION, header_callback);\n    curl_easy_setopt(curl, CURLOPT_HEADERDATA, &headers);\n    curl_easy_setopt(curl, CURLOPT_RETURNTRANSFER, 1L);\n    curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);\n    CURLcode res = curl_easy_perform(curl);\n    curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &response_code);\n    curl_easy_cleanup(curl);\n    curl_slist_free_all(header_list);\n    return res;\n}\n\nstd::string get_authenticated_user(const std::string& token) {\n    std::string url = \"https://api.github.com/user\";\n    std::string response;\n    int response_code;\n    std::map<std::string, std::string> headers;\n    CURLcode res = curl_request(\"GET\", url, \"\", token, response, response_code, headers);\n    if (res != CURLE_OK) {\n        std::cerr << \"cURL error: \" << curl_easy_strerror(res) << std::endl;\n        return \"\";\n    }\n    try {\n        json json_response = json::parse(response);\n        return json_response[\"login\"];\n    } catch (const json::exception& e) {\n        std::cerr << \"JSON parse error: \" << e.what() << std::endl;\n        return \"\";\n    }\n}\n\nvoid create_repo(const std::string& token, const std::string& repo_name) {\n    std::string url = \"https://api.github.com/user/repos\";\n    json payload = {{\"name\", repo_name}, {\"private\", false}, {\"auto_init\", true}};\n    std::string payload_str = payload.dump();\n    std::string response;\n    int response_code;\n    std::map<std::string, std::string> headers;\n    CURLcode res = curl_request(\"POST\", url, payload_str, token, response, response_code, headers);\n    if (res != CURLE_OK) {\n        std::cerr << \"Failed to create repository: \" << curl_easy_strerror(res) << std::endl;\n        return;\n    }\n    if (response_code == 201) {\n        try {\n            json json_response = json::parse(response);\n            std::cout << \"Repository created: \" << json_response[\"html_url\"] << std::endl;\n        } catch (const json::exception& e) {\n            std::cerr << \"JSON parse error: \" << e.what() << std::endl;\n        }\n    } else if (response_code == 422) {\n        std::cerr << \"Repository already exists or invalid parameters.\" << std::endl;\n    } else if (response_code == 403) {\n        std::cerr << \"Rate limiting or other permission issue.\" << std::endl;\n        if (headers.count(\"X-RateLimit-Remaining\") && headers.count(\"X-RateLimit-Limit\") && headers.count(\"X-RateLimit-Reset\")) {\n            std::cout << \"Rate limit remaining: \" << headers[\"X-RateLimit-Remaining\"] << \"/\" << headers[\"X-RateLimit-Limit\"] << std::endl;\n            time_t reset_time = std::stol(headers[\"X-RateLimit-Reset\"]);\n            std::cout << \"Rate limit resets at: \" << std::ctime(&reset_time);\n        }\n    } else {\n        std::cerr << \"Failed to create repository. Status code: \" << response_code << std::endl;\n    }\n}\n\nvoid list_repos(const std::string& token, const std::string& username) {\n    std::string url = \"https://api.github.com/users/\" + username + \"/repos\";\n    std::string response;\n    int response_code;\n    std::map<std::string, std::string> headers;\n    CURLcode res = curl_request(\"GET\", url, \"\", token, response, response_code, headers);\n    if (res != CURLE_OK) {\n        std::cerr << \"Failed to list repositories: \" << curl_easy_strerror(res) << std::endl;\n        return;\n    }\n    try {\n        json json_response = json::parse(response);\n        for (const auto& repo : json_response) {\n            std::cout << repo[\"name\"] << std::endl;\n        }\n    } catch (const json::exception& e) {\n        std::cerr << \"JSON parse error: \" << e.what() << std::endl;\n    }\n}\n\nvoid delete_repo(const std::string& token, const std::string& username, const std::string& repo_name) {\n    std::string url = \"https://api.github.com/repos/\" + username + \"/\" + repo_name;\n    std::string response;\n    int response_code;\n    std::map<std::string, std::string> headers;\n    CURLcode res = curl_request(\"DELETE\", url, \"\", token, response, response_code, headers);\n    if (res != CURLE_OK) {\n        std::cerr << \"Failed to delete repository: \" << curl_easy_strerror(res) << std::endl;\n        return;\n    }\n    if (response_code == 204) {\n        std::cout << \"Repository deleted successfully.\" << std::endl;\n    } else if (response_code == 404) {\n        std::cerr << \"Repository not found.\" << std::endl;\n    } else {\n        std::cerr << \"Failed to delete repository. Status code: \" << response_code << std::endl;\n    }\n}\n\nint main(int argc, char* argv[]) {\n    if (argc < 3) {\n        std::cerr << \"Usage: \" << argv[0] << \" <token> <operation> [options]\" << std::endl;\n        return 1;\n    }\n    std::string token = argv[1];\n    std::string operation = argv[2];\n    std::string username = get_authenticated_user(token);\n    if (username.empty()) {\n        std::cerr << \"Failed to authenticate user.\" << std::endl;\n        return 1;\n    }\n    if (operation == \"create\") {\n        if (argc != 4) {\n            std::cerr << \"Usage: \" << argv[0] << \" <token> create <repo_name>\" << std::endl;\n            return 1;\n        }\n        std::string repo_name = argv[3];\n        create_repo(token, repo_name);\n    } else if (operation == \"list\") {\n        list_repos(token, username);\n    } else if (operation == \"delete\") {\n        if (argc != 4) {\n            std::cerr << \"Usage: \" << argv[0] << \" <token> delete <repo_name>\" << std::endl;\n            return 1;\n        }\n        std::string repo_name = argv[3];\n        delete_repo(token, username, repo_name);\n    } else {\n        std::cerr << \"Invalid operation. Use create, list, or delete.\" << std::endl;\n        return 1;\n    }\n    return 0;\n}\n```\n\n### Usage\n1. **Compile the application**:\n   ```bash\n   mkdir build\n   cd build\n   cmake ..\n   make\n   ```\n\n2. **Run the application**:\n   - To create a repository:\n     ```bash\n     ./github_repo_manager <token> create <repo_name>\n     ```\n   - To list repositories:\n     ```bash\n     ./github_repo_manager <token> list\n     ```\n   - To delete a repository:\n     ```bash\n     ./github_repo_manager <token> delete <repo_name>\n     ```\n\nEnsure that the personal access token has the necessary scopes, particularly the `repo` scope, for repository management operations."
    }
]