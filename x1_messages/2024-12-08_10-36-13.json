[
    {
        "role": "user",
        "content": "Create a Golang web server that serves static files from a specified directory and provides an API endpoint to search for files by their filename. The server should also support pagination, allowing clients to request a specific number of results per page."
    },
    {
        "role": "assistant",
        "content": "Alright, I've got this task to create a Golang web server that serves static files from a specified directory and also provides an API endpoint to search for files by their filename. Additionally, it should support pagination, meaning clients can request a specific number of results per page. Okay, let's break this down.\n\nFirst things first, I need to set up a basic web server in Go. Go has a built-in package called `net/http` that makes it straightforward to create web servers. So, I'll start by importing that.\n\nNext, serving static files. Go's `http` package has a function called `FileServer` which can serve files from a given file system root. So, I'll need to specify the directory from which to serve these static files. Maybe I'll take that directory path as a command-line argument so it's configurable.\n\nNow, for the API endpoint to search for files by filename. I'll need to expose a URL that accepts search queries, probably something like `/search?filename=somepartofthename&page=1&pagesize=10`. So, the endpoint will be `/search`, and it will take query parameters for the filename to search for, the page number, and the page size.\n\nI need to think about how to search for files. Since it's static files, I'll have to list all the files in the specified directory and its subdirectories, and then filter them based on the filename query. For efficiency, especially if there are many files, I might consider caching the list of files, but for simplicity, I'll start by listing them on every search request.\n\nPagination means I need to return a subset of the search results based on the page number and page size. So, if page size is 10 and page number is 1, I should return results 1 through 10. If page number is 2, results 11 through 20, and so on.\n\nI should also think about how to handle cases where the filename query doesn't match any files, or if the page requested is out of range.\n\nLet me outline the steps:\n\n1. Set up the web server to listen on a specified port, maybe default to 8080.\n\n2. Serve static files from a specified directory, accessible at the root URL.\n\n3. Implement a `/search` endpoint that accepts query parameters:\n\n- `filename`: the substring to search for in filenames.\n\n- `page`: the page number, starting from 1.\n\n- `pagesize`: the number of results per page.\n\n4. List all files in the specified directory and its subdirectories.\n\n5. Filter the files whose names contain the `filename` query.\n\n6. Calculate the total number of pages based on the `pagesize`.\n\n7. Return the appropriate slice of results based on the `page` and `pagesize`.\n\n8. Handle edge cases, such as invalid page numbers, page sizes, or no matching files.\n\nI should also consider the file paths. Should I return the full path, or just the filename, or perhaps the path relative to the serve directory?\n\nProbably, returning the relative path to the serve directory would be most useful.\n\nAlright, let's start writing some code.\n\nFirst, I'll set up the basic server:\n\n```go\npackage main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\nfunc main() {\n\t// Define command-line flags\n\tport := flag.Int(\"port\", 8080, \"Port to listen on\")\n\tdir := flag.String(\"dir\", \".\", \"Directory to serve static files from\")\n\tflag.Parse()\n\n\t// Serve static files from the specified directory\n\tfs := http.FileServer(http.Dir(*dir))\n\thttp.Handle(\"/\", fs)\n\n\t// Define the search endpoint\n\thttp.HandleFunc(\"/search\", func(w http.ResponseWriter, r *http.Request) {\n\t\t// Implement search logic here\n\t})\n\n\t// Start the server\n\tfmt.Printf(\"Starting server on port %d, serving files from %s\\n\", *port, *dir)\n\terr := http.ListenAndServe(fmt.Sprintf(\":%d\", *port), nil)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n}\n```\n\nOkay, so I've set up the server to serve static files from the specified directory and defined a `/search` endpoint where I'll implement the search logic.\n\nNow, I need to implement the search logic. First, I need to parse the query parameters: `filename`, `page`, and `pagesize`.\n\nI can use `r.URL.Query()` to get the query parameters.\n\nThen, I need to list all files in the directory and its subdirectories. For that, I can use `filepath.WalkDir` which is efficient and concise.\n\nAs I walk the directory, I'll collect all file paths that contain the `filename` substring in their basename.\n\nThen, I'll sort them or keep them in the order they're found, depending on requirements. For now, let's keep them in the order they're found.\n\nThen, based on the page and page size, I'll calculate which slice of the results to return.\n\nFinally, I'll format the results as JSON or plain text and send them back to the client.\n\nLet me think about the response format. Maybe JSON would be best, something like:\n\n```json\n{\n  \"total\": 100,\n  \"page\": 1,\n  \"pagesize\": 10,\n  \"results\": [\n    \"path/to/file1\",\n    \"path/to/file2\",\n    ...\n  ]\n}\n```\n\nSo, I'll need to count the total number of matching files and include pagination info.\n\nAlso, I should handle cases where the page number is too high or too low.\n\nLet me sketch out the search handler function:\n\n```go\nhttp.HandleFunc(\"/search\", func(w http.ResponseWriter, r *http.Request) {\n    queryParams := r.URL.Query()\n    filename := queryParams.Get(\"filename\")\n    pageStr := queryParams.Get(\"page\")\n    pagesizeStr := queryParams.Get(\"pagesize\")\n\n    // Validate and parse page and pagesize to integers\n    // List all files in the directory that contain the filename substring\n    // Apply pagination\n    // Return the results in JSON format\n})\n```\n\nI need to be careful with parsing the page and pagesize parameters. They should be positive integers, with defaults if not provided.\n\nLet's decide on default values: if `page` is not provided, assume page 1. If `pagesize` is not provided, assume 10.\n\nI'll use ` strconv.Atoi` to parse the strings to integers and handle any errors.\n\nNow, for listing all files that contain the `filename` substring, I'll walk the directory and check each file's basename.\n\nI should also consider case sensitivity. Maybe make it case-insensitive.\n\nWait, but in Go, string comparisons are case-sensitive by default. I can convert both the filename and the basename to lowercase before comparing.\n\nYes, that makes sense for a case-insensitive search.\n\nSo, in the walk function, I'll do something like:\n\n```go\nif strings.ToLower(filepath.Base(fullPath)).Contains(strings.ToLower(filename)) {\n    // add to results\n}\n```\n\nBut actually, `strings.Contains` is case-sensitive, so I need to convert both to lower case first.\n\nWait, better yet, use `strings.Contains(strings.ToLower(basename), strings.ToLower(filename))`.\n\nAlright.\n\nNow, about pagination. I need to calculate the total number of matching files, then determine how many pages there are based on the page size, and then slice the results array to return only the requested page's worth of results.\n\nI need to make sure that if the page number is higher than the total number of pages, I return an empty list or maybe return the last page.\n\nAlso, if the page number is less than 1, return an error.\n\nSimilarly, if the page size is less than 1, return an error.\n\nI should also think about how to handle very large directories with many files. Listing all files could be time-consuming and memory-intensive. Maybe implement a way to limit the depth of directory traversal or find a more efficient way.\n\nBut for now, I'll proceed with `filepath.WalkDir`.\n\nLet me try writing the search handler function step by step.\n\nFirst, parse the query parameters:\n\n```go\nfilename := queryParams.Get(\"filename\")\npageStr := queryParams.Get(\"page\")\npagesizeStr := queryParams.Get(\"pagesize\")\n```\n\nThen, parse `page` and `pagesize` to integers, with defaults:\n\n```go\npage, err := strconv.Atoi(pageStr)\nif err != nil || page < 1 {\n    page = 1\n}\n\npagesize, err := strconv.Atoi(pagesizeStr)\nif err != nil || pagesize < 1 {\n    pagesize = 10\n}\n```\n\nNow, list all files that contain the `filename` substring in their basename, case-insensitive.\n\nI'll need to collect all matching files first.\n\nDefine a slice to hold the matching file paths:\n\n```go\nvar matches []string\n```\n\nThen, use `filepath.WalkDir` to traverse the directory:\n\n```go\nerr := filepath.WalkDir(*dir, func(path string, d fs.DirEntry, err error) error {\n    if err != nil {\n        return err\n    }\n    if !d.IsDir() {\n        basename := filepath.Base(path)\n        if strings.Contains(strings.ToLower(basename), strings.ToLower(filename)) {\n            relativePath, _ := filepath.Rel(*dir, path)\n            matches = append(matches, relativePath)\n        }\n    }\n    return nil\n})\nif err != nil {\n    http.Error(w, \"Error listing files: \"+err.Error(), http.StatusInternalServerError)\n    return\n}\n```\n\nHere, I'm using `filepath.Rel` to get the path relative to the serve directory.\n\nNow, calculate the total number of pages:\n\n```go\ntotal := len(matches)\npages := (total + pagesize - 1) / pagesize // ceil division\n```\n\nThen, validate the page number:\n\n```go\nif page > pages {\n    page = pages\n}\nif page < 1 {\n    page = 1\n}\n```\n\nCalculate the offset and limit for pagination:\n\n```go\noffset := (page - 1) * pagesize\nlimit := offset + pagesize\nif offset >= total {\n    offset = total\n}\nif limit > total {\n    limit = total\n}\n```\n\nSlice the matches to get the current page's results:\n\n```go\nresults := matches[offset:limit]\n```\n\nNow, prepare the response JSON:\n\n```go\nresponse := map[string]interface{}{\n    \"total\":    total,\n    \"page\":     page,\n    \"pagesize\": pagesize,\n    \"results\":  results,\n}\njsonData, err := json.Marshal(response)\nif err != nil {\n    http.Error(w, \"Error generating response: \"+err.Error(), http.StatusInternalServerError)\n    return\n}\nw.Header().Set(\"Content-Type\", \"application/json\")\nw.Write(jsonData)\n```\n\nThat should cover the basic functionality.\n\nI should also think about performance. If the directory has a huge number of files, walking the directory every time a search is performed could be slow. Maybe caching the list of files would be beneficial, but that adds complexity, especially if files can be added or removed.\n\nFor now, I'll keep it simple and list files on every search.\n\nAnother consideration is that `filepath.WalkDir` follows symbolic links by default, which might not be desirable if there are links to other parts of the file system. I might want to set the `FollowDirLinks` option to false.\n\nAlso, I should handle cases where the directory doesn't exist or can't be accessed.\n\nLet me add some error handling for that.\n\nBefore starting the walk, check if the directory exists:\n\n```go\ndirInfo, err := os.Stat(*dir)\nif err != nil {\n    if os.IsNotExist(err) {\n        http.Error(w, \"Directory does not exist\", http.StatusNotFound)\n        return\n    }\n    http.Error(w, \"Error accessing directory: \"+err.Error(), http.StatusInternalServerError)\n    return\n}\nif !dirInfo.IsDir() {\n    http.Error(w, \"Specified path is not a directory\", http.StatusBadRequest)\n    return\n}\n```\n\nGood.\n\nAlso, I should consider the scenario where the filename is empty. Should I return all files in that case? Or treat it as a no-op?\n\nMaybe returning all files if filename is empty would make sense.\n\nWait, but that could be a lot of files. Maybe it's better to require a non-empty filename for the search.\n\nI'll add a check for that:\n\n```go\nif filename == \"\" {\n    http.Error(w, \"Filename query parameter is required\", http.StatusBadRequest)\n    return\n}\n```\n\nAlright, I think that covers the main points.\n\nLet me summarize the steps again:\n\n1. Parse query parameters: `filename`, `page`, `pagesize`.\n\n2. Validate and parse `page` and `pagesize` to integers, with defaults.\n\n3. Check if the serve directory exists and is a directory.\n\n4. Walk the directory and collect files where the basename contains the `filename` substring (case-insensitive).\n\n5. Calculate total number of matches and total pages based on page size.\n\n6. Validate the page number and calculate offset and limit for pagination.\n\n7. Slice the matches to get the current page's results.\n\n8. Prepare and send a JSON response with total count, page info, and results.\n\nI should also think about how to run this server. Probably, I'll need to provide the directory path and port as command-line arguments.\n\nIn the `main` function, I've already set up flags for `port` and `dir`. That should suffice.\n\nLet me think about potential improvements or additional features:\n\n- Allow searching in subdirectories separately.\n\n- Provide options for sorting the results.\n\n- Implement more advanced search capabilities, like regular expressions.\n\n- Cache the list of files to improve performance.\n\nBut for now, I'll keep it simple and implement the basic requirements.\n\nI should also write some tests to ensure that the search works as expected, including pagination and edge cases.\n\nBut since this is a simple implementation, I might skip formal tests for now and just do some manual testing.\n\nAlright, time to write some code.\n\n## Final Solution\nTo create a Golang web server that serves static files from a specified directory and provides an API endpoint to search for files by their filename with pagination, follow these steps:\n\n1. **Set Up the Web Server:**\n   - Use the `net/http` package to create a web server.\n   - Serve static files from a specified directory using `http.FileServer`.\n\n2. **Implement the Search Endpoint:**\n   - Create a handler for the `/search` endpoint that accepts `filename`, `page`, and `pagesize` query parameters.\n   - List all files in the specified directory and its subdirectories.\n   - Filter files based on the `filename` query parameter.\n   - Implement pagination to return a specific number of results per page.\n\n3. **Handle Pagination:**\n   - Calculate the total number of matching files and determine the number of pages based on the page size.\n   - Return the appropriate slice of results based on the requested page and page size.\n\n4. **Error Handling:**\n   - Validate and parse the `page` and `pagesize` parameters.\n   - Handle cases where the directory does not exist or is not accessible.\n   - Ensure that the filename query parameter is provided.\n\n5. **Response Format:**\n   - Return the search results in JSON format, including total counts, page information, and the list of results.\n\n### Solution Code\n\n```go\npackage main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"io/fs\"\n\t\"net/http\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"encoding/json\"\n)\n\nfunc main() {\n\t// Define command-line flags\n\tport := flag.Int(\"port\", 8080, \"Port to listen on\")\n\tdir := flag.String(\"dir\", \".\", \"Directory to serve static files from\")\n\tflag.Parse()\n\n\t// Serve static files from the specified directory\n\tfs := http.FileServer(http.Dir(*dir))\n\thttp.Handle(\"/\", fs)\n\n\t// Define the search endpoint\n\thttp.HandleFunc(\"/search\", func(w http.ResponseWriter, r *http.Request) {\n\t\tqueryParams := r.URL.Query()\n\t\tfilename := queryParams.Get(\"filename\")\n\t\tpageStr := queryParams.Get(\"page\")\n\t\tpagesizeStr := queryParams.Get(\"pagesize\")\n\n\t\tif filename == \"\" {\n\t\t\thttp.Error(w, \"Filename query parameter is required\", http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\n\t\tpage, err := strconv.Atoi(pageStr)\n\t\tif err != nil || page < 1 {\n\t\t\tpage = 1\n\t\t}\n\n\t\tpagesize, err := strconv.Atoi(pagesizeStr)\n\t\tif err != nil || pagesize < 1 {\n\t\t\tpagesize = 10\n\t\t}\n\n\t\tdirInfo, err := os.Stat(*dir)\n\t\tif err != nil {\n\t\t\tif os.IsNotExist(err) {\n\t\t\t\thttp.Error(w, \"Directory does not exist\", http.StatusNotFound)\n\t\t\t\treturn\n\t\t\t}\n\t\t\thttp.Error(w, \"Error accessing directory: \"+err.Error(), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t\tif !dirInfo.IsDir() {\n\t\t\thttp.Error(w, \"Specified path is not a directory\", http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\n\t\tvar matches []string\n\t\terr = filepath.WalkDir(*dir, func(path string, d fs.DirEntry, err error) error {\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif !d.IsDir() {\n\t\t\t\tbasename := filepath.Base(path)\n\t\t\t\tif strings.Contains(strings.ToLower(basename), strings.ToLower(filename)) {\n\t\t\t\t\trelativePath, _ := filepath.Rel(*dir, path)\n\t\t\t\t\tmatches = append(matches, relativePath)\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nil\n\t\t})\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Error listing files: \"+err.Error(), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\ttotal := len(matches)\n\t\tpages := (total + pagesize - 1) / pagesize // Ceiling division\n\n\t\tif page > pages {\n\t\t\tpage = pages\n\t\t}\n\t\tif page < 1 {\n\t\t\tpage = 1\n\t\t}\n\n\t\toffset := (page - 1) * pagesize\n\t\tlimit := offset + pagesize\n\t\tif offset >= total {\n\t\t\toffset = total\n\t\t}\n\t\tif limit > total {\n\t\t\tlimit = total\n\t\t}\n\n\t\tresults := matches[offset:limit]\n\n\t\tresponse := map[string]interface{}{\n\t\t\t\"total\":    total,\n\t\t\t\"page\":     page,\n\t\t\t\"pagesize\": pagesize,\n\t\t\t\"results\":  results,\n\t\t}\n\n\t\tjsonData, err := json.Marshal(response)\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Error generating response: \"+err.Error(), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\t\tw.Header().Set(\"Content-Type\", \"application/json\")\n\t\tw.Write(jsonData)\n\t})\n\n\t// Start the server\n\tfmt.Printf(\"Starting server on port %d, serving files from %s\\n\", *port, *dir)\n\terr := http.ListenAndServe(fmt.Sprintf(\":%d\", *port), nil)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n}\n```\n\n### Explanation\n\n1. **Web Server Setup:**\n   - The server listens on the specified port and serves static files from the specified directory.\n\n2. **Search Endpoint:**\n   - The `/search` endpoint handles GET requests with `filename`, `page`, and `pagesize` parameters.\n   - It lists all files in the directory and its subdirectories, filtering by the filename substring.\n   - Pagination is implemented to return a specific subset of results based on the page number and page size.\n\n3. **Error Handling:**\n   - Ensures the directory exists and is accessible.\n   - Validates and parses page and page size parameters.\n   - Requires the `filename` parameter to be provided.\n\n4. **Response Format:**\n   - Returns a JSON object containing total results, current page, page size, and the list of results for the requested page."
    }
]