[
    {
        "role": "user",
        "content": "Write a Python script to implement a stack data structure with push, pop, and peek operations, along with checking if the stack is empty or full.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Sure! I'd be happy to help you with that. So, you need a Python script that implements a stack data structure with the following operations: push, pop, peek, check if it's empty, and check if it's full. Right?\n\nFirst, let's understand what a stack is. A stack is a linear data structure that follows the Last In First Out (LIFO) principle, which means the last element added to the stack is the first one to be removed.\n\nIn Python, we can implement a stack using a list, where the end of the list acts as the top of the stack. This way, we can use the append() method to push elements onto the stack and the pop() method to remove elements from the stack.\n\nNow, regarding the operations:\n\n1. **Push**: Adds an element to the top of the stack.\n\n2. **Pop**: Removes the element from the top of the stack and returns it. If the stack is empty, it should handle that situation, maybe by returning None or raising an exception.\n\n3. **Peek**: Returns the element at the top of the stack without removing it. Again, if the stack is empty, handle it appropriately.\n\n4. **Is Empty**: Returns True if the stack is empty, otherwise False.\n\n5. **Is Full**: Stacks can be thought of as having unlimited capacity, but for the sake of this exercise, let's assume the stack has a fixed size. So, \"is full\" would mean the stack has reached its maximum capacity.\n\nGiven that, we need to set a maximum size for the stack. Let's say the stack can hold up to 10 elements for this example, but you can adjust that as needed.\n\nHere's how we can structure the code:\n\n- Define a class, say, `Stack`, that will represent our stack.\n\n- Initialize the stack with a fixed size in the constructor (`__init__` method).\n\n- Implement the `push` method to add elements to the stack, but only if it's not full.\n\n- Implement the `pop` method to remove and return the top element, but only if the stack is not empty.\n\n- Implement the `peek` method to return the top element without removing it, again, only if the stack is not empty.\n\n- Implement the `is_empty` method to check if the stack is empty.\n\n- Implement the `is_full` method to check if the stack is full.\n\nWe should also handle cases where someone tries to push onto a full stack or pop/from an empty stack. For simplicity, we'll just return a message indicating the stack is full or empty in those cases.\n\nLet me think about error handling. In Python, it's common to raise exceptions in such cases, but since you're asking for a simple script, maybe we can just return specific values or messages.\n\nAlright, let's sketch out the class:\n\n```python\nclass Stack:\n    def __init__(self, max_size=10):\n        self.stack = []\n        self.max_size = max_size\n\n    def push(self, item):\n        if self.is_full():\n            return \"Stack is full\"\n        else:\n            self.stack.append(item)\n\n    def pop(self):\n        if self.is_empty():\n            return \"Stack is empty\"\n        else:\n            return self.stack.pop()\n\n    def peek(self):\n        if self.is_empty():\n            return \"Stack is empty\"\n        else:\n            return self.stack[-1]\n\n    def is_empty(self):\n        return len(self.stack) == 0\n\n    def is_full(self):\n        return len(self.stack) == self.max_size\n```\n\nThis looks straightforward. Let's test this implementation with some operations.\n\nFirst, create a stack with default size:\n\n```python\ns = Stack()\n```\n\nPush some elements:\n\n```python\ns.push(1)\ns.push(2)\ns.push(3)\n```\n\nNow, peek at the top element:\n\n```python\nprint(s.peek())  # Should print 3\n```\n\nPop an element:\n\n```python\nprint(s.pop())  # Should print 3\n```\n\nPeek again:\n\n```python\nprint(s.peek())  # Should print 2\n```\n\nCheck if empty:\n\n```python\nprint(s.is_empty())  # Should print False\n```\n\nNow, let's try to push more elements until it's full:\n\n```python\nfor i in range(4, 15):\n    print(s.push(i))\n```\n\nThe first 7 pushes should succeed, and then it should start returning \"Stack is full\".\n\nWait a minute, the stack was initially having elements 1, 2, after popping 3. So, the stack has 2 elements. Then we push 4 through 14, which is 11 elements. But the stack size is 10, so after pushing 4 through 13, the stack should be full, and pushing 14 should return \"Stack is full\".\n\nLet me correct that. Initially, the stack has 2 elements (1 and 2), after pushing 3 and then popping it. So, pushing 4 through 13 would be 10 elements, making a total of 12 elements, but the stack size is 10, so pushing 11 through 13 would return \"Stack is full\".\n\nWait, no. Initial stack: [1, 2]\n\nAfter pushing 3: [1, 2, 3]\n\nAfter popping: [1, 2]\n\nThen pushing 4: [1, 2, 4]\n\nPushing 5: [1, 2, 4, 5]\n\n...\n\nUp to pushing 11: [1, 2, 4, 5, 6, 7, 8, 9, 10, 11] (10 elements)\n\nPushing 12: \"Stack is full\"\n\nPushing 13: \"Stack is full\"\n\nAnd so on.\n\nYes, that makes sense.\n\nSimilarly, if we try to pop from an empty stack, it should return \"Stack is empty\".\n\nLet me test that:\n\n```python\ns = Stack()\nprint(s.pop())  # Should print \"Stack is empty\"\nprint(s.peek())  # Should print \"Stack is empty\"\n```\n\nPerfect.\n\nAlternatively, we can raise exceptions instead of returning strings. For example, raise a `FullStackError` when trying to push to a full stack, and a `EmptyStackError` when trying to pop/from an empty stack. This might be a better approach in terms of error handling.\n\nBut since you asked for a simple script, returning strings might be sufficient for now.\n\nAnother thing to consider is ensuring that the stack doesn't exceed its maximum size. In the implementation above, the `push` method checks if the stack is full before pushing, so it should prevent the stack from exceeding its capacity.\n\nAlso, the `is_empty` and `is_full` methods simply check the length of the list against 0 and max_size, respectively, which is efficient.\n\nOne more thing: in a real-world scenario, we might want to handle different data types in the stack, but since we're using a list, it can handle any type of data. So, no issues there.\n\nIf you have any specific requirements or want to add more features, let me know, and I can adjust the implementation accordingly.\n\nBut for now, this should satisfy the requirements you've mentioned.\n\n**Final Solution**\nTo implement a stack data structure in Python with operations like push, pop, peek, and checks for empty or full stack, we can use a list where the end of the list acts as the top of the stack.\n\n## Approach\n1. **Stack Initialization**: \n   - Create a class `Stack` with a constructor to initialize the stack with a fixed size.\n   \n2. **Push Operation**:\n   - Add an element to the top of the stack if the stack is not full.\n   \n3. **Pop Operation**:\n   - Remove and return the element from the top of the stack if the stack is not empty.\n   \n4. **Peek Operation**:\n   - Return the element at the top of the stack without removing it, if the stack is not empty.\n   \n5. **Empty Check**:\n   - Return `True` if the stack is empty, otherwise `False`.\n   \n6. **Full Check**:\n   - Return `True` if the stack is full, otherwise `False`.\n\n## Solution Code\n```python\nclass Stack:\n    def __init__(self, max_size=10):\n        self.stack = []\n        self.max_size = max_size\n\n    def push(self, item):\n        if self.is_full():\n            return \"Stack is full\"\n        else:\n            self.stack.append(item)\n\n    def pop(self):\n        if self.is_empty():\n            return \"Stack is empty\"\n        else:\n            return self.stack.pop()\n\n    def peek(self):\n        if self.is_empty():\n            return \"Stack is empty\"\n        else:\n            return self.stack[-1]\n\n    def is_empty(self):\n        return len(self.stack) == 0\n\n    def is_full(self):\n        return len(self.stack) == self.max_size\n```\n\n## Explanation\n- **Initialization**: \n  - The stack is initialized as an empty list with a specified maximum size (default is 10).\n  \n- **Push Operation**: \n  - Adds an item to the top of the stack if the stack is not full. If full, returns \"Stack is full\".\n  \n- **Pop Operation**: \n  - Removes and returns the top item from the stack if the stack is not empty. If empty, returns \"Stack is empty\".\n  \n- **Peek Operation**: \n  - Returns the top item without removing it if the stack is not empty. If empty, returns \"Stack is empty\".\n  \n- **Empty Check**: \n  - Returns `True` if the stack is empty, otherwise `False`.\n  \n- **Full Check**: \n  - Returns `True` if the stack is full, otherwise `False`.\n\nThis implementation ensures that the stack does not exceed its specified maximum size and handles operations efficiently using list methods."
    }
]