[
    {
        "role": "user",
        "content": "Implement a C++ multithreaded chat server and client using sockets. The server should handle multiple clients simultaneously, broadcasting messages received from one client to all other connected clients. The client should have a simple text-based interface for sending and receiving messages.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Implementing a multithreaded chat server and client in C++ using sockets involves several steps. Below is a basic implementation to get you started.\n\n### Server Code\n\n```cpp\n#include <iostream>\n#include <string>\n#include <thread>\n#include <vector>\n#include <mutex>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nstd::vector<int> client_socks;\nstd::mutex mtx;\n\nvoid broadcast(int sender_sock, const std::string& message) {\n    mtx.lock();\n    for (int sock : client_socks) {\n        if (sock != sender_sock) {\n            send(sock, message.c_str(), message.size(), 0);\n        }\n    }\n    mtx.unlock();\n}\n\nvoid handle_client(int sock) {\n    char buffer[1024];\n    while (true) {\n        ssize_t bytes_received = recv(sock, buffer, sizeof(buffer), 0);\n        if (bytes_received <= 0) {\n            break;\n        }\n        std::string message(buffer, bytes_received);\n        broadcast(sock, message);\n    }\n    mtx.lock();\n    auto it = std::find(client_socks.begin(), client_socks.end(), sock);\n    if (it != client_socks.end()) {\n        client_socks.erase(it);\n    }\n    close(sock);\n    mtx.unlock();\n}\n\nint main() {\n    int server_sock = socket(AF_INET, SOCK_STREAM, 0);\n    if (server_sock == -1) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return 1;\n    }\n\n    struct sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(12345);\n    server_addr.sin_addr.s_addr = INADDR_ANY;\n\n    if (bind(server_sock, (struct sockaddr*)&server_addr, sizeof(server_addr)) == -1) {\n        std::cerr << \"Socket bind failed\" << std::endl;\n        close(server_sock);\n        return 1;\n    }\n\n    if (listen(server_sock, 5) == -1) {\n        std::cerr << \"Listen failed\" << std::endl;\n        close(server_sock);\n        return 1;\n    }\n\n    std::cout << \"Server listening on port 12345\" << std::endl;\n\n    while (true) {\n        struct sockaddr_in client_addr;\n        socklen_t client_len = sizeof(client_addr);\n        int client_sock = accept(server_sock, (struct sockaddr*)&client_addr, &client_len);\n        if (client_sock == -1) {\n            std::cerr << \"Accept failed\" << std::endl;\n            continue;\n        }\n\n        mtx.lock();\n        client_socks.push_back(client_sock);\n        mtx.unlock();\n\n        std::thread client_thread(handle_client, client_sock);\n        client_thread.detach();\n    }\n\n    close(server_sock);\n    return 0;\n}\n```\n\n### Client Code\n\n```cpp\n#include <iostream>\n#include <string>\n#include <thread>\n#include <sys/socket.h>\n#include <arpa/inet.h>\n#include <unistd.h>\n\nvoid receive_messages(int sock) {\n    char buffer[1024];\n    while (true) {\n        ssize_t bytes_received = recv(sock, buffer, sizeof(buffer), 0);\n        if (bytes_received <= 0) {\n            break;\n        }\n        std::string message(buffer, bytes_received);\n        std::cout << \"Received: \" << message << std::endl;\n    }\n    close(sock);\n}\n\nint main() {\n    int sock = socket(AF_INET, SOCK_STREAM, 0);\n    if (sock == -1) {\n        std::cerr << \"Socket creation failed\" << std::endl;\n        return 1;\n    }\n\n    struct sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(12345);\n    inet_pton(AF_INET, \"127.0.0.1\", &server_addr.sin_addr);\n\n    if (connect(sock, (struct sockaddr*)&server_addr, sizeof(server_addr)) == -1) {\n        std::cerr << \"Connection failed\" << std::endl;\n        close(sock);\n        return 1;\n    }\n\n    std::thread receiver(receive_messages, sock);\n    receiver.detach();\n\n    std::string line;\n    while (std::getline(std::cin, line)) {\n        send(sock, line.c_str(), line.size(), 0);\n    }\n\n    close(sock);\n    return 0;\n}\n```\n\n### Explanation\n\n- **Server Code:**\n  - Creates a socket and binds it to a port.\n  - Listens for incoming connections.\n  - Accepts connections and spawns a new thread to handle each client.\n  - Broadcasts messages received from one client to all other connected clients.\n\n- **Client Code:**\n  - Creates a socket and connects to the server.\n  - Spawns a separate thread to receive messages from the server.\n  - Sends user input to the server.\n\n### Compilation and Execution\n\n- Compile the server and client code using a C++ compiler that supports C++11 or later (e.g., `g++` with `-std=c++11` flag).\n\n- Run the server first to start listening for connections.\n\n- Run multiple client instances to connect to the server and exchange messages.\n\nThis is a basic implementation and may require enhancements for robustness, error handling, and security in a production environment."
    }
]