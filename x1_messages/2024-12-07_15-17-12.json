[
    {
        "role": "user",
        "content": "Develop a Node.js application that serves as a RESTful API for managing a simple task management system. The API should support endpoints for creating, updating, deleting, and listing tasks. Each task should have a title, description, due date, and status (completed or not). Store the tasks in a MariaDB database."
    },
    {
        "role": "assistant",
        "content": "Alright, I'm going to tackle this task of creating a RESTful API for a simple task management system using Node.js and MariaDB. I've got some experience with Node.js and databases, but I've mostly worked with MongoDB in the past, so MariaDB will be a new challenge for me.\n\nFirst things first, I need to set up my development environment. I'll need to make sure I have Node.js installed, along with npm (Node Package Manager). I also need to install MariaDB and set up a database for my tasks.\n\nLet's start by initializing a new Node.js project. I'll create a new directory for my project and run `npm init` to set up the package.json file. I can accept all the default settings for now.\n\nNext, I need to install the necessary dependencies. For a Node.js backend, Express is a popular choice for building web applications and APIs. So, I'll install Express using npm.\n\n```bash\nnpm install express\n```\n\nI also need a package to connect to MariaDB. The official MariaDB Node.js connector should do the job.\n\n```bash\nnpm install mariadb\n```\n\nNow, I need to set up my database. I'll need to install MariaDB on my machine if I haven't already. Once installed, I can create a new database for my tasks.\n\nLet's open the MariaDB command line client and create a database called \"task_manager\".\n\n```sql\nCREATE DATABASE task_manager;\n```\n\nThen, I'll need to create a table to store the tasks. Each task should have a title, description, due date, and status. I'll also need a unique identifier for each task.\n\nHere's a possible schema for the tasks table:\n\n```sql\nCREATE TABLE tasks (\n  id INT AUTO_INCREMENT PRIMARY KEY,\n  title VARCHAR(255) NOT NULL,\n  description TEXT,\n  due_date DATE,\n  status VARCHAR(50) DEFAULT 'not completed'\n);\n```\n\nI can execute this SQL statement in the MariaDB client to create the table.\n\nNow, moving on to the Node.js application. I'll set up an Express server that can connect to the MariaDB database and handle CRUD operations for tasks.\n\nFirst, I'll create a new JavaScript file, say \"app.js\", and set up the basic Express server.\n\n```javascript\nconst express = require('express');\nconst app = express();\nconst port = 3000;\n\napp.get('/', (req, res) => {\n  res.send('Task Manager API');\n});\n\napp.listen(port, () => {\n  console.log(`Server running at http://localhost:${port}/`);\n});\n```\n\nThis is a minimal Express server that listens on port 3000 and responds with \"Task Manager API\" for the root URL.\n\nNext, I need to set up the connection to the MariaDB database. I'll use the mariadb package to create a connection pool.\n\nFirst, I'll require the mariadb package and set up the pool.\n\n```javascript\nconst mariadb = require('mariadb');\n\nconst pool = mariadb.createPool({\n  host: 'localhost',\n  user: 'your_username',\n  password: 'your_password',\n  database: 'task_manager'\n});\n```\n\nMake sure to replace 'your_username' and 'your_password' with your actual MariaDB credentials.\n\nNow, I need to create endpoints for creating, updating, deleting, and listing tasks.\n\nLet's start with getting all tasks. I'll create a GET endpoint at /tasks that retrieves all tasks from the database.\n\n```javascript\napp.get('/tasks', async (req, res) => {\n  try {\n    const connection = await pool.getConnection();\n    const rows = await connection.query('SELECT * FROM tasks');\n    res.json(rows);\n  } catch (error) {\n    res.status(500).send('Server error');\n  }\n});\n```\n\nThis endpoint connects to the database, executes a SELECT query to get all tasks, and sends the results as JSON.\n\nNext, I'll create an endpoint to get a single task by its ID.\n\n```javascript\napp.get('/tasks/:id', async (req, res) => {\n  const taskId = req.params.id;\n  try {\n    const connection = await pool.getConnection();\n    const row = await connection.query('SELECT * FROM tasks WHERE id = ?', [taskId]);\n    if (row.length === 0) {\n      res.status(404).send('Task not found');\n    } else {\n      res.json(row[0]);\n    }\n  } catch (error) {\n    res.status(500).send('Server error');\n  }\n});\n```\n\nThis endpoint takes the task ID from the URL parameters, queries the database for that specific task, and returns it if found.\n\nNow, let's create an endpoint to create a new task. I'll use the POST method for this.\n\n```javascript\napp.post('/tasks', async (req, res) => {\n  const { title, description, due_date, status } = req.body;\n  if (!title) {\n    return res.status(400).send('Title is required');\n  }\n  try {\n    const connection = await pool.getConnection();\n    const result = await connection.query('INSERT INTO tasks (title, description, due_date, status) VALUES (?, ?, ?, ?)', [title, description, due_date, status]);\n    res.status(201).json({ id: result.insertId, title, description, due_date, status });\n  } catch (error) {\n    res.status(500).send('Server error');\n  }\n});\n```\n\nThis endpoint expects a JSON body with task details. It inserts a new row into the tasks table and returns the newly created task with its ID.\n\nNext, I'll create an endpoint to update an existing task.\n\n```javascript\napp.put('/tasks/:id', async (req, res) => {\n  const taskId = req.params.id;\n  const { title, description, due_date, status } = req.body;\n  if (!title) {\n    return res.status(400).send('Title is required');\n  }\n  try {\n    const connection = await pool.getConnection();\n    const result = await connection.query('UPDATE tasks SET title = ?, description = ?, due_date = ?, status = ? WHERE id = ?', [title, description, due_date, status, taskId]);\n    if (result.affectedRows === 0) {\n      res.status(404).send('Task not found');\n    } else {\n      res.json({ id: taskId, title, description, due_date, status });\n    }\n  } catch (error) {\n    res.status(500).send('Server error');\n  }\n});\n```\n\nThis endpoint updates an existing task based on the provided ID and returns the updated task details.\n\nFinally, I'll create an endpoint to delete a task.\n\n```javascript\napp.delete('/tasks/:id', async (req, res) => {\n  const taskId = req.params.id;\n  try {\n    const connection = await pool.getConnection();\n    const result = await connection.query('DELETE FROM tasks WHERE id = ?', [taskId]);\n    if (result.affectedRows === 0) {\n      res.status(404).send('Task not found');\n    } else {\n      res.status(204).send();\n    }\n  } catch (error) {\n    res.status(500).send('Server error');\n  }\n});\n```\n\nThis endpoint deletes a task by its ID and returns a 204 No Content status if successful.\n\nAlright, so now I have all the basic CRUD endpoints set up. Let's think about how to test this API. I can use tools like Postman or insomnia to send HTTP requests to my server and see if it's working as expected.\n\nFirst, I'll start my server by running `node app.js` in my terminal. Then, I can use Postman to send a GET request to http://localhost:3000/tasks to see if it returns an empty array, since there are no tasks yet.\n\nNext, I'll send a POST request to http://localhost:3000/tasks with a JSON body containing task details, like:\n\n```json\n{\n  \"title\": \"Buy groceries\",\n  \"description\": \"Milk, eggs, bread\",\n  \"due_date\": \"2023-10-30\",\n  \"status\": \"not completed\"\n}\n```\n\nI should receive a 201 Created response with the task details including the generated ID.\n\nThen, I can send another GET request to http://localhost:3000/tasks and see if the new task is listed.\n\nI can also test updating the task by sending a PUT request to http://localhost:3000/tasks/{id} with updated task details and check if it's updated correctly.\n\nSimilarly, I can test deleting a task by sending a DELETE request to http://localhost:3000/tasks/{id} and verify if it's removed from the list.\n\nSo, that's the basic functionality covered. However, there are a few improvements and considerations I should think about.\n\nFirst, error handling can be enhanced. For example, I should handle cases where the database is not reachable or if there are errors in the SQL queries.\n\nSecond, I should validate the input data more thoroughly. For instance, ensure that the due_date is in the correct format and that the status is either 'completed' or 'not completed'.\n\nThird, I might want to add more features, like filtering tasks based on status or due date, or sorting tasks.\n\nFourth, for a production-ready application, I should consider using environment variables to store sensitive information like database credentials, instead of hardcoding them.\n\nFifth, I should think about implementing user authentication and authorization, especially if multiple users will be using the task management system.\n\nSixth, I might want to add middleware for logging, caching, or rate limiting.\n\nSeventh, I should ensure that the API is secure, protecting against common web vulnerabilities like SQL injection, XSS, etc.\n\nWait a minute, I think I need to make sure that my code is safe from SQL injection attacks. Since I'm using parameterized queries with the mariadb package, it should be safe, but I need to double-check.\n\nLooking at the documentation, it seems that using placeholders (?) and providing an array of values helps prevent SQL injection. So, that's good.\n\nBut just to be safe, I should avoid concatenating user input directly into SQL queries.\n\nAlright, moving on.\n\nI should also consider implementing pagination for the list of tasks, especially if there are a large number of tasks.\n\nAnother thing is that right now, the server runs on localhost on port 3000. If I want to deploy this to a production server, I need to configure it to use environment variables for the port and database credentials.\n\nI can use the `process.env` object to read environment variables.\n\nFor example:\n\n```javascript\nconst port = process.env.PORT || 3000;\n```\n\nSimilarly for database credentials:\n\n```javascript\nconst pool = mariadb.createPool({\n  host: process.env.DB_HOST || 'localhost',\n  user: process.env.DB_USER || 'your_username',\n  password: process.env.DB_PASSWORD || 'your_password',\n  database: process.env.DB_NAME || 'task_manager'\n});\n```\n\nThis way, I can set these environment variables on the server where the application is deployed.\n\nAlso, I should avoid committing sensitive information like passwords to version control. So, I need to make sure that my `.gitignore` file includes any files that contain sensitive data.\n\nSpeaking of version control, I should set up a git repository for this project and commit my changes regularly.\n\nAlright, let's think about how to structure the project. Right now, everything is in a single file, \"app.js\". As the project grows, this can become unwieldy. So, I should consider splitting the code into multiple files and using modules.\n\nFor example, I can create a \"db.js\" file to handle the database connection, a \"routes\" directory to store route handlers, and maybe a \"models\" directory to define the task model.\n\nLet me try to refactor the code accordingly.\n\nFirst, create a \"db.js\" file:\n\n```javascript\nconst mariadb = require('mariadb');\n\nconst pool = mariadb.createPool({\n  host: process.env.DB_HOST || 'localhost',\n  user: process.env.DB_USER || 'your_username',\n  password: process.env.DB_PASSWORD || 'your_password',\n  database: process.env.DB_NAME || 'task_manager'\n});\n\nmodule.exports = pool;\n```\n\nThen, in \"app.js\", I can require this pool:\n\n```javascript\nconst express = require('express');\nconst pool = require('./db');\nconst app = express();\nconst port = process.env.PORT || 3000;\n\napp.use(express.json());\n\napp.get('/', (req, res) => {\n  res.send('Task Manager API');\n});\n\napp.get('/tasks', async (req, res) => {\n  try {\n    const rows = await pool.query('SELECT * FROM tasks');\n    res.json(rows);\n  } catch (error) {\n    res.status(500).send('Server error');\n  }\n});\n\n// Other endpoints...\n\napp.listen(port, () => {\n  console.log(`Server running at http://localhost:${port}/`);\n});\n```\n\nThis is a bit cleaner. Now, let's create a \"routes\" directory and move the task-related routes to a separate file, say \"taskRoutes.js\".\n\nCreate \"routes/taskRoutes.js\":\n\n```javascript\nconst express = require('express');\nconst router = express.Router();\nconst pool = require('../db');\n\nrouter.get('/', async (req, res) => {\n  try {\n    const rows = await pool.query('SELECT * FROM tasks');\n    res.json(rows);\n  } catch (error) {\n    res.status(500).send('Server error');\n  }\n});\n\nrouter.get('/:id', async (req, res) => {\n  const taskId = req.params.id;\n  try {\n    const row = await pool.query('SELECT * FROM tasks WHERE id = ?', [taskId]);\n    if (row.length === 0) {\n      res.status(404).send('Task not found');\n    } else {\n      res.json(row[0]);\n    }\n  } catch (error) {\n    res.status(500).send('Server error');\n  }\n});\n\nrouter.post('/', async (req, res) => {\n  const { title, description, due_date, status } = req.body;\n  if (!title) {\n    return res.status(400).send('Title is required');\n  }\n  try {\n    const result = await pool.query('INSERT INTO tasks (title, description, due_date, status) VALUES (?, ?, ?, ?)', [title, description, due_date, status]);\n    res.status(201).json({ id: result.insertId, title, description, due_date, status });\n  } catch (error) {\n    res.status(500).send('Server error');\n  }\n});\n\nrouter.put('/:id', async (req, res) => {\n  const taskId = req.params.id;\n  const { title, description, due_date, status } = req.body;\n  if (!title) {\n    return res.status(400).send('Title is required');\n  }\n  try {\n    const result = await pool.query('UPDATE tasks SET title = ?, description = ?, due_date = ?, status = ? WHERE id = ?', [title, description, due_date, status, taskId]);\n    if (result.affectedRows === 0) {\n      res.status(404).send('Task not found');\n    } else {\n      res.json({ id: taskId, title, description, due_date, status });\n    }\n  } catch (error) {\n    res.status(500).send('Server error');\n  }\n});\n\nrouter.delete('/:id', async (req, res) => {\n  const taskId = req.params.id;\n  try {\n    const result = await pool.query('DELETE FROM tasks WHERE id = ?', [taskId]);\n    if (result.affectedRows === 0) {\n      res.status(404).send('Task not found');\n    } else {\n      res.status(204).send();\n    }\n  } catch (error) {\n    res.status(500).send('Server error');\n  }\n});\n\nmodule.exports = router;\n```\n\nThen, in \"app.js\", I can use this router:\n\n```javascript\nconst express = require('express');\nconst pool = require('./db');\nconst taskRoutes = require('./routes/taskRoutes');\nconst app = express();\nconst port = process.env.PORT || 3000;\n\napp.use(express.json());\n\napp.use('/', taskRoutes);\n\napp.listen(port, () => {\n  console.log(`Server running at http://localhost:${port}/`);\n});\n```\n\nThis is better organized. Now, if I need to add more routes in the future, I can create separate files for them.\n\nAnother improvement could be to create a \"models\" directory to handle the interaction with the database. For example, I can create a \"taskModel.js\" file that defines functions for CRUD operations on tasks.\n\nThis can help separate the concerns and make the code more modular.\n\nCreate \"models/taskModel.js\":\n\n```javascript\nconst pool = require('../db');\n\nasync function getTasks() {\n  const rows = await pool.query('SELECT * FROM tasks');\n  return rows;\n}\n\nasync function getTaskById(id) {\n  const rows = await pool.query('SELECT * FROM tasks WHERE id = ?', [id]);\n  return rows[0];\n}\n\nasync function createTask(task) {\n  const result = await pool.query('INSERT INTO tasks (title, description, due_date, status) VALUES (?, ?, ?, ?)', [task.title, task.description, task.due_date, task.status]);\n  return { id: result.insertId, ...task };\n}\n\nasync function updateTask(id, task) {\n  const result = await pool.query('UPDATE tasks SET title = ?, description = ?, due_date = ?, status = ? WHERE id = ?', [task.title, task.description, task.due_date, task.status, id]);\n  return result.affectedRows > 0 ? { id, ...task } : null;\n}\n\nasync function deleteTask(id) {\n  const result = await pool.query('DELETE FROM tasks WHERE id = ?', [id]);\n  return result.affectedRows > 0;\n}\n\nmodule.exports = {\n  getTasks,\n  getTaskById,\n  createTask,\n  updateTask,\n  deleteTask\n};\n```\n\nNow, in \"routes/taskRoutes.js\", I can use these functions:\n\n```javascript\nconst express = require('express');\nconst router = express.Router();\nconst taskModel = require('../models/taskModel');\n\nrouter.get('/', async (req, res) => {\n  try {\n    const tasks = await taskModel.getTasks();\n    res.json(tasks);\n  } catch (error) {\n    res.status(500).send('Server error');\n  }\n});\n\nrouter.get('/:id', async (req, res) => {\n  const taskId = req.params.id;\n  try {\n    const task = await taskModel.getTaskById(taskId);\n    if (!task) {\n      res.status(404).send('Task not found');\n    } else {\n      res.json(task);\n    }\n  } catch (error) {\n    res.status(500).send('Server error');\n  }\n});\n\nrouter.post('/', async (req, res) => {\n  const { title, description, due_date, status } = req.body;\n  if (!title) {\n    return res.status(400).send('Title is required');\n  }\n  try {\n    const task = await taskModel.createTask({ title, description, due_date, status });\n    res.status(201).json(task);\n  } catch (error) {\n    res.status(500).send('Server error');\n  }\n});\n\nrouter.put('/:id', async (req, res) => {\n  const taskId = req.params.id;\n  const { title, description, due_date, status } = req.body;\n  if (!title) {\n    return res.status(400).send('Title is required');\n  }\n  try {\n    const task = await taskModel.updateTask(taskId, { title, description, due_date, status });\n    if (!task) {\n      res.status(404).send('Task not found');\n    } else {\n      res.json(task);\n    }\n  } catch (error) {\n    res.status(500).send('Server error');\n  }\n});\n\nrouter.delete('/:id', async (req, res) => {\n  const taskId = req.params.id;\n  try {\n    const deleted = await taskModel.deleteTask(taskId);\n    if (!deleted) {\n      res.status(404).send('Task not found');\n    } else {\n      res.status(204).send();\n    }\n  } catch (error) {\n    res.status(500).send('Server error');\n  }\n});\n\nmodule.exports = router;\n```\n\nThis separation makes the code cleaner and more maintainable.\n\nI should also think about adding middleware for logging requests, handling errors, and parsing JSON bodies.\n\nFor example, I can use the built-in express.json() middleware to parse JSON request bodies.\n\nI've already used it in \"app.js\":\n\n```javascript\napp.use(express.json());\n```\n\nI can also add a logger middleware to log incoming requests.\n\nHere's a simple logger function:\n\n```javascript\nfunction logger(req, res, next) {\n  console.log(`${req.method} ${req.url}`);\n  next();\n}\n\napp.use(logger);\n```\n\nThis will log the HTTP method and URL for each request.\n\nAdditionally, I can create a custom error handler middleware to handle errors in a centralized way.\n\n```javascript\napp.use((err, req, res, next) => {\n  console.error(err.stack);\n  res.status(500).send('Something broke!');\n});\n```\n\nThis middleware will catch any errors that occur in the request handling process and send a generic error message to the client.\n\nHowever, in a production environment, I should be more careful about what error information is sent to the client.\n\nNow, regarding the database schema, I have a simple tasks table with id, title, description, due_date, and status columns.\n\nI might want to add more features in the future, like associating tasks with users or adding categories.\n\nBut for now, this simple schema should suffice.\n\nI should also consider adding validation for the due_date field to ensure it's in the correct format and is a valid date.\n\nIn the current implementation, the database will handle the date validation since the due_date column is of type DATE.\n\nBut in the API, I should ensure that the provided due_date is in the correct format before sending it to the database.\n\nI can use libraries like moment.js or day.js to parse and validate dates.\n\nHowever, for simplicity, I'll assume that the client sends the due_date in the correct format (YYYY-MM-DD).\n\nIf needed, I can add more robust date validation later.\n\nAnother consideration is that the status field is a string that can be either 'completed' or 'not completed'.\n\nI might want to enforce this in the database by using an ENUM type.\n\nIn MariaDB, I can define the status column as ENUM('completed', 'not completed').\n\nThis way, only these two values are allowed.\n\nLet me modify the table schema accordingly.\n\nFirst, I need to alter the existing table to change the status column.\n\nHere's the altered SQL statement:\n\n```sql\nALTER TABLE tasks MODIFY COLUMN status ENUM('completed', 'not completed') DEFAULT 'not completed';\n```\n\nI can execute this statement in the MariaDB client.\n\nThis ensures that only 'completed' or 'not completed' are allowed in the status column.\n\nBack to the API, I should also validate that the status provided in the request body is one of these two values.\n\nIn the createTask and updateTask functions in \"models/taskModel.js\", I can add checks for the status value.\n\nFor example:\n\n```javascript\nif (task.status !== 'completed' && task.status !== 'not completed') {\n  throw new Error('Invalid status');\n}\n```\n\nThis way, I can prevent invalid status values from being stored in the database.\n\nSimilarly, I can add validation for other fields as needed.\n\nNow, let's think about testing the API.\n\nAs I mentioned earlier, I can use tools like Postman or insomnia to send HTTP requests and verify the responses.\n\nBut for more comprehensive testing, I should consider writing automated tests.\n\nI can use a testing framework like Jest along with Supertest to write integration tests for my API.\n\nThis would involve starting the server, making HTTP requests, and asserting that the responses are as expected.\n\nI can write tests for each endpoint, covering both success and error scenarios.\n\nFor example, testing that creating a task with a missing title returns a 400 Bad Request, or testing that updating a non-existing task returns a 404 Not Found.\n\nImplementing tests will help ensure that the API behaves correctly and allow me to catch regressions if I make changes in the future.\n\nAdditionally, I can consider implementing unit tests for individual functions in the model layer to verify their behavior in isolation.\n\nThis would involve mocking the database queries and asserting that the functions interact with the database correctly.\n\nNow, thinking about deployment, I need to consider where and how to host this API.\n\nI can choose to deploy it on a cloud platform like AWS, Google Cloud, or Heroku.\n\nAlternatively, I can set it up on a VPS (Virtual Private Server) like DigitalOcean or AWS EC2.\n\nI need to make sure that the server has Node.js and MariaDB installed, or use a Docker container to package the application and its dependencies.\n\nI should also set up environment variables for database credentials and other configuration options.\n\nFurthermore, I need to configure a reverse proxy like Nginx to handle incoming requests and forward them to the Node.js server.\n\nI should also think about setting up SSL/TLS for secure HTTPS connections.\n\nLoad balancing and scaling may be considerations if the API is expected to handle a large number of requests.\n\nBut for now, since this is a simple task management system, a single server should suffice.\n\nI should also set up monitoring and logging to keep track of the API's performance and any errors that occur.\n\nTools like Prometheus and Grafana can be used for monitoring, and Logstash or ELK Stack for logging.\n\nBut for a small-scale application, the default Node.js logging and some basic monitoring should be adequate.\n\nLastly, I should consider writing documentation for the API, detailing the available endpoints, request formats, and response formats.\n\nI can use tools like Swagger or OpenAPI to generate interactive API documentation.\n\nThis will make it easier for other developers (or myself in the future) to understand and use the API.\n\nIn summary, I've developed a RESTful API for a simple task management system using Node.js and MariaDB.\n\nI've set up the database, created the necessary tables, and implemented CRUD endpoints.\n\nI've also considered improvements such as better error handling, input validation, and code organization.\n\nAdditionally, I've thought about testing, deployment, and documentation for the API.\n\nThis project has been a good exercise in building a backend application with Node.js and MariaDB, and I've learned more about working with relational databases in a Node.js environment.\n\n## Final Solution\nTo create a RESTful API for a simple task management system using Node.js and MariaDB, follow these steps:\n\n### Prerequisites\n1. **Node.js and npm**: Ensure you have Node.js and npm installed.\n2. **MariaDB**: Install and set up MariaDB on your machine.\n\n### Project Setup\n\n1. **Initialize Node.js project**:\n    ```bash\n    mkdir task_manager\n    cd task_manager\n    npm init -y\n    ```\n\n2. **Install dependencies**:\n    ```bash\n    npm install express mariadb\n    ```\n\n3. **Set up MariaDB**:\n    - Start the MariaDB server.\n    - Create a database named `task_manager`:\n      ```sql\n      CREATE DATABASE task_manager;\n      ```\n    - Create a table named `tasks`:\n      ```sql\n      CREATE TABLE tasks (\n        id INT AUTO_INCREMENT PRIMARY KEY,\n        title VARCHAR(255) NOT NULL,\n        description TEXT,\n        due_date DATE,\n        status ENUM('completed', 'not completed') DEFAULT 'not completed'\n      );\n      ```\n\n### Application Code\n\n1. **Database Connection (`db.js`)**:\n    ```javascript\n    const mariadb = require('mariadb');\n\n    const pool = mariadb.createPool({\n      host: process.env.DB_HOST || 'localhost',\n      user: process.env.DB_USER || 'your_username',\n      password: process.env.DB_PASSWORD || 'your_password',\n      database: process.env.DB_NAME || 'task_manager'\n    });\n\n    module.exports = pool;\n    ```\n\n2. **Task Model (`models/taskModel.js`)**:\n    ```javascript\n    const pool = require('../db');\n\n    async function getTasks() {\n      const rows = await pool.query('SELECT * FROM tasks');\n      return rows;\n    }\n\n    async function getTaskById(id) {\n      const rows = await pool.query('SELECT * FROM tasks WHERE id = ?', [id]);\n      return rows[0];\n    }\n\n    async function createTask(task) {\n      const result = await pool.query('INSERT INTO tasks (title, description, due_date, status) VALUES (?, ?, ?, ?)', [task.title, task.description, task.due_date, task.status]);\n      return { id: result.insertId, ...task };\n    }\n\n    async function updateTask(id, task) {\n      const result = await pool.query('UPDATE tasks SET title = ?, description = ?, due_date = ?, status = ? WHERE id = ?', [task.title, task.description, task.due_date, task.status, id]);\n      return result.affectedRows > 0 ? { id, ...task } : null;\n    }\n\n    async function deleteTask(id) {\n      const result = await pool.query('DELETE FROM tasks WHERE id = ?', [id]);\n      return result.affectedRows > 0;\n    }\n\n    module.exports = {\n      getTasks,\n      getTaskById,\n      createTask,\n      updateTask,\n      deleteTask\n    };\n    ```\n\n3. **Task Routes (`routes/taskRoutes.js`)**:\n    ```javascript\n    const express = require('express');\n    const router = express.Router();\n    const taskModel = require('../models/taskModel');\n\n    router.get('/', async (req, res) => {\n      try {\n        const tasks = await taskModel.getTasks();\n        res.json(tasks);\n      } catch (error) {\n        res.status(500).send('Server error');\n      }\n    });\n\n    router.get('/:id', async (req, res) => {\n      const taskId = req.params.id;\n      try {\n        const task = await taskModel.getTaskById(taskId);\n        if (!task) {\n          res.status(404).send('Task not found');\n        } else {\n          res.json(task);\n        }\n      } catch (error) {\n        res.status(500).send('Server error');\n      }\n    });\n\n    router.post('/', async (req, res) => {\n      const { title, description, due_date, status } = req.body;\n      if (!title) {\n        return res.status(400).send('Title is required');\n      }\n      try {\n        const task = await taskModel.createTask({ title, description, due_date, status });\n        res.status(201).json(task);\n      } catch (error) {\n        res.status(500).send('Server error');\n      }\n    });\n\n    router.put('/:id', async (req, res) => {\n      const taskId = req.params.id;\n      const { title, description, due_date, status } = req.body;\n      if (!title) {\n        return res.status(400).send('Title is required');\n      }\n      try {\n        const task = await taskModel.updateTask(taskId, { title, description, due_date, status });\n        if (!task) {\n          res.status(404).send('Task not found');\n        } else {\n          res.json(task);\n        }\n      } catch (error) {\n        res.status(500).send('Server error');\n      }\n    });\n\n    router.delete('/:id', async (req, res) => {\n      const taskId = req.params.id;\n      try {\n        const deleted = await taskModel.deleteTask(taskId);\n        if (!deleted) {\n          res.status(404).send('Task not found');\n        } else {\n          res.status(204).send();\n        }\n      } catch (error) {\n        res.status(500).send('Server error');\n      }\n    });\n\n    module.exports = router;\n    ```\n\n4. **Main Application File (`app.js`)**:\n    ```javascript\n    const express = require('express');\n    const pool = require('./db');\n    const taskRoutes = require('./routes/taskRoutes');\n    const app = express();\n    const port = process.env.PORT || 3000;\n\n    app.use(express.json());\n\n    app.use('/', taskRoutes);\n\n    app.listen(port, () => {\n      console.log(`Server running at http://localhost:${port}/`);\n    });\n    ```\n\n### Running the Application\n\n1. **Start the server**:\n    ```bash\n    node app.js\n    ```\n\n2. **Test the API** using tools like Postman or insomnia:\n    - **GET** `http://localhost:3000/tasks` to list all tasks.\n    - **GET** `http://localhost:3000/tasks/:id` to get a specific task.\n    - **POST** `http://localhost:3000/tasks` to create a new task.\n    - **PUT** `http://localhost:3000/tasks/:id` to update a task.\n    - **DELETE** `http://localhost:3000/tasks/:id` to delete a task.\n\n### Enhancements\n\n- **Environment Variables**: Use environment variables for configurations.\n- **Input Validation**: Add more robust validation for request bodies.\n- **Authentication**: Implement user authentication and authorization.\n- **Testing**: Write tests using Jest and Supertest.\n- **Documentation**: Document the API using Swagger or OpenAPI.\n\nThis setup provides a foundational RESTful API for managing tasks with Node.js and MariaDB, which can be expanded based on further requirements."
    }
]