[
    {
        "role": "user",
        "content": "Create a GoLang server that accepts JSON payloads via HTTP POST requests and stores them into a local file. If the file reaches a certain size (e.g., 10MB), it should automatically create a new file to store subsequent data."
    },
    {
        "role": "assistant",
        "content": "Alright, I'm going to try to create a GoLang server that does what you're asking for. So, the server needs to accept JSON payloads via HTTP POST requests and store them into a local file. Also, if that file reaches a certain size, say 10MB, it should create a new file for further data. Okay, let's break this down.\n\nFirst, I need to set up a basic HTTP server in Go. I know that Go has a built-in package for HTTP called \"net/http\". So, I'll need to import that. Then, I need to define a handler for POST requests.\n\nFor handling JSON payloads, I'll need to read the request body and parse the JSON. Go has the \"encoding/json\" package for that.\n\nStoring the data into a local file will require using the \"os\" package to create and write to files. Also, to manage file sizes, I'll need to check the size of the file before writing to it. If it's about to exceed 10MB, I'll create a new file.\n\nLet me think about the file naming convention. Maybe I can name them sequentially, like data1.json, data2.json, and so on.\n\nAlright, let's start by setting up the basic server structure.\n\n```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"os\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/submit\", handlePost)\n\thttp.ListenAndServe(\":8080\", nil)\n}\n```\n\nSo, this sets up a server listening on port 8080 and routes POST requests to \"/submit\" to the handlePost function.\n\nNow, I need to implement the handlePost function. It should read the JSON payload from the request, and then write it to a file. But first, it needs to check if the current file is about to exceed 10MB. If it is, create a new file.\n\nI need to keep track of the current file being used. Maybe I can have a global variable that holds the current file pointer and the current file's size.\n\nWait, but using global variables might not be the best approach, especially in a multi-request scenario. Maybe I should manage the file handling within the function, perhaps by checking the file size before writing.\n\nLet me think differently. I can have a function that returns the current file to write to. This function can check the size of the file, and if it's about to exceed 10MB, it can create a new file and return that.\n\nI need to make sure that file operations are thread-safe since multiple requests might come in at the same time.\n\nMaybe I can use a mutex to synchronize access to the file.\n\nAlso, I need to decide how to name the files. Perhaps based on a counter or based on timestamps.\n\nLet me sketch a rough plan:\n\n1. Define a function that returns the current file to write to.\n\n2. This function checks if the current file exists and its size.\n\n3. If the size is about to exceed 10MB, create a new file with a new name.\n\n4. Write the JSON payload to the current file.\n\n5. Update the file size.\n\nI need to handle file naming in a way that avoids overwriting existing files.\n\nMaybe I can name the files as data_1.json, data_2.json, and so on, incrementing the counter each time a new file is created.\n\nTo manage the file counter, I need a persistent way to store the current file number. But since this is a simple server, maybe I can keep the counter in memory and reset it when the server restarts.\n\nWait, but if the server restarts, the counter will reset, and it might overwrite files. That's not good.\n\nAlternatively, I can read the highest file number from the existing files in a directory when the server starts.\n\nSo, at server startup, scan a directory for files matching the pattern data_*.json, find the highest number, and start from there.\n\nThat sounds better.\n\nLet me think about error handling. What if there's an issue writing to the file? I should return an appropriate HTTP status code.\n\nAlso, what if the JSON parsing fails? I should return an error to the client.\n\nAlright, let's start implementing this step by step.\n\nFirst, I need to create a directory to store the files. Let's say \"/var/data\" or something like that. But for simplicity, maybe I can store them in the current directory.\n\nWait, but hardcoding paths is not good. Maybe I can make the path configurable, perhaps via an environment variable.\n\nLet's assume there's an environment variable DATA_DIR that specifies where to store the files.\n\nI need to make sure that the directory exists; if not, create it.\n\nThen, at server startup, scan the directory for files named data_*.json, find the highest number, and set the current file number to that plus one.\n\nWait, but if there are existing files, I don't want to overwrite them.\n\nSo, for example, if there are files data_1.json, data_2.json, and data_3.json, the next file should be data_4.json.\n\nI need to implement a function that finds the highest file number in the directory.\n\nLet me write a function for that.\n\n```go\nfunc getCurrentFileNumber(dir string) (int, error) {\n\tfiles, err := ioutil.ReadDir(dir)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tmaxNum := 0\n\tfor _, file := range files {\n\t\tmatch, num := isDataFile(file.Name())\n\t\tif match && num > maxNum {\n\t\t\tmaxNum = num\n\t\t}\n\t}\n\treturn maxNum + 1, nil\n}\n\nfunc isDataFile(filename string) (bool, int) {\n\tre := regexp.MustCompile(`data_(\\d+)\\.json`)\n\tmatches := re.FindStringSubmatch(filename)\n\tif len(matches) == 2 {\n\t\tnum, err := strconv.Atoi(matches[1])\n\t\tif err != nil {\n\t\t\treturn false, 0\n\t\t}\n\t\treturn true, num\n\t}\n\treturn false, 0\n}\n```\n\nI need to import \"regexp\" and \"strconv\" for this.\n\nSo, this function reads the directory, looks for files matching the pattern data_<number>.json, extracts the numbers, finds the highest one, and returns the next number.\n\nThat should work.\n\nNow, I need to have a global variable to store the current file number and the current file being used.\n\nBut as I thought earlier, using global variables in a multi-request scenario might lead to race conditions.\n\nAlternatively, I can manage the file within the handlePost function, opening and closing the file for each request.\n\nBut that might be inefficient.\n\nMaybe a better approach is to have a pool of files or manage file access with a mutex.\n\nWait, perhaps I can have a single file being used at a time, and when it reaches 10MB, switch to a new one.\n\nBut with multiple concurrent requests, I need to ensure that writes are synchronized.\n\nMaybe I can have a mutex that locks the file access while writing.\n\nLet me try to define a struct to hold the current file and a mutex.\n\n```go\ntype FileHandler struct {\n\tmu       sync.Mutex\n\tcurrentFile *os.File\n\tfileNumber int\n\tmaxFileSize int64\n}\n\nfunc NewFileHandler(dir string, maxFileSize int64) (*FileHandler, error) {\n\terr := os.MkdirAll(dir, os.ModePerm)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfileNumber, err := getCurrentFileNumber(dir)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfilename := filepath.Join(dir, fmt.Sprintf(\"data_%d.json\", fileNumber))\n\tfile, err := os.OpenFile(filename, os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0644)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &FileHandler{\n\t\tcurrentFile: file,\n\t\tfileNumber: fileNumber,\n\t\tmaxFileSize: maxFileSize,\n\t}, nil\n}\n```\n\nI need to import \"sync\", \"fmt\", and \"path/filepath\" for this.\n\nSo, the FileHandler struct has a mutex, a current file, the current file number, and the maximum file size.\n\nThe NewFileHandler function initializes the FileHandler by creating the directory if it doesn't exist, finding the current file number, opening the initial file, and setting up the struct.\n\nNow, in the handlePost function, I can use this FileHandler to write the JSON payload.\n\nBut I need to make sure that the file size is checked before writing, and if writing would exceed the max size, create a new file.\n\nAlso, file operations need to be synchronized using the mutex.\n\nLet me think about how to implement the write function.\n\nI can have a write method in the FileHandler that takes the JSON payload, checks the file size, switches to a new file if necessary, and then writes the payload.\n\nSomething like:\n\n```go\nfunc (f *FileHandler) WritePayload(payload []byte) error {\n\tf.mu.Lock()\n\tdefer f.mu.Unlock()\n\n\tfileInfo, err := f.currentFile.Stat()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tcurrentSize := fileInfo.Size()\n\tif currentSize + int64(len(payload)) > f.maxFileSize {\n\t\tf.currentFile.Close()\n\t\tf.fileNumber++\n\t\tnewFilename := filepath.Join(f.dir, fmt.Sprintf(\"data_%d.json\", f.fileNumber))\n\t\tnewFile, err := os.OpenFile(newFilename, os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0644)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tf.currentFile = newFile\n\t}\n\n\t_, err = f.currentFile.Write(payload)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n```\n\nWait, but in this function, I don't have the 'dir' field in the FileHandler. I need to add that.\n\nLet me update the FileHandler struct to include the directory path.\n\n```go\ntype FileHandler struct {\n\tmu         sync.Mutex\n\tcurrentFile *os.File\n\tfileNumber int\n\tdir        string\n\tmaxFileSize int64\n}\n```\n\nAnd update the NewFileHandler function accordingly.\n\nNow, the WritePayload method can create new files in the specified directory.\n\nAlso, I need to make sure that the file is properly closed when the server shuts down. Maybe implement a Close method for the FileHandler.\n\n```go\nfunc (f *FileHandler) Close() error {\n\tf.mu.Lock()\n\tdefer f.mu.Unlock()\n\n\treturn f.currentFile.Close()\n}\n```\n\nAnd in the main function, I need to call this Close method when the server is shutting down.\n\nBut handling server shutdown in Go requires catching interrupt signals or using a context with a timeout.\n\nFor simplicity, maybe I'll just rely on the operating system to clean up the file descriptors when the process exits.\n\nBut it's better to close the file properly.\n\nLet me look into how to handle graceful shutdown in Go.\n\nI can use a context to handle server shutdown.\n\nHere's an example:\n\n```go\nfunc main() {\n\tfileHandler, err := NewFileHandler(\"data\", 10*1024*1024) // 10MB\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer fileHandler.Close()\n\n\thttp.HandleFunc(\"/submit\", func(w http.ResponseWriter, r *http.Request) {\n\t handlePost(w, r, fileHandler)\n\t})\n\n\tsrv := &http.Server{\n\t\tAddr:    \":8080\",\n\t\tHandler: nil,\n\t}\n\n\tgo func() {\n\t\tif err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {\n\t\t\tlog.Fatalf(\"listen: %s\\n\", err)\n\t\t}\n\t}()\n\n\t// Wait for interrupt signal to gracefully shutdown the server with a timeout of 5 seconds.\n\tquit := make(chan os.Signal, 1)\n\tsignal.Notify(quit, os.Interrupt)\n\t<-quit\n\tlog.Println(\"Shutting down server...\")\n\n\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\tdefer cancel()\n\tif err := srv.Shutdown(ctx); err != nil {\n\t\tlog.Fatal(\"Server forced to shutdown:\", err)\n\t}\n\n\tlog.Println(\"Server exiting\")\n}\n```\n\nI need to import \"context\", \"time\", and \"os/signal\" for this.\n\nSo, in this setup, when an interrupt signal is received, the server shuts down gracefully within 5 seconds.\n\nAlso, I have a defer fileHandler.Close() to ensure that the file is closed when the program exits.\n\nNow, let's implement the handlePost function.\n\n```go\nfunc handlePost(w http.ResponseWriter, r *http.Request, fileHandler *FileHandler) {\n\tbody, err := ioutil.ReadAll(r.Body)\n\tif err != nil {\n\t\thttp.Error(w, \"Error reading request body\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tdefer r.Body.Close()\n\n\tvar data map[string]interface{}\n\terr = json.Unmarshal(body, &data)\n\tif err != nil {\n\t\thttp.Error(w, \"Invalid JSON payload\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\terr = fileHandler.WritePayload(body)\n\tif err != nil {\n\t\thttp.Error(w, \"Error writing to file\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tw.WriteHeader(http.StatusAccepted)\n\tfmt.Fprint(w, \"Payload received and stored.\")\n}\n```\n\nHere, I'm reading the request body, parsing it as JSON into a map, and then writing the raw JSON payload to the file using the fileHandler.\n\nI'm sending a 202 Accepted status code back to the client along with a message.\n\nI chose to store the raw JSON payload instead of the parsed map because the map might not preserve the original JSON structure, especially if there are different data types.\n\nBut if needed, I can marshal the map back to JSON, but that might alter the JSON formatting.\n\nSo, storing the raw JSON payload seems better.\n\nAlso, I need to make sure that each JSON object is written to the file with a newline separator so that the file can contain multiple JSON objects, each on a new line.\n\nThis is a common format for log files containing JSON entries.\n\nSo, I can modify the WritePayload method to append a newline after each payload.\n\nHere's the updated WritePayload:\n\n```go\nfunc (f *FileHandler) WritePayload(payload []byte) error {\n\tf.mu.Lock()\n\tdefer f.mu.Unlock()\n\n\tfileInfo, err := f.currentFile.Stat()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tcurrentSize := fileInfo.Size()\n\tpayloadSize := int64(len(payload)) + 1 // +1 for the newline\n\tif currentSize+payloadSize > f.maxFileSize {\n\t\tf.currentFile.Close()\n\t\tf.fileNumber++\n\t\tnewFilename := filepath.Join(f.dir, fmt.Sprintf(\"data_%d.json\", f.fileNumber))\n\t\tnewFile, err := os.OpenFile(newFilename, os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0644)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tf.currentFile = newFile\n\t}\n\n\t_, err = f.currentFile.Write(payload)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = f.currentFile.Write([]byte{'\\n'})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n```\n\nNow, each JSON payload is written followed by a newline.\n\nThis way, the file can be read later as a sequence of JSON objects, one per line.\n\nAlso, I need to make sure that the file is opened in append mode, so new entries are added at the end.\n\nI think this should work.\n\nLet me think about potential error scenarios.\n\n1. Failed to read request body: Already handled by http.Error with 400 Bad Request.\n\n2. Invalid JSON payload: Handled by http.Error with 400 Bad Request.\n\n3. Failed to write to file: Handled by http.Error with 500 Internal Server Error.\n\n4. Failed to create new file when current file is full: This should be handled in the WritePayload method, and an error should be returned.\n\nI should also consider logging these errors for troubleshooting.\n\nMaybe I can log the errors using the standard log package.\n\nLet me import \"log\" and add some log statements.\n\nFirst, import \"log\".\n\nThen, in the handlePost function:\n\n```go\nfunc handlePost(w http.ResponseWriter, r *http.Request, fileHandler *FileHandler) {\n\tbody, err := ioutil.ReadAll(r.Body)\n\tif err != nil {\n\t\tlog.Printf(\"Error reading request body: %v\", err)\n\t\thttp.Error(w, \"Error reading request body\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tdefer r.Body.Close()\n\n\tvar data map[string]interface{}\n\terr = json.Unmarshal(body, &data)\n\tif err != nil {\n\t\tlog.Printf(\"Invalid JSON payload: %v\", err)\n\t\thttp.Error(w, \"Invalid JSON payload\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\terr = fileHandler.WritePayload(body)\n\tif err != nil {\n\t\tlog.Printf(\"Error writing to file: %v\", err)\n\t\thttp.Error(w, \"Error writing to file\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tw.WriteHeader(http.StatusAccepted)\n\tfmt.Fprint(w, \"Payload received and stored.\")\n}\n```\n\nAnd in the WritePayload method:\n\n```go\nfunc (f *FileHandler) WritePayload(payload []byte) error {\n\tf.mu.Lock()\n\tdefer f.mu.Unlock()\n\n\tfileInfo, err := f.currentFile.Stat()\n\tif err != nil {\n\t\tlog.Printf(\"Error stating current file: %v\", err)\n\t\treturn err\n\t}\n\n\tcurrentSize := fileInfo.Size()\n\tpayloadSize := int64(len(payload)) + 1 // +1 for the newline\n\tif currentSize+payloadSize > f.maxFileSize {\n\t\tf.currentFile.Close()\n\t\tf.fileNumber++\n\t\tnewFilename := filepath.Join(f.dir, fmt.Sprintf(\"data_%d.json\", f.fileNumber))\n\t\tnewFile, err := os.OpenFile(newFilename, os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0644)\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Error opening new file %s: %v\", newFilename, err)\n\t\t\treturn err\n\t\t}\n\t\tf.currentFile = newFile\n\t}\n\n\t_, err = f.currentFile.Write(payload)\n\tif err != nil {\n\t\tlog.Printf(\"Error writing payload to file: %v\", err)\n\t\treturn err\n\t}\n\n\t_, err = f.currentFile.Write([]byte{'\\n'})\n\tif err != nil {\n\t\tlog.Printf(\"Error writing newline to file: %v\", err)\n\t\treturn err\n\t}\n\n\treturn nil\n}\n```\n\nThis way, errors are logged, which can help in diagnosing issues.\n\nAlso, I should consider adding a header to the response to specify the content type.\n\nFor example, setting Content-Type to application/json if I'm returning JSON responses.\n\nBut in this case, I'm just returning a plain text message. So, it's okay.\n\nWait, but in Go, when using fmt.Fprint, it automatically sets the Content-Type to text/plain.\n\nIf I wanted to return JSON, I would set the header to application/json.\n\nBut for now, plain text is fine.\n\nLet me think about security considerations.\n\nSince we're accepting JSON payloads and writing them to files, there's a risk of directory traversal attacks if we're not careful with file paths.\n\nBut since we're controlling the file paths by constructing them ourselves with a fixed directory and numbered filenames, I think we're safe.\n\nAlso, since we're writing to files, we need to make sure that the directory has the appropriate permissions so that only the intended user can write to it.\n\nAdditionally, if the server is running with elevated privileges, we need to drop those privileges before writing to files to minimize security risks.\n\nBut that's more of a deployment concern rather than something to handle in the code.\n\nAnother consideration is that if multiple requests come in rapidly, there might be contention for the file lock, which could lead to performance bottlenecks.\n\nTo mitigate that, perhaps I can buffer the writes or use a channel to queue the writes.\n\nBut for simplicity, I'll stick with the current implementation.\n\nIf performance becomes an issue, I can look into optimizing it.\n\nAlso, I need to make sure that the fileHandler is properly initialized before the server starts handling requests.\n\nIn the main function, I'm creating the fileHandler before starting the server, so that should be fine.\n\nLet me summarize the steps again:\n\n1. Define a FileHandler struct to manage file operations with a mutex for synchronization.\n\n2. Implement NewFileHandler to initialize the FileHandler, including finding the current file number and opening the initial file.\n\n3. Implement WritePayload to write JSON payloads to the file, switching to a new file if the current one is about to exceed the maximum size.\n\n4. Implement a Close method to close the current file when the server shuts down.\n\n5. Set up a graceful shutdown mechanism using a context and signal handling.\n\n6. In the handlePost function, read the request body, parse the JSON, and use the fileHandler to write the payload to the file.\n\n7. Return an appropriate HTTP response to the client.\n\nI think that covers the main requirements.\n\nNow, let's think about testing this server.\n\nI can write some integration tests that send HTTP POST requests with JSON payloads and check if the data is correctly written to the files.\n\nI can use the \"net/http/httptest\" package for this.\n\nAlso, I can check if the file rotation works as expected when the file size exceeds the limit.\n\nLet me sketch a rough test function.\n\n```go\nfunc TestFileRotation(t *testing.T) {\n\tdir := \"./testdata\"\n\tos.RemoveAll(dir) // Clean up previous test data\n\tos.MkdirAll(dir, os.ModePerm)\n\n\tfileHandler, err := NewFileHandler(dir, 100) // Set a small max file size for testing\n\tif err != nil {\n\t\tt.Fatalf(\"NewFileHandler failed: %v\", err)\n\t}\n\tdefer fileHandler.Close()\n\n\tpayload := []byte(`{\"key\":\"value\"}`)\n\n\tfor i := 0; i < 20; i++ {\n\t\terr := fileHandler.WritePayload(payload)\n\t\tif err != nil {\n\t\t\tt.Fatalf(\"WritePayload failed: %v\", err)\n\t\t}\n\t}\n\n\t// Check that multiple files were created\n\tfiles, err := ioutil.ReadDir(dir)\n\tif err != nil {\n\t\tt.Fatalf(\"ReadDir failed: %v\", err)\n\t}\n\n\tif len(files) != 2 {\n\t\tt.Fatalf(\"Expected 2 files, got %d\", len(files))\n\t}\n\n\t// Check that each file has the correct content\n\tfor _, file := range files {\n\t\tif !strings.HasPrefix(file.Name(), \"data_\") || !strings.HasSuffix(file.Name(), \".json\") {\n\t\t\tt.Errorf(\"Unexpected filename: %s\", file.Name())\n\t\t\tcontinue\n\t\t}\n\n\t\tcontent, err := ioutil.ReadFile(filepath.Join(dir, file.Name()))\n\t\tif err != nil {\n\t\t\tt.Errorf(\"ReadFile %s failed: %v\", file.Name(), err)\n\t\t\tcontinue\n\t\t}\n\n\t\tlines := strings.Split(string(content), \"\\n\")\n\t\tfor _, line := range lines {\n\t\t\tif line == \"\" {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tvar data map[string]interface{}\n\t\t\terr := json.Unmarshal([]byte(line), &data)\n\t\t\tif err != nil {\n\t\t\t\tt.Errorf(\"Invalid JSON in %s: %v\", file.Name(), err)\n\t\t\t}\n\t\t\t// Add more assertions as needed\n\t\t}\n\t}\n}\n```\n\nHere, I'm setting up a test directory with a small max file size to force file rotation within a few writes.\n\nThen, I write multiple payloads and check if the correct number of files is created and if each file contains valid JSON entries.\n\nThis should help verify that the file rotation logic works as expected.\n\nI should also write tests for error conditions, such as failing to write to the file or receiving invalid JSON payloads.\n\nOverall, I think this covers the requirements. Now, I just need to put all the pieces together and make sure everything works correctly.\n\n## Final Solution\nTo create a GoLang server that accepts JSON payloads via HTTP POST requests and stores them into local files, with automatic file rotation when a file reaches 10MB, follow the steps below.\n\n### Approach\n\n1. **HTTP Server Setup**: Use Go's `net/http` package to set up an HTTP server that listens for POST requests on a specified endpoint.\n2. **JSON Handling**: Read and parse JSON payloads from the request body using the `encoding/json` package.\n3. **File Management**: Write the JSON payloads to local files, ensuring that files are rotated when they reach the 10MB size limit.\n4. **Concurrency Handling**: Use mutex locks to handle concurrent file access safely.\n5. **Graceful Shutdown**: Implement graceful shutdown handling to ensure files are properly closed when the server stops.\n\n### Solution Code\n\n```go\npackage main\n\nimport (\n\t\"bufio\"\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n\t\"os\"\n\t\"os/signal\"\n\t\"path/filepath\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\t\"regexp\"\n)\n\ntype FileHandler struct {\n\tmu         sync.Mutex\n\tcurrentFile *os.File\n\tfileNumber int\n\tdir        string\n\tmaxFileSize int64\n}\n\nfunc NewFileHandler(dir string, maxFileSize int64) (*FileHandler, error) {\n\terr := os.MkdirAll(dir, os.ModePerm)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfileNumber, err := getCurrentFileNumber(dir)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfilename := filepath.Join(dir, fmt.Sprintf(\"data_%d.json\", fileNumber))\n\tfile, err := os.OpenFile(filename, os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0644)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &FileHandler{\n\t\tcurrentFile: file,\n\t\tfileNumber: fileNumber,\n\t\tdir: dir,\n\t\tmaxFileSize: maxFileSize,\n\t}, nil\n}\n\nfunc (f *FileHandler) WritePayload(payload []byte) error {\n\tf.mu.Lock()\n\tdefer f.mu.Unlock()\n\n\tfileInfo, err := f.currentFile.Stat()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tcurrentSize := fileInfo.Size()\n\tpayloadSize := int64(len(payload)) + 1 // +1 for the newline\n\tif currentSize+payloadSize > f.maxFileSize {\n\t\tf.currentFile.Close()\n\t\tf.fileNumber++\n\t\tnewFilename := filepath.Join(f.dir, fmt.Sprintf(\"data_%d.json\", f.fileNumber))\n\t\tnewFile, err := os.OpenFile(newFilename, os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0644)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tf.currentFile = newFile\n\t}\n\n\t_, err = f.currentFile.Write(payload)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = f.currentFile.Write([]byte{'\\n'})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc (f *FileHandler) Close() error {\n\tf.mu.Lock()\n\tdefer f.mu.Unlock()\n\n\treturn f.currentFile.Close()\n}\n\nfunc getCurrentFileNumber(dir string) (int, error) {\n\tfiles, err := ioutil.ReadDir(dir)\n\tif err != nil {\n\t\treturn 0, err\n\t}\n\n\tmaxNum := 0\n\tfor _, file := range files {\n\t\tmatch, num := isDataFile(file.Name())\n\t\tif match && num > maxNum {\n\t\t\tmaxNum = num\n\t\t}\n\t}\n\treturn maxNum + 1, nil\n}\n\nfunc isDataFile(filename string) (bool, int) {\n\tre := regexp.MustCompile(`data_(\\d+)\\.json`)\n\tmatches := re.FindStringSubmatch(filename)\n\tif len(matches) == 2 {\n\t\tnum, err := strconv.Atoi(matches[1])\n\t\tif err != nil {\n\t\t\treturn false, 0\n\t\t}\n\t\treturn true, num\n\t}\n\treturn false, 0\n}\n\nfunc handlePost(w http.ResponseWriter, r *http.Request, fileHandler *FileHandler) {\n\tbody, err := ioutil.ReadAll(r.Body)\n\tif err != nil {\n\t\thttp.Error(w, \"Error reading request body\", http.StatusBadRequest)\n\t\treturn\n\t}\n\tdefer r.Body.Close()\n\n\tvar data map[string]interface{}\n\terr = json.Unmarshal(body, &data)\n\tif err != nil {\n\t\thttp.Error(w, \"Invalid JSON payload\", http.StatusBadRequest)\n\t\treturn\n\t}\n\n\terr = fileHandler.WritePayload(body)\n\tif err != nil {\n\t\thttp.Error(w, \"Error writing to file\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tw.WriteHeader(http.StatusAccepted)\n\tfmt.Fprint(w, \"Payload received and stored.\")\n}\n\nfunc main() {\n\tfileHandler, err := NewFileHandler(\"data\", 10*1024*1024) // 10MB\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer fileHandler.Close()\n\n\thttp.HandleFunc(\"/submit\", func(w http.ResponseWriter, r *http.Request) {\n\t\thandlePost(w, r, fileHandler)\n\t})\n\n\tsrv := &http.Server{\n\t\tAddr:    \":8080\",\n\t\tHandler: nil,\n\t}\n\n\tgo func() {\n\t\tif err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {\n\t\t\tlog.Fatalf(\"listen: %s\\n\", err)\n\t\t}\n\t}()\n\n\t// Wait for interrupt signal to gracefully shutdown the server with a timeout of 5 seconds.\n\tquit := make(chan os.Signal, 1)\n\tsignal.Notify(quit, os.Interrupt)\n\t<-quit\n\tlog.Println(\"Shutting down server...\")\n\n\tctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\n\tdefer cancel()\n\tif err := srv.Shutdown(ctx); err != nil {\n\t\tlog.Fatal(\"Server forced to shutdown:\", err)\n\t}\n\n\tlog.Println(\"Server exiting\")\n}\n```\n\n### Explanation\n\n- **FileHandler Struct**: Manages file operations with synchronized access using a mutex.\n- **NewFileHandler Function**: Initializes the FileHandler by setting up the directory and opening the initial file.\n- **WritePayload Method**: Writes JSON payloads to files, rotating to a new file when the current one approaches the size limit.\n- **handlePost Function**: Handles incoming HTTP POST requests, parses JSON payloads, and uses FileHandler to store data.\n- **Main Function**: Sets up the HTTP server, handles graceful shutdown, and ensures files are properly closed.\n\nThis setup ensures that JSON payloads are efficiently stored in manageable file sizes, with robust error handling and concurrency management."
    }
]