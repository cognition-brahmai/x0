[
    {
        "role": "user",
        "content": "Create a Python program that implements the Dijkstra's shortest path algorithm for a weighted graph represented as an adjacency matrix. The program should accept the source and destination nodes as input and return the shortest path between them. PLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Certainly! Below is a Python program that implements Dijkstra's shortest path algorithm for a weighted graph represented as an adjacency matrix. The program accepts the source and destination nodes as input and returns the shortest path between them.\n\n```python\nimport sys\n\ndef dijkstra(adj_matrix, source, destination):\n    n = len(adj_matrix)\n    visited = [False] * n\n    distances = [sys.maxsize] * n\n    distances[source] = 0\n    path = [-1] * n\n\n    for _ in range(n):\n        min_distance = sys.maxsize\n        min_index = -1\n        for v in range(n):\n            if not visited[v] and distances[v] < min_distance:\n                min_distance = distances[v]\n                min_index = v\n\n        visited[min_index] = True\n\n        for v in range(n):\n            if (\n                adj_matrix[min_index][v] != 0\n                and not visited[v]\n                and distances[min_index] + adj_matrix[min_index][v] < distances[v]\n            ):\n                distances[v] = distances[min_index] + adj_matrix[min_index][v]\n                path[v] = min_index\n\n    # Reconstruct the path\n    shortest_path = []\n    current = destination\n    while current != -1:\n        shortest_path.insert(0, current)\n        current = path[current]\n\n    return shortest_path, distances[destination]\n\ndef main():\n    # Example adjacency matrix\n    adj_matrix = [\n        [0, 10, 20, 0, 0],\n        [10, 0, 5, 16, 1],\n        [20, 5, 0, 20, 2],\n        [0, 16, 20, 0, 5],\n        [0, 1, 2, 5, 0]\n    ]\n\n    source = int(input(\"Enter the source node: \"))\n    destination = int(input(\"Enter the destination node: \"))\n\n    shortest_path, distance = dijkstra(adj_matrix, source, destination)\n\n    print(f\"The shortest path from node {source} to node {destination} is: {shortest_path}\")\n    print(f\"The total distance is: {distance}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\n### Explanation:\n1. **Dijkstra's Algorithm**:\n   - Initializes distances to all nodes as infinite except the source node, which is set to 0.\n   - Selects the node with the smallest distance that has not been visited yet.\n   - Updates the distances of its neighbors if a shorter path is found.\n   - Repeats this process until all nodes are visited or the destination node is visited.\n\n2. **Path Reconstruction**:\n   - Uses a `path` array to keep track of the previous node in the shortest path.\n   - Reconstructs the path by backtracking from the destination to the source.\n\n3. **Input and Output**:\n   - Accepts source and destination nodes from the user.\n   - Prints the shortest path and the total distance.\n\nThis program uses a simple implementation of Dijkstra's algorithm suitable for small graphs. For larger graphs, more efficient data structures like heaps can be used to improve performance."
    }
]