[
    {
        "role": "user",
        "content": "Implement a binary search tree in Python, with methods to insert, delete, and search for nodes. Additionally, create a method that returns the height of the tree.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Sure! I can help you with that. Implementing a binary search tree (BST) in Python involves creating a Node class to represent each node in the tree and a BST class to manage the tree operations.\n\nHere's a step-by-step guide to implementing a BST with insert, delete, search, and height methods:\n\n1. **Node Class**: Each node will have a value, and left and right pointers to its child nodes.\n\n2. **BST Class**: This will handle tree operations:\n   - **Insert**: Adds a new node with the given value.\n   - **Delete**: Removes a node with the specified value.\n   - **Search**: Checks if a value exists in the tree.\n   - **Height**: Returns the height of the tree.\n\nHere's the code:\n\n```python\nclass Node:\n    def __init__(self, key):\n        self.left = None\n        self.right = None\n        self.val = key\n\nclass BST:\n    def __init__(self):\n        self.root = None\n\n    def insert(self, key):\n        if self.root is None:\n            self.root = Node(key)\n        else:\n            self._insert_recursive(self.root, key)\n\n    def _insert_recursive(self, current, key):\n        if key < current.val:\n            if current.left is None:\n                current.left = Node(key)\n            else:\n                self._insert_recursive(current.left, key)\n        else:\n            if current.right is None:\n                current.right = Node(key)\n            else:\n                self._insert_recursive(current.right, key)\n\n    def delete(self, key):\n        self.root = self._delete_recursive(self.root, key)\n\n    def _delete_recursive(self, root, key):\n        if root is None:\n            return root\n\n        if key < root.val:\n            root.left = self._delete_recursive(root.left, key)\n        elif key > root.val:\n            root.right = self._delete_recursive(root.right, key)\n        else:\n            if root.left is None:\n                return root.right\n            elif root.right is None:\n                return root.left\n\n            root.val = self._min_value_node(root.right).val\n            root.right = self._delete_recursive(root.right, root.val)\n\n        return root\n\n    def _min_value_node(self, node):\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current\n\n    def search(self, key):\n        return self._search_recursive(self.root, key)\n\n    def _search_recursive(self, current, key):\n        if current is None or current.val == key:\n            return current is not None\n        if key < current.val:\n            return self._search_recursive(current.left, key)\n        else:\n            return self._search_recursive(current.right, key)\n\n    def height(self):\n        return self._height_recursive(self.root)\n\n    def _height_recursive(self, current):\n        if current is None:\n            return 0\n        else:\n            left_height = self._height_recursive(current.left)\n            right_height = self._height_recursive(current.right)\n            return max(left_height, right_height) + 1\n\n# Example usage:\nbst = BST()\nbst.insert(50)\nbst.insert(30)\nbst.insert(20)\nbst.insert(40)\nbst.insert(70)\nbst.insert(60)\nbst.insert(80)\n\nprint(\"Search 40:\", bst.search(40))  # True\nprint(\"Search 90:\", bst.search(90))  # False\n\nprint(\"Height of tree:\", bst.height())  # 3\n\nbst.delete(20)\nprint(\"Search 20 after deletion:\", bst.search(20))  # False\nbst.delete(30)\nprint(\"Search 30 after deletion:\", bst.search(30))  # False\n```\n\n### Explanation:\n\n1. **Node Class**:\n   - Initializes with a value and optional left and right children.\n\n2. **BST Class**:\n   - **Insert**: Adds a new node using a recursive helper method.\n   - **Delete**: Removes a node using a recursive helper method. It handles three cases:\n     - Node with no children.\n     - Node with one child.\n     - Node with two children (replaces with the smallest in the right subtree).\n   - **Search**: Checks for the existence of a value using a recursive helper method.\n   - **Height**: Computes the height of the tree using a recursive helper method.\n\nThis implementation ensures that the BST properties are maintained during insertions and deletions."
    }
]