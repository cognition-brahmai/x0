[
    {
        "role": "user",
        "content": "Write a Golang program to implement a singly linked list data structure with methods for adding elements at the beginning, end, and at a specific position, as well as removing elements by value and displaying the contents of the list."
    },
    {
        "role": "assistant",
        "content": "Sure, I can help you with that! Implementing a singly linked list in Go involves defining a structure for the nodes and then implementing methods to manipulate the list. Below is a simple implementation that includes methods for adding elements at the beginning, end, and at a specific position, removing elements by value, and displaying the contents of the list.\n\nFirst, let's define the basic structure for the node and the list:\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\n// Node represents a node in the singly linked list\ntype Node struct {\n\tdata int\n\tnext *Node\n}\n\n// LinkedList represents the singly linked list\ntype LinkedList struct {\n\thead *Node\n\tsize int\n}\n```\n\nNow, let's implement the methods for the LinkedList:\n\n1. **Add at the beginning:**\n\n```go\n// AddAtBeginning adds a new node with the given data at the beginning of the list\nfunc (list *LinkedList) AddAtBeginning(data int) {\n\tnewNode := &Node{data, list.head}\n\tlist.head = newNode\n\tlist.size++\n}\n```\n\n2. **Add at the end:**\n\n```go\n// AddAtEnd adds a new node with the given data at the end of the list\nfunc (list *LinkedList) AddAtEnd(data int) {\n\tnewNode := &Node{data, nil}\n\tif list.head == nil {\n\t\tlist.head = newNode\n\t} else {\n\t\tcurrent := list.head\n\t\tfor current.next != nil {\n\t\t\tcurrent = current.next\n\t\t}\n\t\tcurrent.next = newNode\n\t}\n\tlist.size++\n}\n```\n\n3. **Add at a specific position:**\n\n```go\n// AddAtPosition adds a new node with the given data at the specified position\nfunc (list *LinkedList) AddAtPosition(position, data int) {\n\tif position < 0 || position > list.size {\n\t\tfmt.Println(\"Position out of range\")\n\t\treturn\n\t}\n\tif position == 0 {\n\t\tlist.AddAtBeginning(data)\n\t\treturn\n\t}\n\tnewNode := &Node{data, nil}\n\tcurrent := list.head\n\tfor i := 1; i < position; i++ {\n\t\tcurrent = current.next\n\t}\n\tnewNode.next = current.next\n\tcurrent.next = newNode\n\tlist.size++\n}\n```\n\n4. **Remove by value:**\n\n```go\n// RemoveByValue removes the first occurrence of a node with the given data\nfunc (list *LinkedList) RemoveByValue(data int) {\n\tif list.head == nil {\n\t\treturn\n\t}\n\tif list.head.data == data {\n\t\tlist.head = list.head.next\n\t\tlist.size--\n\t\treturn\n\t}\n\tcurrent := list.head\n\tfor current.next != nil {\n\t\tif current.next.data == data {\n\t\t\tcurrent.next = current.next.next\n\t\t\tlist.size--\n\t\t\treturn\n\t\t}\n\t\tcurrent = current.next\n\t}\n}\n```\n\n5. **Display the list:**\n\n```go\n// Display prints the contents of the list\nfunc (list *LinkedList) Display() {\n\tcurrent := list.head\n\tfor current != nil {\n\t\tfmt.Printf(\"%d -> \", current.data)\n\t\tcurrent = current.next\n\t}\n\tfmt.Println(\"nil\")\n}\n```\n\nFinally, let's write a main function to test these methods:\n\n```go\nfunc main() {\n\tlist := &LinkedList{}\n\tlist.AddAtBeginning(1)\n\tlist.AddAtEnd(2)\n\tlist.AddAtPosition(1, 3)\n\tlist.Display() // Should print: 1 -> 3 -> 2 -> nil\n\tlist.RemoveByValue(3)\n\tlist.Display() // Should print: 1 -> 2 -> nil\n}\n```\n\nThis implementation covers the basic operations for a singly linked list in Go. You can expand upon this by adding more features like adding at the end efficiently using a tail pointer, removing all occurrences of a value, etc."
    }
]