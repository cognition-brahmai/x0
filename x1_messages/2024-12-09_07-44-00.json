[
    {
        "role": "user",
        "content": "Create a C++ program that implements a simple stack data structure with push, pop, and peek operations. The stack should be implemented using a linked list, and the program should include error handling for cases such as attempting to pop from an empty stack.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Sure, I can help you with that! Let's create a simple stack data structure in C++ using a linked list. We'll implement the push, pop, and peek operations, and also include error handling for cases like trying to pop from an empty stack.\n\nFirst, we need to understand what a stack is. A stack is a Last In First Out (LIFO) data structure, which means the last element added is the first one to be removed. The basic operations are:\n\n- **Push**: Adds an element to the top of the stack.\n\n- **Pop**: Removes the element from the top of the stack.\n\n- **Peek**: Returns the element at the top of the stack without removing it.\n\nWe'll use a linked list to implement the stack because it allows efficient O(1) time complexity for push and pop operations.\n\n### Step 1: Define the Node Structure\n\nEach node in the linked list will hold the data and a pointer to the next node.\n\n```cpp\nstruct Node {\n    int data;\n    Node* next;\n    Node(int val) : data(val), next(nullptr) {}\n};\n```\n\n### Step 2: Define the Stack Class\n\nThe stack class will have a pointer to the top node.\n\n```cpp\nclass Stack {\nprivate:\n    Node* top;\npublic:\n    Stack() : top(nullptr) {}\n    ~Stack();\n    void push(int value);\n    int pop();\n    int peek();\n    bool isEmpty() const;\n};\n```\n\n### Step 3: Implement the Push Operation\n\nThe push operation adds a new node to the top of the stack.\n\n```cpp\nvoid Stack::push(int value) {\n    Node* newNode = new Node(value);\n    newNode->next = top;\n    top = newNode;\n}\n```\n\n### Step 4: Implement the Pop Operation\n\nThe pop operation removes the top node from the stack and returns its value. We need to handle the case where the stack is empty.\n\n```cpp\nint Stack::pop() {\n    if (isEmpty()) {\n        std::cerr << \"Error: Pop from empty stack.\" << std::endl;\n        exit(EXIT_FAILURE);\n    }\n    int poppedValue = top->data;\n    Node* temp = top;\n    top = top->next;\n    delete temp;\n    return poppedValue;\n}\n```\n\n### Step 5: Implement the Peek Operation\n\nThe peek operation returns the value of the top node without removing it. Again, handle the empty stack case.\n\n```cpp\nint Stack::peek() {\n    if (isEmpty()) {\n        std::cerr << \"Error: Peek on empty stack.\" << std::endl;\n        exit(EXIT_FAILURE);\n    }\n    return top->data;\n}\n```\n\n### Step 6: Implement the IsEmpty Function\n\nThis function checks if the stack is empty.\n\n```cpp\nbool Stack::isEmpty() const {\n    return top == nullptr;\n}\n```\n\n### Step 7: Implement the Destructor\n\nThe destructor will free the memory allocated for the stack.\n\n```cpp\nStack::~Stack() {\n    while (!isEmpty()) {\n        pop();\n    }\n}\n```\n\n### Step 8: Write a Main Function to Test the Stack\n\nLet's write a simple main function to test our stack implementation.\n\n```cpp\nint main() {\n    Stack stack;\n\n    stack.push(10);\n    stack.push(20);\n    stack.push(30);\n\n    std::cout << \"Top element is: \" << stack.peek() << std::endl;  // Output: 30\n\n    stack.pop();\n\n    std::cout << \"Top element after pop is: \" << stack.peek() << std::endl;  // Output: 20\n\n    stack.pop();\n    stack.pop();\n\n    if (stack.isEmpty()) {\n        std::cout << \"Stack is empty.\" << std::endl;\n    } else {\n        std::cout << \"Stack is not empty.\" << std::endl;\n    }\n\n    return 0;\n}\n```\n\n### Full Code\n\nHere's the full code combined:\n\n```cpp\n#include <iostream>\n#include <cstdlib>\n#include <ctime>\n\nstruct Node {\n    int data;\n    Node* next;\n    Node(int val) : data(val), next(nullptr) {}\n};\n\nclass Stack {\nprivate:\n    Node* top;\npublic:\n    Stack() : top(nullptr) {}\n    ~Stack();\n    void push(int value);\n    int pop();\n    int peek();\n    bool isEmpty() const;\n};\n\nvoid Stack::push(int value) {\n    Node* newNode = new Node(value);\n    newNode->next = top;\n    top = newNode;\n}\n\nint Stack::pop() {\n    if (isEmpty()) {\n        std::cerr << \"Error: Pop from empty stack.\" << std::endl;\n        exit(EXIT_FAILURE);\n    }\n    int poppedValue = top->data;\n    Node* temp = top;\n    top = top->next;\n    delete temp;\n    return poppedValue;\n}\n\nint Stack::peek() {\n    if (isEmpty()) {\n        std::cerr << \"Error: Peek on empty stack.\" << std::endl;\n        exit(EXIT_FAILURE);\n    }\n    return top->data;\n}\n\nbool Stack::isEmpty() const {\n    return top == nullptr;\n}\n\nStack::~Stack() {\n    while (!isEmpty()) {\n        pop();\n    }\n}\n\nint main() {\n    Stack stack;\n\n    stack.push(10);\n    stack.push(20);\n    stack.push(30);\n\n    std::cout << \"Top element is: \" << stack.peek() << std::endl;  // Output: 30\n\n    stack.pop();\n\n    std::cout << \"Top element after pop is: \" << stack.peek() << std::endl;  // Output: 20\n\n    stack.pop();\n    stack.pop();\n\n    if (stack.isEmpty()) {\n        std::cout << \"Stack is empty.\" << std::endl;\n    } else {\n        std::cout << \"Stack is not empty.\" << std::endl;\n    }\n\n    return 0;\n}\n```\n\nThis code defines a simple stack using a linked list and includes basic operations with error handling for empty stack scenarios. You can compile and run this code to see how the stack works."
    }
]