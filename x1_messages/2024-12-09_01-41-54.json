[
    {
        "role": "user",
        "content": "Write a JavaScript program that takes an input string and compresses it using the Run Length Encoding (RLE) algorithm. The program should also be able to decompress the compressed string back to its original form."
    },
    {
        "role": "assistant",
        "content": "Run Length Encoding (RLE) is a simple form of data compression where sequences of the same data value are stored as a single data value and count. For example, the string \"aaabbbcc\" can be compressed to \"a3b3c2\". To implement this in JavaScript, we need to create two functions: one for compressing the string and another for decompressing it back to its original form.\n\n### Approach\n\n**Compression:**\n1. Iterate through the string, keeping track of the current character and a counter.\n2. When a different character is encountered, append the current character and its count to the result string.\n3. Reset the counter for the new character.\n4. Continue until all characters are processed.\n\n**Decompression:**\n1. Iterate through the compressed string, identifying sequences of characters followed by their counts.\n2. For each sequence, repeat the character according to its count and append to the result string.\n\n### Solution Code\n\n```javascript\nfunction compress(str) {\n    if (!str) return str; // Return empty string as is\n\n    let result = '';\n    let count = 1;\n\n    for (let i = 0; i < str.length; i++) {\n        const current = str[i];\n        const next = str[i + 1];\n        if (current === next) {\n            count++;\n        } else {\n            result += current + count;\n            count = 1;\n        }\n    }\n\n    return result;\n}\n\nfunction decompress(str) {\n    if (!str) return str; // Return empty string as is\n\n    let result = '';\n    let count = '';\n\n    for (let i = 0; i < str.length; i++) {\n        const char = str[i];\n        if (isNaN(char)) {\n            // If character is not a number, it's a letter\n            if (count !== '') {\n                result += char.repeat(parseInt(count));\n                count = '';\n            } else {\n                result += char;\n            }\n        } else {\n            // If character is a number, build the count\n            count += char;\n        }\n    }\n\n    return result;\n}\n\n// Example usage:\nconst original = \"aaabbbcc\";\nconst compressed = compress(original);\nconsole.log(\"Compressed:\", compressed); // Should print: a3b3c2\nconst decompressed = decompress(compressed);\nconsole.log(\"Decompressed:\", decompressed); // Should print: aaabbbcc\n```\n\n### Explanation\n\n**Compression Function:**\n- We initialize an empty string `result` to build the compressed string.\n- We use a counter `count` to keep track of consecutive identical characters.\n- As we iterate through the string, we check if the current character is the same as the next one.\n- If they are the same, we increment the counter.\n- If they are different, we append the current character and its count to `result` and reset the counter.\n- Finally, we return the compressed string.\n\n**Decompression Function:**\n- We initialize an empty string `result` to build the decompressed string.\n- We use a variable `count` to accumulate the numerical count for each character.\n- As we iterate through the compressed string, we check if each character is a digit or a letter.\n- If it's a letter and there is a count accumulated, we append the letter repeated by the count to `result`.\n- If it's a digit, we accumulate it in the `count` variable.\n- Finally, we return the decompressed string.\n\nThis approach ensures that the string is compressed and decompressed efficiently using the RLE algorithm."
    }
]