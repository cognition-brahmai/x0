[
    {
        "role": "user",
        "content": "Implement a C++ multithreaded program that simulates a producer-consumer scenario. The producer generates random integers and adds them to a shared buffer, while the consumer removes integers from the buffer and calculates their sum. Use mutexes and condition variables to synchronize the threads.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Sure, I can help you with that! Implementing a producer-consumer scenario in C++ using multithreading, mutexes, and condition variables is a great way to understand synchronization primitives. Let's break down the problem and create a step-by-step solution.\n\n### Objective\n\n- **Producer:** Generates random integers and adds them to a shared buffer.\n- **Consumer:** Removes integers from the buffer and calculates their sum.\n- **Synchronization:** Use mutexes and condition variables to ensure thread safety.\n\n### Approach\n\n1. **Shared Buffer:** A fixed-size buffer where producers add items and consumers remove items.\n2. **Mutex:** To protect access to the shared buffer.\n3. **Condition Variables:**\n   - `data_available`: Notifies the consumer that data is available in the buffer.\n   - `space_available`: Notifies the producer that there is space in the buffer to add more items.\n\n### Solution Code\n\n```cpp\n#include <iostream>\n#include <thread>\n#include <queue>\n#include <mutex>\n#include <condition_variable>\n#include <random>\n#include <chrono>\n\nstd::mutex buf_mutex;\nstd::condition_variable data_available;\nstd::condition_variable space_available;\nstd::queue<int> buffer;\nconst size_t buffer_size = 5;\nbool done_producing = false;\n\nvoid producer() {\n    std::random_device rd;\n    std::mt19937 gen(rd());\n    std::uniform_int_distribution<> dis(1, 100);\n\n    for (size_t i = 0; i < 20; ++i) {\n        int data = dis(gen);\n        std::unique_lock<std::mutex> lock(buf_mutex);\n        // Wait until there is space in the buffer\n        space_available.wait(lock, []{ return buffer.size() < buffer_size; });\n        buffer.push(data);\n        std::cout << \"Produced: \" << data << \", Buffer size: \" << buffer.size() << std::endl;\n        data_available.notify_one();\n    }\n    done_producing = true;\n    data_available.notify_all();\n}\n\nvoid consumer() {\n    int sum = 0;\n    while (true) {\n        std::unique_lock<std::mutex> lock(buf_mutex);\n        // Wait until there is data in the buffer or production is done\n        data_available.wait(lock, [&]{ return !buffer.empty() || done_producing; });\n        if (!buffer.empty()) {\n            int data = buffer.front();\n            buffer.pop();\n            sum += data;\n            std::cout << \"Consumed: \" << data << \", Sum: \" << sum << \", Buffer size: \" << buffer.size() << std::endl;\n            space_available.notify_one();\n        } else if (done_producing) {\n            break;\n        }\n    }\n    std::cout << \"Total sum: \" << sum << std::endl;\n}\n\nint main() {\n    std::thread prod(producer);\n    std::thread cons(consumer);\n\n    prod.join();\n    cons.join();\n\n    return 0;\n}\n```\n\n### Explanation\n\n1. **Shared Resources:**\n   - `buffer`: A queue to hold the integers produced.\n   - `buf_mutex`: Mutex to protect access to the buffer.\n   - `data_available`: Condition variable to signal when data is available in the buffer.\n   - `space_available`: Condition variable to signal when there is space in the buffer.\n   - `done_producing`: Flag to indicate that the producer has finished adding items.\n\n2. **Producer Thread:**\n   - Generates random integers and adds them to the buffer.\n   - Waits if the buffer is full using `space_available.wait()`.\n   - Notifies the consumer using `data_available.notify_one()` after adding an item.\n\n3. **Consumer Thread:**\n   - Removes integers from the buffer and calculates their sum.\n   - Waits if the buffer is empty and production is not done using `data_available.wait()`.\n   - Notifies the producer using `space_available.notify_one()` after removing an item.\n   - Exits the loop when the buffer is empty and production is done.\n\n4. **Main Function:**\n   - Creates and joins the producer and consumer threads.\n\nThis setup ensures that the producer and consumer threads synchronize correctly using mutexes and condition variables, preventing race conditions and deadlocks."
    }
]