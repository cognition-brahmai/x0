[
    {
        "role": "user",
        "content": "Implement a simple stack data structure in C++ with push, pop, and peek operations, along with error handling for empty or full stacks."
    },
    {
        "role": "assistant",
        "content": "I'd be happy to help you with that! Implementing a stack in C++ is a great way to understand basic data structures and how to manage memory and operations efficiently. A stack is a Last-In-First-Out (LIFO) data structure, which means the last element added is the first one to be removed.\n\nTo create a simple stack in C++, we can use an array or a dynamic structure like a vector. For this example, I'll use an array to keep it straightforward and focus on the core concepts.\n\n### Key Components\n\n1. **Push Operation**: Adds an element to the top of the stack.\n2. **Pop Operation**: Removes the top element from the stack.\n3. **Peek Operation**: Returns the top element without removing it.\n4. **Error Handling**: Manage cases where the stack is empty (when trying to pop or peek) or full (when trying to push).\n\n### Implementation Steps\n\n1. **Define the Stack Class**:\n   - Private members: an array to store stack elements, top index, and the maximum size of the stack.\n   - Public methods: push, pop, peek, and checks for empty and full stack.\n\n2. **Push Operation**:\n   - Check if the stack is full.\n   - If not full, add the element to the top and increment the top index.\n\n3. **Pop Operation**:\n   - Check if the stack is empty.\n   - If not empty, decrement the top index and return the removed element.\n\n4. **Peek Operation**:\n   - Check if the stack is empty.\n   - If not empty, return the element at the top index.\n\n5. **Error Handling**:\n   - Use conditional checks and possibly throw exceptions or return special values to handle errors.\n\n### Sample Code\n\nHere's a simple implementation of a stack in C++:\n\n```cpp\n#include <iostream>\n\nclass Stack {\nprivate:\n    static const int MAX_SIZE = 100; // Define the maximum size of the stack\n    int arr[MAX_SIZE];\n    int top;\n\npublic:\n    Stack() : top(-1) {} // Initialize top to -1 indicating empty stack\n\n    bool isEmpty() {\n        return top == -1;\n    }\n\n    bool isFull() {\n        return top == MAX_SIZE - 1;\n    }\n\n    void push(int value) {\n        if (isFull()) {\n            std::cout << \"Stack is full. Cannot push \" << value << std::endl;\n            return;\n        }\n        arr[++top] = value;\n        std::cout << \"Pushed \" << value << \" to stack.\" << std::endl;\n    }\n\n    void pop() {\n        if (isEmpty()) {\n            std::cout << \"Stack is empty. Cannot pop.\" << std::endl;\n            return;\n        }\n        std::cout << \"Popped \" << arr[top] << \" from stack.\" << std::endl;\n        --top;\n    }\n\n    int peek() {\n        if (isEmpty()) {\n            std::cout << \"Stack is empty. Cannot peek.\" << std::endl;\n            return -1; // Assuming -1 is an invalid value\n        }\n        return arr[top];\n    }\n};\n\nint main() {\n    Stack stack;\n\n    stack.push(10);\n    stack.push(20);\n    stack.push(30);\n    stack.push(40);\n\n    std::cout << \"Top element is: \" << stack.peek() << std::endl;\n\n    stack.pop();\n    stack.pop();\n\n    std::cout << \"Top element is: \" << stack.peek() << std::endl;\n\n    stack.pop();\n    stack.pop();\n    stack.pop(); // Trying to pop from empty stack\n\n    return 0;\n}\n```\n\n### Explanation\n\n1. **Class Definition**:\n   - `Stack` class has an array `arr` to store elements and an integer `top` to track the top element's index.\n   - Constructor initializes `top` to -1, indicating an empty stack.\n\n2. **Methods**:\n   - `isEmpty()` and `isFull()` check if the stack is empty or full, respectively.\n   - `push(int value)` adds an element to the stack if it's not full.\n   - `pop()` removes the top element if the stack is not empty.\n   - `peek()` returns the top element without removing it if the stack is not empty.\n\n3. **Main Function**:\n   - Demonstrates pushing and popping elements and handling error cases.\n\nThis implementation provides a basic understanding of stack operations and error handling in C++. You can expand upon this by using dynamic arrays or other data structures for more flexibility."
    }
]