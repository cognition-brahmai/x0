[
    {
        "role": "user",
        "content": "Develop a Java program that implements a basic chat server using sockets. The server should allow multiple clients to connect, send messages to each other, and disconnect gracefully. Ensure proper error handling and thread management.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Alright, I've got this task to create a basic chat server in Java using sockets. It needs to handle multiple clients, let them send messages to each other, and handle disconnections properly. Also, I need to make sure that there's proper error handling and thread management. Sounds like a fun project!\n\nFirst, I need to understand the basics of socket programming in Java. Sockets allow for communication between two machines over a network. In this case, I'll have a server socket that listens for incoming connections from clients. Each client will connect to the server via their own socket.\n\nSince multiple clients need to connect, I'll have to handle each client in a separate thread. That way, the server can manage communications with all connected clients simultaneously without blocking.\n\nLet me outline the steps I need to take:\n\n1. **Set up the server socket:** The server will listen on a specific port for incoming connections.\n\n2. **Accept client connections:** When a client connects, accept the connection and create a new thread to handle that client's communications.\n\n3. **Handle client threads:** Each client thread will handle reading messages from the client and broadcasting those messages to all other connected clients.\n\n4. **Handle disconnections:** When a client disconnects, remove it from the list of connected clients and close its socket.\n\n5. **Error handling:** Make sure to handle any exceptions that might occur, such as socket exceptions or I/O errors.\n\nLet me think about the data structures I'll need. I'll probably need a list to keep track of all connected clients so that messages can be broadcasted to everyone. Since multiple threads will be accessing this list, I need to make sure it's thread-safe.\n\nJava's `ConcurrentHashMap` could be a good choice for storing connected clients because it's thread-safe and allows for concurrent access.\n\nEach client will have an identifier, maybe their username or just a unique client ID. For simplicity, I'll use client IDs.\n\nNow, for the messaging part: when a client sends a message, the server should broadcast that message to all other connected clients. I need to read messages from the client's input stream and write them to the output streams of all other clients.\n\nI should also consider how to format the messages. Probably, each message should include the client's ID or username so that other clients know who sent the message.\n\nLet me sketch a rough class structure:\n\n- **ChatServer:** This class will set up the server socket and manage client connections.\n\n- **ClientHandler:** This class will be a thread for each connected client, handling reading and writing messages.\n\nIn the `ChatServer` class:\n\n- Create a server socket on a specified port.\n\n- Maintain a map of connected clients (client ID to ClientHandler).\n\n- Listen for new client connections and create a new ClientHandler thread for each.\n\nIn the `ClientHandler` class:\n\n- Read messages from the client's input stream.\n\n- Broadcast messages to all other connected clients.\n\n- Handle disconnections by removing the client from the list and closing resources.\n\nI need to think about how clients will connect and identify themselves. Maybe when a client connects, they send their username first, which the server can use to identify them.\n\nLet me consider the flow for a new client:\n\n1. Client connects to the server.\n\n2. Server accepts the connection and reads the username from the input stream.\n\n3. Server adds the client to the list of connected clients with their username.\n\n4. Server starts a new thread (ClientHandler) to handle communications for that client.\n\n5. ClientHandler reads messages from the client and broadcasts them to other clients.\n\n6. When the client disconnects, it's removed from the list, and resources are cleaned up.\n\nI should also think about how to close everything properly when the server shuts down. Maybe have a way to stop the server gracefully, closing all client sockets and the server socket.\n\nError handling is crucial here. Sockets can throw various exceptions, such as `IOException` when reading or writing data. I need to make sure that these exceptions are handled gracefully, without crashing the server or leaving resources open.\n\nLet me consider using try-with-resources statements to ensure that sockets and streams are closed properly.\n\nAlso, since multiple threads will be accessing the list of connected clients, I need to synchronize access to that list to prevent concurrency issues.\n\nWait, but if I use a `ConcurrentHashMap`, it's designed for concurrent access, so I might not need explicit synchronization for common operations like adding, removing, and iterating over entries.\n\nBut I need to be careful when iterating over the map to broadcast messages. In Java, iterating over a `ConcurrentHashMap` is safe even if other threads modify the map.\n\nAlright, let's proceed with that plan.\n\nLet me start by writing the `ChatServer` class.\n\nFirst, I need to choose a port number for the server to listen on. For development, I can use a port number above 1024, since lower numbers require administrative privileges.\n\nLet's say port 12345.\n\nIn the `ChatServer` constructor, I'll set up the server socket on that port.\n\nThen, in the `start` method, I'll have a loop that continuously accepts new connections.\n\nFor each connection, I'll read the username from the client, add it to the map, and start a new `ClientHandler` thread.\n\nI need to make sure that usernames are unique. So, when a new client tries to connect with a username that's already taken, I'll have to handle that, maybe by rejecting the connection or asking the client to choose another username.\n\nBut for simplicity, let's assume that usernames are unique and handle the case where a duplicate username is attempted by rejecting the connection.\n\nIn the `ClientHandler` class, I'll have a loop that reads messages from the client's input stream and broadcasts them to other clients.\n\nI need to define the message format. Maybe each message is a string terminated by a newline character.\n\nSo, I can read lines from the input stream using a `BufferedReader`.\n\nSimilarly, for writing messages to clients, I'll use a `PrintWriter` to send messages with newline terminators.\n\nWhen broadcasting a message, I'll need to prefix the message with the sender's username so that recipients know who sent it.\n\nFor example, \"UserA: Hello, everyone!\"\n\nNow, handling disconnections: when a client disconnects, their input stream will throw an `IOException`, which should be caught in the `ClientHandler` thread.\n\nUpon disconnection, I'll remove the client from the map and close their socket.\n\nI should also broadcast a message to other clients indicating that this user has disconnected.\n\nSimilarly, when the server shuts down, I need to close the server socket and all client sockets.\n\nLet me think about how to stop the server gracefully. Maybe have a boolean flag that, when set, breaks the acceptance loop and closes everything.\n\nI can have a `stop` method in the `ChatServer` class that sets this flag and then joins all client threads to ensure they finish before the server exits.\n\nNow, let's consider the client side. I need to have a simple chat client that can connect to the server, send messages, and receive messages from other clients.\n\nBut since the task is to implement the server, I might not need to worry about the client for now, as long as I can test it with standard socket client tools.\n\nHowever, to make sure everything works, I should probably write a simple chat client as well.\n\nBut for now, let's focus on the server.\n\nLet me list down the potential exceptions and errors that need to be handled:\n\n- Failed to bind to the specified port.\n\n- Problems accepting connections.\n\n- Errors reading from or writing to client sockets.\n\n- Clients disconnecting unexpectedly.\n\n- Multiple threads accessing the list of connected clients.\n\nI need to make sure that the server doesn't crash upon encountering these issues but handles them gracefully.\n\nLet me start by writing the skeleton of the `ChatServer` class.\n\nI'll need to import necessary classes:\n\n```java\nimport java.io.*;\nimport java.net.*;\nimport java.util.concurrent.*;\n```\n\nDefine the `ChatServer` class:\n\n```java\npublic class ChatServer {\n    private int port;\n    private ServerSocket serverSocket;\n    private ConcurrentHashMap<String, ClientHandler> clients;\n    private boolean isRunning;\n\n    public ChatServer(int port) {\n        this.port = port;\n        this.clients = new ConcurrentHashMap<>();\n        this.isRunning = false;\n    }\n\n    public void start() throws IOException {\n        serverSocket = new ServerSocket(port);\n        isRunning = true;\n        System.out.println(\"Chat server started on port \" + port);\n\n        while (isRunning) {\n            Socket clientSocket = serverSocket.accept();\n            System.out.println(\"New client connected\");\n\n            // Read username from client\n            BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n            String username = in.readLine();\n\n            // Check if username is already taken\n            if (clients.containsKey(username)) {\n                PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true);\n                out.println(\"Username already taken. Please choose another one.\");\n                clientSocket.close();\n                continue;\n            }\n\n            // Add client to the list\n            ClientHandler clientHandler = new ClientHandler(clientSocket, username, this);\n            clients.put(username, clientHandler);\n\n            // Start a new thread for this client\n            new Thread(clientHandler).start();\n        }\n    }\n\n    public void stop() {\n        isRunning = false;\n        try {\n            serverSocket.close();\n            for (ClientHandler client : clients.values()) {\n                client.stop();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void broadcastMessage(String sender, String message) {\n        for (ClientHandler client : clients.values()) {\n            if (!client.getUsername().equals(sender)) {\n                client.sendMessage(sender + \": \" + message);\n            }\n        }\n    }\n\n    public void removeClient(String username) {\n        clients.remove(username);\n    }\n}\n```\n\nAnd the `ClientHandler` class:\n\n```java\nimport java.io.*;\nimport java.net.*;\n\npublic class ClientHandler implements Runnable {\n    private Socket socket;\n    private String username;\n    private ChatServer server;\n    private PrintWriter out;\n\n    public ClientHandler(Socket socket, String username, ChatServer server) {\n        this.socket = socket;\n        this.username = username;\n        this.server = server;\n    }\n\n    @Override\n    public void run() {\n        try {\n            out = new PrintWriter(socket.getOutputStream(), true);\n            BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\n            String message;\n            while ((message = in.readLine()) != null) {\n                server.broadcastMessage(username, message);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            server.removeClient(username);\n            try {\n                socket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public void sendMessage(String message) {\n        out.println(message);\n    }\n\n    public String getUsername() {\n        return username;\n    }\n\n    public void stop() {\n        try {\n            socket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\nThis is a basic structure. Now, I need to test this server to see if it works as expected.\n\nI can use `telnet` or `netcat` to simulate clients connecting to the server.\n\nFor example, open a terminal and run:\n\n```\ntelnet localhost 12345\n```\n\nThen, enter a username and start sending messages.\n\nI should see messages being broadcasted to other connected clients.\n\nI need to make sure that:\n\n- Multiple clients can connect simultaneously.\n\n- Messages are correctly broadcasted to all connected clients.\n\n- When a client disconnects, it's removed from the list.\n\n- Error handling works as expected, e.g., handling clients that disconnect unexpectedly.\n\nAlso, I should consider edge cases, such as:\n\n- A client trying to use a username that's already taken.\n\n- A client sending multiple messages in quick succession.\n\n- A client sending large messages.\n\n- Handling clients that connect and disconnect rapidly.\n\nI should also think about security, but for a basic chat server, I'll keep it simple and not worry about encryption or authentication for now.\n\nOne thing I should add is a message to inform other clients when a user connects or disconnects.\n\nFor example, when a new user connects, broadcast a message like \"UserX has joined the chat.\"\n\nSimilarly, when a user disconnects, broadcast \"UserX has left the chat.\"\n\nThis will provide better feedback to the users.\n\nLet me modify the `ChatServer` class to include these messages.\n\nIn the `start` method, after adding a new client, broadcast that the user has joined.\n\nIn the `removeClient` method, broadcast that the user has left.\n\nHere's how it can be done:\n\nIn `start` method:\n\n```java\n// Add client to the list\nClientHandler clientHandler = new ClientHandler(clientSocket, username, this);\nclients.put(username, clientHandler);\n\n// Broadcast that the user has joined\nbroadcastMessage(null, username + \" has joined the chat.\");\n\n// Start a new thread for this client\nnew Thread(clientHandler).start();\n```\n\nIn `removeClient` method:\n\n```java\npublic void removeClient(String username) {\n    clients.remove(username);\n    broadcastMessage(null, username + \" has left the chat.\");\n}\n```\n\nAnd in `broadcastMessage`, handle the case when the sender is null:\n\n```java\npublic void broadcastMessage(String sender, String message) {\n    String fullMessage = (sender != null ? sender + \": \" : \"\") + message;\n    for (ClientHandler client : clients.values()) {\n        client.sendMessage(fullMessage);\n    }\n}\n```\n\nThis way, join and leave messages don't include a sender prefix.\n\nAlso, I should handle the case where a client sends an empty message or a message with only whitespace.\n\nMaybe ignore such messages or send a warning to the client.\n\nBut for simplicity, I'll just broadcast whatever the client sends.\n\nAnother consideration is flood control or rate limiting to prevent a single client from overwhelming the server by sending too many messages too quickly.\n\nBut implementing that is beyond the scope of this basic chat server.\n\nI should also think about how to handle large numbers of clients.\n\nJava's thread per client model might not scale well with thousands of clients.\n\nBut for a basic implementation, it should be fine.\n\nIf I were to make this server handle a large number of clients, I'd look into more efficient threading models, like using a thread pool or asynchronous I/O.\n\nBut again, that's beyond the current scope.\n\nLet me think about logging.\n\nIt would be useful to have some logging to see what's happening on the server, like when clients connect or disconnect, and perhaps when messages are broadcasted.\n\nI can use `System.out.println` for logging for now.\n\nIn a more production-ready application, I'd use a proper logging framework like Log4j.\n\nAlso, I should consider exception handling in more detail.\n\nFor example, what if there's an error reading from a client's input stream?\n\nI should make sure that the client is removed from the list and their socket is closed properly.\n\nSimilarly, handle any I/O errors gracefully without crashing the server.\n\nIn the `ClientHandler` class, the `run` method already catches `IOException` and removes the client upon disconnection.\n\nI should make sure that all resources are closed in the `finally` block.\n\nAlso, in the `stop` method of `ChatServer`, I need to make sure that all client threads are stopped properly.\n\nMaybe call `stop` on each `ClientHandler` to close their sockets.\n\nWait, in the `ClientHandler` class, the `stop` method already tries to close the socket.\n\nBut I need to make sure that the `run` method handles the socket closure correctly.\n\nAdditionally, I should consider using try-with-resources for the input and output streams to ensure they're closed properly.\n\nHowever, in this case, since I need to keep the streams open for the duration of the client's connection, I can't use try-with-resources in the `run` method.\n\nInstead, I need to close them explicitly in the `finally` block.\n\nLet me adjust the `ClientHandler` class to ensure that streams are closed properly.\n\nHere's an updated version:\n\n```java\nimport java.io.*;\nimport java.net.*;\n\npublic class ClientHandler implements Runnable {\n    private Socket socket;\n    private String username;\n    private ChatServer server;\n    private PrintWriter out;\n    private BufferedReader in;\n\n    public ClientHandler(Socket socket, String username, ChatServer server) {\n        this.socket = socket;\n        this.username = username;\n        this.server = server;\n    }\n\n    @Override\n    public void run() {\n        try {\n            out = new PrintWriter(socket.getOutputStream(), true);\n            in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\n            String message;\n            while ((message = in.readLine()) != null) {\n                server.broadcastMessage(username, message);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                if (in != null) in.close();\n                if (out != null) out.close();\n                socket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            server.removeClient(username);\n        }\n    }\n\n    public void sendMessage(String message) {\n        out.println(message);\n    }\n\n    public String getUsername() {\n        return username;\n    }\n\n    public void stop() {\n        try {\n            socket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\nThis ensures that input and output streams are closed when the client disconnects.\n\nNow, I need to test this implementation.\n\nI can open multiple terminal windows and use `telnet` or `nc` (netcat) to connect to the server.\n\nFor example:\n\n```\ntelnet localhost 12345\n```\n\nThen, enter a username and start sending messages.\n\nI should see messages being broadcasted to all connected clients.\n\nI should also test scenarios where clients disconnect abruptly, such as by closing the telnet session.\n\nMake sure that the server handles these disconnections properly and removes the client from the list.\n\nAdditionally, test that multiple clients can connect with different usernames and send messages simultaneously.\n\nI should also check for any threading issues, such as race conditions or concurrency errors.\n\nSince I'm using a `ConcurrentHashMap` for the list of clients, which is thread-safe, the risk of concurrency issues is minimized.\n\nHowever, I should still test thoroughly to ensure that there are no bugs in the implementation.\n\nAnother aspect to consider is the performance under load.\n\nWith a moderate number of clients, the server should perform adequately.\n\nBut for a large number of clients, the thread per client model might become inefficient due to the overhead of managing many threads.\n\nIn such cases, more advanced techniques like NIO (Non-Blocking I/O) or using a thread pool would be necessary.\n\nBut for now, with a small number of clients, it should be fine.\n\nLet me think about extending this basic chat server with some additional features.\n\nFor example, private messaging, where a client can send a message to another specific client rather than broadcasting to all.\n\nTo implement private messaging, clients would need to send messages prefixed with the recipient's username.\n\nThe server would then route the message only to the specified recipient, if they are online.\n\nAnother feature could be user lists, where clients can request a list of currently connected users.\n\nThe server could handle a specific command, like \"/users\", to send back the list of usernames.\n\nAlso, support for typing indicators or message timestamps could be added for a richer chat experience.\n\nBut these are enhancements and can be considered beyond the basic requirements.\n\nFor now, I'll stick with the core functionality of connecting multiple clients and broadcasting messages.\n\nOne more thing: error handling in the client connection acceptance loop.\n\nIf there's an error accepting a connection, it should be logged, but the server should continue accepting other connections.\n\nSimilarly, if there's an error reading from a client, only that client should be disconnected without affecting others.\n\nI need to make sure that exceptions in one client's thread don't bring down the entire server.\n\nSince each client is handled in its own thread, exceptions in one thread shouldn't affect others, as long as each thread properly handles its own exceptions.\n\nHowever, to be safe, I should make sure that the `run` method in `ClientHandler` catches all exceptions and doesn't let them propagate to the thread's uncaught exception handler.\n\nI already have a catch block for `IOException`, but I could add a more general catch clause for any exceptions.\n\nHere's an updated `run` method:\n\n```java\n@Override\npublic void run() {\n    try {\n        out = new PrintWriter(socket.getOutputStream(), true);\n        in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\n        String message;\n        while ((message = in.readLine()) != null) {\n            server.broadcastMessage(username, message);\n        }\n    } catch (IOException e) {\n        e.printStackTrace();\n    } catch (Exception e) {\n        e.printStackTrace();\n    } finally {\n        try {\n            if (in != null) in.close();\n            if (out != null) out.close();\n            socket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        server.removeClient(username);\n    }\n}\n```\n\nThis catches any general exceptions and ensures that resources are closed in the `finally` block.\n\nI should also consider implementing a heartbeat mechanism to detect disconnected clients that haven't sent any data for a while.\n\nBut for now, relying on the socket's read timeout to detect disconnections should suffice.\n\nAnother consideration is message buffering.\n\nIf a client sends multiple messages quickly, they should be buffered and sent one by one.\n\nThe `PrintWriter` in Java buffers the output by default, so this should be handled.\n\nHowever, to ensure that messages are sent immediately, I've set auto-flush to true in the `PrintWriter` constructor.\n\nLet me confirm that:\n\n```java\nout = new PrintWriter(socket.getOutputStream(), true);\n```\n\nThe second parameter `true` enables auto-flush, so each println should be sent immediately.\n\nThis is important for real-time chat applications.\n\nI should also make sure that message boundaries are preserved.\n\nSince I'm using `readLine()` to read messages, each message should be terminated with a newline character.\n\nClients need to ensure that they send messages with newline terminators.\n\nIn the `telnet` or `netcat` clients, typing a message and pressing enter should send the message with a newline.\n\nIn a real client application, I'd need to make sure to append a newline when sending messages.\n\nNow, let's think about how to stop the server gracefully.\n\nIn the `stop` method of `ChatServer`, I set `isRunning` to false and close the server socket.\n\nThis will cause the acceptance loop to exit.\n\nHowever, I need to make sure that all client threads are also stopped and their resources are released.\n\nIn the `stop` method, I iterate over the clients and call their `stop` methods, which close their sockets.\n\nThis should cause their `run` methods to exit, cleaning up their resources.\n\nI should also consider joining the client threads to ensure that they have finished before the server exits.\n\nBut since joining threads can block, and there might be many clients, this could take time.\n\nAlternatively, I can set a timeout for joining threads.\n\nBut for simplicity, I'll just close the sockets and let the threads exit on their own.\n\nHere's the `stop` method again:\n\n```java\npublic void stop() {\n    isRunning = false;\n    try {\n        serverSocket.close();\n        for (ClientHandler client : clients.values()) {\n            client.stop();\n        }\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}\n```\n\nI need to make sure that closing the socket in `client.stop()` will cause the `readLine()` in the `run` method to throw an exception, breaking the loop and allowing the thread to clean up.\n\nYes, closing the socket should trigger an `IOException` in the read operation, which is caught and handled appropriately.\n\nAlright, I think this covers the basic requirements for the chat server.\n\nTo summarize, the server:\n\n- Listens on a specified port for incoming client connections.\n\n- Accepts connections and reads usernames from clients.\n\n- Manages each client in a separate thread using the `ClientHandler` class.\n\n- Broadcasts messages from clients to all other connected clients.\n\n- Handles client disconnections gracefully, removing them from the list and broadcasting disconnection messages.\n\n- Includes basic error handling for I/O exceptions and other errors.\n\nNext steps would be to write a simple chat client to test the server and ensure that it functions as expected.\n\nI can also enhance the server with additional features like private messaging, user lists, and better error handling.\n\nBut for now, this should serve as a solid foundation for a basic chat server using Java sockets.\n\n## Final Solution\nTo create a basic chat server in Java using sockets that allows multiple clients to connect, send messages to each other, and disconnect gracefully, follow the steps below. This solution includes proper error handling and thread management.\n\n### Solution Code\n\n```java\nimport java.io.*;\nimport java.net.*;\nimport java.util.concurrent.*;\n\npublic class ChatServer {\n    private int port;\n    private ServerSocket serverSocket;\n    private ConcurrentHashMap<String, ClientHandler> clients;\n    private boolean isRunning;\n\n    public ChatServer(int port) {\n        this.port = port;\n        this.clients = new ConcurrentHashMap<>();\n        this.isRunning = false;\n    }\n\n    public void start() throws IOException {\n        serverSocket = new ServerSocket(port);\n        isRunning = true;\n        System.out.println(\"Chat server started on port \" + port);\n\n        while (isRunning) {\n            Socket clientSocket = serverSocket.accept();\n            System.out.println(\"New client connected\");\n\n            // Read username from client\n            BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));\n            String username = in.readLine();\n\n            // Check if username is already taken\n            if (clients.containsKey(username)) {\n                PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true);\n                out.println(\"Username already taken. Please choose another one.\");\n                clientSocket.close();\n                continue;\n            }\n\n            // Add client to the list\n            ClientHandler clientHandler = new ClientHandler(clientSocket, username, this);\n            clients.put(username, clientHandler);\n\n            // Broadcast that the user has joined\n            broadcastMessage(null, username + \" has joined the chat.\");\n\n            // Start a new thread for this client\n            new Thread(clientHandler).start();\n        }\n    }\n\n    public void stop() {\n        isRunning = false;\n        try {\n            serverSocket.close();\n            for (ClientHandler client : clients.values()) {\n                client.stop();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public void broadcastMessage(String sender, String message) {\n        String fullMessage = (sender != null ? sender + \": \" : \"\") + message;\n        for (ClientHandler client : clients.values()) {\n            client.sendMessage(fullMessage);\n        }\n    }\n\n    public void removeClient(String username) {\n        clients.remove(username);\n        broadcastMessage(null, username + \" has left the chat.\");\n    }\n\n    public static void main(String[] args) {\n        try {\n            ChatServer server = new ChatServer(12345);\n            server.start();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\nclass ClientHandler implements Runnable {\n    private Socket socket;\n    private String username;\n    private ChatServer server;\n    private PrintWriter out;\n    private BufferedReader in;\n\n    public ClientHandler(Socket socket, String username, ChatServer server) {\n        this.socket = socket;\n        this.username = username;\n        this.server = server;\n    }\n\n    @Override\n    public void run() {\n        try {\n            out = new PrintWriter(socket.getOutputStream(), true);\n            in = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\n            String message;\n            while ((message = in.readLine()) != null) {\n                server.broadcastMessage(username, message);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                if (in != null) in.close();\n                if (out != null) out.close();\n                socket.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            server.removeClient(username);\n        }\n    }\n\n    public void sendMessage(String message) {\n        out.println(message);\n    }\n\n    public String getUsername() {\n        return username;\n    }\n\n    public void stop() {\n        try {\n            socket.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n### Explanation\n\n1. **ChatServer Class**:\n    - Manages the server socket and accepts incoming client connections.\n    - Handles multiple clients using separate threads.\n    - Broadcasts messages from one client to all other connected clients.\n    - Manages client additions and removals, including broadcasting join and leave messages.\n\n2. **ClientHandler Class**:\n    - Manages individual client connections.\n    - Reads messages from the client and sends them to the server for broadcasting.\n    - Handles client disconnections and ensures proper resource cleanup.\n\n3. **Main Method**:\n    - Initializes and starts the chat server on port 12345.\n\nThis setup ensures that the chat server can handle multiple clients simultaneously, broadcast messages effectively, and manage client connections and disconnections gracefully."
    }
]