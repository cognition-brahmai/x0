[
    {
        "role": "user",
        "content": "Develop a C program that performs matrix multiplication using multi-threading. The user should be able to input two matrices and the number of threads to use for computation. Ensure proper synchronization between threads. PLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Alright, I'm going to help you create a C program that performs matrix multiplication using multi-threading. We'll use the POSIX Threads (pthreads) library for threading and ensure proper synchronization between threads. Here's a step-by-step guide to achieve this.\n\n### Step 1: Include Necessary Headers\n\nFirst, include the required headers for input/output, thread management, and synchronization.\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <pthread.h>\n```\n\n### Step 2: Define Global Variables\n\nWe need global variables to store matrices and thread-related data.\n\n```c\n#define MAX_SIZE 100\n\nint matrixA[MAX_SIZE][MAX_SIZE];\nint matrixB[MAX_SIZE][MAX_SIZE];\nint matrixC[MAX_SIZE][MAX_SIZE];\nint rowsA, colsA, rowsB, colsB;\nint numThreads;\n```\n\n### Step 3: Get Matrix Dimensions and Data from User\n\nWrite functions to get matrix dimensions and data from the user.\n\n```c\nvoid getMatrixDimensions() {\n    printf(\"Enter dimensions of matrix A (rows columns): \");\n    scanf(\"%d %d\", &rowsA, &colsA);\n    \n    printf(\"Enter dimensions of matrix B (rows columns): \");\n    scanf(\"%d %d\", &rowsB, &colsB);\n    \n    if (colsA != rowsB) {\n        printf(\"Matrix multiplication not possible.\\n\");\n        exit(1);\n    }\n}\n\nvoid getMatrixData(int matrix[rowsA][colsA], char* name) {\n    printf(\"Enter elements of matrix %s:\\n\", name);\n    for (int i = 0; i < rowsA; i++) {\n        for (int j = 0; j < colsA; j++) {\n            scanf(\"%d\", &matrix[i][j]);\n        }\n    }\n}\n```\n\n### Step 4: Create Thread Function\n\nDefine a thread function that calculates a portion of the resulting matrix.\n\n```c\ntypedef struct {\n    int startRow;\n    int endRow;\n} ThreadArgs;\n\nvoid* multiplyMatrices(void* args) {\n    ThreadArgs* threadArgs = (ThreadArgs*) args;\n    int startRow = threadArgs->startRow;\n    int endRow = threadArgs->endRow;\n    \n    for (int i = startRow; i < endRow; i++) {\n        for (int j = 0; j < colsB; j++) {\n            matrixC[i][j] = 0;\n            for (int k = 0; k < colsA; k++) {\n                matrixC[i][j] += matrixA[i][k] * matrixB[k][j];\n            }\n        }\n    }\n    \n    pthread_exit(NULL);\n}\n```\n\n### Step 5: Main Function\n\nIn the main function, get user input, create threads, and wait for them to complete.\n\n```c\nint main() {\n    getMatrixDimensions();\n    \n    getMatrixData(matrixA, \"A\");\n    getMatrixData(matrixB, \"B\");\n    \n    printf(\"Enter the number of threads to use: \");\n    scanf(\"%d\", &numThreads);\n    \n    if (numThreads > rowsA) {\n        printf(\"Number of threads cannot exceed the number of rows in matrix A.\\n\");\n        exit(1);\n    }\n    \n    pthread_t threads[numThreads];\n    ThreadArgs threadArgs[numThreads];\n    \n    int rowsPerThread = rowsA / numThreads;\n    int remainingRows = rowsA % numThreads;\n    int startRow = 0;\n    \n    for (int i = 0; i < numThreads; i++) {\n        int endRow = startRow + rowsPerThread;\n        if (remainingRows > 0) {\n            endRow++;\n            remainingRows--;\n        }\n        \n        threadArgs[i].startRow = startRow;\n        threadArgs[i].endRow = endRow;\n        \n        pthread_create(&threads[i], NULL, multiplyMatrices, (void*) &threadArgs[i]);\n        \n        startRow = endRow;\n    }\n    \n    for (int i = 0; i < numThreads; i++) {\n        pthread_join(threads[i], NULL);\n    }\n    \n    // Print the result matrix\n    printf(\"Resultant Matrix:\\n\");\n    for (int i = 0; i < rowsA; i++) {\n        for (int j = 0; j < colsB; j++) {\n            printf(\"%d \", matrixC[i][j]);\n        }\n        printf(\"\\n\");\n    }\n    \n    return 0;\n}\n```\n\n### Explanation\n\n1. **Headers and Global Variables:** We include necessary headers and define global variables for matrices and thread-related data.\n2. **Getting Matrix Dimensions and Data:** Functions to get matrix dimensions and data from the user.\n3. **Thread Function:** Each thread calculates a portion of the resultant matrix based on its assigned row range.\n4. **Main Function:** Get user input, create and manage threads, and print the result.\n\nThis program ensures that matrix multiplication is performed efficiently using multiple threads, with proper synchronization handled by the pthreads library."
    }
]