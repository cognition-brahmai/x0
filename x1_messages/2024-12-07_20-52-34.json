[
    {
        "role": "user",
        "content": "Implement a binary search tree in C++ with the following functionalities: insertion, deletion, searching for an element, and finding the height of the tree."
    },
    {
        "role": "assistant",
        "content": "Sure! I can help you with that. Implementing a binary search tree (BST) in C++ involves creating a structure for the nodes and defining functions for insertion, deletion, searching, and finding the height of the tree.\n\nFirst, let's define the structure for the nodes. Each node in a BST contains a key value, and pointers to its left and right children.\n\n```cpp\nstruct Node {\n    int key;\n    Node* left;\n    Node* right;\n    Node(int k) : key(k), left(nullptr), right(nullptr) {}\n};\n```\n\n## Insertion\nInsertion in a BST involves finding the correct position for the new node based on its key value and linking it appropriately.\n\n```cpp\nNode* insert(Node* root, int key) {\n    if (root == nullptr) {\n        return new Node(key);\n    }\n    if (key < root->key) {\n        root->left = insert(root->left, key);\n    } else if (key > root->key) {\n        root->right = insert(root->right, key);\n    }\n    return root;\n}\n```\n\n## Deletion\nDeletion is a bit more complex. It involves three cases:\n1. The node to be deleted is a leaf node.\n2. The node has one child.\n3. The node has two children.\n\nFor the third case, we find the in-order successor (smallest in the right subtree) and replace the node's key with it, then delete the in-order successor.\n\n```cpp\nNode* minValueNode(Node* node) {\n    while (node->left != nullptr) {\n        node = node->left;\n    }\n    return node;\n}\n\nNode* deleteNode(Node* root, int key) {\n    if (root == nullptr) {\n        return root;\n    }\n    if (key < root->key) {\n        root->left = deleteNode(root->left, key);\n    } else if (key > root->key) {\n        root->right = deleteNode(root->right, key);\n    } else {\n        if (root->left == nullptr) {\n            Node* temp = root->right;\n            delete root;\n            return temp;\n        } else if (root->right == nullptr) {\n            Node* temp = root->left;\n            delete root;\n            return temp;\n        }\n        Node* temp = minValueNode(root->right);\n        root->key = temp->key;\n        root->right = deleteNode(root->right, temp->key);\n    }\n    return root;\n}\n```\n\n## Searching\nSearching for an element in a BST involves comparing the key with the current node and deciding to go left or right accordingly.\n\n```cpp\nNode* search(Node* root, int key) {\n    if (root == nullptr || root->key == key) {\n        return root;\n    }\n    if (key < root->key) {\n        return search(root->left, key);\n    }\n    return search(root->right, key);\n}\n```\n\n## Finding the Height\nThe height of a BST is the length of the longest path from the root to a leaf. We can find it recursively.\n\n```cpp\nint height(Node* root) {\n    if (root == nullptr) {\n        return 0;\n    }\n    int leftHeight = height(root->left);\n    int rightHeight = height(root->right);\n    return 1 + std::max(leftHeight, rightHeight);\n}\n```\n\n## Full Code\nHere's the full code combining all the above functionalities:\n\n```cpp\n#include <iostream>\n#include <algorithm>\n\nstruct Node {\n    int key;\n    Node* left;\n    Node* right;\n    Node(int k) : key(k), left(nullptr), right(nullptr) {}\n};\n\nNode* insert(Node* root, int key) {\n    if (root == nullptr) {\n        return new Node(key);\n    }\n    if (key < root->key) {\n        root->left = insert(root->left, key);\n    } else if (key > root->key) {\n        root->right = insert(root->right, key);\n    }\n    return root;\n}\n\nNode* minValueNode(Node* node) {\n    while (node->left != nullptr) {\n        node = node->left;\n    }\n    return node;\n}\n\nNode* deleteNode(Node* root, int key) {\n    if (root == nullptr) {\n        return root;\n    }\n    if (key < root->key) {\n        root->left = deleteNode(root->left, key);\n    } else if (key > root->key) {\n        root->right = deleteNode(root->right, key);\n    } else {\n        if (root->left == nullptr) {\n            Node* temp = root->right;\n            delete root;\n            return temp;\n        } else if (root->right == nullptr) {\n            Node* temp = root->left;\n            delete root;\n            return temp;\n        }\n        Node* temp = minValueNode(root->right);\n        root->key = temp->key;\n        root->right = deleteNode(root->right, temp->key);\n    }\n    return root;\n}\n\nNode* search(Node* root, int key) {\n    if (root == nullptr || root->key == key) {\n        return root;\n    }\n    if (key < root->key) {\n        return search(root->left, key);\n    }\n    return search(root->right, key);\n}\n\nint height(Node* root) {\n    if (root == nullptr) {\n        return 0;\n    }\n    int leftHeight = height(root->left);\n    int rightHeight = height(root->right);\n    return 1 + std::max(leftHeight, rightHeight);\n}\n\nint main() {\n    Node* root = nullptr;\n    root = insert(root, 50);\n    insert(root, 30);\n    insert(root, 20);\n    insert(root, 40);\n    insert(root, 70);\n    insert(root, 60);\n    insert(root, 80);\n\n    // Search for an element\n    int searchKey = 40;\n    Node* result = search(root, searchKey);\n    if (result != nullptr) {\n        std::cout << \"Found \" << searchKey << std::endl;\n    } else {\n        std::cout << searchKey << \" not found\" << std::endl;\n    }\n\n    // Delete an element\n    int deleteKey = 20;\n    root = deleteNode(root, deleteKey);\n    std::cout << deleteKey << \" deleted from the tree\" << std::endl;\n\n    // Find height of the tree\n    std::cout << \"Height of the tree is \" << height(root) << std::endl;\n\n    return 0;\n}\n```\n\nThis code provides a basic implementation of a BST with insertion, deletion, searching, and finding the height. You can expand upon this by adding more functionalities like in-order traversal for printing the tree, etc."
    }
]