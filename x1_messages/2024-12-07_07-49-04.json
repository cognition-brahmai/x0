[
    {
        "role": "user",
        "content": "Develop a FastAPI application with an endpoint that accepts a JSON payload containing a list of numbers and returns their mean, median, and mode.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Alright, I've got this task to create a FastAPI application with an endpoint that calculates the mean, median, and mode from a list of numbers provided in a JSON payload. Sounds straightforward, but I need to make sure I cover all the bases here.\n\nFirst things first, I need to set up a FastAPI project. I'm assuming I have Python installed, and I should probably use a virtual environment to keep dependencies neat. So, I'll start by creating a new directory for this project and setting up a virtual environment inside it.\n\nOnce that's done, I'll install FastAPI and Uvicorn. FastAPI is the web framework I'll use to build the API, and Uvicorn is an ASGI server that can run the application.\n\n```bash\nmkdir fastapi_stats\ncd fastapi_stats\npython -m venv venv\nsource venv/bin/activate  # On Windows, use `venv\\Scripts\\activate`\npip install fastapi uvicorn\n```\n\nNow, I need to create the main application file. Let's call it `main.py`. In this file, I'll import the necessary modules from FastAPI and define my endpoint.\n\nBut before diving into code, I should think about the requirements. The endpoint should accept a JSON payload with a list of numbers. From that list, it needs to calculate the mean, median, and mode, and return them in a JSON response.\n\nLet me recall what these statistics are:\n\n- **Mean**: The average of the numbers, calculated by summing all numbers and dividing by the count.\n\n- **Median**: The middle value when the numbers are sorted. If there's an even number of elements, it's usually the average of the two middle numbers.\n\n- **Mode**: The number that appears most frequently in the list. There can be multiple modes if multiple numbers appear with the same highest frequency.\n\nSo, I need to handle all these calculations accurately.\n\nFirst, I'll set up the FastAPI app and define a POST endpoint, say `/stats`, that accepts a JSON payload.\n\nThe JSON payload should look something like this:\n\n```json\n{\n    \"numbers\": [1, 2, 3, 4, 5]\n}\n```\n\nI need to define a Pydantic model to validate this input.\n\nPydantic is great for data validation and serialization. I'll use it to ensure that the input is a list of numbers.\n\nLet me sketch this out:\n\n1. Define a Pydantic model for the input data.\n\n2. Create a FastAPI endpoint that accepts this model as input.\n\n3. Inside the endpoint, calculate mean, median, and mode.\n\n4. Return the results as a JSON response.\n\nSounds plan.\n\nLet me start by defining the Pydantic model.\n\nI need a model that has a single attribute: `numbers`, which is a list of floats or integers.\n\nIn Pydantic, I can define this easily.\n\nAlso, for the response, I should define another model that includes mean, median, and mode.\n\nWait, do I need to? FastAPI is smart enough to handle dictionaries as responses, but using a response model can make things clearer and handle data validation on the way out.\n\nSo, perhaps defining a response model is a good idea.\n\nLet me think about data types:\n\n- Mean, median, and mode could be floats.\n\n- Mode might have multiple values, so it could be a list.\n\nOkay, so the response model could look like this:\n\n```python\nfrom pydantic import BaseModel\n\nclass StatsResponse(BaseModel):\n    mean: float\n    median: float\n    mode: List[float]\n```\n\nWait, `List` needs to be imported from `typing`.\n\nSo, I need to import `List` from `typing`.\n\nAlso, in Pydantic models, types are specified with annotations.\n\nNow, for calculating the statistics:\n\n- **Mean**: Sum of all numbers divided by the count.\n\n- **Median**: Middle value of the sorted list. If the list has an even number of elements, it's the average of the two middle numbers.\n\n- **Mode**: The number(s) that appear most frequently. If there are multiple numbers with the same highest frequency, all of them should be returned.\n\nI need to handle the mode correctly, as there can be multiple modes.\n\nPython's statistics module has functions for mean and median, but for mode, it only returns the smallest mode in a multimodal set.\n\nWait, no. The `statistics.mode` function raises a `StatisticsError` if there are multiple modes.\n\nSo, I need to implement my own mode calculation to handle multimodal cases.\n\nAlright, I need to write a function to calculate the mode correctly.\n\nLet me think about how to do that.\n\nI can use the `Counter` class from the `collections` module to count the frequency of each number.\n\nThen, find the maximum frequency and collect all numbers that have that frequency.\n\nThat should give me all modes.\n\nGood.\n\nNow, for the mean and median, I can use the `statistics` module, but I'll implement them manually for better control.\n\nLet me see.\n\nImplementing mean is straightforward: sum of all numbers divided by the count.\n\nFor median, I need to sort the list and find the middle value(s).\n\nIf the list has an even number of elements, the median is the average of the two middle numbers.\n\nOkay, I can handle that.\n\nError handling is important here.\n\nWhat if the input list is empty? Division by zero for mean and mode doesn't make sense.\n\nFor median, depending on the definition, it could be undefined, but perhaps I can return null or an appropriate message.\n\nBut to keep it simple, I'll assume the input list has at least one number.\n\nI should probably validate that the list is not empty.\n\nAlso, ensure that all elements in the list are numbers.\n\nPydantic should handle that since I'm defining the input model with a list of floats.\n\nBut better to have some checks in place.\n\nAlso, think about performance. Since FastAPI is fast, and these calculations are simple, performance shouldn't be an issue for reasonable list sizes.\n\nBut, for very large lists, calculating these statistics might take some time, but that's beyond the scope of this task.\n\nI'll assume the list is manageable.\n\nLet me outline the steps again:\n\n1. Define an input model with a list of floats.\n\n2. Define a response model with mean, median, and mode.\n\n3. Create a FastAPI app and a POST endpoint at `/stats`.\n\n4. Inside the endpoint, calculate mean, median, and mode from the input list.\n\n5. Return the results as a JSON response.\n\nNow, let's think about the code structure.\n\nI'll need to import FastAPI, Pydantic, and other necessary modules.\n\nI'll organize the code neatly, with clear function definitions for calculating mean, median, and mode.\n\nThis makes the code more readable and testable.\n\nLet me sketch this out.\n\nFirst, imports:\n\n```python\nfrom fastapi import FastAPI\nfrom pydantic import BaseModel\nfrom typing import List\nfrom statistics import mean, median\nfrom collections import Counter\n```\n\nWait, but I want to implement mean and median manually, not use the statistics module.\n\nSo, I can omit importing mean and median from statistics.\n\nBut, if I change my mind later, it's okay.\n\nFor now, I'll implement them manually.\n\nSo, define functions for mean, median, and mode.\n\nMean:\n\n```python\ndef calculate_mean(numbers: List[float]) -> float:\n    return sum(numbers) / len(numbers)\n```\n\nMedian:\n\n```python\ndef calculate_median(numbers: List[float]) -> float:\n    sorted_numbers = sorted(numbers)\n    n = len(sorted_numbers)\n    mid = n // 2\n    if n % 2 == 0:\n        return (sorted_numbers[mid - 1] + sorted_numbers[mid]) / 2\n    else:\n        return sorted_numbers[mid]\n```\n\nMode:\n\n```python\ndef calculate_mode(numbers: List[float]) -> List[float]:\n    counter = Counter(numbers)\n    max_count = max(counter.values())\n    return [num for num, count in counter.items() if count == max_count]\n```\n\nThese functions look good.\n\nNow, define the input model:\n\n```python\nclass StatsRequest(BaseModel):\n    numbers: List[float]\n```\n\nAnd the response model:\n\n```python\nclass StatsResponse(BaseModel):\n    mean: float\n    median: float\n    mode: List[float]\n```\n\nNow, create the FastAPI app and the endpoint:\n\n```python\napp = FastAPI()\n\n@app.post(\"/stats\", response_model=StatsResponse)\nasync def get_stats(stats: StatsRequest):\n    numbers = stats.numbers\n    mean_val = calculate_mean(numbers)\n    median_val = calculate_median(numbers)\n    mode_val = calculate_mode(numbers)\n    return StatsResponse(mean=mean_val, median=median_val, mode=mode_val)\n```\n\nThis seems straightforward.\n\nBut, I should consider edge cases.\n\nFor example:\n\n- If the list has only one number, mean, median, and mode should all be that number.\n\n- If the list has multiple modes, mode should return a list of all modes.\n\n- If all numbers appear only once, mode should return all numbers.\n\nWait, no. If all numbers appear only once, there is no mode, or all numbers are modes, depending on the definition.\n\nIn statistics, if all values have the same frequency, some definitions consider there to be no mode, while others consider all values to be modes.\n\nI'll go with returning all numbers as modes in this case.\n\nAnother consideration: handling non-numeric inputs.\n\nBut since I've defined the input model with List[float], FastAPI should handle validation and return an appropriate error if non-numeric values are provided.\n\nAlso, ensure that the list is not empty.\n\nIf the list is empty, division by zero in mean calculation will occur.\n\nTo prevent this, I can add a check at the beginning of the endpoint.\n\nLike this:\n\n```python\nif not numbers:\n    raise HTTPException(status_code=400, detail=\"List of numbers cannot be empty\")\n```\n\nYes, that's a good idea.\n\nSo, import `HTTPException` from `fastapi`.\n\nNow, put it all together.\n\nLet me write the complete code.\n\n## Final Solution\nTo create a FastAPI application with an endpoint that accepts a JSON payload containing a list of numbers and returns their mean, median, and mode, follow these steps:\n\n### Solution Code\n\n```python\nfrom fastapi import FastAPI, HTTPException\nfrom pydantic import BaseModel\nfrom typing import List\nfrom collections import Counter\n\napp = FastAPI()\n\nclass StatsRequest(BaseModel):\n    numbers: List[float]\n\nclass StatsResponse(BaseModel):\n    mean: float\n    median: float\n    mode: List[float]\n\ndef calculate_mean(numbers: List[float]) -> float:\n    return sum(numbers) / len(numbers)\n\ndef calculate_median(numbers: List[float]) -> float:\n    sorted_numbers = sorted(numbers)\n    n = len(sorted_numbers)\n    mid = n // 2\n    if n % 2 == 0:\n        return (sorted_numbers[mid - 1] + sorted_numbers[mid]) / 2\n    else:\n        return sorted_numbers[mid]\n\ndef calculate_mode(numbers: List[float]) -> List[float]:\n    counter = Counter(numbers)\n    max_count = max(counter.values())\n    return [num for num, count in counter.items() if count == max_count]\n\n@app.post(\"/stats\", response_model=StatsResponse)\nasync def get_stats(stats: StatsRequest):\n    numbers = stats.numbers\n    if not numbers:\n        raise HTTPException(status_code=400, detail=\"List of numbers cannot be empty\")\n    mean_val = calculate_mean(numbers)\n    median_val = calculate_median(numbers)\n    mode_val = calculate_mode(numbers)\n    return StatsResponse(mean=mean_val, median=median_val, mode=mode_val)\n```\n\n### Explanation\n\n1. **Setup**: \n   - Ensure Python is installed and set up a virtual environment.\n   - Install FastAPI and Uvicorn using `pip install fastapi uvicorn`.\n\n2. **Project Structure**:\n   - Create a directory for the project (e.g., `fastapi_stats`).\n   - Inside the directory, create a `main.py` file for the application code.\n\n3. **Data Models**:\n   - Define a Pydantic model `StatsRequest` for the input JSON payload containing a list of numbers.\n   - Define another Pydantic model `StatsResponse` for the output JSON response containing mean, median, and mode.\n\n4. **Statistical Calculations**:\n   - Implement functions to calculate mean, median, and mode.\n   - Mean: Sum of numbers divided by the count.\n   - Median: Middle value of the sorted list; average of two middle values if the list has an even number of elements.\n   - Mode: Numbers with the highest frequency in the list.\n\n5. **FastAPI Endpoint**:\n   - Create a POST endpoint `/stats` that accepts JSON input, validates it using the `StatsRequest` model, computes the statistics, and returns the result using the `StatsResponse` model.\n   - Include error handling for empty lists.\n\n6. **Running the Application**:\n   - Use Uvicorn to run the FastAPI application by executing `uvicorn main:app --reload` in the terminal.\n\nThis setup ensures a robust and efficient API for statistical computations on a list of numbers."
    }
]