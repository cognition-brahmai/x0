[
    {
        "role": "user",
        "content": "Create a Java class implementing the LRU (Least Recently Used) cache eviction policy. The class should support insertion, deletion, and retrieval operations with O(1) time complexity."
    },
    {
        "role": "assistant",
        "content": "Sure! Implementing an LRU cache in Java with O(1) time complexity for insertion, deletion, and retrieval operations requires the use of a combination of a HashMap and a Doubly Linked List. The HashMap will provide quick access to the cache elements, while the Doubly Linked List will help maintain the order of elements based on their usage.\n\nHere's a step-by-step guide to creating such a class:\n\n### Step 1: Define the Node Class\nWe need a Node class to represent each element in the Doubly Linked List. Each node will hold the key and value, as well as references to the previous and next nodes.\n\n```java\nclass Node {\n    int key;\n    int value;\n    Node prev;\n    Node next;\n    \n    public Node(int key, int value) {\n        this.key = key;\n        this.value = value;\n    }\n}\n```\n\n### Step 2: Implement the LRUCache Class\nThe LRUCache class will use a HashMap to store the keys and their corresponding nodes, and a Doubly Linked List to maintain the order of usage.\n\n#### Members:\n- `capacity`: The maximum number of elements the cache can hold.\n- `map`: A HashMap to store keys and their corresponding nodes.\n- `head`: A dummy head node to simplify operations.\n- `tail`: A dummy tail node to simplify operations.\n\n#### Methods:\n- `get(int key)`: Retrieves the value of the key if it exists, making it the most recently used.\n- `put(int key, int value)`: Inserts or updates the value of the key, and evicts the least recently used item if the cache exceeds capacity.\n\n### Step 3: Implement the get Method\n- If the key is not found, return -1.\n- If the key is found, move the corresponding node to the head of the list (most recently used) and return its value.\n\n### Step 4: Implement the put Method\n- If the key already exists, update its value and move it to the head (most recently used).\n- If the key does not exist, create a new node and add it to the head.\n- If the cache exceeds capacity, remove the least recently used node (the one before the tail).\n\n### Step 5: Helper Methods\n- `removeNode(Node node)`: Removes a node from the list.\n- `addNode(Node node)`: Adds a node to the head of the list.\n\n### Final Implementation\n\n```java\nimport java.util.HashMap;\n\npublic class LRUCache {\n    private int capacity;\n    private HashMap<Integer, Node> map;\n    private Node head;\n    private Node tail;\n    \n    public LRUCache(int capacity) {\n        this.capacity = capacity;\n        this.map = new HashMap<>();\n        this.head = new Node(0, 0); // Dummy head\n        this.tail = new Node(0, 0); // Dummy tail\n        head.next = tail;\n        tail.prev = head;\n    }\n    \n    public int get(int key) {\n        if (map.containsKey(key)) {\n            Node node = map.get(key);\n            removeNode(node);\n            addNode(node);\n            return node.value;\n        }\n        return -1;\n    }\n    \n    public void put(int key, int value) {\n        if (map.containsKey(key)) {\n            Node node = map.get(key);\n            node.value = value;\n            removeNode(node);\n            addNode(node);\n        } else {\n            if (map.size() >= capacity) {\n                Node toRemove = tail.prev;\n                removeNode(toRemove);\n                map.remove(toRemove.key);\n            }\n            Node newNode = new Node(key, value);\n            map.put(key, newNode);\n            addNode(newNode);\n        }\n    }\n    \n    private void removeNode(Node node) {\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n    }\n    \n    private void addNode(Node node) {\n        node.prev = head;\n        node.next = head.next;\n        head.next.prev = node;\n        head.next = node;\n    }\n    \n    // Node class remains the same as above\n}\n```\n\n### Explanation\n- **get Operation**: O(1) because HashMap lookup is O(1), and list operations are O(1).\n- **put Operation**: O(1) for the same reasons as get, plus potential removal which is also O(1).\n\nThis implementation ensures that both insertion and retrieval operations are efficient, meeting the requirements of an LRU cache with the specified time complexities."
    }
]