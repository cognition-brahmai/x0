[
    {
        "role": "user",
        "content": "Write a Java program that implements a simple text-based chat server using WebSockets. The server should support multiple clients connecting simultaneously, broadcasting messages to all connected clients, and private messaging between clients.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Alright, I'm going to attempt to write a Java program that creates a simple text-based chat server using WebSockets. I need to make sure it supports multiple clients connecting at the same time, can broadcast messages to all connected clients, and also allows for private messaging between clients.\n\nFirst, I need to understand what WebSockets are. WebSockets provide full-duplex communication channels over a single TCP connection. They are widely used for real-time data transfer in web applications, like chat applications.\n\nIn Java, there are several libraries that can help me implement WebSocket servers. One of the most popular is Java API for WebSocket (JSR 356), which is part of the Java EE specification. However, since Java EE is now succeeded by Jakarta EE, I should check if there are any updates there.\n\nAlternatively, I could use a standalone WebSocket server library like Tyrus, which is the reference implementation for JSR 356, or use a more modern framework like Spring Boot, which has built-in support for WebSockets.\n\nSince the requirement is to write a simple text-based chat server, I'll go with the Java API for WebSocket (JSR 356) to keep it straightforward and not introduce additional dependencies like Spring.\n\nSo, to start, I need to set up a WebSocket server using JSR 356. I'll need to create a server endpoint that clients can connect to. Each client will be represented by a Session object, and I'll need to manage a list of these sessions to broadcast messages to all connected clients.\n\nFor private messaging, I'll need a way to identify each client and route messages to specific sessions.\n\nLet me outline the steps I need to follow:\n\n1. Set up a WebSocket server using JSR 356.\n\n2. Create a server endpoint that handles client connections.\n\n3. Maintain a list of connected client sessions.\n\n4. Implement broadcast functionality to send messages to all connected clients.\n\n5. Implement private messaging by allowing clients to specify a recipient and sending messages directly to that recipient's session.\n\n6. Handle client disconnections properly to remove their sessions from the list.\n\nFirst, I need to include the necessary dependencies. Since JSR 356 is part of Java EE, I might need to include a WebSocket implementation library if I'm not using a Java EE container.\n\nI think I'll use the Tyrus library, which is the reference implementation for JSR 356. I can include it via Maven.\n\nSo, I'll set up a Maven project and add the Tyrus dependencies.\n\nHere's the pom.xml:\n\n```xml\n\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n\nxmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\nxsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n\n<modelVersion>4.0.0</modelVersion>\n\n<groupId>com.example</groupId>\n\n<artifactId>websocket-chat-server</artifactId>\n\n<packaging>jar</packaging>\n\n<version>1.0-SNAPSHOT</version>\n\n<name>WebSocket Chat Server</name>\n\n<dependencies>\n\n<dependency>\n\n<groupId>org.glassfish.tyrus</groupId>\n\n<artifactId>tyrus-server</artifactId>\n\n<version>1.17</version>\n\n</dependency>\n\n<dependency>\n\n<groupId>org.glassfish.tyrus</groupId>\n\n<artifactId>tyrus-container-grizzly-server</artifactId>\n\n<version>1.17</version>\n\n</dependency>\n\n</dependencies>\n\n<mainClass>com.example.websocket.chat.server.ChatServer</mainClass>\n\n</build>\n\n</project>\n\n```\n\nNow, I need to create the WebSocket server endpoint.\n\nI'll create a class annotated with `@ServerEndpoint` to define the endpoint URI.\n\nEach client connection will be handled by an instance of this endpoint class, and I'll have access to the `Session` object for each client.\n\nI need to maintain a list of all connected sessions to broadcast messages.\n\nBut since each endpoint instance is specific to a client, I need a static list to hold all sessions.\n\nAlso, to handle concurrent access to this list, I need to make sure it's thread-safe.\n\nI can use a `CopyOnWriteArrayList` for this purpose.\n\nSo, in the endpoint class, I'll have a static `CopyOnWriteArrayList<Session>` to store all connected sessions.\n\nWhen a client connects, their session will be added to this list, and when they disconnect, it will be removed.\n\nFor broadcasting, I'll have a method that iterates over this list and sends a message to each session.\n\nFor private messaging, I'll need a way to identify each client, probably by a unique username or client ID.\n\nSo, I need to assign a unique identifier to each client when they connect.\n\nI can ask the client to send their username once they connect, and then associate that username with their session.\n\nI'll need to store a mapping from username to session.\n\nSo, I'll have a `ConcurrentHashMap<String, Session>` to store usernames and their corresponding sessions.\n\nWhen a client sends a message, I'll check if it's a private message by checking if it starts with something like \"/msg username message\".\n\nIf it is a private message, I'll extract the username and the message, look up the session for that username, and send the message directly to that session.\n\nIf it's not a private message, I'll broadcast it to all connected clients.\n\nI need to implement methods for handling messages from clients, connecting, and disconnecting.\n\nLet me start by creating the endpoint class.\n\nPackage: com.example.websocket.chat.server\n\nClass: ChatServerEndpoint\n\nAnnotations: @ServerEndpoint(\"/chat\")\n\nImports:\n\nimport javax.websocket.*;\n\nimport java.io.IOException;\n\nimport java.util.*;\n\nimport java.util.concurrent.CopyOnWriteArrayList;\n\nimport java.util.concurrent.ConcurrentHashMap;\n\nNow, inside the class, define the static lists:\n\nprivate static CopyOnWriteArrayList<Session> sessions = new CopyOnWriteArrayList<>();\n\nprivate static ConcurrentHashMap<String, Session> userSessions = new ConcurrentHashMap<>();\n\nI need to handle the connection and disconnection events.\n\nSo, I'll implement the `@OnOpen`, `@OnClose`, `@OnMessage`, and `@OnError` methods.\n\nIn `@OnOpen`, I'll add the session to the list and ask the client to send their username.\n\nIn `@OnMessage`, I'll handle incoming messages, check if it's a username registration or a chat message, and act accordingly.\n\nWait, maybe I need a specific message to register the username.\n\nAlternatively, I can require the client to send a JSON object with a \"type\" field, where \"type\" can be \"register\" or \"message\".\n\nFor example, for registration:\n\n{ \"type\": \"register\", \"username\": \"user1\" }\n\nFor a chat message:\n\n{ \"type\": \"message\", \"to\": \"all\", \"content\": \"Hello everyone!\" }\n\nFor a private message:\n\n{ \"type\": \"message\", \"to\": \"user2\", \"content\": \"Hi user2!\" }\n\nThis way, I can parse the JSON and handle it accordingly.\n\nSo, I'll need a JSON library to parse the incoming messages.\n\nI can use org.json library for simplicity.\n\nAdd the dependency to pom.xml:\n\n<dependency>\n\n<groupId>org.json</groupId>\n\n<artifactId>json</artifactId>\n\n<version>20210307</version>\n\n</dependency>\n\nNow, in the `@OnMessage` method, I'll parse the incoming JSON and handle it based on the \"type\" field.\n\nFor registration, I'll store the username-session mapping.\n\nFor messages, I'll check the \"to\" field: if it's \"all\", broadcast to all; if it's a specific username, send it only to that user.\n\nI also need to handle error cases, like invalid JSON, unknown usernames for private messages, etc.\n\nAdditionally, I need to make sure that only registered users can send messages.\n\nSo, perhaps I'll have a set of registered usernames and check against that.\n\nWait, but if I have a ConcurrentHashMap<String, Session> for username to session mapping, I can consider that as the list of registered users.\n\nSo, in `@OnOpen`, I'll add the session to the sessions list, but not add it to userSessions until the user registers their username.\n\nIn `@OnMessage`, if the message is a registration, I'll add the username-session mapping.\n\nIf it's a message, I'll check if the session has a registered username, and proceed accordingly.\n\nAlso, in `@OnClose`, I'll remove the session from both lists.\n\nNow, let's think about how to implement the broadcast method.\n\nI'll have a static method `broadcastMessage(String message)` that iterates over all sessions in the sessions list and sends the message to each session.\n\nSimilarly, for private messaging, I'll have a method `sendMessageToUser(String username, String message)` that retrieves the session for that username and sends the message to it.\n\nI need to handle cases where the username doesn't exist or the session is not available.\n\nI should also consider that usernames need to be unique.\n\nSo, in the registration phase, I need to check if the username is already taken.\n\nIf it is, I need to send an error message back to the client and not allow the registration.\n\nAlso, I need to handle scenarios where a user tries to register multiple times or with different usernames from the same session.\n\nI think I need to keep track of which sessions are already registered and prevent re-registration.\n\nWait, perhaps I can allow only one registration per session.\n\nSo, once a session registers a username, it cannot register another one.\n\nAlso, when a session closes, I'll remove its username from the userSessions map.\n\nNow, let's think about the message format.\n\nI'll stick with JSON for simplicity.\n\nSo, the client sends JSON strings to the server.\n\nThe server sends plain text messages back to the client, including broadcast messages and private messages.\n\nAlternatively, the server can also send JSON messages, but for simplicity, I'll have the server send plain text messages.\n\nSo, the message format from client to server:\n\n{\n\n\"type\": \"register\",\n\n\"username\": \"user1\"\n\n}\n\nor\n\n{\n\n\"type\": \"message\",\n\n\"to\": \"all\",\n\n\"content\": \"Hello everyone!\"\n\n}\n\nor\n\n{\n\n\"type\": \"message\",\n\n\"to\": \"user2\",\n\n\"content\": \"Hi user2!\"\n\n}\n\nAnd the server sends plain text messages to clients.\n\nFor example, for broadcast messages: \"user1: Hello everyone!\"\n\nFor private messages: \"user1 whispers: Hi user2!\"\n\nI need to format the messages appropriately so that clients can display them correctly.\n\nI should also handle cases where the \"to\" field is invalid or the username is not registered.\n\nIn such cases, I can send an error message back to the sender.\n\nWait, but the server doesn't send messages back to the client who sent an invalid message.\n\nRather, I need to broadcast an error message to all clients or just to the sender.\n\nActually, private messages are sent only to the recipient and the sender, while broadcast messages go to all clients.\n\nIf there's an error in sending a private message (e.g., unknown username), I should inform the sender about it.\n\nSo, perhaps in such cases, the server sends an error message back to the sender.\n\nBut since the server sends plain text messages, I need a way to distinguish between normal messages and error messages.\n\nMaybe prefix error messages with \"ERROR: \".\n\nAlternatively, I can have the server send JSON messages as well, but to keep it simple, I'll have the server send plain text messages.\n\nClients can assume that any message starting with \"ERROR: \" is an error message.\n\nNow, let's think about implementing the endpoint methods.\n\nFirst, `@OnOpen`:\n\n@OnOpen\n\npublic void onOpen(Session session) {\n\nsessions.add(session);\n\n}\n\n`@OnClose`:\n\n@OnClose\n\npublic void onClose(Session session) {\n\nsessions.remove(session);\n\nString username = getUsernameForSession(session);\n\nif (username != null) {\n\nuserSessions.remove(username);\n\n}\n\n}\n\nprivate String getUsernameForSession(Session session) {\n\nfor (Map.Entry<String, Session> entry : userSessions.entrySet()) {\n\nif (entry.getValue().equals(session)) {\n\nreturn entry.getKey();\n\n}\n\n}\n\nreturn null;\n\n}\n\n`@OnMessage`:\n\n@OnMessage\n\npublic void onMessage(String message, Session session) {\n\ntry {\n\nJSONObject json = new JSONObject(message);\n\nString type = json.getString(\"type\");\n\nif (\"register\".equals(type)) {\n\nhandleRegistration(json, session);\n\n} else if (\"message\".equals(type)) {\n\nhandleMessage(json, session);\n\n} else {\n\nsendErrorMessage(session, \"Invalid message type\");\n\n}\n\n} catch (JSONException e) {\n\nsendErrorMessage(session, \"Invalid JSON format\");\n\n}\n\n}\n\nprivate void handleRegistration(JSONObject json, Session session) {\n\ntry {\n\nString username = json.getString(\"username\");\n\nif (userSessions.containsValue(session)) {\n\nsendErrorMessage(session, \"Already registered\");\n\nreturn;\n\n}\n\nif (userSessions.containsKey(username)) {\n\nsendErrorMessage(session, \"Username already taken\");\n\nreturn;\n\n}\n\nuserSessions.put(username, session);\n\nbroadcastMessage(username + \" has joined the chat\");\n\n} catch (JSONException e) {\n\nsendErrorMessage(session, \"Missing username in registration\");\n\n}\n\n}\n\nprivate void handleMessage(JSONObject json, Session session) {\n\ntry {\n\nString to = json.getString(\"to\");\n\nString content = json.getString(\"content\");\n\nString username = getUsernameForSession(session);\n\nif (username == null) {\n\nsendErrorMessage(session, \"Not registered\");\n\nreturn;\n\n}\n\nif (\"all\".equals(to)) {\n\nbroadcastMessage(username + \": \" + content);\n\n} else {\n\nSession recipientSession = userSessions.get(to);\n\nif (recipientSession != null) {\n\nString whisperMessage = username + \" whispers to \" + to + \": \" + content;\n\nrecipientSession.getBasicRemote().sendText(whisperMessage);\n\nsession.getBasicRemote().sendText(whisperMessage);\n\n} else {\n\nsendErrorMessage(session, \"User \" + to + \" not found\");\n\n}\n\n}\n\n} catch (JSONException e) {\n\nsendErrorMessage(session, \"Invalid message format\");\n\n} catch (IOException e) {\n\ne.printStackTrace();\n\n}\n\n}\n\nprivate void sendErrorMessage(Session session, String errorMessage) {\n\ntry {\n\nsession.getBasicRemote().sendText(\"ERROR: \" + errorMessage);\n\n} catch (IOException e) {\n\ne.printStackTrace();\n\n}\n\n}\n\n`@OnError`:\n\n@OnError\n\npublic void onError(Session session, Throwable throwable) {\n\nthrowable.printStackTrace();\n\n}\n\nAlso, I need to implement the broadcast method:\n\nprivate static void broadcastMessage(String message) {\n\nfor (Session session : sessions) {\n\ntry {\n\nsession.getBasicRemote().sendText(message);\n\n} catch (IOException e) {\n\ne.printStackTrace();\n\nsessions.remove(session);\n\n}\n\n}\n\n}\n\nNow, I need to set up the WebSocket server.\n\nI'll create a main class to start the server.\n\nPackage: com.example.websocket.chat.server\n\nClass: ChatServer\n\nMain method:\n\npublic static void main(String[] args) {\n\nSystem.out.println(\"Starting WebSocket chat server...\");\n\nServer server = new Server(\"localhost\", 8080, \"/websocket\", null, ChatServerEndpoint.class);\n\ntry {\n\nserver.start();\n\nSystem.out.println(\"Server started. Press any key to stop.\");\n\nSystem.in.read();\n\n} catch (Exception e) {\n\ne.printStackTrace();\n\n} finally {\n\nserver.stop();\n\n}\n\n}\n\nBut wait, Tyrus uses Grizzly as the HTTP server.\n\nI need to import the Grizzly classes.\n\nActually, looking back at the dependencies, I have `tyrus-container-grizzly-server`, so I can use Grizzly to host the WebSocket endpoint.\n\nI need to look up the Tyrus documentation to see how to set up the server.\n\nLooking at the Tyrus documentation, I can use the `Server` class from Tyrus to start the WebSocket server.\n\nSo, in the main method, I can do something like:\n\nimport org.glassfish.tyrus.server.Server;\n\npublic class ChatServer {\n\npublic static void main(String[] args) {\n\nServer server = new Server(\"localhost\", 8080, \"/websocket\", null, ChatServerEndpoint.class);\n\ntry {\n\nserver.start();\n\nSystem.out.println(\"Press any key to stop the server...\");\n\nSystem.in.read();\n\n} finally {\n\nserver.stop();\n\n}\n\n}\n\n}\n\nThis should start a WebSocket server listening on localhost:8080, with the endpoint at /websocket/chat.\n\nWait, in the `@ServerEndpoint` annotation, I have \"/chat\", so the full URL would be ws://localhost:8080/websocket/chat.\n\nI need to make sure that the context path is set correctly.\n\nIn the `Server` constructor, the third parameter is the context path, which is \"/websocket\" in this case.\n\nSo, the endpoint URL would be ws://localhost:8080/websocket/chat.\n\nI need to make sure that clients connect to this URL.\n\nNow, I need to test this server.\n\nI can write a simple WebSocket client in Java to connect to this server and send messages.\n\nAlternatively, I can use a browser with JavaScript to connect to the WebSocket server.\n\nSince it's a text-based chat server, I'll write a simple Java client for testing.\n\nI'll create another class for the client.\n\nPackage: com.example.websocket.chat.client\n\nClass: ChatClient\n\nMain method:\n\nimport javax.websocket.*;\n\nimport java.net.URI;\n\npublic class ChatClient {\n\n@ClientEndpoint\n\npublic static class ChatClientEndpoint {\n\n@OnOpen\n\npublic void onOpen(Session session) {\n\nSystem.out.println(\"Connected to server\");\n\n// Register username\n\nJSONObject json = new JSONObject();\n\njson.put(\"type\", \"register\");\n\njson.put(\"username\", \"user1\");\n\ntry {\n\nsession.getBasicRemote().sendText(json.toString());\n\n} catch (IOException e) {\n\ne.printStackTrace();\n\n}\n\n}\n\n@OnMessage\n\npublic void onMessage(String message) {\n\nSystem.out.println(\"Received message: \" + message);\n\n}\n\n@OnClose\n\npublic void onClose(Session session, CloseReason closeReason) {\n\nSystem.out.println(\"Connection closed: \" + closeReason);\n\n}\n\n@OnError\n\npublic void onError(Session session, Throwable throwable) {\n\nthrowable.printStackTrace();\n\n}\n\n}\n\npublic static void main(String[] args) {\n\ntry {\n\nWebSocketContainer container = ContainerProvider.getWebSocketContainer();\n\nSession session = container.connectToServer(ChatClientEndpoint.class, URI.create(\"ws://localhost:8080/websocket/chat\"));\n\n// Keep the application running to receive messages\n\nThread.sleep(Long.MAX_VALUE);\n\n} catch (Exception e) {\n\ne.printStackTrace();\n\n}\n\n}\n\n}\n\nThis client connects to the server, registers a username, and listens for incoming messages.\n\nI can run multiple instances of this client to simulate multiple users.\n\nI need to make sure that each client uses a unique username.\n\nAlso, I need to implement sending messages from the client.\n\nI can add a method to send messages in the `ChatClientEndpoint` class.\n\nBut since it's a simple test, I can hardcode sending a message after registration.\n\nFor example, in the `onOpen` method, after registering the username, send a chat message.\n\nLike this:\n\n@OnOpen\n\npublic void onOpen(Session session) {\n\nSystem.out.println(\"Connected to server\");\n\n// Register username\n\nJSONObject json = new JSONObject();\n\njson.put(\"type\", \"register\");\n\njson.put(\"username\", \"user1\");\n\ntry {\n\nsession.getBasicRemote().sendText(json.toString());\n\n// Send a chat message\n\njson.put(\"type\", \"message\");\n\njson.put(\"to\", \"all\");\n\njson.put(\"content\", \"Hello everyone!\");\n\nsession.getBasicRemote().sendText(json.toString());\n\n} catch (IOException e) {\n\ne.printStackTrace();\n\n}\n\n}\n\nThis way, when the client connects, it registers the username and sends a chat message.\n\nI can run multiple instances of this client with different usernames to test the chat functionality.\n\nAlso, I can implement private messaging by sending a message with \"to\" set to a specific username.\n\nFor example:\n\njson.put(\"type\", \"message\");\n\njson.put(\"to\", \"user2\");\n\njson.put(\"content\", \"Hi user2!\");\n\nNow, I need to make sure that the server correctly broadcasts messages to all clients and sends private messages only to the specified recipient.\n\nI should also test edge cases, like sending a message to a non-existent username, trying to register with an already taken username, etc.\n\nAdditionally, I need to handle disconnections properly, removing the session and username from the lists.\n\nI should also broadcast a message when a user leaves the chat.\n\nSo, in the `@OnClose` method of the endpoint, I can send a message like \"{username} has left the chat\".\n\nI'll need to modify the `onClose` method in the endpoint:\n\n@OnClose\n\npublic void onClose(Session session, CloseReason closeReason) {\n\nsessions.remove(session);\n\nString username = getUsernameForSession(session);\n\nif (username != null) {\n\nuserSessions.remove(username);\n\nbroadcastMessage(username + \" has left the chat\");\n\n}\n\n}\n\nI need to add the `CloseReason` parameter to the `onClose` method.\n\nAlso, in the `onOpen` method, I can initialize a list to keep track of registered sessions to prevent re-registration.\n\nWait, in the `handleRegistration` method, I check if the session is already registered by checking `userSessions.containsValue(session)`.\n\nI think that's sufficient.\n\nNow, I need to make sure that the server doesn't allow multiple registrations from the same session.\n\nAlso, I need to ensure that usernames are unique.\n\nI should also think about case sensitivity for usernames.\n\nProbably, usernames should be case-insensitive.\n\nSo, I can convert usernames to lowercase when storing and retrieving them.\n\nModify the `userSessions` map to use lowercase usernames.\n\nIn the `handleRegistration` method:\n\nString username = json.getString(\"username\").toLowerCase();\n\nAnd in `getUsernameForSession`, iterate over the entries and compare lowercase usernames.\n\nWait, but since usernames are unique, I can just use a `HashMap` with lowercase usernames.\n\nSimilarly, in `handleMessage`, convert the \"to\" field to lowercase before looking up the session.\n\nNow, I need to implement this.\n\nModify the `userSessions` map:\n\nprivate static ConcurrentHashMap<String, Session> userSessions = new ConcurrentHashMap<>();\n\nIn `handleRegistration`:\n\nString username = json.getString(\"username\").toLowerCase();\n\nif (userSessions.containsValue(session)) {\n\nsendErrorMessage(session, \"Already registered\");\n\nreturn;\n\n}\n\nif (userSessions.containsKey(username)) {\n\nsendErrorMessage(session, \"Username already taken\");\n\nreturn;\n\n}\n\nuserSessions.put(username, session);\n\nbroadcastMessage(username + \" has joined the chat\");\n\nIn `getUsernameForSession`:\n\nprivate String getUsernameForSession(Session session) {\n\nfor (Map.Entry<String, Session> entry : userSessions.entrySet()) {\n\nif (entry.getValue().equals(session)) {\n\nreturn entry.getKey();\n\n}\n\n}\n\nreturn null;\n\n}\n\nIn `handleMessage`:\n\nString to = json.getString(\"to\").toLowerCase();\n\nSession recipientSession = userSessions.get(to);\n\nNow, this should handle case-insensitivity for usernames.\n\nI should also make sure that the broadcast messages include the username in a consistent case.\n\nProbably, store usernames in lowercase and display them as such.\n\nAlternatively, store the original username case and convert to lowercase only for lookup.\n\nBut to keep it simple, I'll store usernames in lowercase.\n\nNow, I need to think about how to handle error messages.\n\nIn `sendErrorMessage`, I send a plain text message starting with \"ERROR: \".\n\nBut in this setup, all messages from the server are broadcasted to all clients.\n\nMaybe I should send error messages only to the sender.\n\nTo do that, I need to send the error message only to the specific session that caused the error.\n\nIn the `sendErrorMessage` method, I already have the session as a parameter, so I can send the error message only to that session.\n\nBut in the `broadcastMessage` method, I send messages to all sessions.\n\nSo, error messages should only go to the sender, not to all clients.\n\nI need to make sure that error messages are sent only to the sender.\n\nFor example, if a user tries to send a private message to a non-existent username, the error message should only be sent back to that user.\n\nSimilarly, if a user tries to register with an already taken username, the error should only be sent to that user.\n\nSo, in the `sendErrorMessage` method, I'll send the error message only to the specified session.\n\nI think that's already handled in the current implementation.\n\nNow, I need to consider security aspects.\n\nBut for a simple text-based chat server, I'll skip advanced security measures like authentication and message encryption.\n\nHowever, I should at least consider preventing malicious users from flooding the server with messages or performing denial-of-service attacks.\n\nTo mitigate this, I can implement message rate limiting or message size limits.\n\nBut for this simple implementation, I'll omit these features.\n\nAnother consideration is handling large numbers of clients.\n\nSince I'm using a `CopyOnWriteArrayList` for sessions, which is thread-safe and performs well for read-heavy operations, it should handle a reasonable number of clients.\n\nBut for very high concurrency, I might need to optimize this further.\n\nAgain, for this simple implementation, it should suffice.\n\nNow, I need to make sure that the server doesn't crash if a client sends invalid JSON or malformed messages.\n\nI've already added try-catch blocks around JSON parsing and handle exceptions by sending error messages back to the client.\n\nI should also handle cases where required fields are missing in the JSON message.\n\nIn the `handleRegistration` and `handleMessage` methods, I need to check for missing fields and send appropriate error messages.\n\nFor example, in `handleRegistration`, if the \"username\" field is missing, send an error message.\n\nSimilarly, in `handleMessage`, if \"to\" or \"content\" fields are missing, send an error message.\n\nI can improve the error handling by checking for null or empty strings in these fields.\n\nNow, I need to think about how to run this server.\n\nSince it's a Java application, I can package it as a JAR file with dependencies included.\n\nI can use the Maven Shade Plugin to create a fat JAR.\n\nAdd the following to the pom.xml build section:\n\n<build>\n\n<plugins>\n\n<plugin>\n\n<groupId>org.apache.maven.plugins</groupId>\n\n<artifactId>maven-shade-plugin</artifactId>\n\n<version>3.2.4</version>\n\n<executions>\n\n<execution>\n\n<phase>package</phase>\n\n<goals>\n\n<goal>shade</goal>\n\n</goals>\n\n<configuration>\n\n<transformers>\n\n<transformer implementation=\"org.apache.maven.plugins.shade.resource.ManifestResourceTransformer\">\n\n<mainClass>com.example.websocket.chat.server.ChatServer</mainClass>\n\n</transformer>\n\n</transformers>\n\n</configuration>\n\n</execution>\n\n</executions>\n\n</plugin>\n\n</plugins>\n\n</build>\n\nThis will create a shaded JAR with all dependencies included and set the main class.\n\nThen, I can run the JAR using `java -jar websocket-chat-server-1.0-SNAPSHOT.jar`.\n\nNow, I need to test the server with multiple clients.\n\nI can write multiple instances of the `ChatClient` with different usernames and test broadcasting and private messaging.\n\nI should also test disconnecting clients and making sure that the server handles it correctly.\n\nAdditionally, I can implement a simple text-based client that allows users to type messages and send them to the server.\n\nBut for now, the basic implementation should suffice.\n\nI think this covers the requirements of implementing a simple text-based chat server using WebSockets in Java.\n\n**Final Solution**\n\nTo create a simple text-based chat server using WebSockets in Java, we can utilize the Java API for WebSocket (JSR 356) along with the Tyrus library for implementation. This setup allows for real-time communication, making it ideal for chat applications.\n\n### Approach\n\n1. **Setup Maven Project**: Include necessary dependencies for WebSocket implementation using Tyrus.\n2. **Create WebSocket Server Endpoint**: Handle client connections, disconnections, and messages.\n3. **Manage Client Sessions**: Maintain lists of connected sessions and associated usernames for broadcasting and private messaging.\n4. **Implement Message Handling**: Parse JSON messages for registration and different types of chat messages.\n5. **Start the Server**: Use Grizzly to host the WebSocket endpoint.\n\n### Solution Code\n\n#### `pom.xml`\n\n```xml\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n    <modelVersion>4.0.0</modelVersion>\n    <groupId>com.example</groupId>\n    <artifactId>websocket-chat-server</artifactId>\n    <packaging>jar</packaging>\n    <version>1.0-SNAPSHOT</version>\n    <name>WebSocket Chat Server</name>\n    <dependencies>\n        <dependency>\n            <groupId>org.glassfish.tyrus</groupId>\n            <artifactId>tyrus-server</artifactId>\n            <version>1.17</version>\n        </dependency>\n        <dependency>\n            <groupId>org.glassfish.tyrus</groupId>\n            <artifactId>tyrus-container-grizzly-server</artifactId>\n            <version>1.17</version>\n        </dependency>\n        <dependency>\n            <groupId>org.json</groupId>\n            <artifactId>json</artifactId>\n            <version>20210307</version>\n        </dependency>\n    </dependencies>\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-shade-plugin</artifactId>\n                <version>3.2.4</version>\n                <executions>\n                    <execution>\n                        <phase>package</phase>\n                        <goals>\n                            <goal>shade</goal>\n                        </goals>\n                        <configuration>\n                            <transformers>\n                                <transformer implementation=\"org.apache.maven.plugins.shade.resource.ManifestResourceTransformer\">\n                                    <mainClass>com.example.websocket.chat.server.ChatServer</mainClass>\n                                </transformer>\n                            </transformers>\n                        </configuration>\n                    </execution>\n                </executions>\n            </plugin>\n        </plugins>\n    </build>\n</project>\n```\n\n#### `ChatServerEndpoint.java`\n\n```java\npackage com.example.websocket.chat.server;\n\nimport javax.websocket.OnClose;\nimport javax.websocket.OnError;\nimport javax.websocket.OnMessage;\nimport javax.websocket.OnOpen;\nimport javax.websocket.Session;\nimport javax.websocket.server.ServerEndpoint;\nimport java.io.IOException;\nimport java.util.*;\nimport java.util.concurrent.CopyOnWriteArrayList;\nimport java.util.concurrent.ConcurrentHashMap;\nimport org.json.JSONObject;\nimport org.json.JSONException;\n\n@ServerEndpoint(\"/chat\")\npublic class ChatServerEndpoint {\n\n    private static CopyOnWriteArrayList<Session> sessions = new CopyOnWriteArrayList<>();\n    private static ConcurrentHashMap<String, Session> userSessions = new ConcurrentHashMap<>();\n\n    @OnOpen\n    public void onOpen(Session session) {\n        sessions.add(session);\n    }\n\n    @OnClose\n    public void onClose(Session session, CloseReason closeReason) {\n        sessions.remove(session);\n        String username = getUsernameForSession(session);\n        if (username != null) {\n            userSessions.remove(username);\n            broadcastMessage(username + \" has left the chat\");\n        }\n    }\n\n    @OnMessage\n    public void onMessage(String message, Session session) {\n        try {\n            JSONObject json = new JSONObject(message);\n            String type = json.getString(\"type\");\n            if (\"register\".equals(type)) {\n                handleRegistration(json, session);\n            } else if (\"message\".equals(type)) {\n                handleMessage(json, session);\n            } else {\n                sendErrorMessage(session, \"Invalid message type\");\n            }\n        } catch (JSONException e) {\n            sendErrorMessage(session, \"Invalid JSON format\");\n        }\n    }\n\n    @OnError\n    public void onError(Session session, Throwable throwable) {\n        throwable.printStackTrace();\n    }\n\n    private void handleRegistration(JSONObject json, Session session) {\n        try {\n            String username = json.getString(\"username\").toLowerCase();\n            if (userSessions.containsValue(session)) {\n                sendErrorMessage(session, \"Already registered\");\n                return;\n            }\n            if (userSessions.containsKey(username)) {\n                sendErrorMessage(session, \"Username already taken\");\n                return;\n            }\n            userSessions.put(username, session);\n            broadcastMessage(username + \" has joined the chat\");\n        } catch (JSONException e) {\n            sendErrorMessage(session, \"Missing username in registration\");\n        }\n    }\n\n    private void handleMessage(JSONObject json, Session session) {\n        try {\n            String to = json.getString(\"to\").toLowerCase();\n            String content = json.getString(\"content\");\n            String username = getUsernameForSession(session);\n            if (username == null) {\n                sendErrorMessage(session, \"Not registered\");\n                return;\n            }\n            if (\"all\".equals(to)) {\n                broadcastMessage(username + \": \" + content);\n            } else {\n                Session recipientSession = userSessions.get(to);\n                if (recipientSession != null) {\n                    String whisperMessage = username + \" whispers to \" + to + \": \" + content;\n                    recipientSession.getBasicRemote().sendText(whisperMessage);\n                    session.getBasicRemote().sendText(whisperMessage);\n                } else {\n                    sendErrorMessage(session, \"User \" + to + \" not found\");\n                }\n            }\n        } catch (JSONException e) {\n            sendErrorMessage(session, \"Invalid message format\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private String getUsernameForSession(Session session) {\n        for (Map.Entry<String, Session> entry : userSessions.entrySet()) {\n            if (entry.getValue().equals(session)) {\n                return entry.getKey();\n            }\n        }\n        return null;\n    }\n\n    private static void broadcastMessage(String message) {\n        for (Session session : sessions) {\n            try {\n                session.getBasicRemote().sendText(message);\n            } catch (IOException e) {\n                e.printStackTrace();\n                sessions.remove(session);\n            }\n        }\n    }\n\n    private void sendErrorMessage(Session session, String errorMessage) {\n        try {\n            session.getBasicRemote().sendText(\"ERROR: \" + errorMessage);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n#### `ChatServer.java`\n\n```java\npackage com.example.websocket.chat.server;\n\nimport org.glassfish.tyrus.server.Server;\n\nimport javax.websocket.DeploymentException;\nimport java.io.IOException;\n\npublic class ChatServer {\n\n    public static void main(String[] args) {\n        Server server = new Server(\"localhost\", 8080, \"/websocket\", null, ChatServerEndpoint.class);\n        try {\n            server.start();\n            System.out.println(\"Press any key to stop the server...\");\n            System.in.read();\n        } catch (DeploymentException | IOException e) {\n            e.printStackTrace();\n        } finally {\n            server.stop();\n        }\n    }\n}\n```\n\n### Explanation\n\n1. **Dependencies**: The project uses Tyrus for WebSocket implementation and JSON for message parsing.\n2. **Server Endpoint**: Manages client connections and messages, maintaining lists for sessions and registered usernames.\n3. **Message Handling**: Supports user registration, broadcasting messages to all users, and private messaging between users.\n4. **Error Handling**: Sends error messages back to clients for invalid requests or format issues.\n5. **Server Startup**: Uses Grizzly to host the WebSocket endpoint and can be started via the main method in `ChatServer`.\n\nThis setup provides a basic yet functional chat server that can be extended with additional features as needed."
    }
]