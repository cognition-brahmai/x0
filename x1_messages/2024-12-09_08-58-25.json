[
    {
        "role": "user",
        "content": "Create a Java implementation of the LRU (Least Recently Used) cache algorithm. The cache should have a fixed size and support get and put operations. When the cache is full, the least recently used item should be removed before adding a new one.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Sure, I can help you with that! Implementing an LRU cache in Java involves creating a data structure that maintains a limited number of items and removes the least recently used item when the cache reaches its capacity. We'll use a combination of a HashMap and a Doubly Linked List to achieve this efficiently.\n\n### Approach\n\n1. **HashMap**: This will store the keys and their corresponding nodes in the linked list. It allows us to access elements in O(1) time.\n2. **Doubly Linked List**: This will store the order of elements based on their usage. The most recently used element will be at the head, and the least recently used will be at the tail.\n\n### Solution Code\n\n```java\npublic class LRUCache {\n    class DLinkedNode {\n        int key;\n        int value;\n        DLinkedNode prev;\n        DLinkedNode next;\n        \n        public DLinkedNode(int _key, int _value) {\n            key = _key;\n            value = _value;\n        }\n    }\n\n    private void addNode(DLinkedNode node) {\n        // Always add the new node right after head.\n        node.prev = head;\n        node.next = head.next;\n\n        head.next.prev = node;\n        head.next = node;\n    }\n\n    private void removeNode(DLinkedNode node){\n        // Remove an existing node from the linked list.\n        DLinkedNode prev = node.prev;\n        DLinkedNode next = node.next;\n\n        prev.next = next;\n        next.prev = prev;\n    }\n\n    private void moveToHead(DLinkedNode node){\n        // Move certain node in between to the head.\n        removeNode(node);\n        addNode(node);\n    }\n\n    private DLinkedNode popTail() {\n        // Pop the current tail.\n        DLinkedNode res = tail.prev;\n        removeNode(res);\n        return res;\n    }\n\n    private DLinkedNode head;\n    private DLinkedNode tail;\n    private int capacity;\n    private int size;\n    private HashMap<Integer, DLinkedNode> cache;\n\n    public LRUCache(int capacity) {\n        this.capacity = capacity;\n        this.size = 0;\n        cache = new HashMap<Integer, DLinkedNode>();\n        // Use the two dummy nodes as the boundary\n        head = new DLinkedNode(0, 0);\n        tail = new DLinkedNode(0, 0);\n        head.next = tail;\n        tail.prev = head;\n    }\n\n    public int get(int key) {\n        DLinkedNode node = cache.get(key);\n        if (node == null) {\n            return -1;\n        }\n        // Move the accessed node to the head.\n        moveToHead(node);\n        return node.value;\n    }\n\n    public void put(int key, int value) {\n        DLinkedNode node = cache.get(key);\n        if (node != null) {\n            // Update the value.\n            node.value = value;\n            // Move the accessed node to the head.\n            moveToHead(node);\n        } else {\n            DLinkedNode newNode = new DLinkedNode(key, value);\n            cache.put(key, newNode);\n            addNode(newNode);\n            ++size;\n            if (size > capacity) {\n                // Pop the tail\n                DLinkedNode tail = popTail();\n                cache.remove(tail.key);\n                --size;\n            }\n        }\n    }\n}\n```\n\n### Explanation\n\n1. **DLinkedNode Class**: Represents a node in the doubly linked list, containing the key, value, and pointers to previous and next nodes.\n2. **addNode Method**: Adds a new node right after the head of the list.\n3. **removeNode Method**: Removes a node from the list.\n4. **moveToHead Method**: Moves a node to the head of the list, indicating it was recently used.\n5. **popTail Method**: Removes the node at the tail of the list, which is the least recently used.\n6. **LRUCache Constructor**: Initializes the cache with a given capacity and sets up dummy head and tail nodes.\n7. **get Method**: Retrieves a value by key and moves the corresponding node to the head if found.\n8. **put Method**: Adds or updates a key-value pair and manages the cache size by removing the least recently used item if necessary.\n\nThis implementation ensures that both get and put operations are performed in constant time, O(1), making it efficient for scenarios where caching is crucial."
    }
]