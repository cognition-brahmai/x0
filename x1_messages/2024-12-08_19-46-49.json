[
    {
        "role": "user",
        "content": "Implement a simple stack data structure in C++ that supports push, pop, and peek operations. The stack should be dynamically resizable and handle integer values.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Sure! I can help you with that. So, you need a simple stack data structure in C++ that can handle integer values and is dynamically resizable. It should support push, pop, and peek operations.\n\nFirst, let's understand what a stack is. A stack is a Last In First Out (LIFO) data structure, which means the last element added to the stack will be the first one to be removed. The basic operations are:\n\n1. **Push**: Adds an element to the top of the stack.\n2. **Pop**: Removes the element from the top of the stack.\n3. **Peek**: Returns the element at the top of the stack without removing it.\n\nSince you want the stack to be dynamically resizable, we'll use a dynamic array approach, perhaps using pointers or the `std::vector` class for simplicity. However, since you might want to implement it from scratch without using standard library containers, I'll show you both approaches.\n\n### Approach 1: Using `std::vector`\n\nThis is simpler and more efficient, as `std::vector` handles resizing automatically.\n\n```cpp\n#include <vector>\n\nclass Stack {\nprivate:\n    std::vector<int> elements;\n\npublic:\n    // Push an element onto the stack\n    void push(int value) {\n        elements.push_back(value);\n    }\n\n    // Remove the top element from the stack\n    void pop() {\n        if (!elements.empty()) {\n            elements.pop_back();\n        } else {\n            throw std::out_of_range(\"Stack is empty\");\n        }\n    }\n\n    // Get the top element of the stack\n    int peek() const {\n        if (!elements.empty()) {\n            return elements.back();\n        } else {\n            throw std::out_of_range(\"Stack is empty\");\n        }\n    }\n\n    // Check if the stack is empty\n    bool isEmpty() const {\n        return elements.empty();\n    }\n};\n```\n\n### Approach 2: Implementing a Dynamic Array Manually\n\nThis approach gives you more control and understanding of how dynamic resizing works under the hood.\n\n```cpp\n#include <iostream>\n\nclass Stack {\nprivate:\n    int* array;\n    int capacity;\n    int top;\n\npublic:\n    Stack() {\n        capacity = 1;\n        array = new int[capacity];\n        top = -1;\n    }\n\n    ~Stack() {\n        delete[] array;\n    }\n\n    // Double the capacity of the stack\n    void resize() {\n        capacity *= 2;\n        int* temp = new int[capacity];\n        for (int i = 0; i <= top; i++) {\n            temp[i] = array[i];\n        }\n        delete[] array;\n        array = temp;\n    }\n\n    // Push an element onto the stack\n    void push(int value) {\n        if (top + 1 == capacity) {\n            resize();\n        }\n        array[++top] = value;\n    }\n\n    // Remove the top element from the stack\n    void pop() {\n        if (top == -1) {\n            throw std::out_of_range(\"Stack is empty\");\n        }\n        top--;\n    }\n\n    // Get the top element of the stack\n    int peek() const {\n        if (top == -1) {\n            throw std::out_of_range(\"Stack is empty\");\n        }\n        return array[top];\n    }\n\n    // Check if the stack is empty\n    bool isEmpty() const {\n        return top == -1;\n    }\n};\n```\n\n### Explanation\n\n1. **Using `std::vector`**:\n   - The `std::vector` handles dynamic resizing automatically, so you don't need to worry about capacity management.\n   - `push_back` adds elements to the end of the vector.\n   - `pop_back` removes the last element.\n   - `back` returns the last element without removing it.\n\n2. **Manual Dynamic Array**:\n   - Initially, the stack has a capacity of 1.\n   - When the stack is full, the `resize` function doubles the capacity by allocating a new array and copying the elements.\n   - `push` adds elements to the top of the stack and calls `resize` if necessary.\n   - `pop` removes the top element if the stack is not empty.\n   - `peek` returns the top element if the stack is not empty.\n   - `isEmpty` checks if the stack has no elements.\n\nBoth approaches are correct, but using `std::vector` is more efficient and simpler for most use cases. However, implementing a dynamic array manually can be a good exercise to understand memory management in C++.\n\nLet me know if you have any questions or need further clarification!"
    }
]