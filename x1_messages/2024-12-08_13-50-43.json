[
    {
        "role": "user",
        "content": "Write a Golang program to implement a stack data structure with push, pop, and peek operations. The stack should be able to store strings."
    },
    {
        "role": "assistant",
        "content": "Certainly! Below is a simple implementation of a stack data structure in Go that can store strings. This implementation includes the `push`, `pop`, and `peek` operations.\n\n```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\n// Stack represents a stack data structure that stores strings.\ntype Stack struct {\n\titems []string\n}\n\n// NewStack creates a new instance of Stack.\nfunc NewStack() *Stack {\n\treturn &Stack{items: make([]string, 0)}\n}\n\n// Push adds a string to the top of the stack.\nfunc (s *Stack) Push(item string) {\n\ts.items = append(s.items, item)\n}\n\n// Pop removes and returns the string from the top of the stack.\n// It returns an error if the stack is empty.\nfunc (s *Stack) Pop() (string, error) {\n\tif s.IsEmpty() {\n\t\treturn \"\", errors.New(\"stack is empty\")\n\t}\n\tindex := len(s.items) - 1\n\titem := s.items[index]\n\ts.items = s.items[:index]\n\treturn item, nil\n}\n\n// Peek returns the string from the top of the stack without removing it.\n// It returns an error if the stack is empty.\nfunc (s *Stack) Peek() (string, error) {\n\tif s.IsEmpty() {\n\t\treturn \"\", errors.New(\"stack is empty\")\n\t}\n\treturn s.items[len(s.items)-1], nil\n}\n\n// IsEmpty checks if the stack is empty.\nfunc (s *Stack) IsEmpty() bool {\n\treturn len(s.items) == 0\n}\n\n// Size returns the number of items in the stack.\nfunc (s *Stack) Size() int {\n\treturn len(s.items)\n}\n\nfunc main() {\n\tstack := NewStack()\n\tfmt.Println(\"Is stack empty?\", stack.IsEmpty()) // true\n\n\tstack.Push(\"Hello\")\n\tstack.Push(\"World\")\n\tstack.Push!(\"!\")\n\n\tfmt.Println(\"Stack size:\", stack.Size()) // 3\n\n\tpeeked, err := stack.Peek()\n\tif err != nil {\n\t\tfmt.Println(err)\n\t} else {\n\t\tfmt.Println(\"Top item:\", peeked) // !\n\t}\n\n\tpopped, err := stack.Pop()\n\tif err != nil {\n\t\tfmt.Println(err)\n\t} else {\n\t\tfmt.Println(\"Popped item:\", popped) // !\n\t}\n\n\tfmt.Println(\"Stack size after pop:\", stack.Size()) // 2\n\n\tfor !stack.IsEmpty() {\n\t\titem, err := stack.Pop()\n\t\tif err != nil {\n\t\t\tfmt.Println(err)\n\t\t} else {\n\t\t\tfmt.Println(\"Popped item:\", item)\n\t\t}\n\t}\n\n\tfmt.Println(\"Is stack empty?\", stack.IsEmpty()) // true\n}\n```\n\n### Explanation\n\n1. **Stack Structure**: \n   - The `Stack` type is defined with a slice of strings to store the items.\n\n2. **NewStack Function**:\n   - Creates a new instance of `Stack` with an empty slice.\n\n3. **Push Method**:\n   - Adds a string to the end of the slice, which represents the top of the stack.\n\n4. **Pop Method**:\n   - Removes and returns the last item from the slice (top of the stack).\n   - Returns an error if the stack is empty.\n\n5. **Peek Method**:\n   - Returns the last item from the slice without removing it.\n   - Returns an error if the stack is empty.\n\n6. **IsEmpty Method**:\n   - Checks if the slice is empty.\n\n7. **Size Method**:\n   - Returns the number of items in the stack.\n\n8. **Main Function**:\n   - Demonstrates the usage of the stack by pushing items, peeking, popping, and checking if it's empty.\n\nThis implementation ensures that the stack operations are efficient, as appending and removing from the end of a slice in Go are O(1) operations on average."
    }
]