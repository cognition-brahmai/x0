[
    {
        "role": "user",
        "content": "Develop a Golang program that implements a basic HTTP server with support for GET and POST requests. The server should serve static files from a specified directory, handle file uploads to the same directory using unique filenames, and log all incoming requests to a separate log file.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Alright, I'm going to help you create a simple HTTP server in Golang that can handle GET and POST requests, serve static files from a specified directory, handle file uploads with unique filenames, and log all incoming requests to a separate log file. Sounds like a good project!\n\nFirst, make sure you have Go installed on your machine. You can download it from https://golang.org/dl/ if you don't have it already.\n\nLet's start by setting up the basic structure of our project. We'll create a directory for our project, say `simple_http_server`, and inside it, we'll have another directory named `static` where our static files will be served from. Also, we'll have a `logs` directory to store our log files.\n\n```\nsimple_http_server/\n\u251c\u2500\u2500 static/\n\u2502   \u2514\u2500\u2500 index.html\n\u2502   \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 logs/\n\u2502   \u2514\u2500\u2500 access.log\n\u251c\u2500\u2500 main.go\n```\n\nNow, let's think about what our server needs to do:\n\n1. **Serve static files:** We need to serve files from the `static` directory when a GET request is made.\n\n2. **Handle file uploads:** For POST requests, especially file uploads, we need to save the uploaded files to the `static` directory with unique filenames to avoid overwriting existing files.\n\n3. **Log all incoming requests:** Every request, whether GET or POST, should be logged into a file named `access.log` in the `logs` directory.\n\nLet's break this down step by step.\n\n### Step 1: Serve Static Files\n\nIn Go, the `net/http` package has a built-in handler for serving static files called `http.FileServer`. We can use this to serve files from the `static` directory.\n\nFirst, we need to create a file server handler and register it with the server.\n\n```go\nfs := http.FileServer(http.Dir(\"static\"))\nhttp.Handle(\"/\", fs)\n```\n\nThis will serve files from the `static` directory when a user accesses the root URL.\n\n### Step 2: Handle File Uploads\n\nFor handling file uploads, we need to create a handler function that processes POST requests. We'll use `mime/multipart` to parse the form data and extract the uploaded file.\n\nHere's a basic outline of what the handler needs to do:\n\n- Parse the multipart form.\n\n- Retrieve the file from the form data.\n\n- Generate a unique filename to save the file.\n\n- Save the file to the `static` directory.\n\nLet's define a handler function for this:\n\n```go\nfunc uploadHandler(w http.ResponseWriter, r *http.Request) {\n    if r.Method != \"POST\" {\n        http.Error(w, \"Invalid request method\", http.StatusMethodNotAllowed)\n        return\n    }\n\n    err := r.ParseMultipartForm(10 << 20) // Set memory limit to 10MB\n    if err != nil {\n        http.Error(w, \"Error parsing form data\", http.StatusInternalServerError)\n        return\n    }\n\n    file, header, err := r.FormFile(\"file\")\n    if err != nil {\n        http.Error(w, \"Error retrieving file from form data\", http.StatusInternalServerError)\n        return\n    }\n    defer file.Close()\n\n    // Generate a unique filename\n    filename := generateUniqueFilename(header.Filename)\n    filepath := filepath.Join(\"static\", filename)\n\n    out, err := os.Create(filepath)\n    if err != nil {\n        http.Error(w, \"Error creating file\", http.StatusInternalServerError)\n        return\n    }\n    defer out.Close()\n\n    _, err = io.Copy(out, file)\n    if err != nil {\n        http.Error(w, \"Error saving file\", http.StatusInternalServerError)\n        return\n    }\n\n    fmt.Fprintf(w, \"File uploaded successfully as %s\", filename)\n}\n```\n\nWe need to register this handler with a specific URL path, say `/upload`.\n\n```go\nhttp.HandleFunc(\"/upload\", uploadHandler)\n```\n\n### Step 3: Log All Incoming Requests\n\nTo log all incoming requests, we can create a custom middleware that logs the request details before passing it to the actual handler.\n\nHere's how we can implement a logging middleware:\n\n```go\nfunc logRequest(handler http.HandlerFunc) http.HandlerFunc {\n    return func(w http.ResponseWriter, r *http.Request) {\n        // Log the request details\n        log.Printf(\"%s %s %s\", r.RemoteAddr, r.Method, r.URL)\n\n        // Call the actual handler\n        handler(w, r)\n    }\n}\n```\n\nWe need to wrap our handlers with this middleware. For example:\n\n```go\nhttp.HandleFunc(\"/upload\", logRequest(uploadHandler))\n```\n\nAlso, for the file server, since it's not a `http.HandlerFunc`, we need to adapt it to use our middleware. We can do this by creating a new handler that wraps the file server with our logging functionality.\n\n```go\nfs := logRequest(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n    http.FileServer(http.Dir(\"static\")).ServeHTTP(w, r)\n}))\nhttp.Handle(\"/\", fs)\n```\n\n### Step 4: Implement Unique Filename Generation\n\nTo generate unique filenames, we can use a combination of the current timestamp and the original filename.\n\nHere's a simple function to generate a unique filename:\n\n```go\nfunc generateUniqueFilename(originalFilename string) string {\n    ext := filepath.Ext(originalFilename)\n    timestamp := time.Now().Format(\"20060102150405\")\n    random := rand.Intn(1000)\n    return fmt.Sprintf(\"%s_%d%s\", timestamp, random, ext)\n}\n```\n\nThis ensures that each filename is unique by including the current timestamp and a random number.\n\n### Step 5: Write Logs to a File\n\nInstead of logging to the standard output, we want to log to a file named `access.log` in the `logs` directory.\n\nFirst, we need to open the log file:\n\n```go\nlogfile, err := os.OpenFile(\"logs/access.log\", os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0644)\nif err != nil {\n    log.Fatalf(\"Failed to open log file: %v\", err)\n}\ndefer logfile.Close()\n\nlog.SetOutput(logfile)\n```\n\nNow, all calls to `log.Printf` will write to this file.\n\n### Step 6: Putting It All Together\n\nNow, let's put all these pieces together in our `main.go` file.\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"io\"\n    \"log\"\n    \"net/http\"\n    \"os\"\n    \"path/filepath\"\n    \"math/rand\"\n    \"time\"\n)\n\nfunc main() {\n    // Create logs directory if it doesn't exist\n    if err := os.MkdirAll(\"logs\", 0755); err != nil {\n        log.Fatalf(\"Failed to create logs directory: %v\", err)\n    }\n\n    // Open log file\n    logfile, err := os.OpenFile(\"logs/access.log\", os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0644)\n    if err != nil {\n        log.Fatalf(\"Failed to open log file: %v\", err)\n    }\n    defer logfile.Close()\n\n    // Set log output to log file\n    log.SetOutput(logfile)\n\n    // Create static directory if it doesn't exist\n    if err := os.MkdirAll(\"static\", 0755); err != nil {\n        log.Fatalf(\"Failed to create static directory: %v\", err)\n    }\n\n    // File server with logging\n    fs := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        http.FileServer(http.Dir(\"static\")).ServeHTTP(w, r)\n    })\n    http.Handle(\"/\", logRequest(fs))\n\n    // Upload handler with logging\n    http.HandleFunc(\"/upload\", logRequest(uploadHandler))\n\n    // Start the server\n    port := \"8080\"\n    fmt.Printf(\"Starting server on port %s\\n\", port)\n    if err := http.ListenAndServe(\":\"+port, nil); err != nil {\n        log.Fatalf(\"Failed to start server: %v\", err)\n    }\n}\n\nfunc logRequest(handler http.HandlerFunc) http.HandlerFunc {\n    return func(w http.ResponseWriter, r *http.Request) {\n        log.Printf(\"%s %s %s\", r.RemoteAddr, r.Method, r.URL)\n        handler(w, r)\n    }\n}\n\nfunc uploadHandler(w http.ResponseWriter, r *http.Request) {\n    if r.Method != \"POST\" {\n        http.Error(w, \"Invalid request method\", http.StatusMethodNotAllowed)\n        return\n    }\n\n    err := r.ParseMultipartForm(10 << 20) // Set memory limit to 10MB\n    if err != nil {\n        http.Error(w, \"Error parsing form data\", http.StatusInternalServerError)\n        return\n    }\n\n    file, header, err := r.FormFile(\"file\")\n    if err != nil {\n        http.Error(w, \"Error retrieving file from form data\", http.StatusInternalServerError)\n        return\n    }\n    defer file.Close()\n\n    // Generate a unique filename\n    filename := generateUniqueFilename(header.Filename)\n    filepath := filepath.Join(\"static\", filename)\n\n    out, err := os.Create(filepath)\n    if err != nil {\n        http.Error(w, \"Error creating file\", http.StatusInternalServerError)\n        return\n    }\n    defer out.Close()\n\n    _, err = io.Copy(out, file)\n    if err != nil {\n        http.Error(w, \"Error saving file\", http.StatusInternalServerError)\n        return\n    }\n\n    fmt.Fprintf(w, \"File uploaded successfully as %s\", filename)\n}\n\nfunc generateUniqueFilename(originalFilename string) string {\n    ext := filepath.Ext(originalFilename)\n    timestamp := time.Now().Format(\"20060102150405\")\n    random := rand.Intn(1000)\n    return fmt.Sprintf(\"%s_%d%s\", timestamp, random, ext)\n}\n```\n\n### Explanation\n\n1. **Directory Setup:** Ensure `static` and `logs` directories exist.\n2. **Logging:** Set up logging to write to `logs/access.log`.\n3. **File Server:** Serve static files from `static` directory with logging.\n4. **Upload Handler:** Handle file uploads, save with unique filenames, and log requests.\n5. **Server Start:** Listen on port 8080 and handle incoming requests.\n\nThis should give you a basic HTTP server in Golang that serves static files, handles file uploads with unique filenames, and logs all requests to a file. You can run this program using `go run main.go`, and it will start the server on port 8080.\n\n## Final Solution\nTo create a basic HTTP server in Golang that serves static files, handles file uploads with unique filenames, and logs all incoming requests, follow these steps:\n\n### Solution Code\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n    \"io\"\n    \"log\"\n    \"net/http\"\n    \"os\"\n    \"path/filepath\"\n    \"math/rand\"\n    \"time\"\n)\n\nfunc main() {\n    // Create logs directory if it doesn't exist\n    if err := os.MkdirAll(\"logs\", 0755); err != nil {\n        log.Fatalf(\"Failed to create logs directory: %v\", err)\n    }\n\n    // Open log file\n    logfile, err := os.OpenFile(\"logs/access.log\", os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0644)\n    if err != nil {\n        log.Fatalf(\"Failed to open log file: %v\", err)\n    }\n    defer logfile.Close()\n\n    // Set log output to log file\n    log.SetOutput(logfile)\n\n    // Create static directory if it doesn't exist\n    if err := os.MkdirAll(\"static\", 0755); err != nil {\n        log.Fatalf(\"Failed to create static directory: %v\", err)\n    }\n\n    // File server with logging\n    fs := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n        http.FileServer(http.Dir(\"static\")).ServeHTTP(w, r)\n    })\n    http.Handle(\"/\", logRequest(fs))\n\n    // Upload handler with logging\n    http.HandleFunc(\"/upload\", logRequest(uploadHandler))\n\n    // Start the server\n    port := \"8080\"\n    fmt.Printf(\"Starting server on port %s\\n\", port)\n    if err := http.ListenAndServe(\":\"+port, nil); err != nil {\n        log.Fatalf(\"Failed to start server: %v\", err)\n    }\n}\n\nfunc logRequest(handler http.HandlerFunc) http.HandlerFunc {\n    return func(w http.ResponseWriter, r *http.Request) {\n        log.Printf(\"%s %s %s\", r.RemoteAddr, r.Method, r.URL)\n        handler(w, r)\n    }\n}\n\nfunc uploadHandler(w http.ResponseWriter, r *http.Request) {\n    if r.Method != \"POST\" {\n        http.Error(w, \"Invalid request method\", http.StatusMethodNotAllowed)\n        return\n    }\n\n    err := r.ParseMultipartForm(10 << 20) // Set memory limit to 10MB\n    if err != nil {\n        http.Error(w, \"Error parsing form data\", http.StatusInternalServerError)\n        return\n    }\n\n    file, header, err := r.FormFile(\"file\")\n    if err != nil {\n        http.Error(w, \"Error retrieving file from form data\", http.StatusInternalServerError)\n        return\n    }\n    defer file.Close()\n\n    // Generate a unique filename\n    filename := generateUniqueFilename(header.Filename)\n    filepath := filepath.Join(\"static\", filename)\n\n    out, err := os.Create(filepath)\n    if err != nil {\n        http.Error(w, \"Error creating file\", http.StatusInternalServerError)\n        return\n    }\n    defer out.Close()\n\n    _, err = io.Copy(out, file)\n    if err != nil {\n        http.Error(w, \"Error saving file\", http.StatusInternalServerError)\n        return\n    }\n\n    fmt.Fprintf(w, \"File uploaded successfully as %s\", filename)\n}\n\nfunc generateUniqueFilename(originalFilename string) string {\n    ext := filepath.Ext(originalFilename)\n    timestamp := time.Now().Format(\"20060102150405\")\n    random := rand.Intn(1000)\n    return fmt.Sprintf(\"%s_%d%s\", timestamp, random, ext)\n}\n```\n\n### Explanation\n\n1. **Directory Setup:**\n   - Ensure `static` and `logs` directories exist. If not, create them.\n\n2. **Logging:**\n   - Set up logging to write to `logs/access.log`.\n\n3. **File Server:**\n   - Serve static files from the `static` directory.\n   - Log all GET requests using a custom middleware.\n\n4. **Upload Handler:**\n   - Handle POST requests for file uploads.\n   - Save uploaded files to the `static` directory with unique filenames.\n   - Log all POST requests using the same logging middleware.\n\n5. **Server Start:**\n   - Listen on port 8080 and handle incoming requests.\n\nThis setup provides a basic yet functional HTTP server that meets the specified requirements. You can run this server using `go run main.go`, and it will start handling requests on port 8080."
    }
]