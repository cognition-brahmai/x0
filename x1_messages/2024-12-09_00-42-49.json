[
    {
        "role": "user",
        "content": "Create a C++ program that implements a stack data structure using dynamic arrays, including push, pop, top, and size operations."
    },
    {
        "role": "assistant",
        "content": "Certainly! Below is a C++ program that implements a stack data structure using dynamic arrays. The stack supports the following operations:\n\n1. `push`: Adds an element to the top of the stack.\n2. `pop`: Removes the element from the top of the stack.\n3. `top`: Returns the element at the top of the stack without removing it.\n4. `size`: Returns the number of elements in the stack.\n\nTo handle dynamic resizing, the array doubles in size when it fills up and halves in size when it becomes too empty. This ensures efficient performance for both time and space.\n\n## Final Solution\n\n```cpp\n#include <iostream>\n\nclass Stack {\nprivate:\n    int* arr;\n    int capacity;\n    int top_index;\n\npublic:\n    Stack() {\n        capacity = 4; // Initial capacity\n        arr = new int[capacity];\n        top_index = -1;\n    }\n\n    ~Stack() {\n        delete[] arr;\n    }\n\n    void push(int value) {\n        if (top_index + 1 == capacity) {\n            resize(2 * capacity);\n        }\n        arr[++top_index] = value;\n    }\n\n    void pop() {\n        if (isEmpty()) {\n            std::cout << \"Stack is empty. Cannot pop.\\n\";\n            return;\n        }\n        top_index--;\n        if (top_index < capacity / 4) {\n            resize(capacity / 2);\n        }\n    }\n\n    int top() {\n        if (isEmpty()) {\n            std::cout << \"Stack is empty.\\n\";\n            return -1; // Assuming -1 is not a valid stack element\n        }\n        return arr[top_index];\n    }\n\n    int size() {\n        return top_index + 1;\n    }\n\n    bool isEmpty() {\n        return top_index == -1;\n    }\n\nprivate:\n    void resize(int new_capacity) {\n        int* new_arr = new int[new_capacity];\n        for (int i = 0; i <= top_index; i++) {\n            new_arr[i] = arr[i];\n        }\n        delete[] arr;\n        arr = new_arr;\n        capacity = new_capacity;\n    }\n};\n\nint main() {\n    Stack stack;\n\n    stack.push(1);\n    stack.push(2);\n    stack.push(3);\n    stack.push(4);\n    stack.push(5);\n\n    std::cout << \"Top element is: \" << stack.top() << std::endl;\n    std::cout << \"Stack size is: \" << stack.size() << std::endl;\n\n    stack.pop();\n    stack.pop();\n\n    std::cout << \"Top element is: \" << stack.top() << std::endl;\n    std::cout << \"Stack size is: \" << stack.size() << std::endl;\n\n    stack.push(6);\n    stack.push(7);\n\n    std::cout << \"Top element is: \" << stack.top() << std::endl;\n    std::cout << \"Stack size is: \" << stack.size() << std::endl;\n\n    return 0;\n}\n```\n\n## Explanation\n\n- **Initialization**: The stack starts with a capacity of 4. The `arr` array is dynamically allocated to this capacity, and `top_index` is set to -1 to indicate an empty stack.\n\n- **Push Operation**: Adds an element to the top of the stack. If the stack is full (i.e., `top_index + 1 == capacity`), the array is resized to double its current capacity.\n\n- **Pop Operation**: Removes the element from the top of the stack. If the stack is empty, it prints an error message. After popping, if the stack's size is less than one-fourth of its capacity, the array is resized to half its current capacity.\n\n- **Top Operation**: Returns the top element of the stack without removing it. If the stack is empty, it prints an error message and returns -1 (assuming -1 is not a valid stack element).\n\n- **Size Operation**: Returns the number of elements currently in the stack.\n\n- **Resize Function**: Helper function to resize the underlying array. It creates a new array with the specified new capacity, copies the elements from the old array to the new one, deletes the old array, and updates the capacity.\n\nThis implementation ensures efficient handling of stack operations with dynamic resizing for optimal performance."
    }
]