[
    {
        "role": "user",
        "content": "Implement a simple LRU (Least Recently Used) cache in Python that supports the following operations: get(key), put(key, value), and delete(key). The cache should have a maximum size specified during initialization, and automatically evict the least recently used item when it reaches its capacity."
    },
    {
        "role": "assistant",
        "content": "To implement a simple LRU cache in Python, we can use a combination of a dictionary and a doubly-linked list. The dictionary will provide O(1) access time for get and put operations, while the doubly-linked list will help us manage the order of usage for the cache items.\n\nHere's a step-by-step plan:\n\n1. **Initialization**: \n   - Create a dictionary to store the cache items where keys map to nodes in the doubly-linked list.\n   - Create a doubly-linked list to maintain the order of usage. The least recently used item will be at the head, and the most recently used at the tail.\n   - Set the maximum capacity of the cache.\n\n2. **Get Operation**:\n   - If the key exists in the dictionary:\n     - Move the corresponding node to the tail of the linked list (since it's now the most recently used).\n     - Return the value.\n   - If the key does not exist, return None.\n\n3. **Put Operation**:\n   - If the key already exists, update its value and move the node to the tail.\n   - If the key does not exist:\n     - Create a new node with the key and value.\n     - Add it to the dictionary and to the tail of the linked list.\n     - If the cache is at its capacity:\n       - Remove the least recently used item (the node at the head of the linked list).\n       - Remove it from the dictionary.\n\n4. **Delete Operation**:\n   - If the key exists in the dictionary:\n     - Remove the corresponding node from the linked list.\n     - Remove the key from the dictionary.\n   - If the key does not exist, do nothing.\n\nLet's proceed to implement this.\n\n## Final Solution\nTo implement an LRU cache, we'll use a combination of a dictionary and a doubly-linked list. The dictionary provides O(1) access time for get and put operations, while the doubly-linked list helps manage the order of usage.\n\n### Approach\n\n1. **Node Structure**:\n   - Each node in the doubly-linked list contains `key`, `value`, and pointers to the next and previous nodes.\n\n2. **Initialization**:\n   - Create a dictionary to store the cache items where keys map to nodes.\n   - Use a doubly-linked list to maintain the order of usage, with the least recently used item at the head and the most recently used at the tail.\n   - Set the maximum capacity of the cache.\n\n3. **Get Operation**:\n   - If the key exists, move the corresponding node to the tail (most recently used) and return its value.\n   - If the key does not exist, return `None`.\n\n4. **Put Operation**:\n   - If the key already exists, update its value and move the node to the tail.\n   - If the key does not exist:\n     - Create a new node with the key and value.\n     - Add it to the dictionary and to the tail of the linked list.\n     - If the cache is at its capacity:\n       - Remove the least recently used item (node at the head of the linked list).\n       - Remove it from the dictionary.\n\n5. **Delete Operation**:\n   - If the key exists, remove the corresponding node from the linked list and the dictionary.\n   - If the key does not exist, do nothing.\n\n### Solution Code\n\n```python\nclass Node:\n    def __init__(self, key, value):\n        self.key = key\n        self.value = value\n        self.prev = None\n        self.next = None\n\nclass LRUCache:\n    def __init__(self, capacity):\n        self.capacity = capacity\n        self.cache = {}\n        self.head = Node(0, 0)  # Dummy head\n        self.tail = Node(0, 0)  # Dummy tail\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    def _remove(self, node):\n        prev_node = node.prev\n        next_node = node.next\n        prev_node.next = next_node\n        next_node.prev = prev_node\n\n    def _add(self, node):\n        prev_node = self.tail.prev\n        prev_node.next = node\n        node.prev = prev_node\n        node.next = self.tail\n        self.tail.prev = node\n\n    def get(self, key):\n        if key in self.cache:\n            node = self.cache[key]\n            self._remove(node)\n            self._add(node)\n            return node.value\n        return None\n\n    def put(self, key, value):\n        if key in self.cache:\n            node = self.cache[key]\n            self._remove(node)\n            node.value = value\n            self._add(node)\n        else:\n            if len(self.cache) >= self.capacity:\n                least_recently_used = self.head.next\n                self._remove(least_recently_used)\n                del self.cache[least_recently_used.key]\n            new_node = Node(key, value)\n            self.cache[key] = new_node\n            self._add(new_node)\n\n    def delete(self, key):\n        if key in self.cache:\n            node = self.cache[key]\n            self._remove(node)\n            del self.cache[key]\n```\n\n### Explanation\n\n- **Node Structure**: Each node holds a key, value, and pointers to the next and previous nodes.\n- **Initialization**: A dictionary (`cache`) maps keys to nodes, and a doubly-linked list maintains usage order.\n- **Get Operation**: Retrieves the value if the key exists and moves the node to the tail to mark it as recently used.\n- **Put Operation**: Adds or updates the key-value pair and moves the node to the tail. If the cache is full, removes the least recently used item.\n- **Delete Operation**: Removes the node corresponding to the key from both the dictionary and the linked list.\n\nThis implementation ensures that all operations (get, put, delete) are performed in O(1) time complexity, making it efficient for caching purposes."
    }
]