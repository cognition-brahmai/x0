[
    {
        "role": "user",
        "content": "Create a C++ program that implements a stack data structure with push, pop, and peek operations, along with error handling for underflow and overflow conditions.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Sure! I'd be happy to help you with that. So, you need a C++ program that implements a stack data structure with push, pop, and peek operations, and it should also handle error conditions like underflow and overflow. Right?\n\nFirst, let's understand what a stack is. A stack is a linear data structure that follows the Last In, First Out (LIFO) principle. That means the last element added to the stack is the first one to be removed.\n\nIn C++, we can implement a stack using an array or a linked list. For this example, I'll use an array because it's simpler and more straightforward for beginners.\n\nNow, let's think about the operations we need to implement:\n\n1. **Push**: Adds an element to the top of the stack.\n\n2. **Pop**: Removes the top element from the stack.\n\n3. **Peek**: Returns the top element without removing it.\n\nAdditionally, we need to handle two error conditions:\n\n- **Overflow**: When the stack is full and we try to push another element.\n\n- **Underflow**: When the stack is empty and we try to pop or peek an element.\n\nTo handle these errors, we can either use exceptions or return special values to indicate the error.\n\nSince you're asking for a simple program, I'll use return values to indicate success or failure.\n\nLet's start by defining the stack class.\n\nI'll create a class called `Stack` that has the following private members:\n\n- An array to store the stack elements.\n\n- An integer to keep track of the stack's top index.\n\nI'll also need to decide on the maximum size of the stack. Since arrays have a fixed size in C++, I'll define a constant for the maximum stack size.\n\nHere's a rough sketch of the class:\n\n```cpp\nclass Stack {\nprivate:\n    static const int MAX_SIZE = 100;\n    int arr[MAX_SIZE];\n    int top;\n\npublic:\n    Stack() : top(-1) {}\n\n    bool push(int value);\n    bool pop();\n    int peek();\n};\n```\n\nIn the constructor, I initialize `top` to `-1` because the stack is initially empty.\n\nNow, let's implement the `push` function.\n\nThe `push` function should add an element to the top of the stack. Before adding, we need to check if the stack is already full (i.e., `top` is equal to `MAX_SIZE - 1`). If it is full, we should handle the overflow condition.\n\nHere's how we can implement it:\n\n```cpp\nbool Stack::push(int value) {\n    if (top >= MAX_SIZE - 1) {\n        // Stack is full\n        std::cout << \"Error: Stack overflow\" << std::endl;\n        return false;\n    } else {\n        arr[++top] = value;\n        return true;\n    }\n}\n```\n\nNext, the `pop` function.\n\nThe `pop` function should remove the top element from the stack. Before removing, we need to check if the stack is empty (i.e., `top` is less than 0). If it is empty, we should handle the underflow condition.\n\nHere's how we can implement it:\n\n```cpp\nbool Stack::pop() {\n    if (top < 0) {\n        // Stack is empty\n        std::cout << \"Error: Stack underflow\" << std::endl;\n        return false;\n    } else {\n        top--;\n        return true;\n    }\n}\n```\n\nThen, the `peek` function.\n\nThe `peek` function should return the top element of the stack without removing it. Again, we need to check if the stack is empty before accessing the top element.\n\nHere's how we can implement it:\n\n```cpp\nint Stack::peek() {\n    if (top < 0) {\n        // Stack is empty\n        std::cout << \"Error: Stack underflow\" << std::endl;\n        return -1; // Assuming -1 is not a valid stack value\n    } else {\n        return arr[top];\n    }\n}\n```\n\nI chose to return `-1` as an error indicator, assuming that `-1` is not a valid value in the stack. You might want to choose a different value based on your use case.\n\nNow, let's write a simple main function to test our stack class.\n\n```cpp\nint main() {\n    Stack s;\n\n    s.push(10);\n    s.push(20);\n    s.push(30);\n\n    std::cout << \"Top element is: \" << s.peek() << std::endl;\n\n    s.pop();\n    std::cout << \"Top element after pop is: \" << s.peek() << std::endl;\n\n    s.pop();\n    s.pop();\n    s.pop(); // This should cause underflow\n\n    return 0;\n}\n```\n\nThis code pushes three elements onto the stack, peeks at the top element, pops two elements, and then tries to pop again, which should cause an underflow error.\n\nThat's a basic implementation of a stack in C++ with error handling for overflow and underflow conditions.\n\nIf you have any specific requirements or want to handle errors differently, such as using exceptions, let me know, and I can adjust the code accordingly.\n\n**Final Solution**\n\nTo solve this problem, we need to implement a stack data structure in C++ with the standard operations: push, pop, and peek. Additionally, we must handle potential errors such as overflow (when the stack is full) and underflow (when the stack is empty).\n\n### Approach\n\n1. **Stack Implementation**: We will use an array to implement the stack due to its simplicity and efficiency for fixed-size scenarios.\n2. **Operations**:\n   - **Push**: Adds an element to the top of the stack. We need to check for overflow before adding.\n   - **Pop**: Removes the top element from the stack. We need to check for underflow before removing.\n   - **Peek**: Returns the top element without removing it. We need to check for underflow before accessing the top element.\n3. **Error Handling**: We will use return values to indicate success or failure for push and pop operations and print error messages for overflow and underflow conditions.\n\n### Solution Code\n\n```cpp\n#include <iostream>\n\nclass Stack {\nprivate:\n    static const int MAX_SIZE = 100;\n    int arr[MAX_SIZE];\n    int top;\n\npublic:\n    Stack() : top(-1) {}\n\n    bool push(int value);\n    bool pop();\n    int peek();\n};\n\nbool Stack::push(int value) {\n    if (top >= MAX_SIZE - 1) {\n        // Stack is full\n        std::cout << \"Error: Stack overflow\" << std::endl;\n        return false;\n    } else {\n        arr[++top] = value;\n        return true;\n    }\n}\n\nbool Stack::pop() {\n    if (top < 0) {\n        // Stack is empty\n        std::cout << \"Error: Stack underflow\" << std::endl;\n        return false;\n    } else {\n        top--;\n        return true;\n    }\n}\n\nint Stack::peek() {\n    if (top < 0) {\n        // Stack is empty\n        std::cout << \"Error: Stack underflow\" << std::endl;\n        return -1; // Assuming -1 is not a valid stack value\n    } else {\n        return arr[top];\n    }\n}\n\nint main() {\n    Stack s;\n\n    s.push(10);\n    s.push(20);\n    s.push(30);\n\n    std::cout << \"Top element is: \" << s.peek() << std::endl;\n\n    s.pop();\n    std::cout << \"Top element after pop is: \" << s.peek() << std::endl;\n\n    s.pop();\n    s.pop();\n    s.pop(); // This should cause underflow\n\n    return 0;\n}\n```\n\n### Explanation\n\n1. **Stack Class**:\n   - **Private Members**: `arr` is an array to store stack elements, and `top` is an integer to track the top element's index.\n   - **Constructor**: Initializes `top` to -1 indicating an empty stack.\n   - **Push Operation**: Checks if the stack is full (overflow condition). If not, increments `top` and adds the new value.\n   - **Pop Operation**: Checks if the stack is empty (underflow condition). If not, decrements `top` to remove the top element.\n   - **Peek Operation**: Checks if the stack is empty (underflow condition). If not, returns the value at `arr[top]`.\n\n2. **Main Function**:\n   - Creates a stack object `s`.\n   - Pushes values 10, 20, and 30 onto the stack.\n   - Peeks at the top element and prints it.\n   - Pops one element and prints the new top element.\n   - Pops all remaining elements, including an extra pop to demonstrate underflow handling.\n\nThis implementation ensures that all stack operations are performed safely with appropriate error messages for invalid operations."
    }
]