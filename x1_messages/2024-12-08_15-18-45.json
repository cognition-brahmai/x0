[
    {
        "role": "user",
        "content": "Write a Golang program that implements the Dijkstra's shortest path algorithm to find the shortest path between two nodes in a weighted graph.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Implementing Dijkstra's shortest path algorithm in Go involves several steps. First, you need to represent the graph, then implement the algorithm to find the shortest path from a source node to all other nodes, and finally, extract the path to the destination node.\n\nHere's a step-by-step guide to creating such a program:\n\n### Step 1: Represent the Graph\n\nA common way to represent a graph is using an adjacency list, where each node has a list of its neighboring nodes along with the weights of the edges connecting them.\n\n### Step 2: Implement Dijkstra's Algorithm\n\nDijkstra's algorithm finds the shortest paths from a source node to all other nodes in a graph with non-negative edge weights. It uses a priority queue to select the next node to visit based on the current shortest distance from the source.\n\n### Step 3: Extract the Shortest Path\n\nOnce you have the shortest distances and the previous nodes, you can reconstruct the path from the source to the destination.\n\n### Solution Code\n\n```go\npackage main\n\nimport (\n\t\"container/heap\"\n\t\"fmt\"\n)\n\n// Node represents a node in the graph\ntype Node struct {\n\tID      int\n\tEdges   []*Edge\n}\n\n// Edge represents an edge connecting two nodes with a weight\ntype Edge struct {\n\tTo      *Node\n\tWeight  int\n}\n\n// Path represents the path from source to destination\ntype Path struct {\n\tDistance int\n\tPath     []*Node\n}\n\n// Implement a priority queue for Dijkstra's algorithm\ntype PriorityQueue []*Node\n\nfunc (pq PriorityQueue) Len() int { return len(pq) }\n\nfunc (pq PriorityQueue) Less(i, j int) bool {\n\treturn pq[i].Edges[0].Weight < pq[j].Edges[0].Weight\n}\n\nfunc (pq PriorityQueue) Swap(i, j int) {\n\tpq[i], pq[j] = pq[j], pq[i]\n}\n\nfunc (pq *PriorityQueue) Push(x interface{}) {\n\titem := x.(*Node)\n\t*pq = append(*pq, item)\n}\n\nfunc (pq *PriorityQueue) Pop() interface{} {\n\told := *pq\n\tn := len(old)\n\titem := old[n-1]\n\t*pq = old[0 : n-1]\n\treturn item\n}\n\n// Dijkstra finds the shortest path from source to all other nodes\nfunc Dijkstra(source *Node) map[*Node]int {\n\tdistances := make(map[*Node]int)\n\tprev := make(map[*Node]*Node)\n\tpq := make(PriorityQueue, 0)\n\n\tfor node := range graph {\n\t\tdistances[node] = int(^uint(0) >> 1) // Max int value\n\t\tprev[node] = nil\n\t}\n\n\tdistances[source] = 0\n\theap.Push(&pq, source)\n\n\tfor pq.Len() > 0 {\n\t\tcurrent := heap.Pop(&pq).(*Node)\n\t\tfor _, edge := range current.Edges {\n\t\t\tneighbor := edge.To\n\t\t\talt := distances[current] + edge.Weight\n\t\t\tif alt < distances[neighbor] {\n\t\t\t\tdistances[neighbor] = alt\n\t\t\t\tprev[neighbor] = current\n\t\t\t\theap.Push(&pq, neighbor)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn distances, prev\n}\n\n// ReconstructPath builds the shortest path from source to destination\nfunc ReconstructPath(source, destination *Node, prev map[*Node]*Node) *Path {\n\tpath := make([]*Node, 0)\n\tcurrent := destination\n\tfor current != nil {\n\t\tpath = append([]*Node{current}, path...)\n\t\tcurrent = prev[current]\n\t}\n\tif path[0] != source {\n\t\treturn nil // No path found\n\t}\n\treturn &Path{\n\t\tDistance: distances[destination],\n\t\tPath:     path,\n\t}\n}\n\nfunc main() {\n\t// Create nodes\n\tnodeA := &Node{ID: 0}\n\tnodeB := &Node{ID: 1}\n\tnodeC := &Node{ID: 2}\n\tnodeD := &Node{ID: 3}\n\n\t// Create edges\n\tnodeA.Edges = []*Edge{{To: nodeB, Weight: 1}, {To: nodeC, Weight: 4}}\n\tnodeB.Edges = []*Edge{{To: nodeC, Weight: 2}, {To: nodeD, Weight: 5}}\n\tnodeC.Edges = []*Edge{{To: nodeD, Weight: 1}}\n\tnodeD.Edges = []*Edge{}\n\n\t// Run Dijkstra's algorithm from nodeA\n\tdistances, prev := Dijkstra(nodeA)\n\n\t// Reconstruct path from nodeA to nodeD\n\tpath := ReconstructPath(nodeA, nodeD, prev)\n\tif path != nil {\n\t\tfmt.Printf(\"Shortest path from A to D: \")\n\t\tfor _, node := range path.Path {\n\t\t\tfmt.Printf(\"%d \", node.ID)\n\t\t}\n\t\tfmt.Printf(\"(Distance: %d)\\n\", path.Distance)\n\t} else {\n\t\tfmt.Println(\"No path found from A to D.\")\n\t}\n}\n```\n\n### Explanation\n\n1. **Graph Representation**:\n   - `Node` struct holds the node's ID and a list of edges.\n   - `Edge` struct holds the neighboring node and the weight of the edge.\n\n2. **Priority Queue**:\n   - A priority queue is implemented using Go's `container/heap` package to manage nodes based on their current shortest distance from the source.\n\n3. **Dijkstra's Algorithm**:\n   - Initializes distances to all nodes as infinite except the source, which is 0.\n   - Uses a priority queue to select the next node to visit, updating distances and previous nodes as shorter paths are found.\n\n4. **Path Reconstruction**:\n   - Builds the shortest path from source to destination using the `prev` map generated by Dijkstra's algorithm."
    }
]