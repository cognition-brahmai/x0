[
    {
        "role": "user",
        "content": "Create a Rust program that calculates the shortest path between two nodes in a weighted, undirected graph using Dijkstra's algorithm. The graph should be represented as an adjacency matrix read from a text file. The program should take command line arguments for the input file path and the source and destination node IDs, and output the shortest path along with its total weight.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Alright, I've got this task to create a Rust program that calculates the shortest path between two nodes in a weighted, undirected graph using Dijkstra's algorithm. The graph is represented as an adjacency matrix read from a text file, and the program should take command line arguments for the input file path and the source and destination node IDs. Finally, it should output the shortest path along with its total weight.\n\nFirst, I need to understand what an adjacency matrix is and how it represents a graph. An adjacency matrix is a square matrix used to represent a finite graph. The elements of the matrix indicate whether pairs of vertices are adjacent or not in the graph. In the case of a weighted graph, the matrix elements represent the weights of the edges between vertices.\n\nSince the graph is undirected, the adjacency matrix will be symmetric. That means the edge from node i to node j has the same weight as from j to i.\n\nNow, I need to read this matrix from a text file. I should consider the format of the file. Probably, it's a simple text file with rows representing the matrix rows, and elements separated by spaces or commas.\n\nNext, I need to implement Dijkstra's algorithm to find the shortest path from the source node to the destination node.\n\nI recall that Dijkstra's algorithm works by maintaining a set of visited nodes and a priority queue of nodes to visit next, ordered by their current shortest distance from the source. It starts at the source node, marks it as visited, and updates the distances of its neighbors. Then, it selects the unvisited node with the smallest distance, marks it as visited, and updates the distances of its neighbors, and so on, until it reaches the destination node or all nodes have been visited.\n\nI need to make sure that the algorithm handles the weights correctly and that it can handle graphs with no path between the source and destination.\n\nAlso, since the graph is represented as an adjacency matrix, I need to be careful with the indices, making sure they correspond to the correct nodes.\n\nLet me think about the steps in more detail:\n\n1. Read the adjacency matrix from the file.\n\n- Open the file specified by the command line argument.\n\n- Read the lines and parse them into a 2D vector or array.\n\n- Handle any parsing errors, such as non-numeric values or incorrect matrix dimensions.\n\n2. Implement Dijkstra's algorithm.\n\n- Initialize distances to all nodes as infinite, except the source node, which is 0.\n\n- Use a priority queue to keep track of nodes to visit next, ordered by their current distance.\n\n- Keep track of visited nodes to avoid processing them multiple times.\n\n- Keep track of the previous node in the path to reconstruct the path later.\n\n- While the priority queue is not empty:\n\n- Dequeue the node with the smallest distance.\n\n- If this node is the destination, reconstruct the path and calculate the total weight.\n\n- Otherwise, for each neighbor that has not been visited yet:\n\n- Calculate the new distance through the current node.\n\n- If this new distance is smaller than the current known distance, update the distance and the previous node.\n\n3. Output the shortest path and its total weight.\n\n- If a path was found, print the sequence of nodes and the total weight.\n\n- If no path exists, indicate that appropriately.\n\nI should also consider edge cases, such as:\n\n- The source and destination nodes are the same.\n\n- The source or destination node is out of range.\n\n- There are no edges between some nodes.\n\n- All nodes are connected.\n\n- The graph has negative weights (though Dijkstra's algorithm doesn't handle negative weights, so I'll assume all weights are non-negative).\n\n- The file does not exist or has incorrect format.\n\nI need to handle these cases gracefully, providing meaningful error messages when necessary.\n\nLet me sketch a rough plan for the program structure:\n\n- Main function:\n\n- Parse command line arguments: file path, source node ID, destination node ID.\n\n- Read the adjacency matrix from the file.\n\n- Convert the matrix into a suitable data structure, like a 2D vector of integers or floats.\n\n- Validate the matrix (square, correct dimensions, non-negative weights).\n\n- Call the Dijkstra's function with the matrix, source, and destination.\n\n- Print the result.\n\n- Dijkstra's function:\n\n- Initialize distances and previous nodes.\n\n- Use a priority queue to select the next node to visit.\n\n- Track visited nodes to avoid reprocessing.\n\n- Reconstruct the path once the destination is reached.\n\nNow, considering Rust's features, I should use appropriate data structures and error handling mechanisms.\n\nFor the adjacency matrix, a Vec<Vec<f64>> seems suitable, as it can handle a 2D array easily.\n\nFor the priority queue, Rust has the BinaryHeap in the standard library, but it's a max heap. I might need to invert the distances or implement a min heap.\n\nAlternatively, I can use a third-party crate likepriority-queue-cs for a more straightforward min heap.\n\nBut to keep it simple and stick to standard libraries, I'll see how to use BinaryHeap with reversed ordering.\n\nAlso, for tracking visited nodes and previous nodes, I can use vectors or hash maps.\n\nLet me consider the time and space complexity.\n\nSince the graph is represented as an adjacency matrix, accessing edge weights is O(1), which is good.\n\nDijkstra's algorithm with a binary heap has a time complexity of O((V + E) log V), where V is the number of vertices and E is the number of edges.\n\nGiven that, I should be fine for reasonably sized graphs.\n\nBut if the graph is very large, I might need to consider more efficient implementations or different data structures.\n\nHowever, for now, I'll proceed with the standard approach.\n\nLet me think about how to read the file.\n\nAssuming the file contains lines of numbers separated by spaces, like this:\n\n0 2 0 6\n\n2 0 3 8\n\n0 3 0 0\n\n6 8 0 0\n\nThis represents a 4x4 matrix.\n\nI need to read these lines, split them by spaces, parse each number to a float or integer, and store them in a 2D vector.\n\nI should also check that the matrix is square, i.e., all rows have the same number of elements.\n\nIf not, it's an invalid adjacency matrix.\n\nAlso, I need to handle cases where the file doesn't exist or can't be read.\n\nIn Rust, I can use the std::fs::read_to_string function to read the file content into a string, then split the string into lines and process each line.\n\nNow, for Dijkstra's algorithm, I need to keep track of the shortest distances and the path.\n\nI'll need:\n\n- A vector to store the current shortest distance from the source to each node.\n\n- A vector to store the previous node in the path for each node.\n\n- A priority queue to select the next node to visit based on the smallest distance.\n\n- A set or vector to keep track of visited nodes.\n\nIn Rust, I can use a Vec<f64> for distances and a Vec<Option<usize>> for previous nodes.\n\nFor the priority queue, I'll use BinaryHeap, but since it's a max heap, I'll need to store negative distances to simulate a min heap.\n\nAlternatively, I can create a struct for the nodes in the heap and implement Ord to order them by increasing distance.\n\nThat sounds better.\n\nI'll define a struct, say NodeDistance, with fields node_id and distance, and implement Ord so that nodes with smaller distances have higher priority.\n\nYes, that should work.\n\nOnce the algorithm is done, I need to reconstruct the path from the source to the destination using the previous nodes information.\n\nI'll start from the destination and trace back to the source, then reverse the path to get the correct order.\n\nIf the destination is not reachable from the source, I should indicate that no path exists.\n\nNow, let's think about the command line arguments.\n\nThe program should take three arguments: the file path, the source node ID, and the destination node ID.\n\nI need to parse these arguments safely, handling cases where arguments are missing or invalid.\n\nIn Rust, I can use the clap crate to handle command line arguments easily, but to keep it simple, I'll use the std::env::args function and handle the parsing manually.\n\nI need to make sure that the source and destination IDs are valid usize values and within the range of node indices.\n\nNode indices probably start from 0 to V-1, where V is the number of vertices.\n\nI should validate that the source and destination are different and within the valid range.\n\nIf not, display an error message and exit.\n\nError handling is crucial in this program, as there are several points where things can go wrong: file I/O, parsing numbers, invalid matrix format, invalid node IDs, no path found, etc.\n\nI need to handle these errors gracefully and provide informative messages to the user.\n\nIn Rust, I can use the ? operator to propagate errors out of the main function.\n\nI'll define custom error types if necessary, but for simplicity, I can use the anyhow crate for easy error handling.\n\nBut to keep dependencies minimal, I'll stick with standard library error types.\n\nNow, let's think about the output.\n\nThe program should print the shortest path as a sequence of node IDs, starting from the source and ending at the destination, along with the total weight of the path.\n\nFor example:\n\nShortest path: 0 -> 1 -> 3\n\nTotal weight: 5.0\n\nIf no path exists, it should say something like:\n\nNo path found between node 0 and node 2.\n\nI should make sure that the output is clear and easy to understand.\n\nLet me consider writing some unit tests to verify the correctness of the program.\n\nI can create small test matrices and check if the algorithm correctly computes the shortest paths.\n\nHowever, since this is a command line program, it might be more practical to test the functions separately, like having a test for reading the matrix from a file, a test for Dijkstra's algorithm with a known matrix, etc.\n\nRust's testing framework should suffice for this purpose.\n\nNow, let's outline the steps in code terms:\n\n1. Parse command line arguments.\n\n- Get the file path, source ID, and destination ID from args().\n\n- Parse source and destination IDs to usize.\n\n- Handle errors if arguments are missing or invalid.\n\n2. Read the adjacency matrix from the file.\n\n- Use std::fs::read_to_string to read the file content.\n\n- Split the content into lines and then into numbers.\n\n- Parse the numbers to f64 and store them in a 2D vector.\n\n- Validate that the matrix is square.\n\n- Handle any I/O or parsing errors.\n\n3. Implement Dijkstra's algorithm.\n\n- Initialize distances and previous nodes.\n\n- Use a priority queue (BinaryHeap) with custom ordering.\n\n- Track visited nodes.\n\n- Update distances and previous nodes as per the algorithm.\n\n- Reconstruct the path once the destination is reached.\n\n- Handle cases where no path exists.\n\n4. Output the results.\n\n- Print the path and total weight if found.\n\n- Print an error message if no path exists.\n\nI should also consider the performance implications, but for now, focusing on correctness and clarity is more important.\n\nLet me think about how to represent infinity for the distances.\n\nIn Rust, f64 has an INFINITY constant, which I can use to represent infinite distances initially.\n\nWhen updating distances, I'll check if the new distance is smaller than the current distance, and if so, update it.\n\nI need to make sure that the priority queue handles nodes with infinite distances appropriately.\n\nAlso, I should consider that if a node is not connected to the source, its distance will remain infinite.\n\nIn that case, I should check if the destination's distance is still infinite after the algorithm finishes, indicating no path exists.\n\nNow, let's think about the priority queue.\n\nI'll define a struct NodeDistance with fields node_id and distance, and implement Ord so that smaller distances have higher priority.\n\nHere's a rough sketch:\n\nstruct NodeDistance {\n\nnode_id: usize,\n\ndistance: f64,\n\n}\n\nimpl PartialEq for NodeDistance {\n\nfn eq(&self, other: &Self) -> bool {\n\nself.distance == other.distance\n\n}\n\n}\n\nimpl Eq for NodeDistance {}\n\nimpl PartialOrd for NodeDistance {\n\nfn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n\nSome(self.cmp(other))\n\n}\n\n}\n\nimpl Ord for NodeDistance {\n\nfn cmp(&self, other: &Self) -> Ordering {\n\n// We want a min-heap, so smaller distances have higher priority\n\nself.distance.partial_cmp(&other.distance).unwrap()\n\n}\n\n}\n\nWait, but partial_cmp can return None if comparisons are not possible, but in this case, f64 can have NaN values, which might cause issues.\n\nTo simplify, I'll assume that all weights are non-negative, so distances won't be NaN.\n\nAlternatively, I can handle NaN appropriately in the comparison.\n\nBut for now, I'll proceed under the assumption that all weights are non-negative and distances are finite.\n\nIn the Dijkstra's function, I'll need to:\n\n- Initialize distances with infinity, except the source node set to 0.\n\n- Initialize previous nodes with None.\n\n- Insert all nodes into the priority queue with their initial distances.\n\n- While the queue is not empty:\n\n- Dequeue the node with the smallest distance.\n\n- If it's the destination, reconstruct and return the path.\n\n- If it's already visited, skip it.\n\n- Mark it as visited.\n\n- For each neighbor that hasn't been visited yet:\n\n- Calculate the new distance through the current node.\n\n- If it's smaller than the current known distance, update the distance and previous node, and adjust the priority queue.\n\nReconstructing the path:\n\n- Start from the destination node.\n\n- Follow the previous nodes until reaching the source.\n\n- Collect the nodes in reverse order and then reverse the list.\n\n- Calculate the total weight by summing the weights along the path.\n\nI need to make sure that the path reconstruction doesn't enter an infinite loop, which could happen if there are cycles, but since Dijkstra's algorithm doesn't handle negative weights, and we're assuming non-negative weights, this shouldn't be an issue.\n\nNow, let's think about how to represent the adjacency matrix.\n\nA Vec<Vec<f64>> should work.\n\nEach inner vector represents a row in the matrix, and each element is the weight of the edge between the corresponding nodes.\n\nFor example, matrix[row][col] represents the weight of the edge from node row to node col.\n\nSince the graph is undirected, matrix[row][col] should be equal to matrix[col][row].\n\nI need to validate that the matrix is square and symmetric, but for simplicity, I'll assume that the input file provides a valid adjacency matrix.\n\nHowever, it's good to add some checks for robustness.\n\nNow, let's consider writing some pseudocode for the main steps.\n\nPseudocode for reading the matrix from file:\n\nfn read_matrix_from_file(file_path: &str) -> Result<Vec<Vec<f64>>, io::Error> {\n\nlet content = fs::read_to_string(file_path)?;\n\nlet lines: Vec<String> = content.lines().map(str::trim).filter(|line| !line.is_empty()).collect();\n\nlet row_count = lines.len();\n\nlet mut matrix = Vec::with_capacity(row_count);\n\nfor line in lines {\n\nlet row: Result<Vec<f64>, _> = line.split_whitespace().map(str::parse).collect();\n\nmatrix.push(row?);\n\n}\n\n// Validate that all rows have the same number of columns\n\nlet col_count = matrix[0].len();\n\nfor row in &matrix {\n\nif row.len() != col_count {\n\nreturn Err(io::Error::new(io::ErrorKind::InvalidData, \"Matrix is not square\"));\n\n}\n\n}\n\nOk(matrix)\n\n}\n\nPseudocode for Dijkstra's algorithm:\n\nfn dijkstra(matrix: &Vec<Vec<f64>>, source: usize, destination: usize) -> Result<(Vec<usize>, f64), String> {\n\nlet n = matrix.len();\n\nif source >= n || destination >= n {\n\nreturn Err(\"Invalid node IDs\".to_string());\n\n}\n\nlet mut distances = vec![f64::INFINITY; n];\n\ndistances[source] = 0.0;\n\nlet mut previous = vec![None; n];\n\nlet mut visited = vec![false; n];\n\nlet mut heap = BinaryHeap::new();\n\nfor node in 0..n {\n\nheap.push(NodeDistance { node_id: node, distance: distances[node] });\n\n}\n\nwhile let Some(NodeDistance { node_id: current, distance: _ }) = heap.pop() {\n\nif visited[current] {\n\ncontinue;\n\n}\n\nif current == destination {\n\nbreak;\n\n}\n\nvisited[current] = true;\n\nfor neighbor in 0..n {\n\nif !visited[neighbor] && matrix[current][neighbor] > 0.0 {\n\nlet new_distance = distances[current] + matrix[current][neighbor];\n\nif new_distance < distances[neighbor] {\n\ndistances[neighbor] = new_distance;\n\nprevious[neighbor] = Some(current);\n\n// Update the heap\n\nif let Some(index) = heap.iter().position(|nd| nd.node_id == neighbor) {\n\nheap.swap_remove(index);\n\n}\n\nheap.push(NodeDistance { node_id: neighbor, distance: new_distance });\n\n}\n\n}\n\n}\n\n}\n\nif distances[destination] == f64::INFINITY {\n\nreturn Err(\"No path found\".to_string());\n\n}\n\nlet mut path = Vec::new();\n\nlet mut current = destination;\n\nwhile let Some(prev) = previous[current] {\n\npath.push(current);\n\ncurrent = prev;\n\n}\n\npath.push(source);\n\npath.reverse();\n\nlet total_weight = distances[destination];\n\nOk((path, total_weight))\n\n}\n\nPseudocode for the main function:\n\nfn main() {\n\nlet args: Vec<String> = env::args().collect();\n\nif args.len() != 4 {\n\neprintln!(\"Usage: {} <file_path> <source_id> <destination_id>\", args[0]);\n\nstd::process::exit(1);\n\n}\n\nlet file_path = &args[1];\n\nlet source: usize = match args[2].parse() {\n\nOk(num) => num,\n\nErr(_) => {\n\neprintln!(\"Invalid source node ID\");\n\nstd::process::exit(1);\n\n}\n\n};\n\nlet destination: usize = match args[3].parse() {\n\nOk(num) => num,\n\nErr(_) => {\n\neprintln!(\"Invalid destination node ID\");\n\nstd::process::exit(1);\n\n}\n\n};\n\nmatch read_matrix_from_file(file_path) {\n\nOk(matrix) => {\n\nmatch dijkstra(&matrix, source, destination) {\n\nOk((path, total_weight)) => {\n\nprintln!(\"Shortest path: {}\", path.iter().map(|n| n.to_string()).collect::<Vec<_>>().join(\" -> \"));\n\nprintln!(\"Total weight: {}\", total_weight);\n\n}\n\nErr(err_msg) => {\n\neprintln!(\"{}\", err_msg);\n\n}\n\n}\n\n}\n\nErr(e) => {\n\neprintln!(\"Error reading file: {}\", e);\n\n}\n\n}\n\n}\n\nThis seems like a solid plan.\n\nI need to implement the read_matrix_from_file function to read the file and parse the matrix.\n\nThen, implement the dijkstra function to calculate the shortest path using Dijkstra's algorithm.\n\nFinally, in the main function, parse the command line arguments, call the functions, and print the results.\n\nI should also consider adding comments to the code for clarity and possibly handle more edge cases for robustness.\n\nAdditionally, I can think about refactoring some parts into smaller functions to improve readability and maintainability.\n\nFor example, separating the path reconstruction into its own function.\n\nAlso, considering that the adjacency matrix might be large, I should think about memory usage and ensure that the program doesn't consume excessive resources.\n\nBut for now, this plan should suffice to get started.\n\nI'll begin by implementing the read_matrix_from_file function and testing it with a sample file.\n\nThen, I'll proceed to implement Dijkstra's algorithm and test it with known inputs.\n\nFinally, I'll integrate everything into the main function and handle any errors that may arise.\n\n## Final Solution\nTo solve this problem, we need to create a Rust program that calculates the shortest path between two nodes in a weighted, undirected graph using Dijkstra's algorithm. The graph is represented as an adjacency matrix read from a text file. The program should take command line arguments for the input file path and the source and destination node IDs, and output the shortest path along with its total weight.\n\n### Approach\n\n1. **Reading the Adjacency Matrix:**\n   - Read the file specified by the command line argument.\n   - Parse the lines into a 2D vector representing the adjacency matrix.\n   - Ensure the matrix is square and handle any parsing errors.\n\n2. **Dijkstra's Algorithm:**\n   - Initialize distances to all nodes as infinite, except the source node, which is 0.\n   - Use a priority queue to select the next node to visit based on the smallest distance.\n   - Track visited nodes and update distances and previous nodes as needed.\n   - Reconstruct the path once the destination node is reached.\n\n3. **Output the Result:**\n   - Print the sequence of nodes in the shortest path and the total weight.\n   - Handle cases where no path exists between the source and destination nodes.\n\n### Solution Code\n\n```rust\nuse std::env;\nuse std::fs;\nuse std::io;\nuse std::cmp::Ordering;\nuse std::collections::BinaryHeap;\n\n#[derive(Eq)]\nstruct NodeDistance {\n    node_id: usize,\n    distance: f64,\n}\n\nimpl PartialEq for NodeDistance {\n    fn eq(&self, other: &Self) -> bool {\n        self.distance == other.distance\n    }\n}\n\nimpl PartialOrd for NodeDistance {\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n        // We want a min-heap, so smaller distances have higher priority\n        other.distance.partial_cmp(&self.distance)\n    }\n}\n\nimpl Ord for NodeDistance {\n    fn cmp(&self, other: &Self) -> Ordering {\n        self.partial_cmp(other).unwrap()\n    }\n}\n\nfn read_matrix_from_file(file_path: &str) -> io::Result<Vec<Vec<f64>>> {\n    let content = fs::read_to_string(file_path)?;\n    let lines: Vec<String> = content\n        .lines()\n        .map(str::trim)\n        .filter(|line| !line.is_empty())\n        .collect();\n    let row_count = lines.len();\n    let mut matrix = Vec::with_capacity(row_count);\n    for line in lines {\n        let row: Result<Vec<f64>, _> = line.split_whitespace().map(str::parse).collect();\n        matrix.push(row.map_err(|e| io::Error::new(io::ErrorKind::InvalidData, e))?);\n    }\n    // Validate that all rows have the same number of columns\n    let col_count = matrix[0].len();\n    for row in &matrix {\n        if row.len() != col_count {\n            return Err(io::Error::new(io::ErrorKind::InvalidData, \"Matrix is not square\"));\n        }\n    }\n    Ok(matrix)\n}\n\nfn dijkstra(matrix: &Vec<Vec<f64>>, source: usize, destination: usize) -> Result<(Vec<usize>, f64), String> {\n    let n = matrix.len();\n    if source >= n || destination >= n {\n        return Err(\"Invalid node IDs\".to_string());\n    }\n    let mut distances = vec![f64::INFINITY; n];\n    distances[source] = 0.0;\n    let mut previous = vec![None; n];\n    let mut visited = vec![false; n];\n    let mut heap = BinaryHeap::new();\n    for node in 0..n {\n        heap.push(NodeDistance { node_id: node, distance: distances[node] });\n    }\n    while let Some(NodeDistance { node_id: current, distance: _ }) = heap.pop() {\n        if visited[current] {\n            continue;\n        }\n        if current == destination {\n            break;\n        }\n        visited[current] = true;\n        for neighbor in 0..n {\n            if !visited[neighbor] && matrix[current][neighbor] > 0.0 {\n                let new_distance = distances[current] + matrix[current][neighbor];\n                if new_distance < distances[neighbor] {\n                    distances[neighbor] = new_distance;\n                    previous[neighbor] = Some(current);\n                    // Update the heap\n                    if let Some(index) = heap.iter().position(|nd| nd.node_id == neighbor) {\n                        heap.swap_remove(index);\n                    }\n                    heap.push(NodeDistance { node_id: neighbor, distance: new_distance });\n                }\n            }\n        }\n    }\n    if distances[destination] == f64::INFINITY {\n        return Err(\"No path found\".to_string());\n    }\n    let mut path = Vec::new();\n    let mut current = destination;\n    while let Some(prev) = previous[current] {\n        path.push(current);\n        current = prev;\n    }\n    path.push(source);\n    path.reverse();\n    let total_weight = distances[destination];\n    Ok((path, total_weight))\n}\n\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    if args.len() != 4 {\n        eprintln!(\"Usage: {} <file_path> <source_id> <destination_id>\", args[0]);\n        std::process::exit(1);\n    }\n    let file_path = &args[1];\n    let source: usize = match args[2].parse() {\n        Ok(num) => num,\n        Err(_) => {\n            eprintln!(\"Invalid source node ID\");\n            std::process::exit(1);\n        }\n    };\n    let destination: usize = match args[3].parse() {\n        Ok(num) => num,\n        Err(_) => {\n            eprintln!(\"Invalid destination node ID\");\n            std::process::exit(1);\n        }\n    };\n    match read_matrix_from_file(file_path) {\n        Ok(matrix) => {\n            match dijkstra(&matrix, source, destination) {\n                Ok((path, total_weight)) => {\n                    println!(\"Shortest path: {}\", path.iter().map(|n| n.to_string()).collect::<Vec<_>>().join(\" -> \"));\n                    println!(\"Total weight: {}\", total_weight);\n                }\n                Err(err_msg) => {\n                    eprintln!(\"{}\", err_msg);\n                }\n            }\n        }\n        Err(e) => {\n            eprintln!(\"Error reading file: {}\", e);\n        }\n    }\n}\n```\n\n### Explanation\n\n1. **Reading the Matrix:**\n   - The `read_matrix_from_file` function reads the file and parses it into a 2D vector.\n   - It ensures that the matrix is square and handles any I/O or parsing errors.\n\n2. **Dijkstra's Algorithm:**\n   - The `dijkstra` function implements the algorithm using a binary heap as a priority queue.\n   - It maintains distances and previous nodes to reconstruct the path.\n   - It handles cases where no path exists between the source and destination.\n\n3. **Main Function:**\n   - Parses command line arguments for file path, source, and destination.\n   - Calls the matrix reading and path finding functions.\n   - Outputs the shortest path and its total weight or an error message if no path is found."
    }
]