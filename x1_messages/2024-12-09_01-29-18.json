[
    {
        "role": "user",
        "content": "Using PowerShell, create a script that scans a directory and its subdirectories for files larger than a certain size, specified as a command-line argument. The script should output the file paths and sizes sorted by size in descending order. PLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Alright, I've got this task to create a PowerShell script that scans a directory and its subdirectories for files larger than a specified size, and then outputs those files' paths and sizes, sorted by size in descending order. The specified size should come from a command-line argument. Sounds straightforward, but I need to make sure I cover all the bases here.\n\nFirst things first, I need to understand how to handle command-line arguments in PowerShell. I know that PowerShell scripts can accept parameters using the Param keyword. So, I'll probably start my script with something like:\n\n```powershell\nParam(\n    [Parameter(Mandatory=$true)]\n    [int]$Size\n)\n```\n\nThis should make sure that the user provides a size value when running the script, and it's treated as an integer.\n\nNext, I need to scan a directory and its subdirectories for files. In PowerShell, the Get-ChildItem cmdlet is perfect for this. I can use it with the -Recurse parameter to traverse all subdirectories. But I also need to specify the directory to scan. Hmm, perhaps I should add another parameter for the directory path.\n\nLet me update my Param block:\n\n```powershell\nParam(\n    [Parameter(Mandatory=$true)]\n    [int]$Size,\n\n    [Parameter(Mandatory=$true)]\n    [string]$Path\n)\n```\n\nNow, I can use the $Path variable in Get-ChildItem to specify the starting directory.\n\nSo, the basic structure would be:\n\n```powershell\n$files = Get-ChildItem -Path $Path -Recurse -File\n```\n\nThis will give me a list of all files in the specified directory and its subdirectories.\n\nNow, I need to filter these files to find those larger than the specified size. I can use the Where-Object cmdlet for this, checking the Length property of each file.\n\nSomething like:\n\n```powershell\n$largeFiles = $files | Where-Object { $_.Length -gt $Size }\n```\n\nBut I should consider the unit of the size. Is the size in bytes, kilobytes, megabytes? To make it user-friendly, maybe I should allow the user to specify the unit, like KB or MB.\n\nWait, perhaps I can accept the size in bytes by default, but provide an option for KB or MB.\n\nAlternatively, I can make the size parameter accept values with units, like \"1MB\" or \"1024KB\". PowerShell might handle this automatically if I use the appropriate type.\n\nLet me check the documentation for the Parameter attribute. Oh, I can specify the type as [double] and accept units by using the [ValidateScript] attribute or by parsing the input.\n\nActually, PowerShell has built-in unit conversion for some types. For example, [int] can handle KB and MB if I use [uint64].\n\nLet me try:\n\n```powershell\nParam(\n    [Parameter(Mandatory=$true)]\n    [uint64]$Size,\n\n    [Parameter(Mandatory=$true)]\n    [string]$Path\n)\n```\n\nAnd see if I can input \"1MB\" or \"1024KB\".\n\nWait, [uint64] should handle numerical values, but not necessarily unit suffixes. Maybe I need to parse the input myself.\n\nAlternatively, I can keep it simple and accept the size in bytes, and let the user handle the units.\n\nFor now, I'll stick with accepting the size in bytes, and if needed, I can add unit conversion later.\n\nSo, back to filtering files:\n\n```powershell\n$largeFiles = $files | Where-Object { $_.Length -gt $Size }\n```\n\nThen, I need to output the file paths and sizes, sorted by size in descending order.\n\nI can use Select-Object to choose the Name and Length properties, and then sort them using Sort-Object.\n\nLike this:\n\n```powershell\n$largeFiles | Select-Object Name, Length | Sort-Object Length -Descending\n```\n\nWait, but I want the full path, not just the name. So, I should use the FullName property instead of Name.\n\n```powershell\n$largeFiles | Select-Object FullName, Length | Sort-Object Length -Descending\n```\n\nThat should do it.\n\nLet me put it all together:\n\n```powershell\nParam(\n    [Parameter(Mandatory=$true)]\n    [int]$Size,\n\n    [Parameter(Mandatory=$true)]\n    [string]$Path\n)\n\n$files = Get-ChildItem -Path $Path -Recurse -File\n$largeFiles = $files | Where-Object { $_.Length -gt $Size }\n$largeFiles | Select-Object FullName, Length | Sort-Object Length -Descending\n```\n\nI should test this script to make sure it works as expected.\n\nFirst, I'll save this as FindLargeFiles.ps1.\n\nThen, I can run it from the PowerShell prompt, providing a path and a size.\n\nFor example:\n\n```powershell\n.\\FindLargeFiles.ps1 -Size 1048576 -Path C:\\SomeDirectory\n```\n\nThis should find all files larger than 1 MB in C:\\SomeDirectory and its subdirectories, and list them sorted by size descending.\n\nBut, I'm thinking, maybe I should format the output to make the sizes more readable, like showing them in KB or MB instead of bytes.\n\nPowerShell has the Convert-Units cmdlet, but I think I can format the size on the fly using calculated properties in Select-Object.\n\nSomething like:\n\n```powershell\n$largeFiles | Select-Object FullName, @{Name=\"SizeMB\";Expression={\"{0:N2}\" -f ($_?.Length / 1MB)}} | Sort-Object Length -Descending\n```\n\nWait, but I need to sort by the actual Length, but display SizeMB.\n\nAlso, 1MB might not be recognized directly. I should use 1MB as 1 * 1024 * 1024.\n\nLet me correct that.\n\nFirst, define 1MB as 1048576.\n\nSo:\n\n```powershell\n$largeFiles | Select-Object FullName, @{Name=\"SizeMB\";Expression={\"{0:N2}\" -f ($_?.Length / 1048576)}} | Sort-Object Length -Descending\n```\n\nBut in the Sort-Object, I should sort by the Length property, which is in bytes.\n\nAlternatively, I can sort by the calculated SizeMB property.\n\nWait, but if I sort by Length, which is in bytes, it's fine, since it's numeric.\n\nBut to make it more intuitive, maybe I should sort by SizeMB.\n\nBut SizeMB is a calculated property, so I need to sort by a script block.\n\nLike this:\n\n```powershell\n$largeFiles | Select-Object FullName, @{Name=\"SizeMB\";Expression={\"{0:N2}\" -f ($_?.Length / 1048576)}} | Sort-Object -Property { [double]$_.SizeMB } -Descending\n```\n\nBut this might not work directly, because SizeMB is a string formatted to two decimal places.\n\nPerhaps it's better to sort by the Length property and just display SizeMB for readability.\n\nSo:\n\n```powershell\n$largeFiles | Select-Object FullName, @{Name=\"SizeMB\";Expression={\"{0:N2}\" -f ($_?.Length / 1048576)}} | Sort-Object Length -Descending\n```\n\nThis way, the sorting is based on the actual file size in bytes, and SizeMB is just for display.\n\nAlso, to handle potential null values, I used $_?.Length to avoid errors if Length is null.\n\nWait, but Length should always be available for files.\n\nAnyway, to be safe, using the null-conditional operator is good practice.\n\nAdditionally, I might want to include more information, like the directory path separately from the file name.\n\nOr maybe the last write time of the file.\n\nBut for now, keeping it simple with just the full path and size is fine.\n\nI should also consider performance, especially for large directories with many files.\n\nUsing Get-ChildItem with -Recurse can be slow for deep directory structures or networks.\n\nMaybe I can optimize it by using Get-ChildItem with -File and -Recurse, which is already efficient, but perhaps adding -Force to include hidden files as well.\n\nSo, updating the Get-ChildItem line:\n\n```powershell\n$files = Get-ChildItem -Path $Path -Recurse -File -Force\n```\n\nThis will include hidden files in the search.\n\nBut if I don't want to include hidden files, I can omit the -Force parameter.\n\nI'll leave it out for now to avoid including system files or hidden files unintentionally.\n\nAnother thing to consider is error handling. What if the specified path doesn't exist? Or if there are permission issues reading certain files?\n\nI should add try-catch blocks to handle such scenarios.\n\nFor example:\n\n```powershell\ntry {\n    $files = Get-ChildItem -Path $Path -Recurse -File -ErrorAction Stop\n    $largeFiles = $files | Where-Object { $_.Length -gt $Size }\n    $largeFiles | Select-Object FullName, @{Name=\"SizeMB\";Expression={\"{0:N2}\" -f ($_?.Length / 1048576)}} | Sort-Object Length -Descending\n}\ncatch {\n    Write-Error \"An error occurred: $_\"\n}\n```\n\nThis way, if there's an error (like an invalid path or permission issues), it will be caught and an error message will be displayed.\n\nAlso, I can add some validation for the Size parameter to make sure it's a positive integer.\n\nAlthough [int]$Size should handle negative values, I might want to add a validation attribute to ensure it's greater than zero.\n\nLike this:\n\n```powershell\nParam(\n    [Parameter(Mandatory=$true)]\n    [ValidateRange(1, [int]::MaxValue)]\n    [int]$Size,\n\n    [Parameter(Mandatory=$true)]\n    [string]$Path\n)\n```\n\nThis ensures that Size is at least 1 byte.\n\nSimilarly, for the Path parameter, I can validate that it's a valid directory path.\n\nI can use the Test-Path cmdlet for this.\n\nSomething like:\n\n```powershell\nParam(\n    [Parameter(Mandatory=$true)]\n    [ValidateRange(1, [int]::MaxValue)]\n    [int]$Size,\n\n    [Parameter(Mandatory=$true)]\n    [ValidateScript({Test-Path $_ -PathType Container})]\n    [string]$Path\n)\n```\n\nThis should ensure that the provided path exists and is a directory.\n\nIf the path doesn't exist or isn't a directory, an error will be thrown when the script is run.\n\nOkay, now, considering all these points, here's the updated script:\n\n```powershell\nParam(\n    [Parameter(Mandatory=$true)]\n    [ValidateRange(1, [int]::MaxValue)]\n    [int]$Size,\n\n    [Parameter(Mandatory=$true)]\n    [ValidateScript({Test-Path $_ -PathType Container})]\n    [string]$Path\n)\n\ntry {\n    $files = Get-ChildItem -Path $Path -Recurse -File -ErrorAction Stop\n    $largeFiles = $files | Where-Object { $_.Length -gt $Size }\n    $largeFiles | Select-Object FullName, @{Name=\"SizeMB\";Expression={\"{0:N2}\" -f ($_?.Length / 1048576)}} | Sort-Object Length -Descending\n}\ncatch {\n    Write-Error \"An error occurred: $_\"\n}\n```\n\nI should test this script with various scenarios:\n\n1. Valid path and size, files present.\n\n2. Valid path and size, no files larger than the specified size.\n\n3. Invalid path.\n\n4. Permission issues.\n\n5. Size less than 1 (though validated, still good to test).\n\n6. Very large directories to check performance.\n\nFor example:\n\n1. .\\FindLargeFiles.ps1 -Size 1048576 -Path C:\\Users\\YourName\\Documents\n\n2. .\\FindLargeFiles.ps1 -Size 1048576 -Path C:\\NonExistentDirectory\n\n3. .\\FindLargeFiles.ps1 -Size 0 -Path C:\\Users\\YourName\\Documents (should fail due to validation)\n\n4. .\\FindLargeFiles.ps1 -Size 1024 -Path C:\\Windows (may have permission issues)\n\nBy testing these scenarios, I can ensure that the script handles different situations gracefully.\n\nAdditionally, I might want to add some output messages to inform the user about the progress or results.\n\nFor example, displaying the number of files found or a message if no files are larger than the specified size.\n\nI can do this by counting the $largeFiles and outputting a message accordingly.\n\nLike this:\n\n```powershell\n$largeFilesCount = $largeFiles.Count\n\nif ($largeFilesCount -eq 0) {\n    Write-Output \"No files larger than $Size bytes found in $Path.\"\n}\nelse {\n    Write-Output \"Found $largeFilesCount files larger than $Size bytes in $Path:\"\n    $largeFiles | Select-Object FullName, @{Name=\"SizeMB\";Expression={\"{0:N2}\" -f ($_?.Length / 1048576)}} | Sort-Object Length -Descending\n}\n```\n\nThis adds some user feedback, which is always a good practice.\n\nUpdating the script:\n\n```powershell\nParam(\n    [Parameter(Mandatory=$true)]\n    [ValidateRange(1, [int]::MaxValue)]\n    [int]$Size,\n\n    [Parameter(Mandatory=$true)]\n    [ValidateScript({Test-Path $_ -PathType Container})]\n    [string]$Path\n)\n\ntry {\n    $files = Get-ChildItem -Path $Path -Recurse -File -ErrorAction Stop\n    $largeFiles = $files | Where-Object { $_.Length -gt $Size }\n    $largeFilesCount = $largeFiles.Count\n\n    if ($largeFilesCount -eq 0) {\n        Write-Output \"No files larger than $Size bytes found in $Path.\"\n    }\n    else {\n        Write-Output \"Found $largeFilesCount files larger than $Size bytes in $Path:\"\n        $largeFiles | Select-Object FullName, @{Name=\"SizeMB\";Expression={\"{0:N2}\" -f ($_?.Length / 1048576)}} | Sort-Object Length -Descending\n    }\n}\ncatch {\n    Write-Error \"An error occurred: $_\"\n}\n```\n\nThis should cover most of the requirements.\n\nOne more thing: handling very large directories could be time-consuming. Maybe I can add a warning or a progress indicator for such cases.\n\nPowerShell has a built-in feature for showing progress using Write-Progress.\n\nI can use it to show the progress of scanning files.\n\nFor example:\n\n```powershell\n$files = Get-ChildItem -Path $Path -Recurse -File -ErrorAction Stop -Force\n\n$totalFiles = $files.Count\n$counter = 1\n\n$largeFiles = @()\n\nforeach ($file in $files) {\n    Write-Progress -Activity \"Scanning files\" -Status \"Processing file $counter of $totalFiles\" -PercentComplete (($counter / $totalFiles) * 100)\n    if ($file.Length -gt $Size) {\n        $largeFiles += $file\n    }\n    $counter++\n}\n\n# Rest of the script\n```\n\nThis will display a progress bar while scanning files, which can be helpful for large directories.\n\nHowever, this might not be necessary if the default behavior is acceptable.\n\nI'll consider adding it based on testing.\n\nAnother enhancement could be to allow the user to output the results to a file, maybe via a switch parameter.\n\nFor example:\n\n```powershell\nParam(\n    [Parameter(Mandatory=$true)]\n    [ValidateRange(1, [int]::MaxValue)]\n    [int]$Size,\n\n    [Parameter(Mandatory=$true)]\n    [ValidateScript({Test-Path $_ -PathType Container})]\n    [string]$Path,\n\n    [switch]$OutputToFile\n)\n```\n\nThen, if $OutputToFile is specified, save the output to a file, say, LargeFilesReport.csv.\n\nLike this:\n\n```powershell\nif ($OutputToFile) {\n    $largeFiles | Select-Object FullName, @{Name=\"SizeMB\";Expression={\"{0:N2}\" -f ($_?.Length / 1048576)}} | Sort-Object Length -Descending | Export-Csv -Path \"LargeFilesReport.csv\" -NoTypeInformation\n    Write-Output \"Report saved to LargeFilesReport.csv\"\n}\nelse {\n    $largeFiles | Select-Object FullName, @{Name=\"SizeMB\";Expression={\"{0:N2}\" -f ($_?.Length / 1048576)}} | Sort-Object Length -Descending\n}\n```\n\nThis adds flexibility for the user to save the results for further analysis.\n\nUpdating the script:\n\n```powershell\nParam(\n    [Parameter(Mandatory=$true)]\n    [ValidateRange(1, [int]::MaxValue)]\n    [int]$Size,\n\n    [Parameter(Mandatory=$true)]\n    [ValidateScript({Test-Path $_ -PathType Container})]\n    [string]$Path,\n\n    [switch]$OutputToFile\n)\n\ntry {\n    $files = Get-ChildItem -Path $Path -Recurse -File -ErrorAction Stop\n    $largeFiles = $files | Where-Object { $_.Length -gt $Size }\n    $largeFilesCount = $largeFiles.Count\n\n    if ($largeFilesCount -eq 0) {\n        Write-Output \"No files larger than $Size bytes found in $Path.\"\n    }\n    else {\n        Write-Output \"Found $largeFilesCount files larger than $Size bytes in $Path:\"\n        if ($OutputToFile) {\n            $largeFiles | Select-Object FullName, @{Name=\"SizeMB\";Expression={\"{0:N2}\" -f ($_?.Length / 1048576)}} | Sort-Object Length -Descending | Export-Csv -Path \"LargeFilesReport.csv\" -NoTypeInformation\n            Write-Output \"Report saved to LargeFilesReport.csv\"\n        }\n        else {\n            $largeFiles | Select-Object FullName, @{Name=\"SizeMB\";Expression={\"{0:N2}\" -f ($_?.Length / 1048576)}} | Sort-Object Length -Descending\n        }\n    }\n}\ncatch {\n    Write-Error \"An error occurred: $_\"\n}\n```\n\nThis should cover most use cases.\n\nI might also want to allow the user to specify the output file name instead of a fixed name.\n\nI can add another parameter for the output file path.\n\nLike this:\n\n```powershell\nParam(\n    [Parameter(Mandatory=$true)]\n    [ValidateRange(1, [int]::MaxValue)]\n    [int]$Size,\n\n    [Parameter(Mandatory=$true)]\n    [ValidateScript({Test-Path $_ -PathType Container})]\n    [string]$Path,\n\n    [switch]$OutputToFile,\n\n    [string]$OutputFilePath = \"LargeFilesReport.csv\"\n)\n```\n\nThen, in the script:\n\n```powershell\nif ($OutputToFile) {\n    $largeFiles | Select-Object FullName, @{Name=\"SizeMB\";Expression={\"{0:N2}\" -f ($_?.Length / 1048576)}} | Sort-Object Length -Descending | Export-Csv -Path $OutputFilePath -NoTypeInformation\n    Write-Output \"Report saved to $OutputFilePath\"\n}\nelse {\n    $largeFiles | Select-Object FullName, @{Name=\"SizeMB\";Expression={\"{0:N2}\" -f ($_?.Length / 1048576)}} | Sort-Object Length -Descending\n}\n```\n\nThis gives the user the option to specify where to save the report.\n\nNow, the script is quite feature-rich.\n\nI should make sure that all parameters are documented properly using comment-based help in PowerShell.\n\nI can add a help section at the top of the script to explain how to use it and what each parameter does.\n\nHere's an example:\n\n```powershell\n<#\n.SYNOPSIS\nFinds files larger than a specified size in a given directory and its subdirectories.\n\n.DESCRIPTION\nThis script scans a specified directory and its subdirectories to find files that are larger than a given size.\nThe results can be displayed on the console or saved to a CSV file.\n\n.PARAMETER Size\nThe minimum size of files to find, specified in bytes.\n\n.PARAMETER Path\nThe directory path to start the scan.\n\n.PARAMETER OutputToFile\nIf specified, the output will be saved to a CSV file instead of being displayed on the console.\n\n.PARAMETER OutputFilePath\nThe path and filename for the output CSV file. Defaults to 'LargeFilesReport.csv'.\n\n.EXAMPLE\n.\\FindLargeFiles.ps1 -Size 1048576 -Path C:\\Users\\YourName\\Documents\nFinds all files larger than 1 MB in the specified directory and displays them.\n\n.EXAMPLE\n.\\FindLargeFiles.ps1 -Size 1048576 -Path C:\\Users\\YourName\\Documents -OutputToFile -OutputFilePath C:\\Reports\\LargeFiles.csv\nFinds all files larger than 1 MB in the specified directory and saves the report to 'C:\\Reports\\LargeFiles.csv'.\n\n.NOTES\nAuthor: [Your Name]\nDate: [Current Date]\n#>\n\nParam(\n    [Parameter(Mandatory=$true)]\n    [ValidateRange(1, [int]::MaxValue)]\n    [int]$Size,\n\n    [Parameter(Mandatory=$true)]\n    [ValidateScript({Test-Path $_ -PathType Container})]\n    [string]$Path,\n\n    [switch]$OutputToFile,\n\n    [string]$OutputFilePath = \"LargeFilesReport.csv\"\n)\n\ntry {\n    $files = Get-ChildItem -Path $Path -Recurse -File -ErrorAction Stop\n    $largeFiles = $files | Where-Object { $_.Length -gt $Size }\n    $largeFilesCount = $largeFiles.Count\n\n    if ($largeFilesCount -eq 0) {\n        Write-Output \"No files larger than $Size bytes found in $Path.\"\n    }\n    else {\n        Write-Output \"Found $largeFilesCount files larger than $Size bytes in $Path:\"\n        if ($OutputToFile) {\n            $largeFiles | Select-Object FullName, @{Name=\"SizeMB\";Expression={\"{0:N2}\" -f ($_?.Length / 1048576)}} | Sort-Object Length -Descending | Export-Csv -Path $OutputFilePath -NoTypeInformation\n            Write-Output \"Report saved to $OutputFilePath\"\n        }\n        else {\n            $largeFiles | Select-Object FullName, @{Name=\"SizeMB\";Expression={\"{0:N2}\" -f ($_?.Length / 1048576)}} | Sort-Object Length -Descending\n        }\n    }\n}\ncatch {\n    Write-Error \"An error occurred: $_\"\n}\n```\n\nThis adds comprehensive help documentation, which is very useful for users who are not familiar with the script.\n\nI should also consider localizing the script for different cultures, but that might be overkill for this scenario.\n\nFinally, I should test the script thoroughly to ensure there are no bugs or unexpected behaviors.\n\nSome test cases to consider:\n\n- Specifying a valid path and size, with files larger than the specified size.\n\n- Specifying a valid path and size, with no files larger than the specified size.\n\n- Specifying an invalid path.\n\n- Specifying a size less than 1.\n\n- Specifying the OutputToFile switch and providing a custom output file path.\n\n- Handling very large directories with numerous files.\n\n- Handling files with special characters in their names.\n\n- Handling files that are currently in use or have permission issues.\n\nBy testing these scenarios, I can ensure that the script is robust and reliable.\n\nOnce testing is complete, the script is ready to be used.\n\n## Final Solution\nTo create a PowerShell script that scans a directory and its subdirectories for files larger than a specified size and outputs their paths and sizes sorted by size in descending order, follow these steps:\n\n### Solution Code\n\n```powershell\n<#\n.SYNOPSIS\nFinds files larger than a specified size in a given directory and its subdirectories.\n\n.DESCRIPTION\nThis script scans a specified directory and its subdirectories to find files that are larger than a given size.\nThe results can be displayed on the console or saved to a CSV file.\n\n.PARAMETER Size\nThe minimum size of files to find, specified in bytes.\n\n.PARAMETER Path\nThe directory path to start the scan.\n\n.PARAMETER OutputToFile\nIf specified, the output will be saved to a CSV file instead of being displayed on the console.\n\n.PARAMETER OutputFilePath\nThe path and filename for the output CSV file. Defaults to 'LargeFilesReport.csv'.\n\n.EXAMPLE\n.\\FindLargeFiles.ps1 -Size 1048576 -Path C:\\Users\\YourName\\Documents\nFinds all files larger than 1 MB in the specified directory and displays them.\n\n.EXAMPLE\n.\\FindLargeFiles.ps1 -Size 1048576 -Path C:\\Users\\YourName\\Documents -OutputToFile -OutputFilePath C:\\Reports\\LargeFiles.csv\nFinds all files larger than 1 MB in the specified directory and saves the report to 'C:\\Reports\\LargeFiles.csv'.\n\n.NOTES\nAuthor: [Your Name]\nDate: [Current Date]\n#>\n\nParam(\n    [Parameter(Mandatory=$true)]\n    [ValidateRange(1, [int]::MaxValue)]\n    [int]$Size,\n\n    [Parameter(Mandatory=$true)]\n    [ValidateScript({Test-Path $_ -PathType Container})]\n    [string]$Path,\n\n    [switch]$OutputToFile,\n\n    [string]$OutputFilePath = \"LargeFilesReport.csv\"\n)\n\ntry {\n    $files = Get-ChildItem -Path $Path -Recurse -File -ErrorAction Stop\n    $largeFiles = $files | Where-Object { $_.Length -gt $Size }\n    $largeFilesCount = $largeFiles.Count\n\n    if ($largeFilesCount -eq 0) {\n        Write-Output \"No files larger than $Size bytes found in $Path.\"\n    }\n    else {\n        Write-Output \"Found $largeFilesCount files larger than $Size bytes in $Path:\"\n        if ($OutputToFile) {\n            $largeFiles | Select-Object FullName, @{Name=\"SizeMB\";Expression={\"{0:N2}\" -f ($_?.Length / 1048576)}} | Sort-Object Length -Descending | Export-Csv -Path $OutputFilePath -NoTypeInformation\n            Write-Output \"Report saved to $OutputFilePath\"\n        }\n        else {\n            $largeFiles | Select-Object FullName, @{Name=\"SizeMB\";Expression={\"{0:N2}\" -f ($_?.Length / 1048576)}} | Sort-Object Length -Descending\n        }\n    }\n}\ncatch {\n    Write-Error \"An error occurred: $_\"\n}\n```\n\n### Explanation\n\n1. **Parameters**:\n   - `Size`: The minimum file size in bytes.\n   - `Path`: The directory path to scan.\n   - `OutputToFile`: Optional switch to output results to a CSV file.\n   - `OutputFilePath`: Path for the CSV output file (defaults to 'LargeFilesReport.csv').\n\n2. **Error Handling**:\n   - Uses `try` and `catch` to handle errors gracefully, ensuring that any issues during execution are caught and reported.\n\n3. **File Scanning**:\n   - Uses `Get-ChildItem` with `-Recurse` and `-File` parameters to traverse the directory and its subdirectories.\n   - Filters files larger than the specified size using `Where-Object`.\n\n4. **Output**:\n   - Displays file paths and sizes in MB, sorted by size in descending order.\n   - Optionally saves the output to a CSV file if the `OutputToFile` switch is used.\n\n5. **Validation**:\n   - Ensures that the provided size is a positive integer.\n   - Validates that the specified path exists and is a directory.\n\nThis script provides a robust solution for identifying large files within a directory structure and offers flexibility in how the results are presented."
    }
]