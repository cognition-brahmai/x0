[
    {
        "role": "user",
        "content": "Create a Python script that deploys a Kubernetes cluster using the Azure Kubernetes Service (AKS) SDK. The script should accept command line arguments for the resource group, cluster name, node count, and location.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Alright, I've got this task to create a Python script that deploys a Kubernetes cluster using Azure Kubernetes Service (AKS) SDK. The script needs to accept command-line arguments for the resource group, cluster name, node count, and location. Okay, let's break this down.\n\nFirst things first, I need to make sure I have the necessary Azure SDK packages installed. For AKS, I believe I'll need the `azure-mgmt-containerservice` package. I should probably also import some other standard libraries for handling command-line arguments and possibly authentication.\n\nSo, I'll start by importing the required modules. I'll need `default.AzureCredentials` for authentication, and `ContainerServiceClient` from `azure.mgmt.containerservice` to interact with AKS. Also, I'll use the `argparse` module to handle command-line arguments.\n\nNext, I need to set up the command-line arguments. The user should be able to specify the resource group, cluster name, node count, and location. I should also consider adding some help text for each argument to make it user-friendly.\n\nOnce I have the arguments, I need to authenticate to Azure. I can use the `AzureCredentials` to get an access token and then create a `ContainerServiceClient` with this credential.\n\nAfter that, I'll need to check if the resource group exists. If not, I should create it. Then, I'll proceed to create the AKS cluster with the specified name, node count, and location.\n\nI should also consider adding some error handling to manage cases like invalid arguments, authentication failures, or failures during resource group or cluster creation.\n\nLet me think about the structure of the script:\n\n1. Import necessary modules.\n\n2. Set up argument parsing with `argparse`.\n\n3. Authenticate to Azure.\n\n4. Check if the resource group exists; if not, create it.\n\n5. Create the AKS cluster with the specified parameters.\n\n6. Handle any exceptions that may occur.\n\nI should also make sure that the script provides some output to the user, like confirming that the resource group was created or that the cluster creation has been initiated.\n\nAdditionally, I might want to include some waiting mechanism to check if the cluster creation is complete, but that might be optional for now.\n\nAlright, let's start writing some pseudocode to outline the steps.\n\n```\n\nimport argparse\n\nfrom azure.identity import DefaultAzureCredential\n\nfrom azure.mgmt.containerservice import ContainerServiceClient\n\nfrom azure.mgmt.resource import ResourceManagementClient\n\ndef main():\n\nparser = argparse.ArgumentParser(description='Deploy an AKS cluster.')\n\nparser.add_argument('--resource-group', help='Name of the resource group', required=True)\n\nparser.add_argument('--cluster-name', help='Name of the AKS cluster', required=True)\n\nparser.add_argument('--node-count', type=int, help='Number of agent nodes in the cluster', required=True)\n\nparser.add_argument('--location', help='Location for the resource group and cluster', required=True)\n\nargs = parser.parse_args()\n\ncredential = DefaultAzureCredential()\n\nresource_client = ResourceManagementClient(credential, subscription_id)\n\ncontainer_service_client = ContainerServiceClient(credential, subscription_id)\n\n# Check if resource group exists, if not, create it\n\nresource_group_params = {'location': args.location}\n\nresource_group = resource_client.resource_groups.create_or_update(\n\nargs.resource_group,\n\nresource_group_params\n\n)\n\nprint(f\"Resource group {args.resource_group} created or updated.\")\n\n# Define AKS cluster configuration\n\naks_config = {\n\n'location': args.location,\n\n'kubernetes_version': '',  # Maybe latest?\n\n'dns_prefix': '',  # Need to set this\n\n'agent_pool_profiles': [\n\n{\n\n'name': 'default',\n\n'count': args.node_count,\n\n'vertical_scale_type': '',\n\n'os_type': 'Linux',\n\n'storage_profile': 'ManagedDisks',\n\n'vm_size': 'Standard_DS2_v2'\n\n}\n\n],\n\n'linux_profile': {\n\n'admin_username': 'azureuser',\n\n'ssh': {\n\n'public_keys': [\n\n{\n\n'key_data': ''  # Need to set this\n\n}\n\n]\n\n}\n\n}\n\n}\n\n# Create AKS cluster\n\ncluster_async_operation = container_service_client.managed_clusters.begin_create_or_update(\n\nargs.resource_group,\n\nargs.cluster_name,\n\naks_config\n\n)\n\ncluster = cluster_async_operation.result()\n\nprint(f\"AKS cluster {args.cluster_name} created.\")\n\nif __name__ == '__main__':\n\nmain()\n\n```\n\nOkay, this is a rough outline. I need to fill in some details, like the subscription ID, DNS prefix, and SSH key data. I might need to get the subscription ID from the credentials or have it as another command-line argument.\n\nAlso, I need to handle exceptions properly. For example, if the resource group creation fails, or if the AKS cluster creation fails, I should inform the user appropriately.\n\nLet me think about how to handle the subscription ID. Maybe I can retrieve it from the credentials. I believe `DefaultAzureCredential` can be used to get the token for the management endpoint, and from there, I can extract the subscription ID.\n\nAlternatively, I can make the subscription ID another command-line argument. That way, it's more flexible.\n\nI'll add the subscription ID as a command-line argument.\n\nAlso, for the DNS prefix, I can set it to something based on the cluster name, perhaps.\n\nAs for the SSH key, I might need to have the user provide the public key path or directly input the key data. To simplify, maybe I can assume that the public key is available at a default location, like `~/.ssh/id_rsa.pub`, and read it from there.\n\nBut to make it more user-friendly, perhaps I should allow the user to specify the path to the public SSH key via another command-line argument.\n\nLet me update the argument parser to include the subscription ID and SSH public key path.\n\n```\n\nparser.add_argument('--subscription-id', help='Azure Subscription ID', required=True)\n\nparser.add_argument('--ssh-public-key', help='Path to the SSH public key', required=True)\n\n```\n\nThen, in the script, I'll read the SSH public key from the specified path.\n\nAlso, I need to set the DNS prefix. I can construct it based on the cluster name and location, ensuring it's unique.\n\nAzure has requirements for the DNS prefix, like being lowercase and within certain length limits. I need to make sure that the constructed prefix meets these requirements.\n\nMaybe I can set the DNS prefix to something like `<cluster-name>-<location>` and convert it to lowercase, replacing any spaces with hyphens.\n\nI should also validate that the location provided is a valid Azure location.\n\nWait, Azure locations have specific names, like \"eastus\" or \"westeurope\". I should ensure that the user provides a valid location.\n\nAlternatively, I can retrieve the list of available locations using the Resource Management Client and verify that the provided location is in that list.\n\nThat would add an extra layer of validation, but it might be overkill for now. Maybe I'll skip that for simplicity.\n\nNext, I need to handle the agent pool profile. I have set the VM size to `Standard_DS2_v2`, but perhaps I should make this configurable as well.\n\nTo keep it simple, I'll hardcode it for now, but I can consider adding it as another command-line argument if needed.\n\nAlso, I need to handle the Kubernetes version. Should I set it to a specific version or use the latest available?\n\nUsing the latest available might be fine, but I need to check how to specify that in the AKS configuration.\n\nI think setting `kubernetes_version` to an empty string might default to the latest, but I should confirm that.\n\nAlternatively, I can retrieve the list of available Kubernetes versions for the specified location and choose the latest one.\n\nThat would be better, as it ensures I'm using the latest version supported in that location.\n\nSo, I'll need to retrieve the list of versions and select the latest one.\n\nI can do this using the `list_orchestrators` method of the `ContainerServiceClient`.\n\nI'll add that step before creating the AKS cluster.\n\nLet me update the pseudocode accordingly.\n\n```\n\n# Retrieve list of orchestrators (Kubernetes versions)\n\norchestrators = container_service_client.Orchestrators.list_orchestrators(args.location)\n\n# Choose the latest Kubernetes version\n\nlatest_k8s_version = max([o.OrchestratorVersion for o in orchestrators.orchestrators if o.OrchestratorType == 'Kubernetes'])\n\naks_config['kubernetes_version'] = latest_k8s_version\n\n```\n\nI need to make sure that the `Orchestrators.list_orchestrators` method is correctly called and that I'm filtering for Kubernetes types.\n\nAlso, I need to handle the DNS prefix properly. Let's construct it based on the cluster name and location.\n\n```\n\ndns_prefix = f\"{args.cluster_name}-{args.location}\".lower().replace(' ', '-')\n\naks_config['dns_prefix'] = dns_prefix\n\n```\n\nI should also ensure that the DNS prefix meets Azure's requirements for length and character set.\n\nAzure requires the DNS prefix to be between 3 and 63 characters, consisting of lowercase letters, numbers, and hyphens, starting and ending with a letter or number.\n\nI need to validate that the constructed prefix meets these criteria.\n\nTo make it simple, I'll assume that the cluster name and location combined won't exceed the length limit and that they consist of valid characters.\n\nIf needed, I can add more robust validation, but for now, this should suffice.\n\nNow, regarding the Linux profile and SSH key. I'll read the public SSH key from the path provided by the user.\n\nI need to handle cases where the file doesn't exist or can't be read.\n\nI'll add try-except blocks for file operations.\n\nHere's how I can read the SSH public key:\n\n```\n\nwith open(args.ssh_public_key, 'r') as file:\n\nssh_public_key = file.read().strip()\n\n```\n\nThen, set it in the `aks_config`:\n\n```\n\n'linux_profile': {\n\n'admin_username': 'azureuser',\n\n'ssh': {\n\n'public_keys': [\n\n{\n\n'key_data': ssh_public_key\n\n}\n\n]\n\n}\n\n}\n\n```\n\nI should also consider adding more configurations to the cluster, like enabling RBAC or setting specific node pools, but to keep it simple, I'll stick with the basic configuration.\n\nNext, I need to handle exceptions throughout the script. For example:\n\n- If authentication fails, catch the `azure.core.exceptions.AzureError` and inform the user.\n\n- If the resource group creation fails, catch the corresponding exception and provide an error message.\n\n- If the AKS cluster creation fails, catch the exception and provide details if possible.\n\nI'll need to import the necessary exception classes from `azure.core.exceptions`.\n\nAlso, I should consider adding a verbose mode where the script outputs more information about the operations being performed.\n\nFor now, I'll keep it minimal, with just confirmation messages for successful operations.\n\nLet me think about the flow again:\n\n1. Parse command-line arguments.\n\n2. Authenticate to Azure using `DefaultAzureCredential`.\n\n3. Create a Resource Management Client and a Container Service Client.\n\n4. Check if the resource group exists; if not, create it.\n\n5. Retrieve the latest Kubernetes version supported in the location.\n\n6. Construct the AKS configuration with the provided parameters and the retrieved Kubernetes version.\n\n7. Create the AKS cluster.\n\n8. Wait for the cluster creation to complete and confirm success.\n\nI need to make sure that the script waits for the cluster creation to complete before exiting. Since cluster creation can take several minutes, I should inform the user that it's an asynchronous operation and provide a way to check the status.\n\nAlternatively, I can make the script wait for the operation to complete using the `result()` method, as I have in the pseudocode.\n\nBut to provide better feedback, maybe I can add a loop that polls the cluster status and prints progress messages.\n\nHowever, that might complicate the script. For now, I'll stick with using `result()` which blocks until the operation completes.\n\nI should also capture and display any error messages if the cluster creation fails.\n\nNow, let's think about testing this script. I need to make sure that I have the necessary Azure permissions to create resource groups and AKS clusters in the specified subscription.\n\nI should also ensure that the SSH public key provided is valid and accessible.\n\nI might want to run the script with the `--help` option to verify that the argument parser is set up correctly.\n\nAdditionally, I can test the script in a controlled environment, like an Azure subscription with contributor access, to see if it successfully creates the resource group and deploys the AKS cluster.\n\nI should also consider cleaning up after the test by deleting the resource group and its resources to avoid incurring unnecessary costs.\n\nTo automate this, I could add a separate script or functionality to delete the resource group, but that might be out of scope for this task.\n\nAlright, I think I have a solid plan. Now, I'll proceed to write the actual Python script based on this outline.\n\n## Final Solution\nTo deploy a Kubernetes cluster using Azure Kubernetes Service (AKS) SDK, you can use the following Python script. This script accepts command-line arguments for the resource group, cluster name, node count, location, subscription ID, and SSH public key path.\n\n### Prerequisites\n\n1. **Azure Account**: Ensure you have an Azure account with appropriate permissions.\n2. **Azure CLI**: Install and configure Azure CLI.\n3. **Azure SDK for Python**: Install the required packages using pip:\n   ```bash\n   pip install azure-identity azure-mgmt-containerservice azure-mgmt-resource argparse\n   ```\n\n### Script\n\n```python\nimport argparse\nimport os\nfrom azure.identity import DefaultAzureCredential\nfrom azure.mgmt.containerservice import ContainerServiceClient\nfrom azure.mgmt.resource import ResourceManagementClient\nfrom azure.core.exceptions import AzureError\n\ndef main():\n    parser = argparse.ArgumentParser(description='Deploy an AKS cluster.')\n    parser.add_argument('--resource-group', help='Name of the resource group', required=True)\n    parser.add_argument('--cluster-name', help='Name of the AKS cluster', required=True)\n    parser.add_argument('--node-count', type=int, help='Number of agent nodes in the cluster', required=True)\n    parser.add_argument('--location', help='Location for the resource group and cluster', required=True)\n    parser.add_argument('--subscription-id', help='Azure Subscription ID', required=True)\n    parser.add_argument('--ssh-public-key', help='Path to the SSH public key', required=True)\n    args = parser.parse_args()\n\n    try:\n        credential = DefaultAzureCredential()\n        resource_client = ResourceManagementClient(credential, args.subscription_id)\n        container_service_client = ContainerServiceClient(credential, args.subscription_id)\n\n        # Check if resource group exists, if not, create it\n        resource_group_params = {'location': args.location}\n        resource_group = resource_client.resource_groups.create_or_update(\n            args.resource_group,\n            resource_group_params\n        )\n        print(f\"Resource group {args.resource_group} created or updated.\")\n\n        # Retrieve list of orchestrators to get latest Kubernetes version\n        orchestrators = container_service_client.managed_clusters.list_orchestrators(args.location, \"managedClusters\")\n        latest_k8s_version = max([o.orchestrator_version for o in orchestrators.orchestrators if o.orchestrator_type == 'Kubernetes'])\n        print(f\"Latest Kubernetes version: {latest_k8s_version}\")\n\n        # Read SSH public key\n        with open(args.ssh_public_key, 'r') as file:\n            ssh_public_key = file.read().strip()\n\n        # Construct DNS prefix\n        dns_prefix = f\"{args.cluster_name}-{args.location}\".lower().replace(' ', '-')\n        print(f\"DNS prefix: {dns_prefix}\")\n\n        # Define AKS cluster configuration\n        aks_config = {\n            'location': args.location,\n            'kubernetes_version': latest_k8s_version,\n            'dns_prefix': dns_prefix,\n            'agent_pool_profiles': [\n                {\n                    'name': 'default',\n                    'count': args.node_count,\n                    'vm_size': 'Standard_DS2_v2',\n                    'os_type': \"Linux\",\n                    'type': \"VirtualMachineScaleSets\"\n                }\n            ],\n            'linux_profile': {\n                'admin_username': 'azureuser',\n                'ssh': {\n                    'public_keys': [\n                        {\n                            'key_data': ssh_public_data\n                        }\n                    ]\n                }\n            }\n        }\n\n        # Create AKS cluster\n        cluster_lro = container_service_client.managed_clusters.begin_create_or_update(args.resource_group, args.cluster_name, aks_config)\n        cluster = cluster_lro.result()\n        print(f\"AKS cluster {args.cluster_name} created.\")\n\n    except FileNotFoundError:\n        print(f\"Error: SSH public key file not found at {args.ssh_public_key}\")\n    except AzureError as e:\n        print(f\"An Azure-related error occurred: {e}\")\n    except Exception as e:\n        print(f\"An error occurred: {e}\")\n\nif __name__ == '__main__':\n    main()\n```\n\n### Instructions\n\n1. **Save the Script**: Save the script to a file, e.g., `deploy_aks.py`.\n2. **Run the Script**: Execute the script from the command line, providing the required arguments.\n   ```bash\n   python deploy_aks.py --resource-group <resource-group-name> --cluster-name <cluster-name> --node-count <number-of-nodes> --location <location> --subscription-id <subscription-id> --ssh-public-key <path-to-ssh-public-key>\n   ```\n\nThis script will create a resource group if it doesn't exist and then deploy an AKS cluster with the specified parameters. Make sure to handle the cleanup of resources after use to avoid incurring unnecessary costs."
    }
]