[
    {
        "role": "user",
        "content": "Create a Node.js script that fetches JSON data from a given API endpoint and saves it to a local file. The script should accept command line arguments for the API URL, HTTP method (GET/POST), request headers, and output file path. Implement proper error handling for failed requests or invalid URLs.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Alright, I have this task to create a Node.js script that fetches JSON data from an API endpoint and saves it to a local file. The script needs to accept command line arguments for the API URL, the HTTP method (either GET or POST), request headers, and the output file path. Also, I need to make sure that there's proper error handling for cases where the request fails or the URL is invalid.\n\nFirst, I need to set up a new Node.js project. I'll create a directory for this script and initialize a new Node.js project there.\n\n```bash\nmkdir api-fetcher\ncd api-fetcher\nnpm init -y\n```\n\nNext, I need to install any necessary packages. Since Node.js has built-in modules for making HTTP requests and handling files, I might not need to install anything extra. However, to make things easier, I can use the `axios` library for making HTTP requests, as it's more user-friendly than the built-in `http` or `https` modules. I'll also use `yargs` to parse command line arguments, as it makes handling options and arguments more straightforward.\n\nLet me install these packages:\n\n```bash\nnpm install axios yargs\n```\n\nNow, I need to think about the structure of the script. I'll need to:\n\n1. Parse command line arguments using `yargs`.\n\n2. Make an HTTP request to the provided API URL using the specified method (GET or POST).\n\n3. Handle any errors that might occur during the request, such as network errors or invalid URLs.\n\n4. If the request is successful, save the JSON response to a local file specified by the user.\n\n5. Provide feedback to the user about the success or failure of the operation.\n\nLet's start by setting up `yargs` to accept the required arguments. The user should be able to provide the API URL, HTTP method, request headers, and output file path via the command line.\n\nI'll define the arguments in `yargs` like this:\n\n```javascript\nconst yargs = require('yargs');\n\nconst argv = yargs\n  .option('url', {\n    alias: 'u',\n    describe: 'API URL',\n    type: 'string',\n    demandOption: true,\n  })\n  .option('method', {\n    alias: 'm',\n    describe: 'HTTP method (GET or POST)',\n    type: 'string',\n    demandOption: true,\n  })\n  .option('headers', {\n    alias: 'h',\n    describe: 'Request headers (JSON string)',\n    type: 'string',\n    demandOption: false,\n  })\n  .option('output', {\n    alias: 'o',\n    describe: 'Output file path',\n    type: 'string',\n    demandOption: true,\n  })\n  .help()\n  .alias('help', 'h')\n  .argv;\n```\n\nHere, I'm defining options for URL, method, headers, and output file path. I'm also providing aliases for shorter command line usage and making sure that URL, method, and output are required options.\n\nNext, I need to make the HTTP request using `axios`. I'll need to handle both GET and POST methods differently. For GET requests, I can simply pass the URL and headers to `axios.get()`. For POST requests, I'll use `axios.post()` and include any data if provided. Wait, the prompt doesn't mention request data, only headers. So, for now, I'll assume that only headers are needed for both methods.\n\nI need to parse the headers from the command line. Since headers are provided as a JSON string, I'll need to parse that string into a JavaScript object.\n\nHere's how I can do that:\n\n```javascript\nlet headers;\ntry {\n  headers = argv.headers ? JSON.parse(argv.headers) : {};\n} catch (e) {\n  console.error('Invalid headers JSON:', e.message);\n  process.exit(1);\n}\n```\n\nNow, I'll create a function to make the HTTP request based on the method provided.\n\n```javascript\nconst axios = require('axios');\n\nasync function makeRequest(url, method, headers) {\n  try {\n    if (method.toUpperCase() === 'GET') {\n      const response = await axios.get(url, { headers });\n      return response.data;\n    } else if (method.toUpperCase() === 'POST') {\n      const response = await axios.post(url, null, { headers });\n      return response.data;\n    } else {\n      console.error('Unsupported HTTP method:', method);\n      process.exit(1);\n    }\n  } catch (error) {\n    console.error('Error making request:', error.message);\n    process.exit(1);\n  }\n}\n```\n\nIn this function, I'm using `axios` to make either a GET or POST request with the provided headers. If the method is neither GET nor POST, I'll exit the script with an error message.\n\nOnce I have the data from the API, I need to save it to a local file. I'll use the built-in `fs` module for this.\n\nFirst, I need to ensure that the output file path is valid. I'll assume that the user provides a valid path, but I should handle any errors that occur during the file writing process.\n\nHere's how I can save the JSON data to a file:\n\n```javascript\nconst fs = require('fs').promises;\n\nasync function saveToFile(data, outputPath) {\n  try {\n    await fs.writeFile(outputPath, JSON.stringify(data, null, 2));\n    console.log('Data saved to', outputPath);\n  } catch (error) {\n    console.error('Error saving data to file:', error.message);\n    process.exit(1);\n  }\n}\n```\n\nI'm using `fs.promises.writeFile` to write the JSON data to the specified file path. I'm also stringifying the JSON with indentation for better readability.\n\nNow, I need to put all these parts together in the main script.\n\nHere's the complete script so far:\n\n```javascript\nconst yargs = require('yargs');\nconst axios = require('axios');\nconst fs = require('fs').promises;\n\nconst argv = yargs\n  .option('url', {\n    alias: 'u',\n    describe: 'API URL',\n    type: 'string',\n    demandOption: true,\n  })\n  .option('method', {\n    alias: 'm',\n    describe: 'HTTP method (GET or POST)',\n    type: 'string',\n    demandOption: true,\n  })\n  .option('headers', {\n    alias: 'h',\n    describe: 'Request headers (JSON string)',\n    type: 'string',\n    demandOption: false,\n  })\n  .option('output', {\n    alias: 'o',\n    describe: 'Output file path',\n    type: 'string',\n    demandOption: true,\n  })\n  .help()\n  .alias('help', 'h')\n  .argv;\n\nlet headers;\ntry {\n  headers = argv.headers ? JSON.parse(argv.headers) : {};\n} catch (e) {\n  console.error('Invalid headers JSON:', e.message);\n  process.exit(1);\n}\n\nasync function makeRequest(url, method, headers) {\n  try {\n    if (method.toUpperCase() === 'GET') {\n      const response = await axios.get(url, { headers });\n      return response.data;\n    } else if (method.toUpperCase() === 'POST') {\n      const response = await axios.post(url, null, { headers });\n      return response.data;\n    } else {\n      console.error('Unsupported HTTP method:', method);\n      process.exit(1);\n    }\n  } catch (error) {\n    console.error('Error making request:', error.message);\n    process.exit(1);\n  }\n}\n\nasync function saveToFile(data, outputPath) {\n  try {\n    await fs.writeFile(outputPath, JSON.stringify(data, null, 2));\n    console.log('Data saved to', outputPath);\n  } catch (error) {\n    console.error('Error saving data to file:', error.message);\n    process.exit(1);\n  }\n}\n\n(async () => {\n  const data = await makeRequest(argv.url, argv.method, headers);\n  await saveToFile(data, argv.output);\n})();\n```\n\nThis script should work for fetching JSON data from an API endpoint using either GET or POST method, with optional headers, and saving it to a local file.\n\nHowever, I should consider adding more robust error handling, especially for network errors or invalid URLs. Axios provides detailed error objects that I can use to provide more informative error messages to the user.\n\nLet me update the `makeRequest` function to handle different types of errors:\n\n```javascript\nasync function makeRequest(url, method, headers) {\n  try {\n    let response;\n    if (method.toUpperCase() === 'GET') {\n      response = await axios.get(url, { headers });\n    } else if (method.toUpperCase() === 'POST') {\n      response = await axios.post(url, null, { headers });\n    } else {\n      console.error('Unsupported HTTP method:', method);\n      process.exit(1);\n    }\n    return response.data;\n  } catch (error) {\n    if (error.response) {\n      // Server responded with a status code that falls out of the range of 2xx\n      console.error(`Request failed with status ${error.response.status}:`, error.response.data);\n    } else if (error.request) {\n      // The request was made but no response was received\n      console.error('No response received:', error.message);\n    } else {\n      // Something happened in setting up the request that triggered an Error\n      console.error('Error setting up request:', error.message);\n    }\n    process.exit(1);\n  }\n}\n```\n\nThis way, I can provide more specific error messages based on the type of error that occurred.\n\nAdditionally, I should ensure that the output file path is writable and handle any file system related errors appropriately.\n\nAlso, I might want to allow the user to provide request data for POST requests. The current implementation doesn't support sending data with POST requests. If that's a requirement, I need to update the script accordingly.\n\nBut based on the initial prompt, which only mentions request headers and doesn't mention request data, I'll proceed with the current implementation.\n\nTo test the script, I can create a sample API endpoint or use a public API for testing purposes. For example, I can use the JSONPlaceholder API, which provides fake endpoints for testing.\n\nHere's an example of how to run the script:\n\n```bash\nnode script.js -u https://jsonplaceholder.typicode.com/posts -m get -o output.json\n```\n\nThis should fetch the list of posts from the JSONPlaceholder API using a GET request and save the JSON data to `output.json`.\n\nSimilarly, for a POST request:\n\n```bash\nnode script.js -u https://jsonplaceholder.typicode.com/posts -m post -h '{\"Content-Type\": \"application/json\"}' -o output.json\n```\n\nNote that for POST requests, I'm not sending any data in the request body, as per the current implementation.\n\nIf I need to support sending request data for POST requests, I can add another command line option for data and modify the `axios.post()` call accordingly.\n\nBut for now, I'll keep it simple and assume that only headers are needed.\n\nI should also consider adding validation for the method argument to ensure that it's either 'GET' or 'POST'. I've already done that in the `makeRequest` function by exiting the script if an unsupported method is provided.\n\nMoreover, I should make sure that the URL is valid. Axios should handle invalid URLs and throw an error, which I can catch and display an appropriate message.\n\nOverall, the script seems functional for the specified requirements.\n\n## Final Solution\nTo create a Node.js script that fetches JSON data from a given API endpoint and saves it to a local file, with command line arguments for the API URL, HTTP method (GET/POST), request headers, and output file path, follow these steps:\n\n### Solution Code\n\n```javascript\nconst yargs = require('yargs');\nconst axios = require('axios');\nconst fs = require('fs').promises;\n\n// Parse command line arguments\nconst argv = yargs\n  .option('url', {\n    alias: 'u',\n    describe: 'API URL',\n    type: 'string',\n    demandOption: true,\n  })\n  .option('method', {\n    alias: 'm',\n    describe: 'HTTP method (GET or POST)',\n    type: 'string',\n    demandOption: true,\n  })\n  .option('headers', {\n    alias: 'h',\n    describe: 'Request headers (JSON string)',\n    type: 'string',\n    demandOption: false,\n  })\n  .option('output', {\n    alias: 'o',\n    describe: 'Output file path',\n    type: 'string',\n    demandOption: true,\n  })\n  .help()\n  .alias('help', 'h')\n  .argv;\n\n// Parse headers JSON string to object\nlet headers;\ntry {\n  headers = argv.headers ? JSON.parse(argv.headers) : {};\n} catch (e) {\n  console.error('Invalid headers JSON:', e.message);\n  process.exit(1);\n}\n\n// Function to make HTTP request\nasync function makeRequest(url, method, headers) {\n  try {\n    if (method.toUpperCase() === 'GET') {\n      const response = await axios.get(url, { headers });\n      return response.data;\n    } else if (method.toUpperCase() === 'POST') {\n      const response = await axios.post(url, null, { headers });\n      return response.data;\n    } else {\n      console.error('Unsupported HTTP method:', method);\n      process.exit(1);\n    }\n  } catch (error) {\n    if (error.response) {\n      console.error(`Request failed with status ${error.response.status}:`, error.response.data);\n    } else if (error.request) {\n      console.error('No response received:', error.message);\n    } else {\n      console.error('Error setting up request:', error.message);\n    }\n    process.exit(1);\n  }\n}\n\n// Function to save data to file\nasync function saveToFile(data, outputPath) {\n  try {\n    await fs.writeFile(outputPath, JSON.stringify(data, null, 2));\n    console.log('Data saved to', outputPath);\n  } catch (error) {\n    console.error('Error saving data to file:', error.message);\n    process.exit(1);\n  }\n}\n\n// Main execution\n(async () => {\n  const data = await makeRequest(argv.url, argv.method, headers);\n  await saveToFile(data, argv.output);\n})();\n```\n\n### Explanation\n\n1. **Command Line Arguments Parsing:**\n   - Use `yargs` to define and parse command line options for URL, method, headers, and output file path.\n\n2. **Headers Parsing:**\n   - Convert the headers JSON string to a JavaScript object.\n\n3. **HTTP Request:**\n   - Use `axios` to make GET or POST requests based on the provided method.\n   - Handle errors for network issues, invalid URLs, and non-2xx status codes.\n\n4. **Saving Data:**\n   - Use `fs.promises.writeFile` to write the fetched JSON data to a local file with proper formatting.\n\n5. **Error Handling:**\n   - Ensure all potential errors are caught and appropriate messages are displayed, exiting the script gracefully.\n\nThis script provides a robust way to fetch and save JSON data from APIs using specified HTTP methods and headers, with comprehensive error handling."
    }
]