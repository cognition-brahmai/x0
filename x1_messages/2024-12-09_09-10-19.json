[
    {
        "role": "user",
        "content": "Implement a Binary Search Tree (BST) in Python, with methods to insert, delete, and search for nodes. Include an additional method to find the height of the tree."
    },
    {
        "role": "assistant",
        "content": "Sure, I can help you with that! Implementing a Binary Search Tree (BST) in Python involves creating a node class and a tree class with methods for insertion, deletion, search, and finding the height of the tree.\n\nFirst, let's define the structure of a node in the BST. Each node will have a value and pointers to its left and right children.\n\n```python\nclass TreeNode:\n    def __init__(self, key):\n        self.left = None\n        self.right = None\n        self.val = key\n```\n\nNext, we'll create the BST class that will handle the insertion, deletion, search, and heightfinding operations.\n\n### Insertion\n\nInsertion in a BST involves comparing the new value with the current node's value and deciding whether to go left or right. This process is repeated recursively until an appropriate empty spot is found.\n\n```python\nclass BST:\n    def __init__(self):\n        self.root = None\n\n    def insert(self, key):\n        if self.root is None:\n            self.root = TreeNode(key)\n        else:\n            self._insert_recursive(self.root, key)\n\n    def _insert_recursive(self, node, key):\n        if key < node.val:\n            if node.left is None:\n                node.left = TreeNode(key)\n            else:\n                self._insert_recursive(node.left, key)\n        else:\n            if node.right is None:\n                node.right = TreeNode(key)\n            else:\n                self._insert_recursive(node.right, key)\n```\n\n### Search\n\nSearching for a value in a BST involves comparing the target value with the current node's value and deciding whether to go left or right, similar to insertion.\n\n```python\n    def search(self, key):\n        return self._search_recursive(self.root, key)\n\n    def _search_recursive(self, node, key):\n        if node is None or node.val == key:\n            return node\n        if key < node.val:\n            return self._search_recursive(node.left, key)\n        else:\n            return self._search_recursive(node.right, key)\n```\n\n### Deletion\n\nDeletion in a BST is a bit more complex. It involves three cases:\n\n1. **Node to be deleted is leaf:** Simply remove it.\n\n2. **Node to be deleted has one child:** Copy the child to the node and delete the child.\n\n3. **Node to be deleted has two children:** Find the in-order successor (smallest in the right subtree), copy its value to the node, and delete the successor.\n\n```python\n    def delete(self, key):\n        self.root = self._delete_recursive(self.root, key)\n\n    def _delete_recursive(self, root, key):\n        if root is None:\n            return root\n\n        if key < root.val:\n            root.left = self._delete_recursive(root.left, key)\n        elif key > root.val:\n            root.right = self._delete_recursive(root.right, key)\n        else:\n            if root.left is None:\n                return root.right\n            elif root.right is None:\n                return root.left\n\n            temp_val = self._min_value_node(root.right).val\n            root.val = temp_val\n            root.right = self._delete_recursive(root.right, temp_val)\n\n        return root\n\n    def _min_value_node(self, node):\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current\n```\n\n### Height of the Tree\n\nThe height of a BST is the longest path from the root to a leaf. It can be calculated recursively by finding the height of the left and right subtrees and adding 1.\n\n```python\n    def height(self):\n        return self._height_recursive(self.root)\n\n    def _height_recursive(self, node):\n        if node is None:\n            return 0\n        else:\n            left_height = self._height_recursive(node.left)\n            right_height = self._height_recursive(node.right)\n            return max(left_height, right_height) + 1\n```\n\n### Putting It All Together\n\nHere's the complete code for the BST with insertion, deletion, search, and height methods:\n\n```python\nclass TreeNode:\n    def __init__(self, key):\n        self.left = None\n        self.right = None\n        self.val = key\n\nclass BST:\n    def __init__(self):\n        self.root = None\n\n    def insert(self, key):\n        if self.root is None:\n            self.root = TreeNode(key)\n        else:\n            self._insert_recursive(self.root, key)\n\n    def _insert_recursive(self, node, key):\n        if key < node.val:\n            if node.left is None:\n                node.left = TreeNode(key)\n            else:\n                self._insert_recursive(node.left, key)\n        else:\n            if node.right is None:\n                node.right = TreeNode(key)\n            else:\n                self._insert_recursive(node.right, key)\n\n    def search(self, key):\n        return self._search_recursive(self.root, key)\n\n    def _search_recursive(self, node, key):\n        if node is None or node.val == key:\n            return node\n        if key < node.val:\n            return self._search_recursive(node.left, key)\n        else:\n            return self._search_recursive(node.right, key)\n\n    def delete(self, key):\n        self.root = self._delete_recursive(self.root, key)\n\n    def _delete_recursive(self, root, key):\n        if root is None:\n            return root\n\n        if key < root.val:\n            root.left = self._delete_recursive(root.left, key)\n        elif key > root.val:\n            root.right = self._delete_recursive(root.right, key)\n        else:\n            if root.left is None:\n                return root.right\n            elif root.right is None:\n                return root.left\n\n            temp_val = self._min_value_node(root.right).val\n            root.val = temp_val\n            root.right = self._delete_recursive(root.right, temp_val)\n\n        return root\n\n    def _min_value_node(self, node):\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current\n\n    def height(self):\n        return self._height_recursive(self.root)\n\n    def _height_recursive(self, node):\n        if node is None:\n            return 0\n        else:\n            left_height = self._height_recursive(node.left)\n            right_height = self._height_recursive(node.right)\n            return max(left_height, right_height) + 1\n```\n\nYou can now use this BST class to create a binary search tree and perform insertions, deletions, searches, and find the height of the tree."
    }
]