[
    {
        "role": "user",
        "content": "Write a Java program that implements a simple text-based chat server using WebSockets. The server should support multiple clients connecting simultaneously, broadcasting messages to all connected clients, and private messaging between clients."
    },
    {
        "role": "assistant",
        "content": "Implementing a WebSocket-based chat server in Java involves several steps. We'll use the `javax.websocket` API, which is part of the Java EE platform, to handle WebSocket connections. If you're using a Java SE environment, you might need to include the necessary libraries manually.\n\nBelow is a step-by-step guide to creating a simple text-based chat server using WebSockets in Java:\n\n### 1. Setting Up the Project\n\nFirst, ensure you have the necessary dependencies. If you're using Maven, add the following dependencies to your `pom.xml`:\n\n```xml\n<dependencies>\n    <dependency>\n        <groupId>javax.websocket</groupId>\n        <artifactId>javax.websocket-api</artifactId>\n        <version>1.1</version>\n    </dependency>\n    <dependency>\n        <groupId>org.glassfish.tyrus</groupId>\n        <artifactId>tyrus-server</artifactId>\n        <version>1.13</version>\n    </dependency>\n    <dependency>\n        <groupId>org.glassfish.tyrus</groupId>\n        <artifactId>tyrus-container-grizzly-server</artifactId>\n        <version>1.13</version>\n    </dependency>\n</dependencies>\n```\n\n### 2. Creating the WebSocket Endpoint\n\nCreate a class that will handle WebSocket connections. This class will manage client connections, broadcast messages, and handle private messages.\n\n```java\nimport javax.websocket.OnClose;\nimport javax.websocket.OnError;\nimport javax.websocket.OnMessage;\nimport javax.websocket.OnOpen;\nimport javax.websocket.Session;\nimport javax.websocket.server.ServerEndpoint;\nimport java.io.IOException;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.Set;\n\n@ServerEndpoint(\"/chat\")\npublic class ChatServer {\n\n    // Set to hold all connected sessions\n    private static Set<Session> sessions = Collections.synchronizedSet(new HashSet<>());\n\n    @OnOpen\n    public void onOpen(Session session) {\n        sessions.add(session);\n        System.out.println(\"New connection: \" + session.getId());\n    }\n\n    @OnMessage\n    public void onMessage(String message, Session sender) {\n        System.out.println(\"Message from \" + sender.getId() + \": \" + message);\n\n        // Check if the message is a private message\n        if (message.startsWith(\"@\")) {\n            String[] parts = message.split(\" \", 2);\n            if (parts.length < 2) {\n                sendMessage(\"Invalid private message format.\", sender);\n                return;\n            }\n            String recipientId = parts[0].substring(1);\n            String recipientMessage = parts[1];\n            Session recipient = findSessionById(recipientId);\n            if (recipient != null) {\n                sendMessage(\"Private message from \" + sender.getId() + \": \" + recipientMessage, recipient);\n            } else {\n                sendMessage(\"Recipient not found.\", sender);\n            }\n        } else {\n            // Broadcast the message to all connected clients\n            broadcast(message, sender);\n        }\n    }\n\n    @OnClose\n    public void onClose(Session session) {\n        sessions.remove(session);\n        System.out.println(\"Connection closed: \" + session.getId());\n    }\n\n    @OnError\n    public void onError(Session session, Throwable throwable) {\n        System.err.println(\"Error on session \" + session.getId());\n        throwable.printStackTrace();\n    }\n\n    private void broadcast(String message, Session sender) {\n        synchronized (sessions) {\n            for (Session session : sessions) {\n                if (!session.equals(sender)) {\n                    try {\n                        session.getBasicRemote().sendText(\"Broadcast from \" + sender.getId() + \": \" + message);\n                    } catch (IOException e) {\n                        System.err.println(\"Error broadcasting message to \" + session.getId());\n                        e.printStackTrace();\n                    }\n                }\n            }\n        }\n    }\n\n    private Session findSessionById(String id) {\n        synchronized (sessions) {\n            for (Session session : sessions) {\n                if (session.getId().equals(id)) {\n                    return session;\n                }\n            }\n        }\n        return null;\n    }\n\n    private void sendMessage(String message, Session session) {\n        try {\n            session.getBasicRemote().sendText(message);\n        } catch (IOException e) {\n            System.err.println(\"Error sending message to \" + session.getId());\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n### 3. Starting the WebSocket Server\n\nTo start the WebSocket server, you can use the Tyrus library, which provides a simple way to set up a WebSocket server.\n\n```java\nimport org.glassfish.tyrus.server.Server;\n\nimport java.util.Scanner;\n\npublic class ChatServerMain {\n\n    public static void main(String[] args) {\n        Server server = new Server(\"localhost\", 8080, \"/ws\", null, ChatServer.class);\n\n        try {\n            server.start();\n            System.out.println(\"Chat server started. Press any key to stop.\");\n            new Scanner(System.in).nextLine();\n        } catch (Exception e) {\n            System.err.println(\"Error starting server: \" + e.getMessage());\n            e.printStackTrace();\n        } finally {\n            server.stop();\n        }\n    }\n}\n```\n\n### 4. Running the Server\n\nCompile and run the `ChatServerMain` class. The server will start listening on `ws://localhost:8080/ws/chat`.\n\n### 5. Testing the Server\n\nYou can test the server using a simple WebSocket client or by creating a HTML page with JavaScript to connect to the server.\n\nHere's a simple HTML page to test the chat server:\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n    <title>Chat Client</title>\n    <script type=\"text/javascript\">\n        var websocket = new WebSocket(\"ws://localhost:8080/ws/chat\");\n\n        websocket.onopen = function(event) {\n            console.log(\"Connected to server.\");\n        };\n\n        websocket.onmessage = function(event) {\n            var messages = document.getElementById('messages');\n            var message = document.createElement('div');\n            message.textContent = event.data;\n            messages.appendChild(message);\n        };\n\n        websocket.onclose = function(event) {\n            console.log(\"Disconnected from server.\");\n        };\n\n        function sendMessage() {\n            var input = document.getElementById('messageInput');\n            websocket.send(input.value);\n            input.value = '';\n        }\n    </script>\n</head>\n<body>\n    <div id=\"messages\"></div>\n    <input type=\"text\" id=\"messageInput\" />\n    <button onclick=\"sendMessage()\">Send</button>\n</body>\n</html>\n```\n\nOpen multiple instances of this HTML page in different browser tabs to simulate multiple clients connecting to the server.\n\n### 6. Handling Private Messages\n\nTo send a private message, prefix the message with `@recipientId message`. For example, if a client wants to send a private message to another client with ID `12345`, they would type `@12345 Hello` in the message input.\n\n### Conclusion\n\nThis simple chat server demonstrates how to handle multiple WebSocket connections, broadcast messages to all connected clients, and handle private messaging between clients. You can extend this basic implementation with additional features such as user authentication, room support, and more sophisticated message formatting."
    }
]