[
    {
        "role": "user",
        "content": "Implement a simple Least Recently Used (LRU) cache in Python with the following features:\n   - Fixed size, configurable at initialization\n   - Add and retrieve items using key-value pairs\n   - Automatically evict the least recently used item when the cache is full\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Implementing a Least Recently Used (LRU) cache in Python involves creating a data structure that maintains a fixed size and evicts the least recently used item when it reaches capacity. To achieve this, we'll use a combination of a dictionary for quick access and an ordered dictionary or a doubly linked list to track the order of usage.\n\n### Approach\n\n1. **Use of OrderedDict**: Python's `OrderedDict` from the `collections` module is ideal for this purpose because it maintains the order of insertion and allows us to efficiently move elements to the end when they are accessed or added.\n\n2. **Initialization**: The cache should be initialized with a fixed size. If no size is provided, it can default to a reasonable value, say 10.\n\n3. **Add and Retrieve Operations**:\n   - **Retrieve (Get)**: If the key exists, return the value and move the key-value pair to the end to mark it as recently used.\n   - **Add (Set)**: If the key already exists, update its value and move it to the end. If the cache is full, remove the first item (which is the least recently used) before adding the new item.\n\n### Solution Code\n\n```python\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity=10):\n        self.cache = OrderedDict()\n        self.capacity = capacity\n\n    def get(self, key):\n        if key not in self.cache:\n            return None\n        # Move the key to the end to mark as recently used\n        self.cache.move_to_end(key)\n        return self.cache[key]\n\n    def put(self, key, value):\n        if key in self.cache:\n            # Move the key to the end to mark as recently used\n            self.cache.move_to_end(key)\n        self.cache[key] = value\n        if len(self.cache) > self.capacity:\n            # Remove the first item (least recently used)\n            self.cache.popitem(last=False)\n\n# Example Usage:\ncache = LRUCache(2)\ncache.put(1, 'one')\ncache.put(2, 'two')\nprint(cache.get(1))  # Output: 'one'\ncache.put(3, 'three')\nprint(cache.get(2))  # Output: None\ncache.put(4, 'four')\nprint(cache.get(1))  # Output: None\nprint(cache.get(3))  # Output: 'three'\nprint(cache.get(4))  # Output: 'four'\n```\n\n### Explanation\n\n1. **Initialization**: The `LRUCache` class is initialized with a `capacity`. It uses an `OrderedDict` to store the items.\n\n2. **Get Operation**: When `get` is called with a `key`, it checks if the key exists in the cache. If it does, it moves the key to the end of the dictionary (marking it as recently used) and returns its value. If the key does not exist, it returns `None`.\n\n3. **Put Operation**: When `put` is called with a `key` and `value`, it first checks if the key already exists. If it does, it updates the value and moves the key to the end to mark it as recently used. If the key does not exist and the cache has reached its capacity, it removes the least recently used item (the first item in the ordered dictionary) before adding the new key-value pair.\n\nThis implementation ensures that both get and put operations have an average time complexity of O(1), making it efficient for caching purposes."
    }
]