[
    {
        "role": "user",
        "content": "Implement a JavaScript function that takes an array of integers and a target sum as input, and returns all unique combinations of elements within the array that add up to the target sum. The solution should not include duplicate combinations or use the same element more than once.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "To solve this problem, we need to find all unique combinations of elements in an array that add up to a given target sum. Each element in the array can only be used once, and we need to ensure that there are no duplicate combinations in our results.\n\n### Approach\n\n1. **Sort the Array**: Sorting the array helps in easily skipping duplicates and managing the combination of elements.\n2. **Backtracking**: We'll use a backtracking approach to explore all possible combinations that add up to the target sum.\n3. **Skip Duplicates**: While iterating through the array, skip over duplicates to avoid duplicate combinations.\n4. **Adjust the Target Sum**: As we include an element in the current combination, reduce the target sum by that element's value.\n5. **Base Cases**: \n   - If the target sum is zero, we've found a valid combination.\n   - If the target sum becomes negative, stop the current path as it's not a valid combination.\n\n### Solution Code\n\n```javascript\nfunction combinationSum2(candidates, target) {\n    candidates.sort((a, b) => a - b); // Sort the array to handle duplicates and make combinations easier\n    const result = [];\n    \n    function backtrack(start, currentCombination, currentSum) {\n        if (currentSum === target) {\n            result.push([...currentCombination]);\n            return;\n        }\n        if (currentSum > target) {\n            return;\n        }\n        \n        for (let i = start; i < candidates.length; i++) {\n            // Skip duplicates\n            if (i > start && candidates[i] === candidates[i - 1]) continue;\n            currentCombination.push(candidates[i]);\n            backtrack(i + 1, currentCombination, currentSum + candidates[i]);\n            currentCombination.pop();\n        }\n    }\n    \n    backtrack(0, [], 0);\n    return result;\n}\n\n// Example usage:\nconst candidates = [10,1,2,7,6,1,5];\nconst target = 8;\nconsole.log(combinationSum2(candidates, target));\n// Expected output: [[1,1,6], [1,2,5], [1,7], [2,6]]\n```\n\n### Explanation\n\n1. **Sorting the Array**: We sort the `candidates` array to handle duplicates and to make it easier to manage combinations.\n2. **Backtracking Function**:\n   - `backtrack(start, currentCombination, currentSum)`: This function recursively builds combinations.\n   - `start`: The index to start from in the array to avoid reusing the same element.\n   - `currentCombination`: The current combination being built.\n   - `currentSum`: The sum of the current combination.\n3. **Base Cases**:\n   - If `currentSum` equals the `target`, add the current combination to the result.\n   - If `currentSum` exceeds the `target`, stop the recursion.\n4. **Loop through Candidates**:\n   - Skip duplicates by checking if the current candidate is the same as the previous one (only for positions after the start).\n   - Include the current candidate in the combination and recurse with the updated sum and next start index.\n   - Backtrack by removing the last added candidate to explore other combinations.\n\nThis approach ensures that all unique combinations are found without duplicates and without reusing the same element more than once."
    }
]