[
    {
        "role": "user",
        "content": "Create a Java program to implement a Trie data structure with basic operations like insert, search, and delete."
    },
    {
        "role": "assistant",
        "content": "Sure! I'd be happy to help you create a Java program that implements a Trie data structure with basic operations such as insert, search, and delete. A Trie, also known as a prefix tree, is an efficient information retrieval data structure. It is particularly useful for storing and retrieving strings with common prefixes.\n\nFirst, let's understand the basic structure of a Trie. Each node in a Trie represents a single character of the string. The root node doesn't contain any character, and each edge from the root node leads to a node representing the first character of a string. This structure continues for subsequent characters.\n\nHere's a step-by-step plan to implement the Trie:\n\n1. **Define the Trie Node:**\n   - Each node will have an array of references to its child nodes (one for each possible character).\n   - A flag to mark the end of a word.\n\n2. **Implement the Trie Class:**\n   - Insert operation: Traverse the Trie, creating new nodes for characters not already present, and mark the end of the word.\n   - Search operation: Traverse the Trie to check if the word exists and is marked as the end of a word.\n   - Delete operation: Remove the word by unmarking the end of the word and, if the node has no other purposes, remove it.\n\nLet's proceed to write the code accordingly.\n\n## Final Solution\nTo implement a Trie data structure in Java with insert, search, and delete operations, we can follow the steps below:\n\n1. **Define the Trie Node:**\n   - Each node contains an array of references to its child nodes (one for each possible character).\n   - A flag to indicate the end of a word.\n\n2. **Implement the Trie Class:**\n   - **Insert Operation:** Traverse the Trie, creating new nodes for characters not already present, and mark the end of the word.\n   - **Search Operation:** Traverse the Trie to check if the word exists and is marked as the end of a word.\n   - **Delete Operation:** Remove the word by unmarking the end of the word and, if the node has no other purposes, remove it.\n\nHere is the complete Java code implementing the above approach:\n\n```java\nclass TrieNode {\n    TrieNode[] children;\n    boolean isEndOfWord;\n\n    public TrieNode() {\n        children = new TrieNode[26]; // Assuming only lowercase English letters\n        isEndOfWord = false;\n    }\n}\n\nclass Trie {\n    private TrieNode root;\n\n    public Trie() {\n        root = new TrieNode();\n    }\n\n    // Inserts a word into the trie\n    public void insert(String word) {\n        TrieNode current = root;\n        for (char ch : word.toCharArray()) {\n            int index = ch - 'a';\n            if (current.children[index] == null) {\n                current.children[index] = new TrieNode();\n            }\n            current = current.children[index];\n        }\n        current.isEndOfWord = true;\n    }\n\n    // Searches for the word in the trie\n    public boolean search(String word) {\n        TrieNode current = root;\n        for (char ch : word.toCharArray()) {\n            int index = ch - 'a';\n            if (current.children[index] == null) {\n                return false;\n            }\n            current = current.children[index];\n        }\n        return current.isEndOfWord;\n    }\n\n    // Deletes a word from the trie\n    public void delete(String word) {\n        delete(root, word, 0);\n    }\n\n    private boolean delete(TrieNode current, String word, int index) {\n        if (index == word.length()) {\n            if (!current.isEndOfWord) {\n                return false;\n            }\n            current.isEndOfWord = false;\n            return isEmpty(current);\n        }\n        int ch = word.charAt(index) - 'a';\n        if (current.children[ch] == null) {\n            return false;\n        }\n        if (!delete(current.children[ch], word, index + 1)) {\n            return false;\n        }\n        if (current.children[ch].isEndOfWord) {\n            return false;\n        }\n        if (isEmpty(current.children[ch])) {\n            current.children[ch] = null;\n            return isEmpty(current);\n        }\n        return false;\n    }\n\n    private boolean isEmpty(TrieNode current) {\n        for (TrieNode node : current.children) {\n            if (node != null) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Trie trie = new Trie();\n        trie.insert(\"hello\");\n        trie.insert(\"helmet\");\n        System.out.println(trie.search(\"hello\")); // true\n        System.out.println(trie.search(\"helmet\")); // true\n        System.out.println(trie.search(\"hell\")); // false\n        trie.delete(\"hello\");\n        System.out.println(trie.search(\"hello\")); // false\n        System.out.println(trie.search(\"helmet\")); // true\n    }\n}\n```\n\n### Explanation:\n1. **TrieNode Class:**\n   - Contains an array of 26 `TrieNode` objects (for lowercase a-z).\n   - A boolean flag `isEndOfWord` to mark the end of a word.\n\n2. **Trie Class:**\n   - **Insert Operation:** Traverses the Trie, creating new nodes if necessary, and marks the end of the word.\n   - **Search Operation:** Traverses the Trie to check if the word exists and is marked as the end of a word.\n   - **Delete Operation:** Recursively navigates to the node corresponding to the end of the word, unmarks it, and removes any empty nodes on the path back.\n\n3. **Main Class:**\n   - Demonstrates inserting, searching, and deleting words in the Trie."
    }
]