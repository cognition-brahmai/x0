[
    {
        "role": "user",
        "content": "Implement a simple LRU (Least Recently Used) cache in Python with the following features:\n   - Set a maximum capacity for the cache.\n   - Add and retrieve items from the cache.\n   - Automatically remove the least recently used item when the cache reaches its capacity.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Sure! I can help you implement a simple LRU cache in Python with the specified features. To create an LRU cache, we need to ensure that it has a maximum capacity and manages items such that the least recently used item is removed when the cache is full and a new item is added.\n\n### Approach\n\n1. **Use of OrderedDict**: Python's `OrderedDict` from the `collections` module is perfect for this because it maintains the order of insertion. We can use it to keep track of the order in which items are accessed.\n2. **Set Maximum Capacity**: Define a maximum capacity for the cache.\n3. **Add and Retrieve Items**:\n   - When adding an item, if the key already exists, update its value and move it to the end to mark it as recently used.\n   - If the cache is full, remove the least recently used item (which is at the beginning of the OrderedDict).\n   - When retrieving an item, move it to the end of the OrderedDict to mark it as recently used.\n4. **Automatic Management**: Ensure that all operations maintain the order of item usage.\n\n### Solution Code\n\n```python\nfrom collections import OrderedDict\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.cache = OrderedDict()\n        self.capacity = capacity\n\n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        # Move the accessed item to the end to mark it as recently used\n        self.cache.move_to_end(key)\n        return self.cache[key]\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            # Update the value and move it to the end to mark as recently used\n            self.cache[key] = value\n            self.cache.move_to_end(key)\n        else:\n            if len(self.cache) >= self.capacity:\n                # Remove the least recently used item (first item in OrderedDict)\n                oldest_key = next(iter(self.cache))\n                del self.cache[oldest_key]\n            # Add the new item to the cache\n            self.cache[key] = value\n\n# Example usage:\ncache = LRUCache(2)\ncache.put(1, 1)\ncache.put(2, 2)\nprint(cache.get(1))       # returns 1\ncache.put(3, 3)           # evicts key 2\nprint(cache.get(2))       # returns -1 (not found)\ncache.put(4, 4)           # evicts key 1\nprint(cache.get(1))       # returns -1 (not found)\nprint(cache.get(3))       # returns 3\nprint(cache.get(4))       # returns 4\n```\n\n### Explanation\n\n1. **Initialization**:\n   - We initialize the cache with a given capacity and use an `OrderedDict` to store the items.\n\n2. **Get Operation**:\n   - If the key exists in the cache, we move it to the end of the OrderedDict to indicate it was recently used and return its value.\n   - If the key does not exist, we return -1.\n\n3. **Put Operation**:\n   - If the key already exists, we update its value and move it to the end.\n   - If the key does not exist and the cache is at full capacity, we remove the least recently used item (the first item in the OrderedDict).\n   - We then add the new key-value pair to the cache.\n\nThis implementation ensures that all operations (get and put) are efficient, typically O(1) time complexity, due to the properties of the OrderedDict."
    }
]