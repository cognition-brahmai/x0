[
    {
        "role": "user",
        "content": "Develop a C program that can perform matrix multiplication using multi-threading. The user should input two matrices and the number of threads to use. The program should then display the resultant matrix after performing the multiplication operation. PLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Alright, I'm here to help you with this task. So, you need to develop a C program that performs matrix multiplication using multi-threading. The user will input two matrices and specify the number of threads to use, and the program should display the result of the multiplication.\n\nFirst, let's break down the problem into smaller parts to make it manageable.\n\n1. **Input Handling:**\n   - Read the dimensions of the two matrices.\n   - Ensure that the number of columns in the first matrix is equal to the number of rows in the second matrix for multiplication to be possible.\n   - Read the elements of both matrices.\n   - Read the number of threads to use for multiplication.\n\n2. **Matrix Multiplication:**\n   - Implement matrix multiplication using multi-threading.\n   - Each thread will handle a part of the multiplication task.\n\n3. **Output:**\n   - Display the resultant matrix.\n\nSince we're dealing with multi-threading in C, we'll use the POSIX Threads (pthreads) library. Make sure that your system has pthreads support.\n\n### Step 1: Input Handling\n\nWe need to read the dimensions and elements of two matrices from the user, and also the number of threads to use.\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <pthread.h>\n\n#define MAX_SIZE 100\n\ntypedef struct {\n    int **matrix1;\n    int **matrix2;\n    int **result;\n    int rows1;\n    int cols1;\n    int rows2;\n    int cols2;\n    int num_threads;\n} MatrixData;\n\nMatrixData data;\n\nvoid readMatrix(int **matrix, int rows, int cols) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            scanf(\"%d\", &matrix[i][j]);\n        }\n    }\n}\n\nvoid allocateMatrices() {\n    data.matrix1 = (int **)malloc(data.rows1 * sizeof(int *));\n    for (int i = 0; i < data.rows1; i++) {\n        data.matrix1[i] = (int *)malloc(data.cols1 * sizeof(int));\n    }\n\n    data.matrix2 = (int **)malloc(data.rows2 * sizeof(int *));\n    for (int i = 0; i < data.rows2; i++) {\n        data.matrix2[i] = (int *)malloc(data.cols2 * sizeof(int));\n    }\n\n    data.result = (int **)malloc(data.rows1 * sizeof(int *));\n    for (int i = 0; i < data.rows1; i++) {\n        data.result[i] = (int *)malloc(data.cols2 * sizeof(int));\n    }\n}\n\nvoid freeMatrices() {\n    for (int i = 0; i < data.rows1; i++) {\n        free(data.matrix1[i]);\n    }\n    free(data.matrix1);\n\n    for (int i = 0; i < data.rows2; i++) {\n        free(data.matrix2[i]);\n    }\n    free(data.matrix2);\n\n    for (int i = 0; i < data.rows1; i++) {\n        free(data.result[i]);\n    }\n    free(data.result);\n}\n```\n\n### Step 2: Matrix Multiplication with Multi-Threading\n\nWe'll divide the multiplication task among multiple threads. Each thread will compute a portion of the result matrix.\n\nFirst, define a thread function that will perform a part of the multiplication.\n\n```c\ntypedef struct {\n    int start_row;\n    int end_row;\n} ThreadArgs;\n\nvoid *multiplyPart(void *args) {\n    ThreadArgs *thread_args = (ThreadArgs *)args;\n    for (int i = thread_args->start_row; i < thread_args->end_row; i++) {\n        for (int j = 0; j < data.cols2; j++) {\n            data.result[i][j] = 0;\n            for (int k = 0; k < data.cols1; k++) {\n                data.result[i][j] += data.matrix1[i][k] * data.matrix2[k][j];\n            }\n        }\n    }\n    pthread_exit(NULL);\n}\n```\n\nNow, in the main function, create and manage the threads.\n\n```c\nvoid performMultiplication() {\n    pthread_t threads[data.num_threads];\n    int rows_per_thread = data.rows1 / data.num_threads;\n    int remaining_rows = data.rows1 % data.num_threads;\n    int start_row = 0;\n\n    for (int i = 0; i < data.num_threads; i++) {\n        int end_row = start_row + rows_per_thread;\n        if (remaining_rows > 0) {\n            end_row++;\n            remaining_rows--;\n        }\n        ThreadArgs *args = (ThreadArgs *)malloc(sizeof(ThreadArgs));\n        args->start_row = start_row;\n        args->end_row = end_row;\n        pthread_create(&threads[i], NULL, multiplyPart, args);\n        start_row = end_row;\n    }\n\n    for (int i = 0; i < data.num_threads; i++) {\n        pthread_join(threads[i], NULL);\n    }\n}\n```\n\n### Step 3: Output the Result\n\nAfter the multiplication is complete, print the resultant matrix.\n\n```c\nvoid printMatrix(int **matrix, int rows, int cols) {\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            printf(\"%d \", matrix[i][j]);\n        }\n        printf(\"\\n\");\n    }\n}\n```\n\n### Main Function\n\nNow, put everything together in the main function.\n\n```c\nint main() {\n    printf(\"Enter dimensions of first matrix (rows columns): \");\n    scanf(\"%d %d\", &data.rows1, &data.cols1);\n\n    printf(\"Enter dimensions of second matrix (rows columns): \");\n    scanf(\"%d %d\", &data.rows2, &data.cols2);\n\n    if (data.cols1 != data.rows2) {\n        printf(\"Matrix multiplication not possible.\\n\");\n        return 1;\n    }\n\n    printf(\"Enter number of threads: \");\n    scanf(\"%d\", &data.num_threads);\n\n    allocateMatrices();\n\n    printf(\"Enter elements of first matrix:\\n\");\n    readMatrix(data.matrix1, data.rows1, data.cols1);\n\n    printf(\"Enter elements of second matrix:\\n\");\n    readMatrix(data.matrix2, data.rows2, data.cols2);\n\n    performMultiplication();\n\n    printf(\"Resultant matrix:\\n\");\n    printMatrix(data.result, data.rows1, data.cols2);\n\n    freeMatrices();\n\n    return 0;\n}\n```\n\n### Explanation\n\n1. **Input Handling:**\n   - Read matrix dimensions and ensure they are compatible for multiplication.\n   - Read the number of threads.\n   - Allocate memory for matrices.\n\n2. **Matrix Multiplication:**\n   - Divide the rows of the first matrix among the specified number of threads.\n   - Each thread computes a portion of the result matrix.\n   - Use `pthread_create` to create threads and `pthread_join` to wait for them to finish.\n\n3. **Output:**\n   - Print the resultant matrix.\n\nThis approach ensures that the matrix multiplication is performed efficiently using multiple threads, distributing the workload across them."
    }
]