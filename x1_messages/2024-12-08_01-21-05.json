[
    {
        "role": "user",
        "content": "Design a TypeScript class that represents a basic graph data structure with nodes and edges. Implement methods for adding nodes, connecting nodes with edges, and performing depth-first and breadth-first traversals."
    },
    {
        "role": "assistant",
        "content": "Sure! Below is a TypeScript class that represents a basic graph data structure with nodes and edges. It includes methods for adding nodes, connecting nodes with edges, and performing depth-first search (DFS) and breadth-first search (BFS) traversals.\n\n```typescript\nclass GraphNode<T> {\n    public data: T;\n    public neighbors: GraphNode<T>[];\n\n    constructor(data: T) {\n        this.data = data;\n        this.neighbors = [];\n    }\n}\n\nclass Graph<T> {\n    private nodes: GraphNode<T>[];\n\n    constructor() {\n        this.nodes = [];\n    }\n\n    addNode(data: T): GraphNode<T> {\n        const newNode = new GraphNode(data);\n        this.nodes.push(newNode);\n        return newNode;\n    }\n\n    connectNodes(node1: GraphNode<T>, node2: GraphNode<T>): void {\n        if (!node1 || !node2) {\n            throw new Error('Nodes must be valid.');\n        }\n        if (node1.neighbors.includes(node2)) {\n            console.warn('Edge already exists.');\n            return;\n        }\n        node1.neighbors.push(node2);\n        node2.neighbors.push(node1);\n    }\n\n    depthFirstSearch(startNode: GraphNode<T>, visit: (node: GraphNode<T>) => void): void {\n        const visited = new Set<GraphNode<T>>();\n        this._dfsHelper(startNode, visited, visit);\n    }\n\n    private _dfsHelper(currentNode: GraphNode<T>, visited: Set<GraphNode<T>>, visit: (node: GraphNode<T>) => void): void {\n        if (visited.has(currentNode)) {\n            return;\n        }\n        visited.add(currentNode);\n        visit(currentNode);\n        for (const neighbor of currentNode.neighbors) {\n            this._dfsHelper(neighbor, visited, visit);\n        }\n    }\n\n    breadthFirstSearch(startNode: GraphNode<T>, visit: (node: GraphNode<T>) => void): void {\n        const visited = new Set<GraphNode<T>>();\n        const queue: GraphNode<T>[] = [];\n\n        visited.add(startNode);\n        queue.push(startNode);\n        visit(startNode);\n\n        while (queue.length > 0) {\n            const currentNode = queue.shift()!;\n            for (const neighbor of currentNode.neighbors) {\n                if (!visited.has(neighbor)) {\n                    visited.add(neighbor);\n                    queue.push(neighbor);\n                    visit(neighbor);\n                }\n            }\n        }\n    }\n}\n\n// Example usage:\nconst graph = new Graph<string>();\n\nconst nodeA = graph.addNode('A');\nconst nodeB = graph.addNode('B');\nconst nodeC = graph.addNode('C');\nconst nodeD = graph.addNode('D');\n\ngraph.connectNodes(nodeA, nodeB);\ngraph.connectNodes(nodeB, nodeC);\ngraph.connectNodes(nodeC, nodeD);\ngraph.connectNodes(nodeD, nodeA);\n\nconsole.log('DFS Traversal:');\ngraph.depthFirstSearch(nodeA, node => console.log(node.data));\n\nconsole.log('BFS Traversal:');\ngraph.breadthFirstSearch(nodeA, node => console.log(node.data));\n```\n\n### Explanation:\n\n1. **GraphNode Class**:\n   - Represents a node in the graph with some data and a list of its neighboring nodes.\n\n2. **Graph Class**:\n   - Manages the collection of nodes and provides methods to add nodes and connect them with edges.\n   - Implements DFS and BFS traversal methods.\n\n3. **addNode Method**:\n   - Adds a new node with the given data to the graph.\n\n4. **connectNodes Method**:\n   - Connects two nodes with an edge. Since graphs are typically undirected, both nodes are added to each other's neighbor lists.\n\n5. **depthFirstSearch Method**:\n   - Performs a depth-first search starting from a given node, applying a visit function to each node in the traversal.\n\n6. **breadthFirstSearch Method**:\n   - Performs a breadth-first search starting from a given node, applying a visit function to each node in the traversal.\n\nThis implementation should cover the basic requirements for a graph data structure with DFS and BFS traversals."
    }
]