[
    {
        "role": "user",
        "content": "Create a Golang program that implements a simple LRU (Least Recently Used) cache with a fixed size. The cache should support insertion, retrieval, and deletion of key-value pairs."
    },
    {
        "role": "assistant",
        "content": "Creating a simple LRU cache in Golang is a great way to understand both data structures and concurrency in Go. An LRU cache is particularly useful when you have a limited amount of space and you want to keep the most recently used items readily accessible.\n\n### Approach\n\n1. **Data Structure**:\n   - **Map**: To store key-value pairs for O(1) access time.\n   - **Doubly Linked List**: To maintain the order of usage (most recently used to least recently used).\n\n2. **Operations**:\n   - **Get(key)**: Retrieve the value associated with the key if it exists, and move the key to the front of the list.\n   - **Put(key, value)**: Insert or update the key-value pair and move it to the front of the list. If the cache is full, remove the least recently used item.\n   - **Delete(key)**: Remove the key from the cache if it exists.\n\n3. **Concurrency**:\n   - Use mutexes to handle concurrent access to the cache.\n\n### Solution Code\n\n```go\npackage main\n\nimport (\n\t\"container/list\"\n\t\"fmt\"\n\t\"sync\"\n)\n\ntype LRUCache struct {\n\tcapacity int\n\tcache    map[int]*list.Element\n\tlist     *list.List\n\tmu       sync.Mutex\n}\n\ntype cacheItem struct {\n\tkey   int\n\tvalue int\n}\n\nfunc NewLRUCache(capacity int) *LRUCache {\n\treturn &LRUCache{\n\t\tcapacity: capacity,\n\t\tcache:    make(map[int]*list.Element),\n\t\tlist:     list.New(),\n\t}\n}\n\nfunc (c *LRUCache) Get(key int) int {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\telement, exists := c.cache[key]\n\tif !exists {\n\t\treturn -1\n\t}\n\tc.list.MoveToFront(element)\n\titem := element.Value.(*cacheItem)\n\treturn item.value\n}\n\nfunc (c *LRUCache) Put(key int, value int) {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\tif element, exists := c.cache[key]; exists {\n\t\tc.list.MoveToFront(element)\n\t\telement.Value.(*cacheItem).value = value\n\t} else {\n\t\tif c.list.Len() >= c.capacity {\n\t\t\tbackElement := c.list.Back()\n\t\t\tdelete(c.cache, backElement.Value.(*cacheItem).key)\n\t\t\tc.list.Remove(backElement)\n\t\t}\n\t\tnewItem := &cacheItem{key: key, value: value}\n\t\telement := c.list.PushFront(newItem)\n\t\tc.cache[key] = element\n\t}\n}\n\nfunc (c *LRUCache) Delete(key int) {\n\tc.mu.Lock()\n\tdefer c.mu.Unlock()\n\n\telement, exists := c.cache[key]\n\tif exists {\n\t\tc.list.Remove(element)\n\t\tdelete(c.cache, key)\n\t}\n}\n\nfunc main() {\n\tcache := NewLRUCache(2)\n\n\tcache.Put(1, 1)\n\tcache.Put(2, 2)\n\tfmt.Println(cache.Get(1)) // returns 1\n\tcache.Put(3, 3)           // evicts key 2\n\tfmt.Println(cache.Get(2)) // returns -1 (not found)\n\tcache.Put(4, 4)           // evicts key 1\n\tfmt.Println(cache.Get(1)) // returns -1 (not found)\n\tfmt.Println(cache.Get(3)) // returns 3\n\tfmt.Println(cache.Get(4)) // returns 4\n\tcache.Delete(3)\n\tfmt.Println(cache.Get(3)) // returns -1 (not found)\n}\n```\n\n### Explanation\n\n1. **Data Structures**:\n   - `cache`: A map to store keys and their corresponding list elements for O(1) access.\n   - `list`: A doubly linked list to maintain the order of elements based on usage.\n\n2. **Get Operation**:\n   - If the key exists, move the corresponding list element to the front and return its value.\n   - If the key doesn't exist, return -1.\n\n3. **Put Operation**:\n   - If the key already exists, update its value and move it to the front.\n   - If the key doesn't exist, add it to the front.\n   - If the cache is full, remove the least recently used item (the one at the back of the list).\n\n4. **Delete Operation**:\n   - If the key exists, remove it from the map and the list.\n\n5. **Concurrency**:\n   - A mutex (`mu`) is used to synchronize access to the cache, ensuring thread safety.\n\nThis implementation ensures that all operations are efficient and the cache behaves as expected, maintaining the most recently used items readily accessible."
    }
]