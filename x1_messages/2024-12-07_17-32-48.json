[
    {
        "role": "user",
        "content": "Write a Golang program that listens on a specified TCP port and acts as a simple key-value store. It should support commands like SET, GET, and DELETE, and respond to clients over the network.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Sure! I can help you with that. Creating a simple key-value store in Golang that listens on a specified TCP port and handles commands like SET, GET, and DELETE is a great way to understand networking and concurrency in Go.\n\nFirst, let's outline the steps we need to take:\n\n1. **Set up a TCP server**: This will listen on a specified port for incoming connections.\n2. **Handle multiple clients**: We need to manage multiple clients simultaneously, so we'll use Go's concurrency features.\n3. **Parse client commands**: Each client can send commands like SET, GET, or DELETE followed by key-value pairs.\n4. **Implement key-value storage**: We'll use a map to store key-value pairs.\n5. **Respond to clients**: After processing a command, send an appropriate response back to the client.\n\nLet's dive into the code step by step.\n\n### Step 1: Set up a TCP server\n\nWe'll use the `net` package to create a TCP server. The `ListenTCP` function will help us bind to a specified address and port.\n\n```go\npackage main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"net\"\n\t\"os\"\n\t\"strings\"\n)\n\nfunc main() {\n\tport := \"8080\"\n\tlistener, err := net.Listen(\"tcp\", \":\"+port)\n\tif err != nil {\n\t\tfmt.Println(\"Error starting server:\", err)\n\t\tos.Exit(1)\n\t}\n\tdefer listener.Close()\n\n\tfmt.Println(\"Server listening on port\", port)\n\n\tfor {\n\t\tconn, err := listener.Accept()\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error accepting connection:\", err)\n\t\t\tcontinue\n\t\t}\n\t\tgo handleConnection(conn)\n\t}\n}\n```\n\n### Step 2: Handle multiple clients\n\nTo handle multiple clients simultaneously, we'll spawn a new goroutine for each client connection using the `go` keyword.\n\n```go\nfunc handleConnection(conn net.Conn) {\n\tdefer conn.Close()\n\n\treader := bufio.NewReader(conn)\n\tfor {\n\t\tdata, err := reader.ReadString('\\n')\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error reading from connection:\", err)\n\t\t\treturn\n\t\t}\n\t\tcommand := strings.TrimSpace(data)\n\t\tresponse := processCommand(command)\n\t\tconn.Write([]byte(response + \"\\n\"))\n\t}\n}\n```\n\n### Step 3: Parse client commands\n\nWe need to parse the commands sent by the client. The commands will be in the format:\n\n- `SET key value`\n- `GET key`\n- `DELETE key`\n\nWe'll split the command string into parts and handle each command accordingly.\n\n### Step 4: Implement key-value storage\n\nWe'll use a map to store the key-value pairs. Since multiple goroutines might access this map, we need to handle concurrency safely. We'll use a mutex to protect the map.\n\n```go\nvar (\n\tkvStore = make(map[string]string)\n\tmu      = &sync.RWMutex{}\n)\n```\n\n### Step 5: Respond to clients\n\nAfter processing each command, we'll send a response back to the client indicating the success or failure of the operation.\n\nLet's put it all together.\n\n## Final Program\n\n```go\npackage main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"net\"\n\t\"os\"\n\t\"strings\"\n\t\"sync\"\n)\n\nvar (\n\tkvStore = make(map[string]string)\n\tmu      = &sync.RWMutex{}\n)\n\nfunc main() {\n\tport := \"8080\"\n\tlistener, err := net.Listen(\"tcp\", \":\"+port)\n\tif err != nil {\n\t\tfmt.Println(\"Error starting server:\", err)\n\t\tos.Exit(1)\n\t}\n\tdefer listener.Close()\n\n\tfmt.Println(\"Server listening on port\", port)\n\n\tfor {\n\t\tconn, err := listener.Accept()\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error accepting connection:\", err)\n\t\t\tcontinue\n\t\t}\n\t\tgo handleConnection(conn)\n\t}\n}\n\nfunc handleConnection(conn net.Conn) {\n\tdefer conn.Close()\n\n\treader := bufio.NewReader(conn)\n\tfor {\n\t\tdata, err := reader.ReadString('\\n')\n\t\tif err != nil {\n\t\t\tfmt.Println(\"Error reading from connection:\", err)\n\t\t\treturn\n\t\t}\n\t\tcommand := strings.TrimSpace(data)\n\t\tresponse := processCommand(command)\n\t\tconn.Write([]byte(response + \"\\n\"))\n\t}\n}\n\nfunc processCommand(command string) string {\n\tparts := strings.SplitN(command, \" \", 3)\n\tif len(parts) < 1 {\n\t\treturn \"Invalid command\"\n\t}\n\n\tswitch parts[0] {\n\tcase \"SET\":\n\t\tif len(parts) != 3 {\n\t\t\treturn \"SET requires key and value\"\n\t\t}\n\t\tkey := parts[1]\n\t\tvalue := parts[2]\n\t\tmu.Lock()\n\t\tkvStore[key] = value\n\t\tmu.Unlock()\n\t\treturn \"OK\"\n\tcase \"GET\":\n\t\tif len(parts) != 2 {\n\t\t\treturn \"GET requires key\"\n\t\t}\n\t\tkey := parts[1]\n\t\tmu.RLock()\n\t\tvalue, exists := kvStore[key]\n\t\tmu.RUnlock()\n\t\tif exists {\n\t\t\treturn value\n\t\t}\n\t\treturn \"Key not found\"\n\tcase \"DELETE\":\n\t\tif len(parts) != 2 {\n\t\t\treturn \"DELETE requires key\"\n\t\t}\n\t\tkey := parts[1]\n\t\tmu.Lock()\n\t\tdelete(kvStore, key)\n\t\tmu.Unlock()\n\t\treturn \"OK\"\n\tdefault:\n\t\treturn \"Unknown command\"\n\t}\n}\n```\n\n### Explanation\n\n1. **TCP Server Setup**: The server listens on port 8080 for incoming connections.\n2. **Handling Connections**: Each client connection is handled in a separate goroutine to allow multiple clients to connect simultaneously.\n3. **Command Parsing and Processing**: The server reads commands from the client, processes them, and sends back appropriate responses.\n4. **Concurrency Safety**: A mutex is used to ensure that the key-value store is accessed safely by multiple goroutines.\n\nThis simple key-value store can be extended with more features like supporting multiple data types, implementing expiration for keys, or adding authentication."
    }
]