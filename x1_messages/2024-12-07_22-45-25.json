[
    {
        "role": "user",
        "content": "Write a Java program that implements the Fibonacci sequence using dynamic programming.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Sure! Implementing the Fibonacci sequence using dynamic programming in Java is an efficient way to avoid the exponential time complexity associated with the naive recursive approach. Dynamic programming helps by storing the results of overlapping subproblems, thus reducing the computation time significantly.\n\n## Approach\n\n1. **Memoization (Top-Down Approach):**\n   - Use a memoization table (an array) to store already computed Fibonacci numbers.\n   - Start with the standard recursive approach but check if the result is already in the memoization table before computing it.\n\n2. **Tabulation (Bottom-Up Approach):**\n   - Build a table iteratively from the bottom up, starting from the smallest subproblems.\n   - Fill the table with Fibonacci numbers starting from `F(0)` and `F(1)` up to the desired `n`.\n\nBoth approaches ensure that each Fibonacci number is computed only once, bringing the time complexity down to O(n).\n\n## Solution Code\n\n```java\npublic class FibonacciDP {\n\n    // Memoization array to store computed Fibonacci numbers\n    private static long[] memo;\n\n    public static void main(String[] args) {\n        int n = 10; // Example: Compute the 10th Fibonacci number\n        memo = new long[n + 1];\n        Arrays.fill(memo, -1);\n\n        // Using memoization\n        long fibMemo = fibonacciMemo(n);\n        System.out.println(\"Fibonacci number at position \" + n + \" using memoization: \" + fibMemo);\n\n        // Using tabulation\n        long fibTab = fibonacciTab(n);\n        System.out.println(\"Fibonacci number at position \" + n + \" using tabulation: \" + fibTab);\n    }\n\n    // Memoization approach\n    public static long fibonacciMemo(int n) {\n        if (n <= 1) {\n            return n;\n        }\n        if (memo[n] != -1) {\n            return memo[n];\n        }\n        memo[n] = fibonacciMemo(n - 1) + fibonacciMemo(n - 2);\n        return memo[n];\n    }\n\n    // Tabulation approach\n    public static long fibonacciTab(int n) {\n        if (n <= 1) {\n            return n;\n        }\n        long[] dp = new long[n + 1];\n        dp[0] = 0;\n        dp[1] = 1;\n        for (int i = 2; i <= n; i++) {\n            dp[i] = dp[i - 1] + dp[i - 2];\n        }\n        return dp[n];\n    }\n}\n```\n\n## Explanation\n\n1. **Memoization:**\n   - We initialize a memoization array `memo` of size `n+1` and fill it with `-1` to indicate that no value has been computed yet.\n   - The `fibonacciMemo` function checks if the value is already computed. If yes, it returns the value from the memoization array; otherwise, it computes it recursively and stores it in the array.\n\n2. **Tabulation:**\n   - We create a dp array of size `n+1` and initialize the base cases `dp[0] = 0` and `dp[1] = 1`.\n   - We then iteratively fill the dp array from position `2` to `n` by summing the two previous numbers.\n\nBoth methods efficiently compute the Fibonacci sequence, and you can choose either based on your preference or specific requirements."
    }
]