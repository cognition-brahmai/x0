[
    {
        "role": "user",
        "content": "Develop a simple Golang REST API that supports CRUD operations for managing a list of tasks. The API should use JSON for data exchange and support command line arguments for specifying the listening IP and port.\nPLAINFORMAT"
    },
    {
        "role": "assistant",
        "content": "Alright, I'm going to help you create a simple REST API in Go that manages a list of tasks. This API will support basic CRUD operations: Create, Read, Update, and Delete. We'll also make it configurable via command line arguments for the IP and port it should listen on.\n\nFirst, make sure you have Go installed on your machine. You can download it from [https://golang.org/dl/](https://golang.org/dl/).\n\nLet's start by setting up the project structure. Create a new directory for your project, say `taskapi`, and inside it, create a file named `main.go`. This is where we'll write our code.\n\n### Step 1: Setting up the basic structure\n\nOpen `main.go` and import the necessary packages:\n\n```go\npackage main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"net/http\"\n\n\t\"github.com/gorilla/mux\"\n)\n```\n\nHere, we're importing:\n\n- `flag` for handling command line arguments.\n\n- `fmt` for formatted I/O.\n\n- `net/http` for HTTP server functionality.\n\n- `github.com/gorilla/mux` for routing.\n\nYou'll need to install the Gorilla Mux package if you haven't already. You can do this by running:\n\n```sh\ngo get -u github.com/gorilla/mux\n```\n\n### Step 2: Defining command line flags\n\nWe'll use flags to specify the IP and port for the server to listen on.\n\n```go\nvar (\n\tip   string\n\tport string\n)\n\nfunc init() {\n\tflag.StringVar(&ip, \"ip\", \"127.0.0.1\", \"IP address to listen on\")\n\tflag.StringVar(&port, \"port\", \"8000\", \"Port number to listen on\")\n}\n```\n\nHere, we define two string variables, `ip` and `port`, and use `flag.StringVar` to bind them to command line flags. We also provide default values.\n\n### Step 3: Setting up the router\n\nWe'll use Gorilla Mux for routing.\n\n```go\nfunc main() {\n\tflag.Parse()\n\n\tr := mux.NewRouter()\n\tapi := r.PathPrefix(\"/api\").Subrouter()\n\n\t// Define your API endpoints here\n\n\tfmt.Printf(\"Starting server on http://%s:%s\\n\", ip, port)\n\thttp.ListenAndServe(fmt.Sprintf(\"%s:%s\", ip, port), r)\n}\n```\n\nIn this setup, all API endpoints will be prefixed with `/api`.\n\n### Step 4: Managing tasks\n\nWe need a way to store tasks. For simplicity, we'll use an in-memory slice.\n\nDefine a `Task` struct:\n\n```go\ntype Task struct {\n\tID          string `json:\"id\"`\n\tDescription string `json:\"description\"`\n\tCompleted   bool   `json:\"completed\"`\n}\n```\n\nAnd a slice to hold tasks:\n\n```go\nvar tasks = make(map[string]Task)\n```\n\nWe're using a map with `ID` as the key for easy retrieval and updates.\n\n### Step 5: Implementing CRUD operations\n\n#### Create Task\n\nDefine a handler to create a new task.\n\n```go\nfunc createTask(w http.ResponseWriter, r *http.Request) {\n\tvar task Task\n\terr := decodeJSON(r, &task)\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n\t\treturn\n\t}\n\n\ttask.ID = strconv.Itoa(len(tasks) + 1) // Simple ID generation\n\ttasks[task.ID] = task\n\tencodeJSON(w, task)\n}\n```\n\nWe'll need helper functions to decode request bodies and encode responses.\n\n#### Read Tasks\n\nDefine handlers to get all tasks and a single task by ID.\n\n```go\nfunc getTasks(w http.ResponseWriter, r *http.Request) {\n\tencodeJSON(w, tasks)\n}\n\nfunc getTask(w http.ResponseWriter, r *http.Request) {\n\tid := mux.Vars(r)[\"id\"]\n\ttask, exists := tasks[id]\n\tif !exists {\n\t\thttp.Error(w, \"Task not found\", http.StatusNotFound)\n\t\treturn\n\t}\n\tencodeJSON(w, task)\n}\n```\n\n#### Update Task\n\nDefine a handler to update an existing task.\n\n```go\nfunc updateTask(w http.ResponseWriter, r *http.Request) {\n\tid := mux.Vars(r)[\"id\"]\n\ttask, exists := tasks[id]\n\tif !exists {\n\t\thttp.Error(w, \"Task not found\", http.StatusNotFound)\n\t\treturn\n\t}\n\n\terr := decodeJSON(r, &task)\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n\t\treturn\n\t}\n\n\ttasks[id] = task\n\tencodeJSON(w, task)\n}\n```\n\n#### Delete Task\n\nDefine a handler to delete a task.\n\n```go\nfunc deleteTask(w http.ResponseWriter, r *http.Request) {\n\tid := mux.Vars(r)[\"id\"]\n\t_, exists := tasks[id]\n\tif !exists {\n\t\thttp.Error(w, \"Task not found\", http.StatusNotFound)\n\t\treturn\n\t}\n\n\tdelete(tasks, id)\n\tw.WriteHeader(http.StatusNoContent)\n}\n```\n\n### Step 6: Helper functions for JSON encoding and decoding\n\nDefine helper functions to handle JSON serialization and deserialization.\n\n```go\nfunc decodeJSON(r *http.Request, v interface{}) error {\n\tdefer r.Body.Close()\n\treturn json.NewDecoder(r.Body).Decode(v)\n}\n\nfunc encodeJSON(w http.ResponseWriter, v interface{}) {\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(w).Encode(v)\n}\n```\n\n### Step 7: Wiring up the routes\n\nBack in `main`, wire up the routes for each CRUD operation.\n\n```go\napi.HandleFunc(\"/tasks\", createTask).Methods(\"POST\")\napi.HandleFunc(\"/tasks\", getTasks).Methods(\"GET\")\napi.HandleFunc(\"/tasks/{id}\", getTask).Methods(\"GET\")\napi.HandleFunc(\"/tasks/{id}\", updateTask).Methods(\"PUT\")\napi.HandleFunc(\"/tasks/{id}\", deleteTask).Methods(\"DELETE\")\n```\n\n### Step 8: Running the server\n\nWith all the pieces in place, you can run your server using:\n\n```sh\ngo run main.go -ip=127.0.0.1 -port=8000\n```\n\nYou can test your API using tools like `curl` or Postman.\n\n### Full Code\n\nHere's the full code for reference:\n\n```go\npackage main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"strconv\"\n\n\t\"github.com/gorilla/mux\"\n\t\"encoding/json\"\n)\n\nvar (\n\tip   string\n\tport string\n\ttasks = make(map[string]Task)\n)\n\ntype Task struct {\n\tID          string `json:\"id\"`\n\tDescription string `json:\"description\"`\n\tCompleted   bool   `json:\"completed\"`\n}\n\nfunc init() {\n\tflag.StringVar(&ip, \"ip\", \"127.0.0.1\", \"IP address to listen on\")\n\tflag.StringVar(&port, \"port\", \"8000\", \"Port number to listen on\")\n}\n\nfunc main() {\n\tflag.Parse()\n\n\tr := mux.NewRouter()\n\tapi := r.PathPrefix(\"/api\").Subrouter()\n\n\tapi.HandleFunc(\"/tasks\", createTask).Methods(\"POST\")\n\tapi.HandleFunc(\"/tasks\", getTasks).Methods(\"GET\")\n\tapi.HandleFunc(\"/tasks/{id}\", getTask).Methods(\"GET\")\n\tapi.HandleFunc(\"/tasks/{id}\", updateTask).Methods(\"PUT\")\n\tapi.HandleFunc(\"/tasks/{id}\", deleteTask).Methods(\"DELETE\")\n\n\tfmt.Printf(\"Starting server on http://%s:%s\\n\", ip, port)\n\thttp.ListenAndServe(fmt.Sprintf(\"%s:%s\", ip, port), r)\n}\n\nfunc createTask(w http.ResponseWriter, r *http.Request) {\n\tvar task Task\n\terr := decodeJSON(r, &task)\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n\t\treturn\n\t}\n\n\ttask.ID = strconv.Itoa(len(tasks) + 1)\n\ttasks[task.ID] = task\n\tencodeJSON(w, task)\n}\n\nfunc getTasks(w http.ResponseWriter, r *http.Request) {\n\tencodeJSON(w, tasks)\n}\n\nfunc getTask(w http.ResponseWriter, r *http.Request) {\n\tid := mux.Vars(r)[\"id\"]\n\ttask, exists := tasks[id]\n\tif !exists {\n\t\thttp.Error(w, \"Task not found\", http.StatusNotFound)\n\t\treturn\n\t}\n\tencodeJSON(w, task)\n}\n\nfunc updateTask(w http.ResponseWriter, r *http.Request) {\n\tid := mux.Vars(r)[\"id\"]\n\ttask, exists := tasks[id]\n\tif !exists {\n\t\thttp.Error(w, \"Task not found\", http.StatusNotFound)\n\t\treturn\n\t}\n\n\terr := decodeJSON(r, &task)\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n\t\treturn\n\t}\n\n\ttasks[id] = task\n\tencodeJSON(w, task)\n}\n\nfunc deleteTask(w http.ResponseWriter, r *http.Request) {\n\tid := mux.Vars(r)[\"id\"]\n\t_, exists := tasks[id]\n\tif !exists {\n\t\thttp.Error(w, \"Task not found\", http.StatusNotFound)\n\t\treturn\n\t}\n\n\tdelete(tasks, id)\n\tw.WriteHeader(http.StatusNoContent)\n}\n\nfunc decodeJSON(r *http.Request, v interface{}) error {\n\tdefer r.Body.Close()\n\treturn json.NewDecoder(r.Body).Decode(v)\n}\n\nfunc encodeJSON(w http.ResponseWriter, v interface{}) {\n\tw.Header().Set(\"Content-Type\", \"application/json\")\n\tjson.NewEncoder(w).Encode(v)\n}\n```\n\nThis should give you a basic CRUD API for managing tasks in Go, with configurable IP and port via command line arguments.\n"
    }
]