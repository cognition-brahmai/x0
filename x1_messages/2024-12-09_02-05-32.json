[
    {
        "role": "user",
        "content": "Implement a C++ class called \"Matrix\" that represents a 2D matrix of integers. The class should have methods for adding, subtracting, and multiplying matrices, as well as a method for calculating the determinant of a square matrix. Include appropriate error handling for invalid operations."
    },
    {
        "role": "assistant",
        "content": "Sure, I can help you with that! Let's create a `Matrix` class in C++ that can handle basic operations like addition, subtraction, multiplication, and determinant calculation for square matrices. We'll also include some error handling to make sure that operations are only performed when they make mathematical sense.\n\nFirst, we need to decide how to store the matrix data. A natural choice is to use a vector of vectors, where each inner vector represents a row of the matrix. This will make it easy to handle matrices of varying sizes.\n\nHere's a step-by-step plan:\n\n1. **Constructor**: Allow creation of a matrix from a 2D vector of integers.\n2. **Addition**: Implement matrix addition, which requires that both matrices have the same dimensions.\n3. **Subtraction**: Similar to addition, but subtract corresponding elements.\n4. **Multiplication**: Implement matrix multiplication, which requires that the number of columns in the first matrix equals the number of rows in the second matrix.\n5. **Determinant**: Calculate the determinant for square matrices (where the number of rows equals the number of columns). For non-square matrices, this operation doesn't make sense.\n\nWe'll also need to handle errors gracefully, such as trying to add matrices of different sizes or calculating the determinant of a non-square matrix.\n\nLet's start by defining the class and its constructor.\n\n### Step 1: Define the Class and Constructor\n\n```cpp\n#include <vector>\n#include <iostream>\n\nclass Matrix {\nprivate:\n    std::vector<std::vector<int>> data;\n    size_t rows, cols;\n\npublic:\n    Matrix(const std::vector<std::vector<int>>& mat) : data(mat), rows(mat.size()), cols(mat[0].size()) {\n        // Check if all rows have the same number of columns\n        for (const auto& row : mat) {\n            if (row.size() != cols) {\n                throw std::invalid_argument(\"All rows must have the same number of columns.\");\n            }\n        }\n    }\n\n    // More methods to be added...\n};\n```\n\n### Step 2: Implement Addition\n\nFor addition, we need to ensure that both matrices have the same dimensions.\n\n```cpp\nMatrix operator+(const Matrix& other) const {\n    if (rows != other.rows || cols != other.cols) {\n        throw std::invalid_argument(\"Matrices must have the same dimensions to be added.\");\n    }\n\n    std::vector<std::vector<int>> result(rows, std::vector<int>(cols));\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 0; j < cols; ++j) {\n            result[i][j] = data[i][j] + other.data[i][j];\n        }\n    }\n    return Matrix(result);\n}\n```\n\n### Step 3: Implement Subtraction\n\nSubtraction is similar to addition.\n\n```cpp\nMatrix operator-(const Matrix& other) const {\n    if (rows != other.rows || cols != other.cols) {\n        throw std::invalid_argument(\"Matrices must have the same dimensions to be subtracted.\");\n    }\n\n    std::vector<std::vector<int>> result(rows, std::vector<int>(cols));\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 0; j < cols; ++j) {\n            result[i][j] = data[i][j] - other.data[i][j];\n        }\n    }\n    return Matrix(result);\n}\n```\n\n### Step 4: Implement Multiplication\n\nFor multiplication, the number of columns in the first matrix must equal the number of rows in the second matrix.\n\n```cpp\nMatrix operator*(const Matrix& other) const {\n    if (cols != other.rows) {\n        throw std::invalid_argument(\"The number of columns in the first matrix must equal the number of rows in the second matrix.\");\n    }\n\n    std::vector<std::vector<int>> result(rows, std::vector<int>(other.cols, 0));\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 0; j < other.cols; ++j) {\n            for (size_t k = 0; k < cols; ++k) {\n                result[i][j] += data[i][k] * other.data[k][j];\n            }\n        }\n    }\n    return Matrix(result);\n}\n```\n\n### Step 5: Implement Determinant Calculation\n\nDeterminant calculation is only valid for square matrices. We'll use recursion for this purpose.\n\n```cpp\nint determinant() const {\n    if (rows != cols) {\n        throw std::invalid_argument(\"Determinant is only defined for square matrices.\");\n    }\n\n    if (rows == 1) {\n        return data[0][0];\n    } else if (rows == 2) {\n        return data[0][0] * data[1][1] - data[0][1] * data[1][0];\n    } else {\n        int det = 0;\n        for (size_t c = 0; c < cols; ++c) {\n            Matrix submatrix;\n            // Create submatrix by excluding the first row and current column\n            std::vector<std::vector<int>> subdata;\n            for (size_t i = 1; i < rows; ++i) {\n                std::vector<int> row;\n                for (size_t j = 0; j < cols; ++j) {\n                    if (j != c) {\n                        row.push_back(data[i][j]);\n                    }\n                }\n                subdata.push_back(row);\n            }\n            submatrix = Matrix(subdata);\n            det += (c % 2 == 0 ? 1 : -1) * data[0][c] * submatrix.determinant();\n        }\n        return det;\n    }\n}\n```\n\n### Step 6: Add a Method to Print the Matrix\n\nIt's helpful to have a method to print the matrix for testing purposes.\n\n```cpp\nvoid print() const {\n    for (const auto& row : data) {\n        for (int val : row) {\n            std::cout << val << \" \";\n        }\n        std::cout << std::endl;\n    }\n}\n```\n\n### Step 7: Put It All Together\n\nNow, let's put all these parts together into a complete class definition.\n\n```cpp\n#include <vector>\n#include <iostream>\n\nclass Matrix {\nprivate:\n    std::vector<std::vector<int>> data;\n    size_t rows, cols;\n\npublic:\n    Matrix(const std::vector<std::vector<int>>& mat) : data(mat), rows(mat.size()), cols(mat[0].size()) {\n        // Check if all rows have the same number of columns\n        for (const auto& row : mat) {\n            if (row.size() != cols) {\n                throw std::invalid_argument(\"All rows must have the same number of columns.\");\n            }\n        }\n    }\n\n    Matrix operator+(const Matrix& other) const {\n        if (rows != other.rows || cols != other.cols) {\n            throw std::invalid_argument(\"Matrices must have the same dimensions to be added.\");\n        }\n\n        std::vector<std::vector<int>> result(rows, std::vector<int>(cols));\n        for (size_t i = 0; i < rows; ++i) {\n            for (size_t j = 0; j < cols; ++j) {\n                result[i][j] = data[i][j] + other.data[i][j];\n            }\n        }\n        return Matrix(result);\n    }\n\n    Matrix operator-(const Matrix& other) const {\n        if (rows != other.rows || cols != other.cols) {\n            throw std::invalid_argument(\"Matrices must have the same dimensions to be subtracted.\");\n        }\n\n        std::vector<std::vector<int>> result(rows, std::vector<int>(cols));\n        for (size_t i = 0; i < rows; ++i) {\n            for (size_t j = 0; j < cols; ++j) {\n                result[i][j] = data[i][j] - other.data[i][j];\n            }\n        }\n        return Matrix(result);\n    }\n\n    Matrix operator*(const Matrix& other) const {\n        if (cols != other.rows) {\n            throw std::invalid_argument(\"The number of columns in the first matrix must equal the number of rows in the second matrix.\");\n        }\n\n        std::vector<std::vector<int>> result(rows, std::vector<int>(other.cols, 0));\n        for (size_t i = 0; i < rows; ++i) {\n            for (size_t j = 0; j < other.cols; ++j) {\n                for (size_t k = 0; k < cols; ++k) {\n                    result[i][j] += data[i][k] * other.data[k][j];\n                }\n            }\n        }\n        return Matrix(result);\n    }\n\n    int determinant() const {\n        if (rows != cols) {\n            throw std::invalid_argument(\"Determinant is only defined for square matrices.\");\n        }\n\n        if (rows == 1) {\n            return data[0][0];\n        } else if (rows == 2) {\n            return data[0][0] * data[1][1] - data[0][1] * data[1][0];\n        } else {\n            int det = 0;\n            for (size_t c = 0; c < cols; ++c) {\n                Matrix submatrix;\n                // Create submatrix by excluding the first row and current column\n                std::vector<std::vector<int>> subdata;\n                for (size_t i = 1; i < rows; ++i) {\n                    std::vector<int> row;\n                    for (size_t j = 0; j < cols; ++j) {\n                        if (j != c) {\n                            row.push_back(data[i][j]);\n                        }\n                    }\n                    subdata.push_back(row);\n                }\n                submatrix = Matrix(subdata);\n                det += (c % 2 == 0 ? 1 : -1) * data[0][c] * submatrix.determinant();\n            }\n            return det;\n        }\n    }\n\n    void print() const {\n        for (const auto& row : data) {\n            for (int val : row) {\n                std::cout << val << \" \";\n            }\n            std::cout << std::endl;\n        }\n    }\n};\n\nint main() {\n    // Example usage\n    std::vector<std::vector<int>> mat1 = {{1, 2}, {3, 4}};\n    std::vector<std::vector<int>> mat2 = {{5, 6}, {7, 8}};\n    Matrix m1(mat1);\n    Matrix m2(mat2);\n\n    Matrix sum = m1 + m2;\n    sum.print();\n\n    Matrix diff = m1 - m2;\n    diff.print();\n\n    Matrix prod = m1 * m2;\n    prod.print();\n\n    int det = m1.determinant();\n    std::cout << \"Determinant: \" << det << std::endl;\n\n    return 0;\n}\n```\n\nThis code defines a `Matrix` class that can perform addition, subtraction, multiplication, and determinant calculation. It includes basic error handling to ensure that operations are only performed when the matrices are compatible for those operations."
    }
]